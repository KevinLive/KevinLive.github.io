<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AT5799 [AGC043B] 123 Triangle</title>
    <url>/2022/09/19/AT5799-AGC043B-123-Triangle/</url>
    <content><![CDATA[<p> mydcwfy 提供的题目。</p>
<span id="more"></span>
<p>很显然对于 $n&gt;1$ 的情况答案一定不为 $2$，特判即可。其他情况我们先做一次操作。</p>
<p>接着我们手动模拟，大胆猜测：若序列中有 $1$，则答案一定不为 $2$。似乎也比较显然，因为只要 $1$ 与 $2$ 在操作过程中相遇，那么 $2$ 就会被消掉，而 $1$ 并不会。对于只有 $2$ 的情况，我们可以把整个序列 $\div 2$ 就和 $0-1$ 序列的情况一样了，最后答案 $\times 2$ 即可。</p>
<p>实际上我们只需要判断答案奇偶，操作也变成了模 $2$ 意义下的。比较重要的是：$f_{k,x}=f_{k-1,x}-f_{k-1,x-1}=f_{k-1,x}+f_{k-1,x-1} \mod 2$。这很像组合数，我们进一步可以得到：$f_{n,1}=\sum_{i=1}^{n} a_i \cdot \binom{n-1}{i-1} \mod 2$。使用 Lucas 定理或者 <code>[n&amp;m==m]</code> 判断奇偶都可以。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;<span class="keyword">return</span> (n&amp;m)==m;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=<span class="built_in">abs</span>(a[i]-a[i+<span class="number">1</span>]),flag|=(a[i]==<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            a[i]&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    flag^=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans^=<span class="built_in">C</span>(n<span class="number">-1</span>,i<span class="number">-1</span>)*(a[i]&amp;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans&lt;&lt;flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF671D Roads in Yusland</title>
    <url>/2023/01/04/CF671D-Roads-in-Yusland/</url>
    <content><![CDATA[<p>线段树合并优化 DP。</p>
<span id="more"></span>
<p>考虑与 NOI2020D1T2 命运 类似的方法，设计状态 $f_{x,i}$ 为以 $x$ 为根的子树中的边全部被覆盖，并且被覆盖的路径向上延伸至深度为 $i$ 的节点，所需要的最小花费。状态转移方程：$f_{x,i}=f_{x,i}+ \min_{j\ge i} \{f_{y,j},f_{y,i}\}+\min_{j\ge i}{f_{x,j}}$。这个方程中两边状态都与下标 $i$ 相同 ，并且信息也是线段树好维护的，于是可以用线段树合并来优化。</p>
<p>注意一些细节。（<del>笔者因为不咋写动态开点误将</del> <code>ql,qr</code>  <del>写成</del> <code>l,r</code> <del>调了将近一天，敲个警钟</del>）。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ll INF=<span class="number">1e16</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    ll val,tag;</span><br><span class="line">&#125;tr[N*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt,rt[N],d[N];</span><br><span class="line"><span class="type">int</span> top,sta[N*<span class="number">20</span>];</span><br><span class="line">vector&lt;Edge&gt;vec[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sta[++top]=x;</span><br><span class="line">    tr[x].lc=tr[x].rc=<span class="number">0</span>;</span><br><span class="line">    tr[x].val=INF,tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top)<span class="keyword">return</span> sta[top--];</span><br><span class="line">    tr[++cnt].val=INF;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val=<span class="built_in">min</span>(tr[tr[x].lc].val,tr[tr[x].rc].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val+=k,tr[x].tag+=k;</span><br><span class="line">    tr[x].val=<span class="built_in">min</span>(tr[x].val,INF);</span><br><span class="line">    tr[x].tag=<span class="built_in">min</span>(tr[x].tag,INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[x].tag)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">update</span>(tr[x].lc,tr[x].tag);</span><br><span class="line">    <span class="built_in">update</span>(tr[x].rc,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)x=<span class="built_in">newnode</span>();</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].val=<span class="built_in">min</span>(tr[x].val,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(tr[x].lc,l,mid,pos,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||(l&gt;=ql&amp;&amp;r&lt;=qr))<span class="keyword">return</span> tr[x].val;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll res=INF;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(tr[x].lc,l,mid,ql,qr));</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(tr[x].rc,mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r,ll resx,ll resy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x&amp;&amp;!y)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!x)<span class="keyword">return</span> <span class="built_in">update</span>(y,resx),y;</span><br><span class="line">    <span class="keyword">if</span>(!y)<span class="keyword">return</span> <span class="built_in">update</span>(x,resy),x;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].val=<span class="built_in">min</span>(&#123;tr[x].val+resy,tr[y].val+resx,INF&#125;);</span><br><span class="line">        <span class="built_in">del</span>(y);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x),<span class="built_in">pushdown</span>(y);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[x].lc=<span class="built_in">merge</span>(tr[x].lc,tr[y].lc,l,mid,resx,resy);</span><br><span class="line">    tr[x].rc=<span class="built_in">merge</span>(tr[x].rc,tr[y].rc,mid+<span class="number">1</span>,r,resx,resy);</span><br><span class="line">    <span class="built_in">del</span>(y);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        flag=<span class="number">1</span>,d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(!rt[x])</span><br><span class="line">        &#123;</span><br><span class="line">            rt[x]=rt[y];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll resx=<span class="built_in">query</span>(rt[x],<span class="number">1</span>,n,<span class="number">1</span>,d[x]),resy=<span class="built_in">query</span>(rt[y],<span class="number">1</span>,n,<span class="number">1</span>,d[x]);</span><br><span class="line">        rt[x]=<span class="built_in">merge</span>(rt[x],rt[y],<span class="number">1</span>,n,resx,resy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)<span class="built_in">modify</span>(rt[x],<span class="number">1</span>,n,d[x],<span class="number">0</span>);</span><br><span class="line">    ll res=<span class="built_in">query</span>(rt[x],<span class="number">1</span>,n,<span class="number">1</span>,d[x]);</span><br><span class="line">    <span class="keyword">if</span>(res&gt;=INF)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:vec[x])</span><br><span class="line">        <span class="built_in">modify</span>(rt[x],<span class="number">1</span>,n,d[y.v],res+y.w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">read</span>(x,y,z);</span><br><span class="line">        vec[x].<span class="built_in">push_back</span>(&#123;y,z&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>,tr[<span class="number">0</span>].val=INF;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ll ans=<span class="built_in">query</span>(rt[<span class="number">1</span>],<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans&gt;=INF)?<span class="number">-1</span>:ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>整体DP</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CF708C Centroids</title>
    <url>/2022/10/17/CF708C-Centroids/</url>
    <content><![CDATA[<p>有一点思维的换根DP。</p>
<span id="more"></span>
<p>如果一个点不是重心，我们则考虑将它其中某一个子树断开在接到这个节点上。于是我们需要在以该节点为根的树中，找一个 $size\le {n\over2}$ 的最大子树。</p>
<p>接下来很容易想到换根 DP。注意到换根时 $f_x$ 的决策点可能就是 $y$。还应该维护预处理次大值。</p>
<p>随便放个代码。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tot,head[maxn],ver[<span class="number">2</span>*maxn],ne[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="type">int</span> si[maxn],d[maxn][<span class="number">2</span>],f[maxn],pre[maxn],maxsize[maxn];</span><br><span class="line"><span class="type">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(to,x);</span><br><span class="line">        si[x]+=si[to];</span><br><span class="line">        <span class="keyword">if</span>(si[to]&gt;si[maxsize[x]])maxsize[x]=to;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">if</span>(si[to]&lt;=n/<span class="number">2</span>)v=si[to];</span><br><span class="line">        <span class="keyword">else</span> v=d[to][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(d[x][<span class="number">0</span>]&lt;v)</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">1</span>]=d[x][<span class="number">0</span>];</span><br><span class="line">            d[x][<span class="number">0</span>]=v;</span><br><span class="line">            pre[x]=to;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[x][<span class="number">1</span>]&lt;v)d[x][<span class="number">1</span>]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(si[maxsize[x]]&gt;n/<span class="number">2</span>) ans[x]=(si[maxsize[x]]-d[maxsize[x]][<span class="number">0</span>]&lt;=n/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n-si[x]&gt;n/<span class="number">2</span>) ans[x]=(n-si[x]-f[x]&lt;=n/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=ver[i];</span><br><span class="line">		<span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">		<span class="keyword">if</span>(n-si[x]&gt;n/<span class="number">2</span>)v=f[x];</span><br><span class="line">		<span class="keyword">else</span> v=n-si[x];</span><br><span class="line">		f[to]=<span class="built_in">max</span>(f[to],v);</span><br><span class="line">		<span class="keyword">if</span>(pre[x]==to)f[to]=<span class="built_in">max</span>(f[to],d[x][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">else</span> f[to]=<span class="built_in">max</span>(f[to],d[x][<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">dfs</span>(to,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>换根DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 游记</title>
    <url>/2022/10/27/CSP-S-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>爆炸。</p>
<span id="more"></span>
<h4 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h4><p>连续两天 ZR 模拟赛爆炸，心态也有些爆炸。总感觉自己很不自信，总觉得自己写不出来（多半是后遗症 ），一些实际上不难的题都没有做出来，于是被吊打，极其难受。</p>
<p>到考场上我又应该怎么办呢？T1 不会我应该采取怎么样的策略？或许我的担心也是不必要的，我可能也改变不了最后的结局。</p>
<h4 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h4><p>上午神仙讲课，半懂不通的，又被吊打。</p>
<p>下午去试了下机子，帮老师调试虚拟机。然后用搞来的出门条出去吃了顿华莱士，回机房继续学习了一会。还是很紧张。晚上早早睡了。</p>
<h4 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h4><p>上午复习了会板子，又颓废了一会。心态稍微稳定一点。似乎这次考试也其实并不那么重要了，还不如当成刷经验值来。</p>
<p>到了考场，发现身份证忘带了，幸好还是准时进去了。很紧张，不敢动鼠标键盘。</p>
<p>题发下来，看了 T1，感觉瞬间寄了，想了几个比较正经的写法都寄了，怎么办？也想过要不要开始乱搞（还并没有意识到这题就是乱搞），于是直接就去看 T2，此时大约 15:00。</p>
<p>然后就发现 T2 很简单，是个分讨加上数据结构，于是直接开始大力写，写了四棵线段树，然后调了十多分钟，感觉过了大样例就差不多了。</p>
<p>看到 T3 题面又臭又长，只有写 $\mathcal O(nq)$ 暴力。T4 看起来暴力都不想写，此时已经过去两个多小时。</p>
<p>写完 T3 暴力接着想 T1，脑子里依然是用什么什么算法来做，结果仍然没有头绪。也只好在原来 $\mathcal O(n^3)$ 的基础上再写个 $k=1$ 的 sub。</p>
<p>中间甚至还有一段乌龙，我以为 18:00 就考完了，于是从 17:30 就开始检查，<del>然后发现 T2 大样例其实没过</del>，又赶快改了十多分钟。监考老师提醒时间的时候才意识到还有半个小时。其实可以把 T4 暴力写完的。。。</p>
<p>随着广播里的提示考试结束，我也只好接受自己爆炸的现实。出来一看就我 T1 没切，还说什么呢，只能是技不如人了。。。</p>
<p>晚上选手数据发了下来，然后去测了下，大概还是 190 pts 左右，还是爆炸。</p>
<p>然后迷迷糊糊就睡了。</p>
<p>赛后感觉 T3 T4 巨多部分分且好写，并且 T3 正解很短，T4 正解也比较好想，但是还是寄的离谱。。。</p>
<h4 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h4><p>成绩出来了，60 + 100 + 40 = 200 pts。已经无所谓了，只是希望能够更认真地准备 NOIP 吧。</p>
<p>就这样。</p>
<h4 id="Day-20"><a href="#Day-20" class="headerlink" title="Day 20"></a>Day 20</h4><p>分数线 195 pts，混了个没 B 用的 1=。</p>
<p>真的就这样了么。。。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>DP 专项训练</title>
    <url>/2022/08/26/DP-%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p>可以说是 DP 乱做。</p>
<span id="more"></span>
<p>先做几道真题。</p>
<h4 id="1-P7077-CSP-S2020-函数调用"><a href="#1-P7077-CSP-S2020-函数调用" class="headerlink" title="1.P7077 [CSP-S2020] 函数调用"></a>1.<a href="https://www.luogu.com.cn/problem/P7077">P7077 [CSP-S2020] 函数调用</a></h4><p>很明显各个函数的调用关系是一张 DAG。假如只有函数 2，我们就只需要 dfs 一遍就可以求出所有函数的 $mul_i$。我们并不好处理先进行函数 1 再进行函数 2 的情况。于是我们考虑再求出一个 $add_i$ 表示调用完所有函数后第 $i$ 个数的增量。</p>
<p>容易想到在拓扑序 DP 来求这个东西。其实想要求 $add$ 数组很简单，乘 $k$ 也看作将该函数被执行 $k$ 次，我们只需要求出每个函数被执行了多少次，这个我们用 $f_i$ 表示函数 $i$ 被执行了多少次。</p>
<p>因为我们是按照拓扑序来考虑每个函数，而非函数本来的执行顺序。所以我们需要先考虑 $f$ 的初值。$res$ 是一个动态维护的值，表示在第 $i$ 个执行的函数被执行了 $res$ 次（注意上文所说的“被执行”）。对于三种类型的函数分开讨论：1.直接加上 $res$；2.用 $res$ 乘上 $mul_{fuc_i}$（不用加上 $res$，因为我们们根本不关心函数 2 的 $f$ 值）；3.先加上 $res$ ，再用 $res$ 乘上 $mul_{fuc_i}$。</p>
<p>接着我们考虑 DP，设当前节点为 $x$。还是对于三种类型的函数分开讨论：1.直接计算 $add_{pos_x}$；2.根本不用管；3.我们尝试倒序遍历其所有出点，就像上面求初值一样来处理所有出点的 $f$ 值，只不过不需要讨论类型，还有最开始的 $res$ 的值应该为 $f_x$ 。</p>
<p>似乎就这样做完了。。。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>)<span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;<span class="built_in">putchar</span>(c);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>&#123;<span class="keyword">while</span>(*s)<span class="built_in">putchar</span>(*s++);&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x,T1 ...x1)</span></span>&#123;<span class="built_in">write</span>(x),<span class="built_in">write</span>(x1...);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N],fuc[N];</span><br><span class="line"><span class="type">int</span> type[N],pos[N],val[N];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line">ll mul[N],f[N],add[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mul[x]=(type[x]==<span class="number">2</span>)?val[x]:<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> si=e[x].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!~mul[y])<span class="built_in">dfs</span>(y);</span><br><span class="line">        mul[x]=mul[x]*mul[y]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">topo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(!deg[i])</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(type[x]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            add[pos[x]]=(add[pos[x]]+val[x]*f[x])%mod;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll res=f[x];</span><br><span class="line">        <span class="type">int</span> si=e[x].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=si<span class="number">-1</span>;~i;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=e[x][i];</span><br><span class="line">            f[y]=(f[y]+res)%mod;</span><br><span class="line">            res=res*mul[y]%mod;</span><br><span class="line">            <span class="keyword">if</span>(!--deg[y])q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(type[i]);</span><br><span class="line">        mul[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(type[i]==<span class="number">1</span>)<span class="built_in">read</span>(pos[i],val[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type[i]==<span class="number">2</span>)<span class="built_in">read</span>(val[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c;</span><br><span class="line">            <span class="built_in">read</span>(c);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x;</span><br><span class="line">                <span class="built_in">read</span>(x);</span><br><span class="line">                e[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">                deg[x]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(!deg[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        <span class="built_in">read</span>(fuc[i]);</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q;i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=fuc[i];</span><br><span class="line">        <span class="keyword">if</span>(type[x]==<span class="number">1</span>)f[x]=(f[x]+res)%mod;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type[x]==<span class="number">2</span>)res=res*mul[x]%mod;</span><br><span class="line">        <span class="keyword">else</span> f[x]=(f[x]+res)%mod,res=res*mul[x]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">write</span>((<span class="number">1ll</span>*a[i]*res+add[i])%mod,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="2-P7961-NOIP2021-数列"><a href="#2-P7961-NOIP2021-数列" class="headerlink" title="2.P7961 [NOIP2021] 数列"></a>2.<a href="https://www.luogu.com.cn/problem/P7961">P7961 [NOIP2021] 数列</a></h4><p>注意到 $n,m$ 的范围，应该是个高维 DP。</p>
<p>先设计状态，将我们不太好处理的东西直接记录入状态：比如 $1$ 的个数和进位的问题，设 $f_{i,j,k,p}$，意为前 $i$ 个数选取 $j$，$1$ 的个数为 $k$，先高一位进位 $p$ 的方案数。</p>
<p>从之前的状态转移到当前状态显然不好搞，所以考虑从当前状态向之后的状态进行转移。同时最后一层枚举 $t$，表示选  $t$  个 $i$。似乎很容易得到状态的转移：</p>
<script type="math/tex; mode=display">
f_{i+1,j+t,k+(t+p)\\\&1,\frac{(t+p)}{2}}\gets f_{i,j,k,p}</script><p>因为权值是一个乘积和的形式，我们也可以尝试拆贡献，也可以比较容易得到：$v_i^t\times C_{n-j}^{t}$。然后就转移就可以了。时间复杂度$\mathcal O(n^4m)$。</p>
<p>其实还可以用滚动数组优化一下，<del>但影响不大</del>。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">40</span>,M=<span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a,pos=<span class="number">1</span>;</span><br><span class="line">ll ans;</span><br><span class="line">ll v[M],sum[M][N],C[N][N];</span><br><span class="line">ll f[<span class="number">2</span>][N][N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">popcnt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)res+=x&amp;<span class="number">1</span>,x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">read</span>(n,m,a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(v[i]);</span><br><span class="line">        sum[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            sum[i][j]=sum[i][j<span class="number">-1</span>]*v[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f[pos],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[pos]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=a;k++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;=n&gt;&gt;<span class="number">1</span>;p++)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=n-j;t++)</span><br><span class="line">                        f[pos][j+t][k+(t+p&amp;<span class="number">1</span>)][t+p&gt;&gt;<span class="number">1</span>]=(f[pos][j+t][k+(t+p&amp;<span class="number">1</span>)][t+p&gt;&gt;<span class="number">1</span>]</span><br><span class="line">                            +f[pos^<span class="number">1</span>][j][k][p]*sum[i][t]%mod*C[n-j][t]%mod)%mod;</span><br><span class="line">        pos^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=a;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;=n&gt;&gt;<span class="number">1</span>;p++)</span><br><span class="line">            <span class="keyword">if</span>(k+<span class="built_in">popcnt</span>(p)&lt;=a)</span><br><span class="line">                ans=(ans+f[pos^<span class="number">1</span>][n][k][p])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="3-P3953-NOIP2017-提高组-逛公园"><a href="#3-P3953-NOIP2017-提高组-逛公园" class="headerlink" title="3.P3953 [NOIP2017 提高组] 逛公园"></a>3.<a href="https://www.luogu.com.cn/problem/P3953">P3953 [NOIP2017 提高组] 逛公园</a></h4><p>我们很容易想到用 DP，并且注意观察 $k$ 的值很小，考虑可以将其记录进状态。设 $f_{x,k}$ 表示从 $1$ 走到点 $x$ ，长度为最短路 $+k$ 的路径数量。 考虑建反图然后记忆化搜索。设边为 $(x,y,z)$，转移很显然有：</p>
<script type="math/tex; mode=display">
f_{x,k}=\sum_y f_{y,dis_x+k-dis_y-z}</script><p>如何判 $0$ 环呢，只需要开一个数组判断一下会不会递归到我们需要求解的状态就可以了。</p>
<p>其实似乎也可以递推求解，状态与上面相似，需要按照 $dis$ 从小到大的顺序转移。只不过对于有 $0$ 的边，需要以拓扑序为第二关键字进行转移。稍微麻烦一点。</p>
<p>下面是记忆化搜索的代码。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,K=<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> T,n,m,k,p;</span><br><span class="line">vector&lt;Edge&gt;e1[N],e2[N];</span><br><span class="line"><span class="type">int</span> dis[N],vis[N];</span><br><span class="line"><span class="type">int</span> flag,f[N][K],v[N][K];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>,vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> si=e1[x].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=e1[x][i].v,z=e1[x][i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+z&lt;dis[y])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y]=dis[x]+z;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y])q.<span class="built_in">push</span>(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">0</span>||flag)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(v[x][k])</span><br><span class="line">    &#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[x][k])<span class="keyword">return</span> f[x][k];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,si=e2[x].<span class="built_in">size</span>();</span><br><span class="line">    v[x][k]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e2[x][i].v,z=e2[x][i].w;</span><br><span class="line">        ans=(ans+<span class="built_in">dp</span>(y,dis[x]+k-dis[y]-z))%p;</span><br><span class="line">    &#125;</span><br><span class="line">    v[x][k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> f[x][k]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(n,m,k,p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            e1[i].<span class="built_in">clear</span>(),e2[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u,v,w;</span><br><span class="line">            <span class="built_in">read</span>(u,v,w);</span><br><span class="line">            e1[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">            e2[v].<span class="built_in">push_back</span>(&#123;u,w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">SPFA</span>();</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//注意这个细节，是用来判 0 环的</span></span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//因为我们需要赋初值，但是赋完我们就不能判断经过 1 的 0 环了，所以上面需要先跑一遍</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">            ans=(ans+<span class="built_in">dp</span>(n,i))%p;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Kruskal 重构树</title>
    <url>/2022/08/25/Kruskal-%E9%87%8D%E6%9E%84%E6%A0%91/</url>
    <content><![CDATA[<p>Kruskal 生成树算法的扩展应用。</p>
<span id="more"></span>
<h3 id="Kruskal-重构树"><a href="#Kruskal-重构树" class="headerlink" title="Kruskal 重构树"></a>Kruskal 重构树</h3><p>考虑一下该算法的过程：一开始 Kruskal 重构树只有 $n$ 个点，没有边。还是类似 Kruskal，我们将所有边从大到小进行考虑。对于每一条边 $(u,v,w)$，若 $u,v$ 不联通，我们就在 Kruskal 重构树上新建一个 $t$。将 $u,v$ 在重构树上的根节点 $rt_u,rt_v$ 作为 $t$ 的左右儿子，并且令 $t$ 点的权值为 $val_t=w$。</p>
<p>建了这样一棵树，我们很明显有这几个性质：</p>
<p>1.一般情况下他是一棵二叉树。</p>
<p>2.原图的节点都是重构树的叶子节点。</p>
<p>3.对于任意节点 $u$ 其祖先 $v$，$val_u$ 与 $val_v$ 满足相同偏序关系。</p>
<p>咕咕咕。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>图论</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#2115. 「HNOI2015」落忆枫音</title>
    <url>/2022/11/09/LOJ-2115-%E3%80%8CHNOI2015%E3%80%8D%E8%90%BD%E5%BF%86%E6%9E%AB%E9%9F%B3/</url>
    <content><![CDATA[<p>拓扑序DP。</p>
<span id="more"></span>
<p>考虑有向无环图，答案显然为 $\prod_i \deg_i$。但是加了一条边可能会出现环，产生不合法的方案。我们考虑将不合法的方案减去。</p>
<p>把环从图中剖出来，那么剩下点的 $\prod_i \deg_i$ 就是该环不合法的方案数。理由很简单，这个环没有入度的，而其它所有点都可以随便选父亲。于是我们将环上点的 $\deg_i$ 除掉即可。</p>
<p>可能会出现多个环。但其实 $a$ 与 $b$ 一定会出现在环上的。此过程可以 DP，计算 $f_i$ 为从 $b$ 到 $i$ 的方案数，最终用原答案减去  $f_a$ 即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],ne[M];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line">ll ans=<span class="number">1</span>,sum=<span class="number">1</span>,f[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mod-(mod/x)*<span class="built_in">inv</span>(mod%x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[x])</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(x==b)</span><br><span class="line">    &#123;</span><br><span class="line">        f[x]=sum*<span class="built_in">inv</span>(deg[x])%mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        f[x]=(f[x]+f[y])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=f[x]*<span class="built_in">inv</span>(deg[x])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">        deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    deg[<span class="number">1</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==b)ans=ans*(deg[i]+<span class="number">1</span>)%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=ans*deg[i]%mod;</span><br><span class="line">        sum=sum*deg[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans+mod-f[a])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#2743. 「JOI Open 2016」摩天大楼</title>
    <url>/2022/09/02/LOJ-2743-%E3%80%8CJOI-Open-2016%E3%80%8D%E6%91%A9%E5%A4%A9%E5%A4%A7%E6%A5%BC/</url>
    <content><![CDATA[<p>经典 DP，费用提前计算的思想。</p>
<span id="more"></span>
<p>对于序列类型的 DP 题，我们可以想到用分段型 DP，每次将当前的数插入进去，求解方案数。但是这道题的并费用不好直接计算。</p>
<p>先将 $a$ 排序，并从小到大插入。对于 $i&lt;j$ ，有 $|a_i-a_j|=\sum_{k=i}^{j-1} a_{k+1}-a_k$。根据这个我们可以尝试进行<strong>费用提前计算</strong>。对于之后每个插在当前的 $k$ 个端点上的数，会一共产生 $(a_{i+1}-a_{i})\times k$ 的费用。</p>
<p>状态转移比较套路。注意边界上是没有花费的，所以还需要将边界上填了多少个记录进状态。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">10</span>,M=<span class="number">1e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">ll f[N][N][M][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>;d&lt;=<span class="number">2</span>;d++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> t=k+(a[i+<span class="number">1</span>]-a[i])*(<span class="number">2</span>*j-d);</span><br><span class="line">                    <span class="keyword">if</span>(t&gt;m||!f[i][j][k][d])<span class="keyword">continue</span>;</span><br><span class="line">                    f[i+<span class="number">1</span>][j+<span class="number">1</span>][t][d]=(f[i+<span class="number">1</span>][j+<span class="number">1</span>][t][d]+f[i][j][k][d]*(j+<span class="number">1</span>-d))%mod;</span><br><span class="line">                    <span class="keyword">if</span>(j)f[i+<span class="number">1</span>][j<span class="number">-1</span>][t][d]=(f[i+<span class="number">1</span>][j<span class="number">-1</span>][t][d]+f[i][j][k][d]*(j<span class="number">-1</span>))%mod;</span><br><span class="line">                    <span class="keyword">if</span>(j)f[i+<span class="number">1</span>][j][t][d]=(f[i+<span class="number">1</span>][j][t][d]+f[i][j][k][d]*(<span class="number">2</span>*j-d))%mod;</span><br><span class="line">                    <span class="keyword">if</span>(d&lt;<span class="number">2</span>)f[i+<span class="number">1</span>][j+<span class="number">1</span>][t][d+<span class="number">1</span>]=(f[i+<span class="number">1</span>][j+<span class="number">1</span>][t][d+<span class="number">1</span>]+f[i][j][k][d]*(<span class="number">2</span>-d))%mod;</span><br><span class="line">                    <span class="keyword">if</span>(j&amp;&amp;d&lt;<span class="number">2</span>)f[i+<span class="number">1</span>][j][t][d+<span class="number">1</span>]=(f[i+<span class="number">1</span>][j][t][d+<span class="number">1</span>]+f[i][j][k][d]*(<span class="number">2</span>-d))%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        ans=(ans+f[n][<span class="number">1</span>][i][<span class="number">2</span>])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3339. 「NOI2020」美食家</title>
    <url>/2022/12/25/LOJ-3339-%E3%80%8CNOI2020%E3%80%8D%E7%BE%8E%E9%A3%9F%E5%AE%B6/</url>
    <content><![CDATA[<p>一些小 trick。</p>
<span id="more"></span>
<p>注意到 $T$ 很大，并且 $n,m$ 都比较小，并且求的是恰好 $T$ 时刻。想到用矩阵快速幂来做。</p>
<p>如何处理路径长度？因为 $w_i$ 很小，我们可以考虑拆边，这样总点数是 $n+5m$ 的，不太能接受。实际上我们可以考虑拆点，这样总点数是 $5n$ 的，可以接受。另外还需要将点权转化为边权。</p>
<p>如何处理美食节？我们可以将美食节按照时间进行排序，每次计算时间之差内愉悦值变化，再加上美食节额外的愉悦值即可。</p>
<p>但是这样暴力快速幂做是 $\mathcal O(n^3k\log T)$ 的，无法通过所有数据。其实我们只需要保留矩阵的第一行即可。于是可以预处理原始矩阵的次幂，在求解过程中倍增计算。于是时间复杂度就降到了 $\mathcal O(n^3\log T+n^2k\log T)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">250</span>+<span class="number">10</span>,M=<span class="number">5e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    ll e[N][N];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;<span class="built_in">memset</span>(e,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(e));&#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix a,<span class="type">const</span> Matrix b)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix c;</span><br><span class="line">        c.x=a.x,c.y=b.y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a.x;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=b.y;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a.y;k++)</span><br><span class="line">                    c.e[i][j]=<span class="built_in">max</span>(c.e[i][j],a.e[i][k]+b.e[k][j]);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;f[<span class="number">50</span>],ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Festival</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t,x,y;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Festival a,<span class="type">const</span> Festival b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.t&lt;b.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n,m,t,k;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i<span class="number">-1</span>)*<span class="number">5</span>+j+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;delicacy.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;delicacy.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(n,m,t,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">            f[<span class="number">0</span>].e[<span class="built_in">num</span>(i,j)][<span class="built_in">num</span>(i,j+<span class="number">1</span>)]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        f[<span class="number">0</span>].e[<span class="built_in">num</span>(u,w<span class="number">-1</span>)][<span class="built_in">num</span>(v,<span class="number">0</span>)]=c[v];</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>].x=<span class="number">5</span>*n,f[<span class="number">0</span>].y=<span class="number">5</span>*n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">31</span>;i++)</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]*f[i<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i].t,a[i].x,a[i].y);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+k);</span><br><span class="line">    a[<span class="number">0</span>]=(Festival)&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    a[k+<span class="number">1</span>]=(Festival)&#123;t,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    ans.e[<span class="number">1</span>][<span class="number">1</span>]=c[<span class="number">1</span>];</span><br><span class="line">    ans.x=<span class="number">1</span>,ans.y=<span class="number">5</span>*n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d=a[i].t-a[i<span class="number">-1</span>].t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;~i;i--)</span><br><span class="line">            <span class="keyword">if</span>(d&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                ans=ans*f[i];</span><br><span class="line">        ans.e[<span class="number">1</span>][<span class="built_in">num</span>(a[i].x,<span class="number">0</span>)]+=a[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.e[<span class="number">1</span>][<span class="number">1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans.e[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <tags>
        <tag>题解</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3340. 「NOI2020」命运</title>
    <url>/2022/12/25/LOJ-3340-%E3%80%8CNOI2020%E3%80%8D%E5%91%BD%E8%BF%90/</url>
    <content><![CDATA[<p>线段树合并优化 DP。</p>
<span id="more"></span>
<p>注意到对于所有 $(u,v)\in \mathcal Q$ 的 $v$ 只需要深度最深的 $u$ 满足即可。考虑设计状态 $f_{x,i}$ 表示以 $x$ 为根的子树中未满足条件的 $u$ 深度最大为 $i$ 的方案数。考虑 $(x,y)$ 为连向子树的边，选取该条边为 $1$ 的贡献是 $\sum_{j=0}^{dep_x} f_{x,i}\times f_{y,j}$，不选取的贡献是 $\sum_{j=0}^{i} f_{x,i}\times f_{y,j}+\sum_{j=0}^{i-1} f_{x,j}\times f_{y,i}$。用前缀和优化，得到总的转移方程：</p>
<script type="math/tex; mode=display">
f_{x,i}=f_{x,i}\times (sum_y(dep_x)+sum_y(i))+f_{y,i}\times sum_x(i-1)</script><p>这样做到 $\mathcal O(n^2)$，对深度离散化可以做到 $\mathcal O(n\min{n,m})$，建虚树可以做到 $\mathcal O((\min{n,m})^2)$。</p>
<p>观察式子，先不管 $sum_y(dep_x)$，剩下的项全都和下标 $i$ 有关，求区间和。而且真正有用的状态数是 $\mathcal O(m)$ 的，于是考虑整体 DP。整个过程用线段树合并来维护，合并过程中维护 $sum_x,sum_y$，先合并左子树，再合并右子树。$sum_y(dep_x)$ 在线段树上查一下就行了。时间复杂度 $\mathcal O(n \log n)$。</p>
<p>全都和下标 $i$ 有关这一点提醒我们也可以用启发式合并，但是感觉比较难写，是 $\mathcal O(n\log^2 n)$，有被卡的风险。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    ll sum,tag;</span><br><span class="line">&#125;tr[N*<span class="number">80</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> rt[N],d[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].sum=(tr[tr[x].lc].sum+tr[tr[x].rc].sum)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].sum=tr[x].sum*k%mod;</span><br><span class="line">    tr[x].tag=tr[x].tag*k%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].tag==<span class="number">1</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].lc)<span class="built_in">update</span>(tr[x].lc,tr[x].tag);</span><br><span class="line">    <span class="keyword">if</span>(tr[x].rc)<span class="built_in">update</span>(tr[x].rc,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=++cnt;</span><br><span class="line">    tr[x].sum=tr[x].tag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">insert</span>(tr[x].lc,l,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||r&lt;=pos)<span class="keyword">return</span> tr[x].sum;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(tr[x].lc,l,mid,pos);</span><br><span class="line">    <span class="keyword">return</span> (tr[tr[x].lc].sum+<span class="built_in">query</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r,ll &amp;sumx,ll &amp;sumy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x&amp;&amp;!y)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">    &#123;</span><br><span class="line">        sumy=(sumy+tr[y].sum)%mod;</span><br><span class="line">        <span class="built_in">update</span>(y,sumx);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!y)</span><br><span class="line">    &#123;</span><br><span class="line">        sumx=(sumx+tr[x].sum)%mod;</span><br><span class="line">        <span class="built_in">update</span>(x,sumy);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        sumx=(sumx+tr[x].sum)%mod;</span><br><span class="line">        sumy=(sumy+tr[y].sum)%mod;</span><br><span class="line">        tr[x].sum=(tr[x].sum*sumy%mod+tr[y].sum*((sumx+mod-tr[x].sum)%mod)%mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x),<span class="built_in">pushdown</span>(y);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[x].lc=<span class="built_in">merge</span>(tr[x].lc,tr[y].lc,l,mid,sumx,sumy);</span><br><span class="line">    tr[x].rc=<span class="built_in">merge</span>(tr[x].rc,tr[y].rc,mid+<span class="number">1</span>,r,sumx,sumy);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:vec[x])</span><br><span class="line">        res=<span class="built_in">max</span>(res,d[y]);</span><br><span class="line">    <span class="built_in">insert</span>(rt[x],<span class="number">0</span>,n<span class="number">-1</span>,res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        ll sumx=<span class="number">0</span>,sumy=<span class="built_in">query</span>(rt[y],<span class="number">0</span>,n<span class="number">-1</span>,d[x]);</span><br><span class="line">        rt[x]=<span class="built_in">merge</span>(rt[x],rt[y],<span class="number">0</span>,n<span class="number">-1</span>,sumx,sumy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;destiny.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;destiny.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        vec[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(rt[<span class="number">1</span>],<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>整体DP</tag>
        <tag>线段树合并</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP 游记</title>
    <url>/2022/11/24/NOIP%20%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>与诸君共勉。</p>
<span id="more"></span>
<h4 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h4><p>上午考试，T1 做了很久，后面的题也没时间想解法，关键 T1 大样例很水，又挂了分，有点爆炸。</p>
<p>NOIP 就在眼前了，有时候感觉自己或许也比以前进步了很多，但还是达不到真正有水平。我还在犹豫什么呢？我曾经觉得这些考试决定了我人生的轨迹。而我，如今，和各位前途光明的 OIers 坐在同一个机房，并试图说服自己也是他们中的一员，却不断地在空想中迷茫。</p>
<p>可至少和大家一起还是很快乐的吧？大不了考完就退役滚去学文化课，似乎也没什么了，只不过我还是很喜欢 OI 罢了。</p>
<h4 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h4><p>感觉自己很颓废，机房里大家都在耍。而我只是颓废得很，简直不知道干什么。早上 T1 又挂分，在垫底间徘徊。又在洛谷上开了个之前讲过的题，想不出来解法了。这时才感觉到自己真的是废物一个。</p>
<p>晚上打算复习一下板子，其余就都没了。</p>
<h4 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h4><p>睡得不太好。做完核酸就去考试。</p>
<p>开题，T1 形式化的题面让人感觉很不友好，把全部题看完还是决定按照顺序开题。</p>
<p>T1 按照每一列来算，乘法原理计算就可以了，9:20 才写完，然后看 T2。感觉很阴间，想了一个似乎正确的做法，然后感觉比较难写。实际开始写的时候感觉比想象中难写一百倍。写了 20 min 连第一步怎么处理的没写完。决定看后面的题。</p>
<p>然后发现 T3 暴力也不太好写，只有 T4 数据结构题暴力比较好写。</p>
<p>当时已经知道 T3 大概是个边双 + 树形 DP，感觉可能比较难做。但是做出了本场最错误的决定——我选择猛冲 T2，直接放弃 T3。</p>
<p>然后就寄了，甚至连 $k=2\times n-2$ 的解法的写对没有都不清楚，也没时间写 SPJ 了。12:50 写完乱搞，最后检查一遍就结束了。</p>
<p>最后走出了考场，大家都想骂出题人。机房里除了 Dyd 和 mydcwfy 都考得不尽人意（毕竟只有这两位神仙看出来 T3 并不困难），Dyd T1 挂分但是 T3 切掉了，mydcwfy T3 挂分但是 T4 84pts。</p>
<p>那么我呢？甚至 T1 忘记乘上 $c,f$ 一定会挂 7pts，而且前缀和数组在做乘法的时候忘记强制转换了，被 InfOJ 卡到 64pts（InfOJ 的数据真的很强！）。T2 T3 都报零，T4 20pts 暴力。</p>
<p>InfOJ： 64 + 0 + 0 + 20 = 84 pts</p>
<p>luogu：93 + 0 + 0 + 20 = 113 pts</p>
<p>考完感觉整个人都是处于红温状态，回寝室睡得也并不好，</p>
<h4 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h4><p>早上起来整个人都是恍恍惚惚的，昨日仿佛如梦一般，我所认为的很重要的一天就过去。</p>
<p>如果我 T1 没有挂分，看出来 T3 比 T2 更加可做的话，结局是否会改变呢？我得不到答案，我觉得我的水平仍然未达到我想要的高度，仍然不能使我自己变得足够优秀。我只能尽力提升自己，并且希望，能够在明年此时，不会因为当初做的决定而后悔。</p>
<p>新的一天又开始了呢。。。</p>
<h4 id="Day-2-8"><a href="#Day-2-8" class="headerlink" title="Day 2~8"></a>Day 2~8</h4><p>在学文化课，摆了很多常规作业，感觉有点累（NOIP前都没有这般感觉），不知道为什么突然十分迫切地想要放假回去休息。</p>
<p>其实也想明白一些事情吧，或许当我有一天也离开了 OI 这门我所热爱的学科，我也会继续有着自己的生活，继续走着自己的路，只是从万千平凡的 OIer 变成万千平凡的 whker。回忆仍然让我们感到快乐。</p>
<p>分数也不重要了，反正 1= 肯定没戏了。更重要的是好好地走完这一段不知长短的路。</p>
<h4 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h4><p>出分了。没什么感觉。</p>
<p>总分： 93 + 0 + 0 + 20 = 113 pts</p>
<p>一等奖线就是 120 pts，而我差的就是那挂掉的 7 pts。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>我们的故事仍未结束，甚至，才刚刚开始。。。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>OI日记</title>
    <url>/2022/08/19/OI%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b00721cb79b4ec5649b40294c00ca2060fa76d31a7d94c2fd4212fd4f3ea7757">6333146992d1960170704a0dfad69583847809dc3c2f675101e538cf9f82e80b8e5664514d76bd3dcb241ed48fd6185c9939373ed1a1dbc349457a49a9845b3d7b0b3bb7bd3aae5d34db10b20a9ae31ecc37009465aabd291eac1ef74b7fa48edbce0fb02e9ce0d0bd3a51d664d58e5baeddc23d3f7ada7c06c4fbf655b4dd1cc26aca7a95cc6e00efde7202aa065cf25dd2662733f183c90a437089b031167f2b544d344976df9cf245f7a22bd73b5337ae8684c25f5aaf660e5d844aca7a6281de19ac568f89096f87838af6b10d49378049f6ce6be60c6e403a683128a54f5c1dea17ee777af3a9abff9e57cacb347e556a6f5153f12450264250e163fd7aee2b57cb3b53c436f645fbc3a8f967c84d8ba4866c672ef8c0d3bd508036ad8f86646751ef3f21e2807c7c3c3d0aab571c8ad5cff4efa62943bb0742545f3b7ad5766dd666ef8c29240534645429a87da63eb9c94c038d7c85831cb0019790e5d3a98495f07f6bb97a00831eed7c5c9b568e0b062fb892e5a6ecb69b95566e09e5a5f0c8fbfe8c4920eef4e71f35043742b1a923a7600b4f7f0fb2e7af0287e92dd56cd8296261c524e91139225217eb1adb19677429f22431370444f4265f15ec37cb250009d90007316056c01970ea70cfc2f08990ba056666924b2cfcb852b4a651a22e908cc9a8bfe13fb77278423c6dc372efc8a63ff6a4dcf7d634baef612a55b4a7e9374b29cf8888c8197d6c7c2610b967ee928433af1899b61927f351d2a7b3b9b5982178b8e98c1f26b72cac96edab3f41f92e80d4b41782bbe3355e9f247e842d8040821849f50b328e60e4b75f730ede876bb0fa0f1256b034ed6bb219c07bce968991a36681a7d775e9ddde41c30e1caa7759d8e359cc3ad2b73abcdd9bf3eb213b694089090717c1d62c2f6f28100995933c7b52cb021180b9894a4b1881324a1e32ff1d0b96e1980bf5c64d2782c350d7b4824cb09a9b11658f0c9e90d24822ba670d6eb90efb2d9ada102a5d0dc7c2a881da74669da6bcb50a9c1c7195c59cdcdcf51d29373a68f4dd1da9799495f8adf70f909c32f7b7f077039e0a0325fbe597086c65ebb45c480947ef62f4d566e97e409b7b2a8e368ef31019f35a5bd6220cb390faad09d0a24365fa0d73be805ac04fc9ba3a5242a876ce5ee811b643a6a1047ae953ab147ceb17afbce669a28f7c7fc595bb86955e0cd2092859c14e27f9c4b307ea11746c82b4046c8a3ebb2ba102a8dd2cb6361cf76caa2c1bd36082f05d31d942573abb4bf37b85800601f7f418a6dfaae8da84a06b4b1cd9a3a916a8948ad98e7d7e77ba21d1d0da4d395ac381c37f0de923f51bd59186eafedcc6db350ebe143befc5702727d2ee88f6c89e65dda5379d971cf35165568518e4e0d5f843618d1d5008cceca7f39e6314e771ede8110ebcfcb0ef3a3faecc95b58e53de56dee49d11cafa6ba5ab00e5c82f229e16f3f23d00cf72811c898ba551fcf3b8be3a184a6d4b429a488511a5c54f40dd4b3bf429eff446404110ad925b31d2f51ff7449a229806db591f7f2b4e7a01312b8cbd49ee5f23d611f87d6e800bd7099f770698c7a7e2a9e01ad5b699ac9502207554351efd44dac8d77befec67d817e5b100dbd24e7235d854096faffe4c87074066686b4a405ba5645ae9ec798854904b2da750adc4db67dbaeeebe0765b7596dc10cff8e16d106951bedfdf53b91e523d39a0f0114ea0d6ac45d12455b78162aa74791000b57ca3c3a26234da476fb3e09c49cb13388579c198af2c6693457e96a297ea23fa8dfd4398c466970793facc9eb34ae377eaf9a291694f37d698b76f2ba13b1871f07c37ee02169db02f5c5d1fe0b59bbc9edbdabad3161807fa3af1e59a87571d3af1c3e7d302d709449ecb23ace8757d4af48e85656fb62cc64cce2561bdccd9c3ddc66ca1c43d81cafb93f1d230284da30728cd0e8ded5613df6b54b6fcb0119f41acb1e4433c2aca8acfb9592ec62c74b01d63f2f4bfb0df2268807a548be90353642f8924ed24d974825b04ca18dccaf40db4ceffbceaca7b22b23a3926bafd3f57cf1f515d797962ec16d8102ca8858f04968d7f599e6ad600820f0bb4f7c8b668cb3e872dfd365bc98a5b651cfa4da73a7bd467843fdb55a56ae616511fac7452aad76b2bdbc3289e2489a0dd7c34cc3068cbae758a92ce7b1a8c01f09096f7b4870bd5f339c97a34f9521aed2cd55c02d3441aa2917ed09f728e70801ff4ef2c19de2185f46b03a1733156c3e38e1f00faecd100d21569e9dfd9afcd137672d55bc4f911b8216138157fd4bfd821e09f750075ba12e37ce6f50933c30721627250ecaabd9b22f5de13fea6a4fb29f5090400acb95154c35fb0829f9f375394e6aa4ae99ddf1a18dc4b40fc50d638a70940499543fcc22381e6d826dd14c67093d86cda16cd33dd617a7005f92afb5f7c432756a0c711e22f3773cab0e00765bad80dde64e91956f82cbe8997012f9804e85627ae0bcd6d29c3fbd14e6e9651bcabeb2210668ce572403e2d61e579d4063118682b849c3caa992f4627fee4c3bee664f34591602265783940f73ffbd85d497709f4b9813106a041f173794004cc560d96ac66e7536a8dcc49bdc48bd55eb334fef62bdf96890d512845892e4cbccd62bceed7b38656db14481625bb41234c1b8b99954770462b9148f4448afa53fd685cee0c07316494896fbf883c1ffeb48bdebfbbf480b9f671b925ad797b2016bd48c33ed4a23b7263155b894eb6744e68a83f37abd7405cec637831cf562c957a95e18f98b3f37d75283a6bbb544f484fafa32529eaf90032dff6c4c3af86e24ddf33748025cf474be5a7ee7182ac6b95bc773d11d5fe0b983a5623e18bf1bc0c64aad58ce4ff596e6e2f5bf762ecec7ef8becf5bf8affb485ea5177b24f01bff0e84a3d48bf160deef5a7626cc4e1fe429e091767a2ddab241930cf6c05672593dfc451740b9dec677d4f2c7becb95c9772642410732ba574cef481a3d51f95f87e158fcd24fda4584b87dfef30d9bf0b89f935e8df49b691d28e9d13c1e017f397626f636aacbd107f67b4b0ccb644c78a37dc4bfdd35c1f0908be894d32abadfd700881baf8de0f91523000649a96bfcd8ba11916664f53e3158f35033a4ffc0ceffffd15cda492d0647628a92fa0979c16d7cbd38838ff93a35d0906bdca177d466052635d562571addec8334a495d56d3a5611ef3317518770fe35bcb47a9245f48f3d3c398a465fdf91f1f0a43b3bfc7458a6675ce713be4c97ab89c6af26967c63708f7bcb43a77f1785dcd4455e96bbc1a08fbbe18806ece9b450760a6aa081aefc8cec8428f227451c22e1fa4a92f8cd757db7ef0fc3b92da5e9be13b6c3abad2623b3b54dfd6cd99659656373a88ae952a422b172aabe5561812ac7dfed78024cb2f7a3c9c8714d44317c46e5421c62cce5278e5f8204765d20df77c1cac16aed0baf02f715be4d5925e2a0dce13559418d1a6ef417477d81becff17c7707f3a29bf9092a37cf434b74675e0ea2f9e4ddd900c122b91a8eca90c76cd148d9f782a3824dcf5c66cb329652f2bdb71a01f400d58b86756f676bdcc8ecaf9c84e918dfdd4849dc62bc88f9b5904a7e2ee458708995325ff47c38ddd57b7696f5c5ed9a0992ae71fecc824d92e5e7d5330060cd6d693abad65f11985577a68fdf00444d826869c613dcfa01096a37294518ccff35b36f749a137245db78848d166bcc7cbc347f151ebdc6c1fa5c7564a2f617452b3736109ffbf064cd0beb87056e28bef905d9ac7a50635b9091a3a2f2f3b094360370f7d4a07b1f31f4924e97c6c0bfdb9135e72f3cf5f899e5232ed5cbac9f8cefb87cc51c9df5251a7fcdc080df387545d8e6b4cabde3343c358a5a7c0a4a40fe6f13fe054c5f3b97fc8ed60278bfafc752486ebc178d73ef4fa2c30e6e83e2df1b90c71479e7ab4c3c03b364085c0ddaa79d7bd09db8f5e38dc45743ba574f1fc9269e4245e126b33f91ffae6bc23282ab3a4ddc64458b6fbd80f79e2fca8a21b7369fd89f8b1452429a3eeda617e1d73ca5f9c9f3b3faf086d61699ccc2bbc949c0b1867b36c808a95715bea3ad2f2595de031e34115277d0f83e7333763f29513fed211287d1dc76f49ee5ca5bbc40379aeb42de63575485d299e546e98567f797ea5329f59b6ecf60c9bdfcb410def89a51963e07357c35f4a688c2fc26eaef80d246e97880a8fbf192cd9ead918cc1240da6295e293be01e2ae95620a2ee78d4d01c32d72e2118e635eab1f1b683345530e0b465fb4352eb76768c6976fd61742382e0591e379f203b80fa4a5bdcd849b3fb3078fb630adfcc50c300c8592a87d116ae534e4d679cd1eee9b4a478088faed079c811373aa4d2445532ce54a2a03b4b138e5080ab9d4d41787a52a9ecc517dc8f9aa166e34f7783b7dd07f42eecf81efae51fef3c2e60e17408b8aaeed22f7e1273c076e04ce84c959494ab17fb4c48b82e9ed5e37eb2075f693d1203c628aca26f0282df523b9ce9b3d669c9491a27d568c10137784c1c79e88d9e3d95a97fb0c2975fc06a52f524f8e0b621fa3ee2525b33f378ea8881e7871a5cc098434796d8ce29a3c7fd391442bcade23e9c339014e3112ca47f96d1b16f4458c6464ad18cc92af4011374f02aa9c96f29bec2674970285e912594e90736c41872bf1582ac298b5295090508fab8d297665926ab053da7beed292fc423665a5ab8a17d30097258a662e14220f7c3e63335055e47afd56a5db8ce09b5c0f496cb74fd713d64f71d18a14c8d6a4668db24a127ca111cbe6fa507658bdd7341cafb7906647f9f51c7f540d4022362c6db5c4869ce770d8514408dd66f1516a81c3601c9ab92f841a7853fb31b008c7279a14c478135756160d69d2be43dfe9883b4ceac91febcb53ad49f336211a01aa647f28190e169ead2e6c63cd39e10a02ffc90942adcd993aa6e6c34eaddae295b123</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">? 竞赛 : 生活</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>P1829 [国家集训队]Crash的数字表格 / JZPTAB</title>
    <url>/2023/01/05/P1829-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC-JZPTAB/</url>
    <content><![CDATA[<p>不错的莫反练手题，可以说把大部分套路都涵盖了。</p>
<span id="more"></span>
<p>不妨令 $n\le m$，让我们求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{j=1}^{m} \text{lcm}(i,j)</script><p>先转换为我们熟悉的 $\gcd$：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{j=1}^{m} \frac{i\cdot j}{\gcd(i,j)}</script><p>枚举 $\gcd(i,j)$：</p>
<script type="math/tex; mode=display">
\sum_{k=1}^{n} \sum_{i=1}^n \sum_{j=1}^{m} \frac{i\cdot j \cdot [\gcd(i,j)=k]}{k}</script><p>变换为 $[\gcd(i,j)=1]$ 的形式：</p>
<script type="math/tex; mode=display">
\sum_ {k=1} ^ {n} \sum_ {i=1} ^ {\lfloor \frac{n}{k}\rfloor} \sum_ {j=1} ^ {\lfloor \frac{m}{k}\rfloor} {i\cdot j \cdot k \cdot [\gcd(i,j)=1]}</script><p>根据经典式子 $[\gcd(i,j)=1]=\sum\limits_{d|\gcd(i,j)} \mu(d)$，进一步得到：</p>
<script type="math/tex; mode=display">
\sum_ {k=1} ^ {n} \sum_ {i=1} ^ {\lfloor \frac{n}{k}\rfloor} \sum_ {j=1} ^ {\lfloor \frac{m}{k}\rfloor} \sum_{d|\gcd(i,j)} \mu(d) \cdot {i\cdot j \cdot k }</script><p>把 $d$ 提到前面去，尝试枚举 $d$：</p>
<script type="math/tex; mode=display">
\sum_ {k=1} ^ {n}  \sum_{d=1}^{\lfloor\frac{n}{k}\rfloor} \mu(d) \cdot k \cdot d^2\sum_ {i=1} ^ {\lfloor\frac {n}{kd}\rfloor} \sum_ {j=1} ^ {\lfloor\frac{m}{kd}\rfloor}{i\cdot j}</script><p>把 $kd$  看做一个整体，设 $kd=T$，又得到：</p>
<script type="math/tex; mode=display">
\sum_ {T=1} ^ {n}  T\sum_{d|T}\mu(d) \cdot d\sum_ {i=1} ^ {\lfloor\frac {n}{T}\rfloor} \sum_ {j=1} ^ {\lfloor\frac{m}{T}\rfloor}{i\cdot j}</script><p>最后面是个等差数列求和，并且可以整数分块做。考虑如何求 $f(x)=\sum\limits_{d|x}\mu(d)\cdot d$，很容易知道这是个积性函数，考虑在线性筛的过程中如何求，设 $x=i\cdot j$ ，其中 $j$ 为 $x$ 最小的质因子：</p>
<p>1.$x\in \text{prime}$ ，$f(x)=-x+1$。</p>
<p>2.$j$ 为 $i$ 的质因子，那么 $j$ 对 $f(x)$ 是没有贡献的，$f(x)=f(i)$。</p>
<p>3.$j$ 不为 $i$ 的质因子，那么根据积性函数的定义，$f(x)=f(i)\cdot f(j)$。</p>
<p>时间复杂度 $\mathcal O(n+T\sqrt n)$，$T$ 为询问总数，<del>不过洛谷上这道题只有一个询问</del>。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>,mod=<span class="number">20101009</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> cnt,prime[N],vis[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            f[i]=mod-i+<span class="number">1</span>,prime[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;<span class="number">1ll</span>*i*prime[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                f[i*prime[j]]=f[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i*prime[j]]=<span class="number">1ll</span>*f[i]*f[prime[j]]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">       f[i]=<span class="built_in">adj</span>(f[i<span class="number">-1</span>]+<span class="number">1ll</span>*f[i]*i%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1ll</span>*(x+<span class="number">1</span>)*x/<span class="number">2</span>)%mod*(<span class="number">1ll</span>*(y+<span class="number">1</span>)*y/<span class="number">2</span>%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=<span class="built_in">min</span>(n/(n/l),m/(m/l));</span><br><span class="line">        res=<span class="built_in">adj</span>(res+<span class="number">1ll</span>*<span class="built_in">adj</span>(f[r]-f[l<span class="number">-1</span>]+mod)*<span class="built_in">sum</span>(n/l,m/l)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span>(N<span class="number">-10</span>);</span><br><span class="line">    T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(n,m);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;m)<span class="built_in">swap</span>(n,m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(n,m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>P2505 [HAOI2012]道路</title>
    <url>/2022/03/05/P2505-HAOI2012-%E9%81%93%E8%B7%AF/</url>
    <content><![CDATA[<p>最短路 DAG。</p>
<span id="more"></span>
<p>首先，我们很容易知道：$i\to j$ 的最短路径的任意子路径 $u\to v$ 都是最短路径，接着我们可以得到另一个结论：若存在一条子路径 $u\to v$ 不是最短路径，那么很明显可以找到一条更短的 $u\to v$ 使得 $i\to j$ 更短。根据这个原则，我们可以得出在固定源点下，存在 $G$ 的一个子图 $G’$，使得 $G’$ 的每一条边都在 $S$ 到其他至少一个点的最短路径上，且 $G’$ 以外的边不在 $S$ 到任意一个点的最短路径上。这里把称 $G’$ 为源点为 $S$  时 $G$ 的<strong>最短路图</strong>。而求出最短路图的方式很简单，就是如果有 $dis_{v_i}=dis_{u_i}+w_i$，我们给这条路打上一个标记就行了。</p>
<p>容易得到这个最短路图是无环的，我们就可以在<strong>最短路图</strong>上进行<strong>拓扑排序</strong>。考虑维护两个数组为 $cnt1_i$ 与 $cnt2_i$ 。接着我们考虑正反两次拓扑分别表示 $i\to u$ 和 $v\to j$ 的最短路径条数，而答案就为 $cnt_1({u_i})*cnt_2({v_i})$ 之和。</p>
<p>使用 Dijkstra 的话时间复杂度应该是 $\mathcal O(nm\log n + n^2)$，只不过这里用了 SPFA。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1500</span>+<span class="number">10</span>,M=<span class="number">5000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> u[M],v[M],w[M];</span><br><span class="line"><span class="type">int</span> dis[N],vis[N];</span><br><span class="line"><span class="type">int</span> flag[M],ans[M];</span><br><span class="line"><span class="type">int</span> len,top[N],deg[N];</span><br><span class="line"><span class="type">int</span> cnt1[N],cnt2[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[now]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[to]&gt;dis[now]+e[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to]=dis[now]+e[i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[to])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[to]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(dis[v[i]]==dis[u[i]]+w[i])</span><br><span class="line">            flag[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">memset</span>(cnt1,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt1));</span><br><span class="line">    <span class="built_in">memset</span>(cnt2,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topo</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(flag[i])deg[v[i]]++;</span><br><span class="line">    cnt1[s]++;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        top[++len]=now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> to=v[i];</span><br><span class="line">            <span class="keyword">if</span>(!--deg[v[i]])q.<span class="built_in">push</span>(to);</span><br><span class="line">            cnt1[to]=(cnt1[to]+cnt1[now])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=top[i];</span><br><span class="line">        cnt2[now]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=head[now];j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> to=ver[j];</span><br><span class="line">            cnt2[now]=(cnt2[now]+cnt2[to])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">SPFA</span>(s);</span><br><span class="line">    <span class="built_in">topo</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(flag[i])</span><br><span class="line">            ans[i]=(ans[i]+cnt1[u[i]]*cnt2[v[i]])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">        <span class="built_in">add</span>(u[i],v[i],w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>P3177 [HAOI2015] 树上染色</title>
    <url>/2022/09/03/P3177-HAOI2015-%E6%A0%91%E4%B8%8A%E6%9F%93%E8%89%B2/</url>
    <content><![CDATA[<p>树上背包。</p>
<span id="more"></span>
<p>在这道题之前，我一直认为树上背包是 $\mathcal O(n^2m)$ ，直到这道题，才知道树上背包可以做到 $\mathcal O(nm)$ 的qwq。。。</p>
<p>状态很明显是 $f_{x,i}$，表示在 $x$ 为根的子树中选取 $i$ 个黑点得到的最大贡献。很明显我们不能直接计算，而是应该计算每条边的贡献，计算每条边被路径覆盖的次数并乘上其长度。</p>
<p>考虑覆盖次数。 $cnt=k\times (m-k)+size_y\times (n-m-(size_y-k))$，表示 $x$ 的儿子 $y$ 中选取 $k$ 个黑色节点时，$(x,y)$ 的覆盖次数，这很容易理解。然后就树上背包即可。</p>
<p>注意需要先转移 $k=0$ 的状态。还有需要注意不可行的状态，判一下边界即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,M=<span class="number">4e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> si[N];</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">min</span>(si[x]+si[y],m);~j;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="built_in">max</span>(j-si[x],<span class="number">0</span>);k&lt;=<span class="built_in">min</span>(si[y],j);k++)</span><br><span class="line">            &#123;</span><br><span class="line">                ll cnt=k*(m-k)+(si[y]-k)*(n-m+k-si[y]);</span><br><span class="line">                f[x][j]=<span class="built_in">max</span>(f[x][j],f[x][j-k]+f[y][k]+cnt*e[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    m=<span class="built_in">min</span>(m,n-m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>P3193 [HNOI2008]GT考试</title>
    <url>/2022/02/18/P3193-GT%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<p>KMP + 矩阵快速幂。</p>
<span id="more"></span>
<p>首先考虑暴力 DP。</p>
<p>设计状态 $f_{i,j}$ 为长串匹配 $i$ 位，短串最多匹配 $j$ 位时的方案数。</p>
<p>易得转移方程式 $ f_{i,j}\sum_{i=0}^{m-1}= f_{i-1,k}\times g_{k,j}$。</p>
<p>很明显 $g$ 数组是不变的，并且可以通过 KMP 预处理出。</p>
<p>这时我们再观察数据范围 $n$ 很大， $m$ 很小并且 $g$ 数组是不变的，于是我们考虑使用 <strong>矩阵快速幂</strong>。</p>
<p>我们的 $g$ 数组就是我们的构造矩阵，此时直接套上矩阵快速幂即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,mod,ans;</span><br><span class="line"><span class="type">int</span> a[maxn],ne[maxn];</span><br><span class="line"><span class="type">int</span> g[maxn][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;<span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in">sizeof</span>(s));&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix a,<span class="type">const</span> Matrix b)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">                c.s[i][j]=(c.s[i][j]+a.s[i][k]*b.s[k][j])%mod;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KMP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=ne[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(a[j+<span class="number">1</span>]!=a[i]&amp;&amp;j)j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(a[j+<span class="number">1</span>]==a[i])ne[i]=j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp=i;</span><br><span class="line">            <span class="keyword">while</span>(temp&amp;&amp;a[temp+<span class="number">1</span>]!=j)temp=ne[temp];</span><br><span class="line">            <span class="keyword">if</span>(j==a[temp+<span class="number">1</span>])temp++;</span><br><span class="line">            g[i][temp]++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">quickpow</span><span class="params">(Matrix a,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        sum.s[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)sum=sum*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,a+i);</span><br><span class="line">    <span class="built_in">KMP</span>();</span><br><span class="line">    Matrix a,b;</span><br><span class="line">    a.s[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            b.s[i][j]=g[i][j];</span><br><span class="line">    a=a*<span class="built_in">quickpow</span>(b,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        ans=(ans+a.s[<span class="number">0</span>][i])%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>矩阵快速幂</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>P3571 [POI2014]SUP-Supercomputer</title>
    <url>/2022/06/16/P3571-POI2014-SUP-Supercomputer/</url>
    <content><![CDATA[<p> 可以用堆做到 $\mathcal O(n\log n)$ ，也可以用更加优秀的斜率优化实现 $\mathcal O(n)$。</p>
<span id="more"></span>
<p><a href="https://www.luogu.com.cn/problem/P3571">题目链接</a></p>
<p>考虑按照 $dep$ 分层。记 $cnt_{dep}$ 表示深度为 $dep$ 的点数。考虑从大到小枚举 $k$，将对于每个 $k$ 的最优解都求出来。</p>
<p>在 $k$ 足够大时，显然一次能且仅能选择同一层的点，即 $ans_k=\max {dep_i}$。当某一时刻，$cnt_i&gt;k$，那么我们无法在一次内选择完第 $i$ 层的点，需要将其中 $cnt_i-k$ 个点挪到下一层选取。</p>
<p>题目中限制了拥有父子关系的两个点无法同时选择，我们需要证明只需要将剩下的点向下挪动一层就能够得到合法解。</p>
<p>假设此时 $cnt_{i-1}\le k$。  </p>
<p>我们需要在第 $i$ 次和第 $i+1$ 共选取 $2k$ 个点其中第 $i$ 层选取 $cnt_i$ 个，第 $i+1$ 层选取 $2k-cnt_i$ 个点。  </p>
<p>1. $cnt_{i+1}&lt;2k-cnt_i$：第 $i+1$ 天未取满 $k$ 个点，并不影响结果。  </p>
<p>2. $cnt_{i+1}&gt;2k-cnt_i$：将第 $i+1$ 层多余的点挪向第 $i+2$ 层，这显然是一个相同的子问题。  </p>
<p>3. $cnt_i&gt;2k$：将第 $i$ 层多余的点和第 $i+1$ 层所有点挪向第 $i+2$ 层，这显然又是一个相同的子问题。  </p>
<p>而这 $2k$ 个点拥有父子关系的点对数 $&lt;k$，故一定能找到合法方案。</p>
<p>也可以感性理解，既然当 $k’&gt;k$ 时，被选中的点可以在当层选择，那么挪到下一层就更容易有合法方案了。</p>
<p>由上面的结论我们可以得到，我们始终可以把操作一次多余的点挪向下一层，保证每层的点数 $\le k$，最多有 $n$ 层。  </p>
<p>这个时候暴力维护是不行的，因为我们并不关心多出来的点来自哪一层，我们尝试将多层放在一起合并后维护。  </p>
<p>我们于是就维护的就是一段区间 $[l,r]$，表示连续 $r-l+1$ 天仅选取第 $[l,r]$ 层的点，且一定取完，即 $\sum_{i=l}^r cnt_i\le (r-l+1)\times k$。  </p>
<p>故我们只需要用维护区间，每次将堆顶不合法区间取出，向下合并即可。</p>
<p>时间复杂度 $\mathcal O(n\log n)$ ，比隔壁斜率优化 $\mathcal O(n)$ 要慢，但也算提供新的思路吧。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1&amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l,r,cnt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;rhs)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (ll)cnt*(rhs.r-rhs.l+<span class="number">1</span>)&lt;(ll)rhs.cnt*(r-l+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (ll)(r-l+<span class="number">1</span>)*k&lt;cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> query[N],ans[N];</span><br><span class="line"><span class="type">int</span> cnt[N],dep[N];</span><br><span class="line"><span class="type">int</span> ed[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">priority_queue&lt;Node&gt;q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    	<span class="built_in">read</span>(query[i]);</span><br><span class="line">    ++cnt[dep[<span class="number">1</span>]=<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">int</span> fa;</span><br><span class="line">    	<span class="built_in">read</span>(fa);</span><br><span class="line">    	++cnt[dep[i]=dep[fa]+<span class="number">1</span>];</span><br><span class="line">    	res=<span class="built_in">max</span>(res,dep[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ed[i]=i;</span><br><span class="line">		q.<span class="built_in">push</span>((Node)&#123;i,i,cnt[i]&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1e6</span>;k&gt;=<span class="number">1</span>;k--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(q.<span class="built_in">top</span>().<span class="built_in">check</span>(k))</span><br><span class="line">		&#123;</span><br><span class="line">			Node x=q.<span class="built_in">top</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span>(vis[x.l])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			vis[x.r+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">			res=<span class="built_in">max</span>(res,ed[x.l]=ed[x.r+<span class="number">1</span>]);</span><br><span class="line">			cnt[x.l]+=cnt[x.r+<span class="number">1</span>];</span><br><span class="line">			q.<span class="built_in">push</span>((Node)&#123;x.l,ed[x.l],cnt[x.l]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		ans[k]=res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[query[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>P3960 [NOIP2017 提高组] 列队</title>
    <url>/2022/09/15/P3960-NOIP2017-%E6%8F%90%E9%AB%98%E7%BB%84-%E5%88%97%E9%98%9F/</url>
    <content><![CDATA[<p>平衡树的应用。</p>
<span id="more"></span>
<p>我们很容易将模型抽象成有 $n+1$ 个序列，然后我们对其进行区间移动操作。这似乎很容易用平衡树解决。但是发现空间根本开不下。</p>
<p>一个有用的 trick：我们可以尝试用每个节点储存一个区间。我们需要用这个区间中的子区间时，我们只需要将这个区间拆开就行。这样我们可以保证点的个数始终是 $\mathcal O(n+q)$ 的。</p>
<p>实现用 FHQ-Treap 或 Splay 都可以。FHQ-Treap 写起来似乎要简单一点，但是我却因为某个 merge 中变量写反了而调了很久。。。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll l,r;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> val,cnt;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> tot,rt[N],x,y,z;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].cnt=tr[tr[x].son[<span class="number">0</span>]].cnt+tr[tr[x].son[<span class="number">1</span>]].cnt+(tr[x].r-tr[x].l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">insert</span><span class="params">(ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[++tot].cnt=r-l+<span class="number">1</span>;</span><br><span class="line">    tr[tot].l=l;</span><br><span class="line">    tr[tot].r=r;</span><br><span class="line">    tr[tot].val=<span class="built_in">rand</span>();</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y)<span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].val&lt;tr[y].val)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].son[<span class="number">1</span>]=<span class="built_in">merge</span>(tr[x].son[<span class="number">1</span>],y);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[y].son[<span class="number">0</span>]=<span class="built_in">merge</span>(x,tr[y].son[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">pushup</span>(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> k,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> x=y=<span class="number">0</span>,<span class="built_in">void</span>();</span><br><span class="line">    <span class="keyword">if</span>(tr[tr[p].son[<span class="number">0</span>]].cnt&gt;=k)</span><br><span class="line">        y=p,<span class="built_in">split</span>(tr[p].son[<span class="number">0</span>],k,x,tr[p].son[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=k-tr[tr[p].son[<span class="number">0</span>]].cnt;</span><br><span class="line">        <span class="type">int</span> len=tr[p].r-tr[p].l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(res&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> q=<span class="built_in">insert</span>(tr[p].l+res,tr[p].r);</span><br><span class="line">            tr[p].r=tr[p].l+res<span class="number">-1</span>;</span><br><span class="line">            tr[p].son[<span class="number">1</span>]=<span class="built_in">merge</span>(q,tr[p].son[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">pushup</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        x=p,<span class="built_in">split</span>(tr[p].son[<span class="number">1</span>],res-len,tr[p].son[<span class="number">1</span>],y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        rt[i]=<span class="built_in">insert</span>(<span class="number">1ll</span>*(i<span class="number">-1</span>)*m+<span class="number">1</span>,<span class="number">1ll</span>*i*m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        rt[n+<span class="number">1</span>]=<span class="built_in">merge</span>(rt[n+<span class="number">1</span>],<span class="built_in">insert</span>(<span class="number">1ll</span>*i*m,<span class="number">1ll</span>*i*m));</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">read</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(b==m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">split</span>(rt[n+<span class="number">1</span>],a,x,y);</span><br><span class="line">            <span class="built_in">split</span>(x,a<span class="number">-1</span>,x,z);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,tr[z].l);</span><br><span class="line">            rt[n+<span class="number">1</span>]=<span class="built_in">merge</span>(x,<span class="built_in">merge</span>(y,z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">split</span>(rt[a],b,x,y);</span><br><span class="line">            <span class="built_in">split</span>(x,b<span class="number">-1</span>,x,z);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,tr[z].l);</span><br><span class="line">            <span class="type">int</span> x1,y1,z1;</span><br><span class="line">            <span class="built_in">split</span>(rt[n+<span class="number">1</span>],a,x1,y1);</span><br><span class="line">            <span class="built_in">split</span>(x1,a<span class="number">-1</span>,x1,z1);</span><br><span class="line">            rt[a]=<span class="built_in">merge</span>(x,<span class="built_in">merge</span>(y,z1));</span><br><span class="line">            rt[n+<span class="number">1</span>]=<span class="built_in">merge</span>(x1,<span class="built_in">merge</span>(y1,z));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>FHQ-Treap</tag>
      </tags>
  </entry>
  <entry>
    <title>P5574 [CmdOI2019]任务分配问题</title>
    <url>/2022/12/07/P5574-CmdOI2019-%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>决策单调性 + 分治 优化 DP。</p>
<span id="more"></span>
<p>$\mathcal O(k n^2\log n)$ 是比较显然的。注意到 $w(i,j)+w(i-1,j+1)=w(i-1,j)+w(i,j+1)$，联想到决策单调性。因为贡献是不太好算的，于是我们尝试利用决策单调性直接分治求解，而每次贡献利用树状数组 $\mathcal O(n\log n)$ 求。最后一共求解 $k$ 次即可。时间复杂度为 $\mathcal O(kn\log ^2n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,K=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],t[N];</span><br><span class="line"><span class="type">int</span> f[N],g[N];</span><br><span class="line"><span class="type">int</span> res,tl,tr;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        t[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        res+=t[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tl&gt;l)tl--,res+=<span class="built_in">ask</span>(a[tl]),<span class="built_in">add</span>(a[tl],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(tr&lt;r)tr++,res+=tr-tl-<span class="built_in">ask</span>(a[tr]),<span class="built_in">add</span>(a[tr],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(tl&lt;l)<span class="built_in">add</span>(a[tl],<span class="number">-1</span>),res-=<span class="built_in">ask</span>(a[tl]),tl++;</span><br><span class="line">    <span class="keyword">while</span>(tr&gt;r)<span class="built_in">add</span>(a[tr],<span class="number">-1</span>),res-=tr-tl-<span class="built_in">ask</span>(a[tr]),tr--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,pm=mid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(pr,mid<span class="number">-1</span>);i&gt;=pl;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">calc</span>(i+<span class="number">1</span>,mid);</span><br><span class="line">        <span class="keyword">if</span>(g[i]+res&lt;=f[mid])f[mid]=g[i]+res,pm=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(pl,pm,l,mid<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">solve</span>(pm,pr,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        a[i]=n-a[i]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tl=<span class="number">1</span>,tr=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>]=g[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            g[j]=f[j];</span><br><span class="line">        <span class="built_in">solve</span>(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>决策单调性</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P4841 [集训队作业2013]城市规划</title>
    <url>/2023/01/12/P4841-%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013-%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>所以，到底用没用了生成函数的知识？</p>
<span id="more"></span>
<p>之前在蓝书上看到过一点这类题的 DP 做法。结果感觉这题的做法有点类似，只不过变成卷积来求，反而跟生成函数没有太大的联系（？）。</p>
<p>设计两个函数 $f(x),g(x)$ 分别表示有标号的无向图和有标号的无向连通图。考虑这类问题的经典套路，固定点 $1$，枚举点 $1$ 所在连通块大小，可以得到关系式：</p>
<script type="math/tex; mode=display">
g(x)=\sum_{i=1}^x {\binom{x-1}{i-1} f(i)g(x-i)}</script><p>显然有 $g(x)=2^{\binom{x}{2}}$，将其带入并做一些变换：</p>
<script type="math/tex; mode=display">
2^{\binom{x}{2}}=\sum_{i=1}^x {\binom{x-1}{i-1} f(i)2^{\binom{n-i}{2}}}\\
\frac {2^{\binom{x}{2}}}{(n-1)!}=\sum_{i=1}^x {\frac{f(i)2^{\binom{n-i}{2}}}{(i-1)!(n-i)!}}</script><p>这就变成类似卷积的形式了，为了更好的操作，我们另外设计几个函数：</p>
<script type="math/tex; mode=display">
F(x)=\frac{f(x)}{(x-1)!}\\
G(x)=\frac{2^{\binom{n-x}{2}}}{x!}\\
H(x)=\frac{2^{\binom{n-x}{2}}}{(x-1)!}</script><p>我们明显有：</p>
<script type="math/tex; mode=display">
H(x)=F(x)G(X)\\
F(x)=H(x)G^{-1}(x) \mod x^{n+1}</script><p>对 $G(x)$ 求逆再和 $H(x)$ 卷积就得到了 $F(x)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,mod=<span class="number">1004535809</span>,G=<span class="number">3</span>,Gi=<span class="number">334845270</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> fac[N],finv[N];</span><br><span class="line"><span class="type">int</span> bit,tot,rev[N];</span><br><span class="line"><span class="type">int</span> g[N],ginv[N],h[N];</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bit=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;(len&lt;&lt;<span class="number">1</span>))bit++;</span><br><span class="line">	tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;bit<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">		x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		<span class="keyword">if</span>(rev[i]&lt;i)<span class="built_in">swap</span>(a[rev[i]],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> g=<span class="built_in">qpow</span>(inv==<span class="number">1</span>?G:Gi,(mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,cur=<span class="number">1</span>;j&lt;mid;j++,cur=<span class="number">1ll</span>*cur*g%mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x=a[i+j],y=<span class="number">1ll</span>*cur*a[i+j+mid]%mod;</span><br><span class="line">				a[i+j]=<span class="built_in">adj</span>(x+y),a[i+j+mid]=<span class="built_in">adj</span>(x-y+mod);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poly_mul</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">1</span>),<span class="built_in">NTT</span>(b,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		a[i]=<span class="number">1ll</span>*a[i]*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> inv=<span class="built_in">qpow</span>(tot,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		a[i]=<span class="built_in">adj</span>(<span class="number">1ll</span>*a[i]*inv%mod+mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poly_inv</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		b[<span class="number">0</span>]=<span class="built_in">qpow</span>(a[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">poly_inv</span>(a,b,(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">init</span>(len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;i&lt;tot;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		c[i]=(i&lt;len?a[i]:<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">1</span>),<span class="built_in">NTT</span>(c,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		b[i]=<span class="number">1ll</span>*<span class="built_in">adj</span>(<span class="number">2</span><span class="number">-1ll</span>*b[i]*c[i]%mod+mod)*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> inv=<span class="built_in">qpow</span>(tot,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		b[i]=<span class="built_in">adj</span>(<span class="number">1ll</span>*b[i]*inv%mod+mod);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;tot;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	fac[<span class="number">0</span>]=finv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod,finv[i]=<span class="built_in">qpow</span>(fac[i],mod<span class="number">-2</span>);</span><br><span class="line">	g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> res=<span class="built_in">qpow</span>(<span class="number">2</span>,(<span class="number">1ll</span>*i*(i<span class="number">-1</span>)/<span class="number">2</span>)%(mod<span class="number">-1</span>));</span><br><span class="line">		g[i]=<span class="number">1ll</span>*res*finv[i]%mod;</span><br><span class="line">		h[i]=<span class="number">1ll</span>*res*finv[i<span class="number">-1</span>]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	n++;</span><br><span class="line">	<span class="built_in">poly_inv</span>(g,ginv,n);</span><br><span class="line">	<span class="built_in">poly_mul</span>(h,ginv,n);</span><br><span class="line">	n--;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1ll</span>*h[n]*fac[n<span class="number">-1</span>]%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>P5999 [CEOI2016] kangaroo</title>
    <url>/2022/09/01/P5999-CEOI2016-kangaroo/</url>
    <content><![CDATA[<p>可能（？）有用的 DP trick。</p>
<span id="more"></span>
<p><a href="https://www.luogu.com.cn/problem/P5999">题目链接</a></p>
<p>先转化题意，我们实际上需要求的就是满足以下条件的 $1\to n$ 排列 $a$ 的个数：</p>
<p>1.$a_1=s,a_n=t$；</p>
<p>2.$\forall i\in [2,n-1],(a_i-a_{i-1})\times (a_i-a_{i+1}) &gt;0$。</p>
<p>如何 DP 呢？这似乎并不好弄，因为我们进行传统的 DP 时我们并不好知道用了哪些数。</p>
<p>于是我们考虑新的思路，尝试分段型 DP。从小到大考虑将每个数插到满足条件的两段之间。这样得到的新段一定是满足条件的，并且不会算重。于是设计状态 $f_{i,j}$ 表示插入了 $i$ 个数，形成了 $j$ 个连续的段的方案数。转移时考虑将 $i$ 插进前面两段之间，或者新建一段就可以了。注意只能将 $s$ 插到最前面，将 $t$ 插到最后面。并且新建一段时不可以将其他数插在 $s$ 之前 $t$ 之后。</p>
<p>或者换一种理解方式，我们将 $f_{i,j}$ 表示使用前 $i$ 个数建了 $j$ 个笛卡尔树。每次转移时，将已有的某两颗笛卡尔树接在当前的 $i$ 上，或者以 $i$ 再建一颗笛卡尔树。容易发现这样构成的笛卡尔树所对应的序列就是满足条件的排列 $a$。</p>
<p>我们这里是将每一段看做相对有序的。其实也可以看成相对无序的，转移方程有所不同。但结果都一样是 $f_{n,1}$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,s,t;</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;s,&amp;t);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=s&amp;&amp;i!=t)</span><br><span class="line">                f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j+<span class="number">1</span>]*j+f[i<span class="number">-1</span>][j<span class="number">-1</span>]*(j-(i&gt;s)-(i&gt;t)))%mod;<span class="comment">//插到中间或新建一段</span></span><br><span class="line">            <span class="keyword">else</span> f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;<span class="comment">//插到两端或新建一段</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P6186 [NOI Online #1 提高组] 冒泡排序</title>
    <url>/2022/08/29/P6186-NOI-Online-1-%E6%8F%90%E9%AB%98%E7%BB%84-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>不错的思维题。</p>
<span id="more"></span>
<p>先考虑进行一轮冒泡排序的结果。我们发现，对于一个数，当且仅当它前面没有大于它的数，它的位置会被后移到第一个大于它的数，并且在之后的每一轮都会后移。并且每轮冒泡排序有 $k$ 个这样的数，那么这一轮减少的逆序对数量就是 $n-k$。更进一步，我们发现：若一个数前面有 $\le k$ 个大于它的数，那么它将在第 $k+1$ 轮冒泡排序时一定会被后移。</p>
<p>于是我们考虑预处理出 $pre_i$ 表示第 $i$ 个数前面有多少个大于它的数，这个很容易可以用树状数组来求。而逆序对个数就是 $\sum_{i=1}^{n} pre_i$。我们再用树状数组来维护 $k$ 轮冒泡排序进行完后的逆序对个数就行了。</p>
<p>对于修改操作也很简单，就是一个差分形式，直接单点修改就可以了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">ll sum,c[N],pre[N],p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        c[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        res+=c[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        pre[i]=i<span class="number">-1</span>-<span class="built_in">ask</span>(a[i]);</span><br><span class="line">        sum+=pre[i],p[pre[i]]++;</span><br><span class="line">        <span class="built_in">add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>,sum);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res+=p[i];</span><br><span class="line">        <span class="built_in">add</span>(i+<span class="number">2</span>,res-n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,x;</span><br><span class="line">        <span class="built_in">read</span>(op,x);</span><br><span class="line">        x=<span class="built_in">min</span>(x,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[x+<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">swap</span>(pre[x],pre[x+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[x]&lt;a[x+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                pre[x]--;</span><br><span class="line">                <span class="built_in">add</span>(pre[x]+<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">add</span>(pre[x+<span class="number">1</span>]+<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">                pre[x+<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask</span>(x+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>P8112 [Cnoi2021]符文破译</title>
    <url>/2022/08/18/P8112-Cnoi2021-%E7%AC%A6%E6%96%87%E7%A0%B4%E8%AF%91/</url>
    <content><![CDATA[<p>不错的 Z 函数练习题。</p>
<span id="more"></span>
<p>很明显正着做不好搞，因为假如选取了当前某个前缀，很容易影响到后面的选取，并且不好优化。</p>
<p>经典<strong>正难则反</strong>的思想，考虑从后面逐渐选取模式串的前缀，这样就不会影响到前面前缀的选取（感性理解）。也就意味着，我们每次尝试选取一个文本串的一个<strong>后缀</strong>，使其等于模式串的<strong>前缀</strong>，然后进行下一步操作。</p>
<p>这是我们想到什么？ Z 函数不就是用来求出这东西的吗。考虑 DP，我们很容易写出状态转移方程：</p>
<p>$f_i=min_{i+1\le j\le i+p_i}{f[j]+1}$。</p>
<p>有了这个，直接暴力DP是 $\mathcal O(n^2)$ 的，显然可以用线段树来维护，但 $\mathcal O(n\log n)$ 复杂度仍不允许我们通过此题。</p>
<p>还能继续优化吗？注意到对于所以可以转移到的 $f_i$  一定是具有<strong>单调性</strong>，因为较短的后缀的代价一定不会大于较长的后缀的代价。而且根据 <strong>Z 函数</strong>的性质，对于所有可以转移到的 $i$，$i+p_i$ 明显是<strong>单调递减</strong>的。这瞬间就转化为经典模型了，我们很容易用<strong>单调队列</strong>来优化，于是复杂度就变为了优秀的 $\mathcal O(n)$。</p>
<p>因为 $f_i$ 具有<strong>单调性</strong>，每次我们直接将其加入队尾就可以了。然后注意一些细节就可以了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> z[N],p[N],f[N];</span><br><span class="line"><span class="type">int</span> l,r,q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Z</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    z[<span class="number">1</span>]=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r)z[i]=<span class="built_in">min</span>(z[i-l+<span class="number">1</span>],r-i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i+z[i]&lt;=n&amp;&amp;s[i+z[i]]==s[z[i]+<span class="number">1</span>])z[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+z[i]<span class="number">-1</span>&gt;r)l=i,r=i+z[i]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exkmp</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n,<span class="type">char</span> *t,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Z</span>(t,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r)p[i]=<span class="built_in">min</span>(z[i-l+<span class="number">1</span>],r-i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i+p[i]&lt;=n&amp;&amp;s[i+p[i]]==t[p[i]+<span class="number">1</span>])p[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+p[i]<span class="number">-1</span>&gt;r)l=i,r=i+p[i]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//Z函数模板</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s %s&quot;</span>,&amp;m,&amp;n,b+<span class="number">1</span>,a+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exkmp</span>(a,n,b,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        j&gt;i+p[i]?p[i]=<span class="number">0</span>:j=i+p[i];<span class="comment">//注意处理不可能转移到的情况</span></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[q[l=r=<span class="number">1</span>]=n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!p[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&gt;i+p[i])l++;</span><br><span class="line">        f[i]=f[q[l]]+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// while(l&lt;=r&amp;&amp;f[q[r]]&gt;=f[i])r--;</span></span><br><span class="line">        <span class="comment">//这里直接入队就可以了</span></span><br><span class="line">        q[++r]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[<span class="number">1</span>]&lt;=INF)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Fake&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>希望没有误人子弟 qwq。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>KMP</tag>
        <tag>字符串</tag>
        <tag>Z函数</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P8867 [NOIP2022] 建造军营</title>
    <url>/2022/12/05/P8867-NOIP2022-%E5%BB%BA%E9%80%A0%E5%86%9B%E8%90%A5/</url>
    <content><![CDATA[<p>算是敲个警钟。</p>
<span id="more"></span>
<p>题外话：笔者在 NOIP2022 的考场上，因为水平并不高，给了自己一种会做 T2 的错觉，于是直接放弃可做性更强的 T3 选择暴冲 T2 。最终没有能够取得理想成绩。在此警示后人。</p>
<p>提供一种不太一样的 DP（？）。</p>
<p>很容易考虑到双连通分量缩点，再树形DP（不在树上的边我们称之为非树边）。对于 $\mathcal O(n^2)$ 有比较显然的树形背包。</p>
<p>考虑如何做到线性。设计状态 $f_x$ 表示在以 $x$ 为根的子树中，至少选了一个点，且与 $x$ 连通的方案数。设 $sum_x$ 表示以 $x$ 为根的子树中边的总数。考虑每个子节点 $y$ 对 $f_x$ 的贡献：选取的话贡献为 $f_y$，不选取那么子树 $y$ 中的边和 $y\to x$ 这条边可以随便选（但是点不能选），所以贡献为 $2^{sum_y+1}$。再减去一个点不选的方案数 $2^{sum_x}$ 即可。</p>
<p>因为子树外的边（并且除去到父亲节点的边）可以随便选取，所以对答案的贡献就是 $f_x\times2^{m-sum_x-[fa!=0]}$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,head[N],ver[M&lt;&lt;<span class="number">1</span>],ne[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> num,dfn[N],low[N],bri[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt,c[N];</span><br><span class="line"><span class="type">int</span> a[N],b[N],sum[N];</span><br><span class="line">ll f[N],ans,p[N+M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y,i);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]&lt;low[y])</span><br><span class="line">                bri[i]=bri[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i!=(pre^<span class="number">1</span>))</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c[x]=cnt;</span><br><span class="line">    a[cnt]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!c[y]&amp;&amp;!bri[i])</span><br><span class="line">            <span class="built_in">prework</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x]=p[a[x]+b[x]]%mod;<span class="comment">//f[x]初值</span></span><br><span class="line">    sum[x]=b[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        sum[x]+=sum[y]+<span class="number">1</span>;</span><br><span class="line">        f[x]=f[x]*((f[y]+p[sum[y]+<span class="number">1</span>])%mod)%mod;</span><br><span class="line">        <span class="comment">//y对f[x]的贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=(f[x]+mod-p[sum[x]])%mod;<span class="comment">//减去一个点都不选的方案数</span></span><br><span class="line">    ans=(ans+f[x]*p[m-sum[x]-(fa!=<span class="number">0</span>)]%mod)%mod;<span class="comment">//统计总的方案数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Tarjan</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!c[i])</span><br><span class="line">            cnt++,<span class="built_in">prework</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(c[x]==c[y])b[c[x]]++;</span><br><span class="line">            <span class="keyword">else</span> e[c[x]].<span class="built_in">push_back</span>(c[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        b[i]/=<span class="number">2</span>;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)</span><br><span class="line">        p[i]=(p[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>缩点</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>P8907 [USACO22DEC] Making Friends P</title>
    <url>/2023/01/02/P8907-USACO22DEC-Making-Friends-P/</url>
    <content><![CDATA[<p>线段树合并，也可以启发式合并。</p>
<span id="more"></span>
<p>首先，对于一条边 $i \to j$，只有 $i &lt; j$ 时有意义，并且。对于每个点，统计时我们也只统计这样的边。考虑维护每个点与相邻点的点集，而每次将该点的点集合并到 该点的点集中编号最小的点上，仔细思考会发现这样是不重不漏的。</p>
<p>较为简单地可以用 set 启发式合并维护这个点集，时间复杂度 $\mathcal O(n\log^2 n)$。但更加优秀的是用线段树合并来维护，时间复杂度 $\mathcal O(n \log n)$，<del>但是竟然没有前面一种写法跑得快</del>。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> tot,rt[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr[N*<span class="number">80</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].sum=tr[tr[x].lc].sum+tr[tr[x].rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)x=++tot;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> tr[x].sum=<span class="number">1</span>,<span class="built_in">void</span>();</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">insert</span>(tr[x].lc,l,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p||!q)<span class="keyword">return</span> p+q;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum=tr[p].sum|tr[q].sum;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[p].lc=<span class="built_in">merge</span>(tr[p].lc,tr[q].lc,l,mid);</span><br><span class="line">    tr[p].rc=<span class="built_in">merge</span>(tr[p].rc,tr[q].rc,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].lc&amp;&amp;tr[tr[x].lc].sum)<span class="keyword">return</span> <span class="built_in">query</span>(tr[x].lc,l,mid);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(tr[x].rc,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> tr[x].sum=k,<span class="built_in">void</span>();</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(tr[x].lc,l,mid,pos,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="keyword">if</span>(u&gt;v)<span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="built_in">insert</span>(rt[u],<span class="number">1</span>,n,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[rt[x]].sum)<span class="keyword">continue</span>;</span><br><span class="line">        ans+=tr[rt[x]].sum;</span><br><span class="line">        <span class="type">int</span> y=<span class="built_in">query</span>(rt[x],<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">modify</span>(rt[x],<span class="number">1</span>,n,y,<span class="number">0</span>);</span><br><span class="line">        rt[y]=<span class="built_in">merge</span>(rt[y],rt[x],<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans-m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树合并</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>P8917 [DMOI-R2] 风神瞳（Aeolus Hitomi）</title>
    <url>/2022/12/30/P8917-DMOI-R2-%E9%A3%8E%E7%A5%9E%E7%9E%B3%EF%BC%88Aeolus-Hitomi%EF%BC%89/</url>
    <content><![CDATA[<p>比较裸的树上背包。</p>
<span id="more"></span>
<p>最需要处理的就是向叶子节点连续跳 $k$ 步。设计状态 $f_{x,t,i}$ 为从 $x$ 还需要向叶子节点跳 $t$ 步并且收集 $i$ 个风神瞳最少花费。</p>
<p>考虑如何转移。因为这 $t$ 步只能跳一次，转移过程中我们令 $f_{x,t,i}$ 已经使用了这 $t$ 步。而对于子节点 $y$：</p>
<p>1.在 $y$ 上跳这 $t$ 步，那么相当于 $x$ 在之前的子树上需要跳 $0$ 步：$f_{x,t,i}\gets f_{x,0,i-j}+f_{y,t-1,j}+1$。</p>
<p>2.在之前的子树上跳了这 $t$ 步，那么相当 $x$ 在 $y$ 上需要跳 $0$ 步。而我们可以选择直接走到 $y$，或者先向上走 $\le \min \{dep_x-1,k\}$ 步，再向叶子结点跳 $k$ 步：$f_{x,t,i}\gets f_{x,t,i-j}+ \min \{f_{y,0,j}+2,\min_{p=\max \{k-dep_x+1,1\}}^{k}{k-p+1+f_{y,p-1,j}+1 \}}$，后面的式子是一个整体，拿出来单独计算即可。</p>
<p>对于 $t=0$ 单独处理，类似上面的转移。时间复杂度 $\mathcal O(nmk)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,M=<span class="number">5e2</span>+<span class="number">10</span>,K=<span class="number">1e2</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,p,q;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> a[N],si[N],d[N];</span><br><span class="line"><span class="type">int</span> f[N][K][M],ans[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=a[x];</span><br><span class="line">    f[x][<span class="number">0</span>][a[x]]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=si[x]+si[y];~j;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="built_in">max</span>(j-si[x],<span class="number">0</span>);k&lt;=si[y];k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> res=INF;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="built_in">max</span>(p-d[x],<span class="number">1</span>);t&lt;=p;t++)</span><br><span class="line">                    res=<span class="built_in">min</span>(res,(p-t+<span class="number">1</span>)+f[y][t<span class="number">-1</span>][k]+<span class="number">1</span>);</span><br><span class="line">                res=<span class="built_in">min</span>(res,f[y][<span class="number">0</span>][k]+<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=p<span class="number">-1</span>;t++)</span><br><span class="line">                    f[x][t][j]=<span class="built_in">min</span>(&#123;f[x][t][j],f[x][<span class="number">0</span>][j-k]+<span class="number">1</span>+f[y][t<span class="number">-1</span>][k],f[x][t][j-k]+res&#125;);</span><br><span class="line">                f[x][<span class="number">0</span>][j]=<span class="built_in">min</span>(f[x][<span class="number">0</span>][j],f[x][<span class="number">0</span>][j-k]+res);</span><br><span class="line">            &#125;</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,p,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        a[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][m+<span class="number">1</span>]=<span class="number">2</span>*n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=f[<span class="number">1</span>][<span class="number">0</span>][i];j&lt;f[<span class="number">1</span>][<span class="number">0</span>][i+<span class="number">1</span>];j++)</span><br><span class="line">            ans[j]=i;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">2</span>*n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>SP3734 PERIODNI - Periodni</title>
    <url>/2022/09/02/SP3734-PERIODNI-Periodni/</url>
    <content><![CDATA[<p>笛卡尔树上进行 DP。</p>
<span id="more"></span>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506">HDU 1506 最大子矩形</a> 也可以用笛卡尔树来做，具体思路就是对于高度建笛卡尔树，再一遍 dfs 即可计算。注意到这道题，直觉告诉我们也需要从高度最小的考虑。于是我们也考虑建出笛卡尔树进行 DP。</p>
<p>这样就变成一个树上背包计数，我们每一次递归子树的时候考虑    将当前列的高度去掉，只计算之上的，这样就不会影响到当前行。很明显有转移方程：$f_{x,i}\gets f_{x,i-j}\times f_{y,j}$。</p>
<p>再考虑将当前高度，就是计算在 $h_x\times size_x$ 的方格里选取 $k$ 个点的方案数。选 $k$ 行 $\binom{k}{h_x}$，选 $k$ 列 $\binom{k}{size_x}$，并且是无序的，所以方案数就是 $k! \cdot \binom{k}{h_x}\cdot \binom{k}{size_x}$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,M=<span class="number">1e7</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> top,sta[N];</span><br><span class="line">ll fac[M];</span><br><span class="line"><span class="type">int</span> si[N];</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;M;i++)</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (mod-mod/x)*<span class="built_in">inv</span>(mod%x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*<span class="built_in">inv</span>(fac[m])%mod*<span class="built_in">inv</span>(fac[n-m])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>]=si[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=tr[x].l;</span><br><span class="line">        <span class="built_in">dfs</span>(y,tr[x].val);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(si[x],k);~i;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,si[y]);j++)</span><br><span class="line">                f[x][i]=(f[x][i]+f[x][i-j]*f[y][j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=tr[x].r;</span><br><span class="line">        <span class="built_in">dfs</span>(y,tr[x].val);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(si[x],k);~i;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,si[y]);j++)</span><br><span class="line">                f[x][i]=(f[x][i]+f[x][i-j]*f[y][j]%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(si[x],k);~i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,tr[x].val-res);j++)</span><br><span class="line">            f[x][i]=(f[x][i]+f[x][i-j]*fac[j]%mod*<span class="built_in">C</span>(tr[x].val-res,j)%mod*<span class="built_in">C</span>(si[x]-(i-j),j)%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(tr[i].val);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=top;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;tr[sta[p]].val&gt;tr[i].val)</span><br><span class="line">            p--;</span><br><span class="line">        <span class="keyword">if</span>(p)tr[sta[p]].r=i;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;top)tr[i].l=sta[p+<span class="number">1</span>];</span><br><span class="line">        sta[++p]=i;</span><br><span class="line">        top=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(sta[<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[sta[<span class="number">1</span>]][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title>SP6717 TWOPATHS - Two Paths</title>
    <url>/2022/09/05/SP6717-TWOPATHS-Two-Paths/</url>
    <content><![CDATA[<p>比较裸的换根 DP。</p>
<span id="more"></span>
<p><del>虚高题</del>。</p>
<p>update on 2022.11.13。原题解被 @zhanghenglei 所 Hack。现在已将解法修正，如果仍有问题，欢迎指出qwq。</p>
<p>不难想到用 $f_x,g_x$ 分别表示以 $x$ 为根的子树内和子树外最长链的长度。答案就是 $\max\{f_x\times g_x\}$。$f_x$ 很容易求，考虑 $g_x$ 怎么求。</p>
<p>$g_x$ 可以从父亲节点转移过来，这启发我们可以类似于换根 DP 的方法来求 $g_x$。</p>
<p>考虑怎么构成一条子树外的链。无非是从父节点往上延伸，或者从父节点往下延伸的链。再将他们最长的两段在父节点拼起来成为一个答案。</p>
<p>但是我们选取的两段链不能在 $x$ 的子树中。这就意味着我们需要先求出，从父节点往下延伸的链的最大值、亚大值和次大值，以及对应的子节点。转移时判断一下所选的链有没有在 $x$ 的子树中就行。</p>
<p>从该节点 $x$ 往上延伸的最长链也可以通过最大值和亚大值通过换根 DP 来求出，也比较简单。</p>
<p>但是这样解是有漏洞的，$g_x$ 求出来只是恰好经过其父节点的最长链，而不是整棵树中除去该子树的最长链，就像这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/93kgatph.png" alt=""></p>
<p><code>output : 30</code><br><code>answer : 36</code></p>
<p>所以我们需要再多记一个 $h_x$ 表示该节点的父节点的子树之外的最长链，转移与上面类似。</p>
<p>具体可看看代码，有一些注释。有点繁琐，但还是比较好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[N][<span class="number">3</span>],l[N],t[N][<span class="number">3</span>],f[N],g[N],h[N];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">2</span>]=d[x][<span class="number">1</span>],t[x][<span class="number">2</span>]=t[x][<span class="number">1</span>];</span><br><span class="line">            d[x][<span class="number">1</span>]=d[x][<span class="number">0</span>],t[x][<span class="number">1</span>]=t[x][<span class="number">0</span>];</span><br><span class="line">            d[x][<span class="number">0</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">0</span>]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">2</span>]=d[x][<span class="number">1</span>],t[x][<span class="number">2</span>]=t[x][<span class="number">1</span>];</span><br><span class="line">            d[x][<span class="number">1</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">1</span>]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">2</span>])</span><br><span class="line">            d[x][<span class="number">2</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">2</span>]=y;</span><br><span class="line">        <span class="comment">//处理出从该节点往下延伸的链的最大值、亚大值和次大值</span></span><br><span class="line">        <span class="comment">//以及其所对应的儿子</span></span><br><span class="line">        f[x]=<span class="built_in">max</span>(f[x],f[y]);<span class="comment">//从子节点转移</span></span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=<span class="built_in">max</span>(f[x],d[x][<span class="number">0</span>]+d[x][<span class="number">1</span>]);<span class="comment">//从自己转移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,<span class="number">1ll</span>*f[x]*<span class="built_in">max</span>(g[x],h[x]));<span class="comment">//统计答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        l[y]=l[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[x][<span class="number">0</span>]&amp;&amp;t[x][<span class="number">0</span>]!=y)</span><br><span class="line">            l[y]=<span class="built_in">max</span>(l[x],d[x][<span class="number">0</span>])+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[x][<span class="number">1</span>])</span><br><span class="line">            l[y]=<span class="built_in">max</span>(l[x],d[x][<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//转移从该节点向上延伸的最长链</span></span><br><span class="line">        <span class="type">int</span> res[<span class="number">4</span>];</span><br><span class="line">        res[<span class="number">0</span>]=t[x][<span class="number">0</span>]!=y?d[x][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>]=t[x][<span class="number">1</span>]!=y?d[x][<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">2</span>]=t[x][<span class="number">2</span>]!=y?d[x][<span class="number">2</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">3</span>]=l[x];</span><br><span class="line">        <span class="built_in">sort</span>(res,res+<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//从四条链中选取合法的最长的两条</span></span><br><span class="line">        g[y]=<span class="built_in">max</span>(g[x],res[<span class="number">2</span>]+res[<span class="number">3</span>]);</span><br><span class="line">        h[y]=h[x];</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x);</span><br><span class="line">        res[<span class="number">0</span>]=t[y][<span class="number">0</span>]!=y?d[y][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>]=t[y][<span class="number">1</span>]!=y?d[y][<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">2</span>]=t[y][<span class="number">2</span>]!=y?d[y][<span class="number">2</span>]:<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(res,res+<span class="number">3</span>);</span><br><span class="line">        h[x]=<span class="built_in">max</span>(h[x],res[<span class="number">1</span>]+res[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//转移该节点的父节点的子树之外的最长链</span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>换根DP</tag>
      </tags>
  </entry>
  <entry>
    <title>初级图论</title>
    <url>/2022/08/23/%E5%88%9D%E7%BA%A7%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<p>学习和做题笔记，旧的与新的都有。</p>
<span id="more"></span>
<h2 id="1-最短路"><a href="#1-最短路" class="headerlink" title="1 最短路"></a>1 最短路</h2><p>最短路是图论中最基础的一类问题。</p>
<h3 id="1-1-Bellman-Ford"><a href="#1-1-Bellman-Ford" class="headerlink" title="1.1 Bellman-Ford"></a>1.1 Bellman-Ford</h3><p>Bellman-Ford 是一种较为暴力求最短路的算法。</p>
<p>称一轮<strong>松弛</strong>为对于每一条边 $(u,v)$，用 $dis_u+w(u,v)$ 更新 $dis_v$。那么每一轮<strong>松弛</strong>必然会有一个节点的最短路会被更新，只需松弛 $n-1$ 即可。时间复杂度为 $\mathcal O(nm)$。</p>
<p>而我们也可以用该算法来判断<strong>是否存在负环</strong>：若<strong>松弛</strong>超过 $n-1$ 轮仍有节点最短路被更新，那么图中存在负环。</p>
<h3 id="1-2-SPFA"><a href="#1-2-SPFA" class="headerlink" title="1.2 SPFA"></a>1.2 SPFA</h3><p><a href="https://www.luogu.com.cn/problem/P4768">关于SPFA，它死了。</a></p>
<p>本质上是使用队列来优化的 Bellman-Ford。很明显我们每次并不需要枚举所有边，而只需要枚举在上一轮<strong>松弛</strong>中最短路被更新的节点的出边即可。因此每次我们在<strong>松弛</strong>过程中将最短路被更新的加入队列之中。并且可以记录某个节点是否在队列，若是则不用加入。</p>
<p>该算法在随机图上效率很高，但是对于特殊构造的数据，例如<strong>菊花图</strong>，会被卡成与 Bellman-Ford 相同的 $\mathcal O(nm)$。所以对于<strong>非负权图</strong>，应该采用下面即将提到的 Dikjstra 算法。</p>
<p>当然，SPFA 也可以用来判断负环，若<strong>最短路边数</strong>大于 $n-1$，则图中存在负环。（也可以判断每个点的入队次数，不过会稍慢一点）。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">1e3</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> tot,ver[M],e[M],ne[M],head[M];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x15f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!vis[now])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[now]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=ne[i])</span><br><span class="line">            <span class="keyword">if</span>(dis[now]+e[i]&lt;dis[ver[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[ver[i]]=dis[now]+e[i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[ver[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[ver[i]]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(ver[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">SPFA</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-3-Dijkstra"><a href="#1-3-Dijkstra" class="headerlink" title="1.3 Dijkstra"></a>1.3 Dijkstra</h3><p>Dijkstra是基于<strong>贪心</strong>的最短路算法，只适用于<strong>非负权图</strong>。</p>
<p>称<strong>扩展</strong>节点 $u$ 为对于 $u$ 的所有出边 $(u,v)$ ，用 $dis_u+w(u,v)$ 来更新</p>
<p>对于所有当前已经得到最短路的节点，取出所有未扩展节点中 $dis$ 最小的节点并扩展。因为没有负权边，所以取出的节点的 $dis_x$ 必然是<strong>单调不降</strong>的。</p>
<p>注意，这个贪心过程，当每个点被第一次取出时，此时的 $dis$ 就是源点到它的最短路。很容易即可证明这一点。</p>
<p>取出 $dis$ 最小的节点的过程可以用优先队列来实现。每次扩展后将最短路得到更新的节点加入优先队列中。</p>
<p>需要注意的是一个节点可能被扩展多次并多次进入优先队列，这样又会扩展多次，这会使我们的算法退化至 $\mathcal O(m^2\log m)$。但是我们知道每次它第一次被取出时，一定是源点到该节点的最短路。为了避免某个节点扩展多次，我们需要记录该点是否已经从队列中取出（已经得到最短路并扩展），若已经从队列中取出，则直接跳过，否则得到最短路直接扩展并记录。时间复杂度为 $\mathcal O(m\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id,dis;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(Node u,Node v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> u.dis&gt;v.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>((Node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().id;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])<span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+e[i]&lt;dis[ver[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[ver[i]]=dis[x]+e[i];</span><br><span class="line">                q.<span class="built_in">push</span>((Node)&#123;ver[i],dis[ver[i]]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-4-Floyd"><a href="#1-4-Floyd" class="headerlink" title="1.4 Floyd"></a>1.4 Floyd</h3><p>用于求<strong>全源最短路</strong>的最常用算法，核心思想是 DP。</p>
<p>主要四步，枚举中转点 $k$，枚举 $i$，枚举 $j$，使用 $dis(i,k)+dis(k,j)$ 来更新 $dis_{i,j}$。</p>
<p>最需要注意的是枚举顺序，需要先枚举中转点 $k$，然后接着枚举 $i,j$ 。该算法正确性很显然，此处不再赘述。</p>
<p>Floyd 常被用来求传递闭包。将内层操作改为 $dis(i,j)\gets dis(i,j) \or (dis(i,k) \and dis(k,j))$ 即可。可用 <code>bitset</code> 来优化。</p>
<p>代码就算了。</p>
<h3 id="1-5-Johnson"><a href="#1-5-Johnson" class="headerlink" title="1.5 Johnson"></a>1.5 Johnson</h3><p>对于<strong>带负权稀疏图的全源最短路</strong>。因为带负权，无法使用 Dijkstra。我们可以直接跑 $n$ 遍 SPFA，但是被卡到 $\mathcal O(n^2m)$就直接寄了，我们需要更为优秀的算法。</p>
<p>Johnson 的巧妙之处在于为每个点恰当地赋上<strong>势能</strong> $h_i$，这里的<strong>势能</strong>可以类似于物理上的势能。然后将 $(u,v)$ 的边权变为 $w(u,v)+h_u-h_v$，不难发现 $dis(s,t)=dis’(s,t)-h_s+h_t$，这只与 $s,t$ 有关，并且仍然是原来的最短路。于是我们可以直接在求最短路。</p>
<p>但是我们还没有解决负权的问题。我们需要使得 $w(u,v)+h_u\ge h_v$，（<del>这个形式不就是我们的<strong>差分约束</strong>吗？直接跑就可以得到 $h$ 的一组解</del>），联想到<strong>三角形不等式</strong>，如果没负环我们一定可以通过不断松弛使得 $h$ 满足上述关系式。将每个点直接入队（相当于新建一个源点 $0$ 再向每个点连长度为 $0$ 的边），然后跑一遍 SPFA，得出得最短路数组即为 $h$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e3</span>+<span class="number">10</span>,M=<span class="number">6e3</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> cnt[N],h[N],dis[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id,d;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d&gt;t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        q.<span class="built_in">push</span>(i),vis[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(h[x]+e[i]&lt;h[y])</span><br><span class="line">            &#123;</span><br><span class="line">                h[y]=h[x]+e[i];</span><br><span class="line">                cnt[y]=cnt[x]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[y]&gt;=n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y])q.<span class="built_in">push</span>(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    priority_queue&lt;Node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    dis[s][s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().id;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])<span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[s][x]+e[i]+h[x]-h[y]&lt;dis[s][y])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[s][y]=dis[s][x]+e[i]+h[x]-h[y];</span><br><span class="line">                q.<span class="built_in">push</span>((Node)&#123;y,dis[s][y]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">SPFA</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">Dijkstra</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i][j]&gt;INF)</span><br><span class="line">                ans+=<span class="number">1ll</span>*j*INF;</span><br><span class="line">            <span class="keyword">else</span> ans+=<span class="number">1ll</span>*j*(dis[i][j]-h[i]+h[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-6-例题"><a href="#1-6-例题" class="headerlink" title="1.6 例题"></a>1.6 例题</h3><h4 id="1-P2505-HAOI2012-道路"><a href="#1-P2505-HAOI2012-道路" class="headerlink" title="1.P2505 [HAOI2012]道路"></a>1.<a href="https://www.luogu.com.cn/problem/P2505">P2505 [HAOI2012]道路</a></h4><p>题目简述：一张有向图，求出每条边被不同最短路径经过的次数， $n\le 1500,m\le 5000$。</p>
<p>经典题，考点：最短路图（或者说 最短路DAG？）。先说一下最短路图的概念：</p>
<p>首先，我们很容易知道：$i\to j$ 的最短路径的任意子路径 $u\to v$ 都是最短路径，接着我们可以得到另一个结论：若存在一条子路径 $u\to v$ 不是最短路径，那么很明显可以找到一条更短的 $u\to v$ 使得 $i\to j$ 更短。根据这个原则，我们可以得出在固定源点下，存在 $G$ 的一个子图 $G’$，使得 $G’$ 的每一条边都在 $S$ 到其他至少一个点的最短路径上，且 $G’$ 以外的边不在 $S$ 到任意一个点的最短路径上。这里把称 $G’$ 为源点为 $S$  时 $G$ 的<strong>最短路图</strong>。而求出最短路图的方式很简单，就是如果有 $dis_{v_i}=dis_{u_i}+w_i$，我们给这条路打上一个标记就行了。</p>
<p>有了这个有什么用呢？容易得到这个最短路图是无环的，我们就可以在<strong>最短路图</strong>上进行<strong>拓扑排序</strong>。考虑维护两个数组为 $cnt1_i$ 与 $cnt2_i$ 。接着我们考虑正反两次拓扑分别表示 $i\to u$ 和 $v\to j$ 的最短路径条数，而答案就为 $cnt_1({u_i})*cnt_2({v_i})$ 之和。</p>
<p>使用 Dijkstra 的话时间复杂度应该是 $\mathcal O(nm\log n + n^2)$，SPFA 也能过。</p>
<h4 id="2-P2680-NOIP2015-提高组-运输计划"><a href="#2-P2680-NOIP2015-提高组-运输计划" class="headerlink" title="2.P2680 [NOIP2015 提高组] 运输计划"></a>2.<a href="https://www.luogu.com.cn/problem/P2680">P2680 [NOIP2015 提高组] 运输计划</a></h4><p><del>还是说几个经典题。</del></p>
<p>注意到需要求的是最后一个完成的任务时间的最小值。最大值最小很容易想到二分答案。设二分值为 $lim$。对于修建的虫洞，其必然经过每个用时大于 $lim$ 的任务，并且用时最多的减去虫洞的长度需要小于 $lim$。</p>
<p>先考虑第一个条件，我们很容易想到<strong>树上差分</strong>，然后通过统计子树和来计算每条边被任务经过的次数。然后我们再统计所有满足第一个条件的边中最长的长度，最后判断一下第二个条件就行了。</p>
<h4 id="3-P4009-汽车加油行驶问题"><a href="#3-P4009-汽车加油行驶问题" class="headerlink" title="3.P4009 汽车加油行驶问题"></a>3.<a href="https://www.luogu.com.cn/problem/P4009">P4009 汽车加油行驶问题</a></h4><p>表面上是一个网络流24题，但直接跑<strong>分层图最短路</strong>就可以了。</p>
<h4 id="4-P7916-CSP-S-2021-交通规划"><a href="#4-P7916-CSP-S-2021-交通规划" class="headerlink" title="4.P7916 [CSP-S 2021] 交通规划"></a>4.<a href="https://www.luogu.com.cn/problem/P7916">P7916 [CSP-S 2021] 交通规划</a></h4><p>第一眼是一个经典最小割模型，直接上 Dinic 有 65pts（<del>真的很多了</del>）。</p>
<p>先考虑 $k=2$ 的情况，不就是 <a href="https://www.luogu.com.cn/problem/P4001">P4001 [ICPC-Beijing 2006] 狼抓兔子</a>吗？直接转成对偶图跑最短路即可。类似的 trick 还有 <a href="https://www.luogu.com.cn/problem/P2046">P2046 [NOI2010] 海拔</a>。</p>
<p>对于 $k&gt;2$ 的情况，我们还是从对偶图最短路的角度进行思考。考虑对于任意两个颜色不同的关键点之间新建一个点。很容易发现对于所有新建的点中，任意两个点的最短路就可以把这张图割成两半。就像这样：<img src="image1.png" alt=""></p>
<p>我们对每个新建的点分别作为源，求与其他点的最短路。因为最优的方案的中的最短路一定不会相交（调整法），于是我们可以尝试断环为链进行区间DP，也就是对其进行两两匹配，最后便可以得出答案。时间复杂度：$\mathcal O(\sum knm\log (nm)+\sum k^3)$。</p>
<h4 id="5-P5304-GXOI-GZOI2019-旅行者"><a href="#5-P5304-GXOI-GZOI2019-旅行者" class="headerlink" title="5.P5304 [GXOI/GZOI2019]旅行者"></a>5.<a href="https://www.luogu.com.cn/problem/P5304">P5304 [GXOI/GZOI2019]旅行者</a></h4><p>首先说一种较为暴力的做法，我们尝试将 $k$ 个关键点分为两组，超级源点 $s$ 向其中一组连边，另一组则向超级汇点 $t$ 连边，很明显 $s\to t$ 的最短路就是不同组之间进行配对的答案 。</p>
<p>介于这个思路，有一个较为暴力做法：每次将点的编号按照二进制中的第 $i$ 位来分为两组，然后按照上述方法跑 $\log k$ 次 $s\to t$ 的最短路，最后取 min 就是答案。这样很显然是正确的，因为最近的一对点的编号本来就是不同的，所以说一定会被统计到。</p>
<p>还有更优秀的做法。我们尝试用 Dijkstra 求出从 $i$ 到最近的关键点的距离 $dis1_i$ 和从最近的关键点到 $i$ 的距离 $dis_2(i)$，并且记录是从哪个关键点转移过来，设为 $f_i$ 和 $g_i$。然后我们枚举每一条边 $(u,v,w)$，若 $f_u$ 不等于 $g_v$，将 $dis_1(u)+w+dis_2(v)$ 计入答案即可。</p>
<p>这样枚举边为什么是正确的呢？这里留给读者思考。想通了这个问题也就不难明白为什么枚举点是错误的。</p>
<h4 id="6-CF843D-Dynamic-Shortest-Path"><a href="#6-CF843D-Dynamic-Shortest-Path" class="headerlink" title="6.CF843D Dynamic Shortest Path"></a>6.<a href="https://codeforces.com/problemset/problem/843/D">CF843D Dynamic Shortest Path</a></h4><p>每次询问直接暴力当然不能够通过。我们考虑先做一次 Dijkstra，然后再计算最短路的增量。</p>
<p>如何计算增量？设原来的最短路为 $dis_i$，考虑类似于 Johnson 的做法，我们把边权变为 $w(u,v)+dis_u-dis_v$，再跑最短路。这样就得到了增量。类似于 Johnson 的边权，这里的边权也一定是非负的。但是为什么这样是正确的呢？还是类似于 Johnson 中最短路的式子，有 $dis’_u=w’(s,p_1)+w’(p_1,p_2)+\dots+w’(p_{l-1},p_l)-dis_u$。于是这里求出的最短路径也是原图上的最短路径。</p>
<p>但是直接用的 Dijkstra 来求增量跟暴力的复杂度没有区别。但是注意到每次的增量最多为 $\min(c,n-1)$，并且最短路是单调不降的，于是我们可以将朴素 Dijkstra 中的堆直接换成桶 ，对于桶的每一个位置开一个队列，再从前往后做就可以了。这样的单次的复杂度就是 $\mathcal O(m)$ 的。</p>
<p>最开始仍然需要做一遍朴素 Dijkstra，总复杂度为 $\mathcal O(m\log n +qm)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e15</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    ll d;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d&gt;t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,T;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>((Node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().id;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])<span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+e[i]&lt;dis[y])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y]=dis[x]+e[i];</span><br><span class="line">                q.<span class="built_in">push</span>((Node)&#123;y,dis[y]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=lim;i++)<span class="keyword">while</span>(!q[i].<span class="built_in">empty</span>())q[i].<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i]=lim;</span><br><span class="line">    q[<span class="number">0</span>].<span class="built_in">push</span>(<span class="number">1</span>),f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=mx;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q[t].<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=q[t].<span class="built_in">front</span>();</span><br><span class="line">            q[t].<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(f[x]&lt;t)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> y=ver[i];</span><br><span class="line">                <span class="keyword">if</span>(f[x]+e[i]+dis[x]-dis[y]&lt;f[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    f[y]=f[x]+e[i]+dis[x]-dis[y];</span><br><span class="line">                    mx=<span class="built_in">max</span>(mx,f[y]);</span><br><span class="line">                    q[f[y]].<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(dis[i]&lt;INF)dis[i]+=f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,c;</span><br><span class="line">        <span class="built_in">read</span>(op,c);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dis[c]&lt;INF?dis[c]:<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=c;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x;</span><br><span class="line">                <span class="built_in">read</span>(x);</span><br><span class="line">                e[x]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">BFS</span>(<span class="built_in">min</span>(c,n<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="2-差分约束"><a href="#2-差分约束" class="headerlink" title="2 差分约束"></a>2 差分约束</h2><h3 id="2-1-算法介绍"><a href="#2-1-算法介绍" class="headerlink" title="2.1 算法介绍"></a>2.1 算法介绍</h3><p>前置芝士：Bellman-Ford 和 SPFA。</p>
<p>差分约束问题为：给出若干形如 $x_a-x_b\le c$ 或 $x_a-x_b\ge c$ 求解任意一组 $x$ 的解。</p>
<p>我们很容易将所有的限制写为 $x_i+c\ge x_j$。这熟悉的形式，让我们想起<strong>三角形不等式</strong>，使得我们可以用最短路求解。我们从 $i\to j$ 连一条长度为 $c$ 的边，然后从超级源点 $s$ 向每个点连长度为 $0$ 的边以防止不连通（或者说一开始令所有的 $dis=0$ 并将所有的点入队），跑最短路，每个点的最短路长度就是一组合法解。</p>
<p>因为 $c$ 一般都有负数，所以用 Bellman-Ford 和 SPFA 求解最短路，此时得到的解为字典序最大解（似乎有些违反直觉，但确实是这样）。显然，若出现负环则无解。</p>
<p>时间复杂度为 $\mathcal O(nm)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>,M=<span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> vis[N],dis[N],cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        q.<span class="built_in">push</span>(i),vis[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+e[i]&lt;dis[ver[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[ver[i]]=dis[x]+e[i];</span><br><span class="line">                cnt[ver[i]]=cnt[x]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[ver[i]]&gt;=n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!vis[ver[i]])</span><br><span class="line">                    q.<span class="built_in">push</span>(ver[i]),vis[ver[i]]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">SPFA</span>())</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="2-2-例题"><a href="#2-2-例题" class="headerlink" title="2.2 例题"></a>2.2 例题</h3><h4 id="1-P5590-赛车游戏"><a href="#1-P5590-赛车游戏" class="headerlink" title="1.P5590 赛车游戏"></a>1.<a href="https://www.luogu.com.cn/problem/P5590">P5590 赛车游戏</a></h4><p>每条边的长度我们并不好直接将构造，但很明显我们只需要构造一组合法的 $dis$ 就可以了。</p>
<p>考虑<strong>三角形不等式</strong>，对于每条边 $(u,v)$，满足 $1\le dis_v-dis_u\le 9$。熟悉的形式使我们想到<strong>差分约束</strong>。按照模型将图建出来，得到 $dis$ 的任意一组解即可。</p>
<p>需要注意一下去除与答案无关的边，这些边随便取什么值都可以，正反两遍 dfs 即可判断。</p>
<h4 id="2-P4926-1007-倍杀测量者"><a href="#2-P4926-1007-倍杀测量者" class="headerlink" title="2.P4926 [1007]倍杀测量者"></a>2.<a href="https://www.luogu.com.cn/problem/P4926">P4926 [1007]倍杀测量者</a></h4><p>很明显需要先二分，看起来是个<strong>差分约束</strong>的形式，可是我们需要求的是倍数的形式，而非差分。怎样转换？我们只需要对所有的 $k$ 取对数就可以把乘法转化为加法。这样我们直接上差分约束判断负环就可以了。</p>
<p>注意这里给定了初值，我们从 $0$ 向  $i$ 分别连 $\log x$ 和 $-\log x$ 的边就可以了，相等形式的边都可以这样连（转化为 $x_i\ge x_j$ 且 $x_j\ge x_i$ 即可）。</p>
<h4 id="3-AGC056C-01-Balanced"><a href="#3-AGC056C-01-Balanced" class="headerlink" title="3.[AGC056C] 01 Balanced"></a>3.<a href="https://atcoder.jp/contests/agc056/tasks/agc056_c">[AGC056C] 01 Balanced</a></h4><p>形式就很差分约束，可以直接对前缀和数组进行差分约束，但是这样的复杂度是 $\mathcal O(nm)$，无法通过。</p>
<p>我们发现最令人头疼的是对于 $[l,r]$ 这样的限制，因为我们必须建权值为 $(r-l+1)/2$ 的边。这样我们只能够暴力跑 SPFA。</p>
<p>但是我们可以将 $0$ 看为 $1$，而将 $1$ 看为 $-1$。这样我们对于 $[l,r]$ 这样的限制，只需要建长度为 $0$ 的边即可。相邻点的限制变成了 $|v_i-v_{i-1}|\le 1$。所有边权只剩下 $0,1$，我们可以直接用 01 BFS 跑最短路。因为差分约束求出来的解有字典序为最大解，所以求出来就是原问题最小字典序的解。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,M=<span class="number">3e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line">deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i],d=dis[x]+e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[y]&gt;d)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y]=d;</span><br><span class="line">                <span class="keyword">if</span>(!e[i])q.<span class="built_in">push_front</span>(y);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add</span>(i,i<span class="number">-1</span>,<span class="number">1</span>),<span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">read</span>(l,r);</span><br><span class="line">        <span class="built_in">add</span>(r,l<span class="number">-1</span>,<span class="number">0</span>),<span class="built_in">add</span>(l<span class="number">-1</span>,r,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BFS</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dis[i<span class="number">-1</span>]&gt;dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="4-P7515-省选联考-2021-A-卷-矩阵游戏"><a href="#4-P7515-省选联考-2021-A-卷-矩阵游戏" class="headerlink" title="4.P7515 [省选联考 2021 A 卷] 矩阵游戏"></a>4.<a href="https://www.luogu.com.cn/problem/P7515">P7515 [省选联考 2021 A 卷] 矩阵游戏</a></h4><p>最重要的限制是矩阵 $a$ 中每个数的大小 $\le 10^6$。</p>
<p>我们考虑先构造出任意一种 $a$，再对其进行调整即可，我们按照奇偶对行列进行分类对奇数 $\pm 1$，对偶数 $\mp 1$，这样还是能够满足 $b$ 的限制的。转化为 $0\le a_{i,j} +(-1)^i h_{i} +(-1)^j l_{j} \le 10^6$。但是当行与列的奇偶性相同时就会出先和约束，这是我们无法解决的。</p>
<p>考虑如何限制 $(-1)^i,(-1)^j$，使其不会出现符号相同的情况。尝试对其进行黑白染色，限制转化为 $0\le a_{i,j} +(-1)^{i+j} h_{i} +(-1)^{i+j+1} l_{j} \le 10^6$，这样也能够满足 $b$ 的限制，并且可以直接跑差分约束求出 $h,l$ 即可。</p>
<p>可能有一点卡常，据说可以使用寻址更连续 Bellman-Ford 来代替 SPFA，但感觉没啥用。真正有用的是将存图方式从链式前向星改成用 vector 实现的邻接表。因为边的数量很多，并且寻址变得非常连续。笔者的代码在改了之后快了将近 5 ~ 6 倍。</p>
<h2 id="3-最小生成树"><a href="#3-最小生成树" class="headerlink" title="3 最小生成树"></a>3 最小生成树</h2><h3 id="3-1-Kruskal"><a href="#3-1-Kruskal" class="headerlink" title="3.1 Kruskal"></a>3.1 Kruskal</h3><p>最经典且常用的最小生成树算法，非常简单且基础。</p>
<p>现将所有边排序，贪心地从小到大选取，若边的两个端点所属联通块不同，就将该边加入答案，用并查集维护连通性。正确性用反证法就可以很容易证明了。其它应用还有 Kruskal 重构树。</p>
<h3 id="3-2-Prim"><a href="#3-2-Prim" class="headerlink" title="3.2 Prim"></a>3.2 Prim</h3><p>Prim 总是维护 MST 的一部分，每次选取维护的联通块所相连的边中最小的边，将该边加入答案的同时维护联通块。其中选取最小的边用优先队列就可以了，时间复杂度 $\mathcal O(m\log n)$。可以类似于 Dijkstra。</p>
<h3 id="3-3-Boruvka"><a href="#3-3-Boruvka" class="headerlink" title="3.3 Boruvka"></a>3.3 Boruvka</h3><p>从点来考虑，对于每个点而言，与它相邻的边权最小的边必然入选。这一点还是可以通过反证法可以证明。</p>
<p>于是我们每次求出每个点与其相连的最小的边。将所有这些边加入最小生成树中。出去至多 $\frac{n}{2}$ 重边，每条边会使联通块个数 $-1$，因此一次这样过程可以使得联通块的个数严格减少一半。这样对剩余联通块继续上述过程至多 $\log_2 n$ 轮即可求得 MST。时间复杂度为 $\mathcal O(m\log n)$。Boruvka 在解决某类最小生成树问题上非常有用。对于形如给定一张 n 个点的完全图，两点之间的信息可以通过某种关系计算得出，该算法可以较好得求解。</p>
<h3 id="3-4-例题"><a href="#3-4-例题" class="headerlink" title="3.4 例题"></a>3.4 例题</h3><h4 id="1-CF827D-Best-Edge-Weight"><a href="#1-CF827D-Best-Edge-Weight" class="headerlink" title="1.CF827D Best Edge Weight"></a>1.<a href="https://codeforces.com/problemset/problem/827/D">CF827D Best Edge Weight</a></h4><p>显然，我们应该先把最小生成树求出来，然后逐渐考虑每条边。设求出的生成树是 $T$，且下文中的路径都指生成树上的路径。</p>
<p>1.$(u,v,w)\notin T$：如果选取这条边，那么很明显其最大值为路径 $(u,v)$ 上的边的边权最大值。</p>
<p>2.$(u,v,w)\in T$：这种情况稍微复杂一点，这种边的最大值，是所有能覆盖这条边的非树边的最小值。何为能覆盖？就是对于一条非树边 $(x,y,z)$，若某一树边 $(u,v,w)$ 在路径 $(x,y)$ 上，我们则称之为能覆盖。</p>
<p> 于是我们先考虑非树边，求出这条边的答案。然后每次对路径 $(u,v)$ 上的边权与 $w$ 进行取 min 操作。这可以用树链剖分很好的维护。但是有更好的做法，因为我们是按照边权从小到大排过序的，所以对于已经覆盖过的边，其已经是最优答案了，我们并不需要再覆盖它。于是我们可以每次直接暴力覆盖，然后用并查集维护未被覆盖的边就行了。时间复杂度 $\mathcal O(m\log m)$，瓶颈是排序。</p>
<p>代码非常的好写。</p>
<h4 id="2-CF609E-Minimum-spanning-tree-for-each-edge"><a href="#2-CF609E-Minimum-spanning-tree-for-each-edge" class="headerlink" title="2.CF609E Minimum spanning tree for each edge"></a>2.<a href="https://codeforces.com/problemset/problem/609/E">CF609E Minimum spanning tree for each edge</a></h4><p>与上一道题套路差不多，只不过要用树链剖分维护。</p>
<h4 id="3-CF1120D-Power-Tree"><a href="#3-CF1120D-Power-Tree" class="headerlink" title="3.CF1120D Power Tree"></a>3.<a href="https://codeforces.com/problemset/problem/1120/D">CF1120D Power Tree</a></h4><p>考虑将树上操作转化为在 $dfn$ 序上进行操作。子树操作就变成了区间操作。对于区间操作我们又可以考虑用差分将其转化为单点操作。这里的 $dfn$ 序可以只考虑叶子结点。</p>
<p>接着很自然地想到了生成树，对于每个操作 $(dfn_i,dfn_i+size_i,w_i)$，我们都把他转化为 $n$ 个节点的图上的一条边。显然只要使这个图联通我们就可以控制所有点的点权。求一遍 MST 就行了。</p>
<h4 id="4-CF888G-Xor-MST"><a href="#4-CF888G-Xor-MST" class="headerlink" title="4.CF888G Xor-MST"></a>4.<a href="https://codeforces.com/problemset/problem/888/G">CF888G Xor-MST</a></h4><p>考虑 Kruskal，我们每次都是贪心的选取边权最小的边。异或最小值我们可以考虑在 01-Trie 上进行操作。</p>
<p>我们考虑将所有点权放进 01-Trie 上。然后从根节点开始，考虑先递归其子树，使左右子树分别联通，再在 01-Trie 中查找边权最小的边，并将左右子树连起来。过程中计算花费即可。时间复杂度 $\mathcal O(n\log V)$，其中 $V$ 为值域。常数稍微有点大。</p>
<p>另外可以用 Boruvka 做。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1ll</span>&lt;&lt;<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,ch[N&lt;&lt;<span class="number">4</span>][<span class="number">2</span>],ed[N&lt;&lt;<span class="number">4</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;~i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][num])</span><br><span class="line">            ch[u][num]=++tot;</span><br><span class="line">        u=ch[u][num];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[u]=x;</span><br><span class="line">&#125;<span class="comment">//01-Trie</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ed[u]||ed[v])<span class="keyword">return</span> ed[u]^ed[v];</span><br><span class="line">    ll res1=INF,res2=INF;</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>]&amp;&amp;ch[v][<span class="number">0</span>])res1=<span class="built_in">solve</span>(ch[u][<span class="number">0</span>],ch[v][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">1</span>]&amp;&amp;ch[v][<span class="number">1</span>])res2=<span class="built_in">solve</span>(ch[u][<span class="number">1</span>],ch[v][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(res1!=INF||res2!=INF)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(res1,res2);<span class="comment">//贪心，先尝试朝同一方向走</span></span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>]&amp;&amp;ch[v][<span class="number">1</span>])res1=<span class="built_in">solve</span>(ch[u][<span class="number">0</span>],ch[v][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">1</span>]&amp;&amp;ch[v][<span class="number">0</span>])res2=<span class="built_in">solve</span>(ch[u][<span class="number">1</span>],ch[v][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(res1,res2);<span class="comment">//再向不同方向走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>])<span class="built_in">dfs</span>(ch[u][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">1</span>])<span class="built_in">dfs</span>(ch[u][<span class="number">1</span>]);<span class="comment">//先递归，使其子树联通</span></span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>]&amp;&amp;ch[u][<span class="number">1</span>])</span><br><span class="line">        ans+=<span class="built_in">solve</span>(ch[u][<span class="number">0</span>],ch[u][<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//再查找最小边权，将左右子树连起来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀自动机 (SAM)</title>
    <url>/2022/06/17/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>启发式合并</title>
    <url>/2022/11/20/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>运用广泛的合并信息方式。</p>
<span id="more"></span>
<blockquote>
<p>启发式算法是什么呢？<br>启发式算法是基于人类的经验和直观感觉，对一些算法的优化。</p>
</blockquote>
<p>启发式合并又名 （dsu on tree），常常运用在树上信息的合并，常见的并查集的按秩合并就是其中一种。并且常常与树链剖分相结合，从而达到较优的时间复杂度。</p>
<h3 id="1-重链剖分"><a href="#1-重链剖分" class="headerlink" title="1.重链剖分"></a>1.重链剖分</h3><h4 id="CF275D-Tree-and-Queries"><a href="#CF275D-Tree-and-Queries" class="headerlink" title="CF275D Tree and Queries"></a><a href="https://codeforces.com/problemset/problem/375/D">CF275D Tree and Queries</a></h4><p>考虑离线。我们对于一颗子树，先计算它的所有轻儿子的答案，但是删除轻儿子的信息。然后计算重儿子的答案并直接继承重儿子的信息。再暴力将所有轻儿子的信息合并上，最终计算该节点的答案。这样做是 $\mathcal O(n\log n)$。</p>
<p>看起来很不对？我们来分析一波。对于每一个点，到根节点，每有一条轻边就会使该点被暴力计算一次。根据树链剖分经典结论，每个点到根节点的轻边数不会超过 $\mathcal O( \log n)$ 条。那么每个点最多只会被暴力计算  $\mathcal O( \log n)$次，那么时间复杂度就是 $\mathcal O(n\log n)$ 。</p>
<p>当然也可以线段树合并。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> c[N],q[N];</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt,dfn[N],num[N],si[N],son[N];</span><br><span class="line"><span class="type">int</span> col[N],sum[N],ans[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[++col[c[x]]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[col[c[x]]--]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num[dfn[x]=++cnt]=x;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        <span class="keyword">if</span>(si[y]&gt;si[son[x]])</span><br><span class="line">            son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa,<span class="type">bool</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x])</span><br><span class="line">        <span class="built_in">dfs2</span>(son[x],x,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=dfn[y];j&lt;=dfn[y]+si[y]<span class="number">-1</span>;j++)</span><br><span class="line">            <span class="built_in">insert</span>(num[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec[x])</span><br><span class="line">        ans[i]=sum[q[i]];</span><br><span class="line">    <span class="keyword">if</span>(op)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=dfn[x];i&lt;=dfn[x]+si[x]<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="built_in">del</span>(num[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u;</span><br><span class="line">        <span class="built_in">read</span>(u,q[i]);</span><br><span class="line">        vec[u].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>通过上面的例子可以发现，启发式合并需要一个点的贡献很容易加上或者删除。</p>
<h3 id="2-长链剖分"><a href="#2-长链剖分" class="headerlink" title="2.长链剖分"></a>2.长链剖分</h3><p>常常用来优化状态包含深度的 DP。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>无</title>
    <url>/2022/08/18/%E6%97%A0/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d4ae7f5d494f03af1a8664b66f4cef6335c3b2241f9df3b23d2f810984d156d3">2e38a67a3587ae81f8e8aaf04b5440843fe32d479caec342b0f00ee7e0b2dba2d49b078f4eb1df66ae05138d21963060de67353b08284844a8a2b4975bccd9ff27fe545e7686465f7906381b0d39293462ce664585782717af13ceb2175cd994b8d678ca9e99d51e5b1a6e691fde46d76137449b34d998e97bc0a3cfa397d890b88370501b3dc867629151d338653cf41da13679f466d7be21de4248b094660bab24453b07d7a616a4d094e6d7af065fe4b380e4c8cd603ca3b4fdad08627e1cf6e362fe917dc1b9be2f70faae51aa1efd59b4692cc48484065f430b0875c3ef5371d5b0d35b0be7ca4e3754d861ad0aab9324dc93b61e051c47dc59387985b9060c8fb8892cb88db463bb97a6c474523a6fe9522bdf6644210d6e8456f656f4bd91692ddcd2afa521a6a3ac01e197fc64d5418c4702596300669b2cbdb0c1f57894ae1f2150097626c037376f68b91a50a434c62a12406753e083bc3512794eb1a120497374b08e7f21456a7077d6a303ba2b6b017797111ed94d2a041ae2ddb7d40af1ffdd3110aad1d19523737ea22dcecbfa0fc6f19bb18ef363026f21eb82529593ba945cf9b9feba5a7f42f31f4648dd95c0cc5b7090e87190510730861eab0a0a0fe475932b54f684ec970746f37cdeacdccd2e6116e8f93a14d59cda91577ce40ddbabc37d401d5f8ff85ab5888070a8d675e347f58998fc47d654e5c1f656e6e04b90751f78658800bce127f26b3931992a5de4510c2ae868ec3bca5d06976a2fe3d9fb05a2634e38138b58775b7897803beb737b2986c98172ca48b27952cbfe649b9741271716523cba6767566e3aea020566e3e0a9655fe8e3727e9b1d757f89cd8a35671eef2555a649567474d75da9af74acd06b258120226b12f9f391cc3b1094f03a8d981620e394aec3ac4006fde6b3b7f1a54dbf662233a44eefb63c2bfdec37ee20866b20349d5666d18dbfbb31a3a81f025a83d5377ba676a5bd99a6bbe4d91c039f3772c92bc7cbe841b3ab1c9569eaf2a497305ffe906fd644275c4cae905b8d43e3611f75189a38e54c7e028e79576ad5244a20f7869aa29eb370eeebc7117b2b79dd8a741eed51ce1d3353ccb3bd745546da875236c14012410b2265053f0f762eb76c955514a7695cbde9e01287f85641da16f326f4f48e892c9f08234592b8c5980fb747f0845f4e03ad6237a17cb971aadb0c16f326204b781eabf5c243789740bc8593ce3a0238d9d47cf480685b7cfcf8dd819433adad4e0906b50447f28923f58edfd9e27ae8ea048a95283122b0f4e63308e4dd9dfa51e17ab3e3a57fbd5c2c9399e873360ee3091abad46bed9071cff72385e03abdb550d45fe6d3f8644f329466f75421658a2bfe21d174dc6727aa88cf56ed51743d34a0ad612a84fdc70445d2a6cc50f0e0deadd14512407ba41773a5591975d744bf9615f5c3a6953560e666bd07481b874bbe434886cb61278d87cfc013baf8a771c39db2d38dba33ffeb2c126d826ad001e6f074ff193e66215d4d6800e426d0865e7222bc8b4e2cf1f67ff4f950992bbd6de44667e6c96905d2668bff96893b8678ee7153385422a0794c89dd16a67d43cfc796565cd04add59ae28b448cd376eba092e2a7faafcb318681daa38781dfa425649939211ec77fac7b6c25c767df702fdd2b717122bde5bfa4bd28768885d37e34d1fdea418cbe53713479e9c115204ced44614cb9cfe497107a8f1b2bfa9ff2e74855624e0e045f502502284d5988a2a2f12f10b7d7605bdd9a4b64b8c2aac550698e0898aca72aa8ed6f7c8df320dc055044d4906e6fabcdb78078ea59e77f510d7b93e93aa3eab520ff94e4bf65e4659a58329fad7b7f5b1c2768be01fe0b8ef58a03317bdc00f94fd63997cb622fed37ab25c9a81352e74065b9ebcc907d89a1b03815ff237e7ef82d6eb876b4638fa92ee645ab2d01be4b3f0be11053965879b0af17bee2aaba1c0677af7ff7622cee794611c2d8eda650c3f909925d03d6e74d8177c5285e6f92ba90eb325c9fa026e2a876c1383321e712a9c04fd9d035b2a2edd75fe0823e1493cdab7bc12fa0d1ff3742714d667d36548662637028696cc077594a30a1a0959fc2dcb3a545d3b64ac20dee95651a1135e3101fc8715a64ab11878dcb8146aedeb8c990dd89bcb15d5b385faa68c9304d298d9d661b53834e457c2eb78bc50459876dba6c2a8a76e062ed27d7c16800f47a75433dc1037e3a71b5b9133fb51dba0bf01ce6b01ff3d3a4d9bdf3053f60b3b1aac612a3f5fc7fd7ccc795206d1732238872d8280b0e67bee0d43d7b19a8198811a3a7aecaf3bfdc82ffb7c94579a24ab6917e59053b7ba377844ef045e7b9194ef98f32242fa2b5b6e9f81a79c633882009523efb24f2bc7c482dbe14889b309172cae84ef7abf81623049b09c74d1ae10f45c192aee068035c7a6bb75e9e45ec962858992dd84190679567ca6eda17b94e63baea0926a316ade729e1cf2377da89cd111840f559ffb0489e4744481d404223cdea1c12634e08d6f39568a455cc2651bba9615850b55fce292a83c02b684a237aaf87b6f50109cfc1271602d508cedffbcda26474497f0954bb5b1155f14447d54d0dbf9223503144e740fe3c982b53d807acc3e883b46b44b0c40505132abda25f0aeef959ec7289ff0c8db007ca48e3803835ad311e8a3180bf276f552679365adcd91fabbf82e118e1db464f815aec4aa2fc49d046557a9eeed4d4973320a79d0882b304767265afcbeb49dbd1b26183312be706b7bd3cd76e820bc6ac486cfd2c6c914d741b8efb28aa211fab7960947f289a16e1ca2c005d87c17739d433840f796320f4626fe671130e49959fdea7d825c96305f973795d35fafbc34b6326e22ca7409459f1d3650cb4f3c01fde71c1e5e7eb5f19a5b922854cc9564d0e38cb3d6e25fe6132882f2567f8a537e7fda1d19857a9a9bbebf0fe161f4cacd8d7ba702806ee756dc6e847d0187853dd1af8b35421372f31c2f90578a6db01b312fa9ed27ad92acb3600dd26d77cd402a5b16e9dc8918c8d27ab22fafff7d297aef63e33f6c73dd1d74ea8af09294da10472c456c079c3fda47d652850d5a57e145aa6014b3ded3d8f4d2b2d10d0a290956e17efb94ae4e74c3b4855e20edd7d8d64cc7e64c0eec458646d4a83e1a37edf26c4e0b72adfb843892c4dc2e6f188c04191a1f7fc56fc6ec457fbccf64276b1770544080ff700659fecfc20ad60b3d0e501dddac200340160a134e15a73a04a2475904b55ea1cf8bcf2563ca4d1e477ff9a232ac9b62986ca4a565f1eb3a61928559b484aa6adcf3a87b4f4051c4e840bec8d79cc896d069997d45de4f9881e155757daed0976bcfcd04dcee1720b6ee947601a78f0c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">无</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>无</tag>
      </tags>
  </entry>
  <entry>
    <title> </title>
    <url>/2022/11/15/%E6%B2%89%E9%BB%98/</url>
    <content><![CDATA[<p> ……</p>
<span id="more"></span>
<p>总有人选择沉默，似乎对于任何事都是这样，无论好的坏的。有人认为他们故作深沉，但他们的姿态不是事不关己，也不是高高在上——而是像树木一般，无言中挺立着。</p>
<p>沉默也许来源于内心的孤独。沉默是因为所流露的感情却也无人在意。既然无人倾听，那就没什么必要用话讲出来了。一个人的路上深一脚浅一脚地走，也只能感觉到自己的情感在泛滥，只好拼尽全力去保护玻璃般的心。随之语言功能也就逐渐退化，独自读一些写一些半懂不通的文字，仿佛徜徉于自己内心的世界的朦胧感，无法自拔。最后只是如此日复一日，江河日下罢了。这就是从前的感觉，像是得了病，是失去了能量的车轮，没有了向上的动力。</p>
<p>但也随着经历的是非越来越多——我想也多半是因为人总是要成长的。人们说：“沉默是成年人的默契。”此话只对了一半。从前的我们也很喜欢较真，一定要争个胜负，也不知道是为了得到什么——或许就是所谓的 <em>优越感</em>，却也害怕着被揭穿，好保住自己可怜的自尊心与<em>优越感</em>。不过谁谁谁做的什么什么事情，其实都心知肚明，只是也不愿多言。这种或是理解，或是不愿与其同流合污但也却无力改变，只暗下决心——像埋下了一颗种子，要用自己的方式完成自己的使命。更多的是少说话而多做事。自然还有一种则是纵容与包庇，这就直接成了令人厌恶的冷眼旁观者，于是这种更是废物了，并不归于这一类。沉默之中，也像这样观察着周围的一切。如此，在沉默中自身也逐渐变化着，褪去青涩就剩下粗糙的枝干，也不知道是应该高兴还是难过。只剩下沉默，直到应当的时机，再爆出口。</p>
<p>开始将目光移向自身，生活中的事物也沉淀下来。沉默中能够摒弃一些浮躁与戾气，逐渐深入自己，感觉到自我生命的本真，并明白自己想要成为什么，不想要成为什么。一切只是关乎你对自己生命价值的满足与充实的快乐。才能够宁静而致远。生命的意义是个永远求不出解的问题，但你能够知道这个问题有解，也会告诉自己继续要不停走下去。自己也在朦胧的内心世界开始清晰起来，也就不会再为了过去而后悔，为了未来而彷徨。</p>
<p>于是只是像树木一般，无言中挺立着。在冷气之中，只是感觉到充实与自由。</p>
<blockquote>
<p>人一旦悟透了就会变得沉默，不是没有与人相处的能力，而是没有了逢人作戏的兴趣。——鲁迅</p>
</blockquote>
]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>生成函数</title>
    <url>/2023/01/12/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>随便记一些。</p>
<span id="more"></span>
<h3 id="普通生成函数-OGF"><a href="#普通生成函数-OGF" class="headerlink" title="普通生成函数 OGF"></a>普通生成函数 OGF</h3><p>记几个式子，$F(x)$ 为序列 $a$ 的生成函数：</p>
<p>1.$\displaystyle a_n=\binom{m}{n}\Rightarrow F(x)=\sum_{n\ge0} \binom{m}{n} x^n=(1+x)^m$</p>
<p>证明：二项式定理。</p>
<p>2.$\displaystyle a_n=\binom{m+n}{n} \Rightarrow F(x)=\sum_{n\ge0} \binom{m+n}{n}x^n=\frac{1}{(1-x)^{m+1}}$</p>
<p>证明：归纳法。</p>
<p>当 $m=0$ 时，$F(x)$ 显然等于 $\frac{1}{1-x}$。</p>
<p>当 $m&gt;0$ 时，有：</p>
<script type="math/tex; mode=display">
\begin{align}
\frac{1}{(1-x)^{m+1}}&=\frac{1}{1-x}\frac{1}{(1-x)^m} \\
&=\left(\sum_{n\ge 0}x^n \right)\left(\sum_{n\ge0} \binom{m+n-1}{n}x^n \right) \\
&=\sum_{n\ge 0}{x^n}\sum_{i=0}^{n}\binom{m+i-1}{i} \\
&=\sum_{n\ge0} \binom{m+n}{n}x^n \\
\end{align}</script><p>感觉 OGF 好理解一些，更重要的还是推式子。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>随机100题</title>
    <url>/2022/06/16/%E9%9A%8F%E6%9C%BA100%E9%A2%98/</url>
    <content><![CDATA[<p> 随机的100道题作为练习 ，争取在NOIP前做完。</p>
<span id="more"></span>
<p>update: NOIP前应该是做不完了，还是太菜了。</p>
<p>update: NOIP爆炸了，可能是因为没把这东西做完吧。。。</p>
<p>update: 摆了，练习题目都做不完，还是有空再来吧。。。</p>
<h4 id="1-P4881-hby与tkw的基情"><a href="#1-P4881-hby与tkw的基情" class="headerlink" title="1.P4881 hby与tkw的基情"></a>1.<a href="https://www.luogu.com.cn/problem/P4881">P4881 hby与tkw的基情</a></h4><p>设 $m=\frac{(n+1)}{2}$​，容易得到要求的是 $Ans=\sum_{i=1}^{m}(2i-1)\cdot 26^i $​ </p>
<p>再用错位相减随便推一下得到：  </p>
<p>$26Ans=\sum_{i=1}^{m}(2i-1)\cdot 26^{i+1} $​  </p>
<p>$25Ans=-26+(2m-1)\cdot 26^{m+1}+2\cdot \sum_{i=2}^{m}26^i $​ </p>
<p>最后运用等比数列求和公式就可以得到：</p>
<p>$Ans=\frac{-26+(2m-1)\cdot26^{m+1}+2\cdot \frac{26^{n+1}-26^2}{25} }{25}$</p>
<p>最后直接套式子，除法用逆元即可，时间复杂度 $\mathcal O(T\log n)$。    </p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,inv;</span><br><span class="line"><span class="function">ll <span class="title">power</span><span class="params">(ll a,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inv=<span class="built_in">power</span>(<span class="number">25</span>,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(n);</span><br><span class="line">        <span class="type">int</span> m=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        ll res=<span class="built_in">power</span>(<span class="number">26</span>,m+<span class="number">1</span>);</span><br><span class="line">        ll ans=((<span class="number">2</span>*m<span class="number">-1</span>)*res%mod<span class="number">-26</span><span class="number">-2</span>*((res<span class="number">-26</span>*<span class="number">26</span>+mod)%mod*inv%mod)%mod+mod)%mod*inv%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="2-P5148-大循环"><a href="#2-P5148-大循环" class="headerlink" title="2.P5148 大循环"></a>2.<a href="https://www.luogu.com.cn/problem/P5148">P5148 大循环</a></h4><p>很明显得到 $Ans=C_{n}^{k}\cdot f(q)$ 。<br>而求 $f(q)$ 也很简单的用一个秦九韶算法就完了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line">ll n,m,k,q;</span><br><span class="line">ll a[N],pre[N];</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=a[m]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i;i--)</span><br><span class="line">        res=(res*q%mod+a[i<span class="number">-1</span>])%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (mod-mod/x)*<span class="built_in">inv</span>(mod%x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> pre[n]*<span class="built_in">inv</span>(pre[m])%mod*<span class="built_in">inv</span>(pre[n-m])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k,q);</span><br><span class="line">    q%=mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">f</span>(q)*<span class="built_in">C</span>(n,k)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="3-CF1601C-Optimal-Insertion"><a href="#3-CF1601C-Optimal-Insertion" class="headerlink" title="3.CF1601C Optimal Insertion"></a>3.<a href="https://www.luogu.com.cn/problem/CF1601C">CF1601C Optimal Insertion</a></h4><p>不错的一道分治，也不算很难。</p>
<p>运用调整法很容易证明，将 $b$ 按照升序插入才可能得到最优解，于是我们先将 $b$ 排序。 </p>
<p>考虑求出一个 $pos_i$ 为将 $b_i$ 插入到 $a_{pos_i}$ 前面（特别地 $pos_i=n+1$ 表示将 $b_i$ 插入到 $a$ 的最后面 ）。  </p>
<p>有上面的结论可以得到，$b$ 中的元素各自的<strong>产生的逆序对数</strong>是<strong>互不影响</strong>的，但他们的位置又互相受到限制，都是因为 $b$ 是以升序插入的，于是我们可以知道：当若有 $l&lt;mid&lt;r$ ，那么 $b_{mid}$ 在 $[pos_l,pos_r]$中的最优解即为在全局 $[1,n]$ 中的最优解（微扰法可以证明，此处就不再赘述）。</p>
<p>其实这个贡献有关系式 $w(i,j)+w(i-1,j+1)=w(i,j+1)+w(i-1,j)$，这就是决策单调性的经典式子了。</p>
<p>有了这个新结论，我们利用决策单调性这一点进行分治，用 $solve(p,q,l,r)$，表示将 $b_l,b_{l+1},…,b_r$ 插入到 $a$ 的 $[p,q]$ 之间，每次递归只需要用 $\mathcal O(p-q)$ 求出 $pos_{mid}$。</p>
<p>随后根据求出的 $pos$ 将 $b$ 插入 $a$ 中再求逆序对即可。时间复杂度 $\mathcal O((n+m)\log(n+m))$。</p>
<p>实际上还有另外一种解法，就是先将 $a$ 离散化并计算逆序对，再建立一颗线段树，表示每个位置维护插入到位置 $i$ 新增加的逆序对数。新增加的逆序对数由两部分组成，前面比 $b_i$ 大的 $+$ 后面比 $b_i$ 小的。我们接着考虑当 $b_i$ 变为 $b_{i+1}$ 时对线段树的影响，同时 $a$ 也需要小到大考虑，得到：当 $a_x&lt;b_i$ 时，应当使 $[1,x]+1$；而当 $a_y\le b_i$ 时，应当使 $[y+1,n+1]-1$，同时动态维护答案即可。时间复杂度 $\mathcal O(n\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> pos[N];</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> sum1[N],sum2[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	sum1[p<span class="number">-1</span>]=sum2[q<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=q;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum1[i]=a[i]&gt;b[mid];</span><br><span class="line">		sum2[i]=a[i]&lt;b[mid];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">		sum1[i]+=sum1[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=q<span class="number">-1</span>;i&gt;=p;i--)</span><br><span class="line">		sum2[i]+=sum2[i+<span class="number">1</span>];</span><br><span class="line">	pos[mid]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=q;i++)</span><br><span class="line">		<span class="keyword">if</span>(!pos[mid]||sum1[i<span class="number">-1</span>]+sum2[i]&lt;sum1[pos[mid]<span class="number">-1</span>]+sum2[pos[mid]])</span><br><span class="line">			pos[mid]=i;</span><br><span class="line">	<span class="built_in">solve</span>(p,pos[mid],l,mid<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">solve</span>(pos[mid],q,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) </span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge</span>(a,l,mid);</span><br><span class="line">    <span class="built_in">merge</span>(a,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>,k=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">        &#123;</span><br><span class="line">        	h[k]=a[i];</span><br><span class="line">			k++;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">            h[k]=a[j];</span><br><span class="line">			k++;</span><br><span class="line">			j++;</span><br><span class="line">            ans+=mid-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">        h[k]=a[i],k++,i++;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">        h[k]=a[j],k++,j++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        a[i]=h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(n,m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">read</span>(a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			<span class="built_in">read</span>(b[i]);</span><br><span class="line">		<span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m);</span><br><span class="line">		<span class="built_in">solve</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">		<span class="type">int</span> p=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;=m&amp;&amp;pos[j]==i)</span><br><span class="line">				c[++p]=b[j++];</span><br><span class="line">            c[++p]=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">merge</span>(c,<span class="number">1</span>,n+m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="4-P4516-JSOI2018-潜入行动"><a href="#4-P4516-JSOI2018-潜入行动" class="headerlink" title="4.P4516 [JSOI2018] 潜入行动"></a>4.<a href="https://www.luogu.com.cn/problem/P4516">P4516 [JSOI2018] 潜入行动</a></h4><p>树形背包裸题，状态和转移方程稍复杂，还需要滚动数组优化一下。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,K=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> si[N];</span><br><span class="line"><span class="type">int</span> f[N][K][<span class="number">2</span>][<span class="number">2</span>],g[K][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    f[x][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=f[x][<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(fa==y)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(y,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(si[x],m);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[j][<span class="number">0</span>][<span class="number">0</span>]=f[x][j][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            g[j][<span class="number">0</span>][<span class="number">1</span>]=f[x][j][<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">            g[j][<span class="number">1</span>][<span class="number">0</span>]=f[x][j][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            g[j][<span class="number">1</span>][<span class="number">1</span>]=f[x][j][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            f[x][j][<span class="number">0</span>][<span class="number">0</span>]=f[x][j][<span class="number">0</span>][<span class="number">1</span>]=f[x][j][<span class="number">1</span>][<span class="number">0</span>]=f[x][j][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(si[x],m);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=si[y]&amp;&amp;j+k&lt;=m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[x][j+k][<span class="number">0</span>][<span class="number">0</span>]=(f[x][j+k][<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1ll</span>*g[j][<span class="number">0</span>][<span class="number">0</span>]*f[y][k][<span class="number">0</span>][<span class="number">1</span>]%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">0</span>][<span class="number">1</span>]=(f[x][j+k][<span class="number">0</span>][<span class="number">1</span>]+<span class="number">1ll</span>*g[j][<span class="number">0</span>][<span class="number">1</span>]*(f[y][k][<span class="number">0</span>][<span class="number">1</span>]+f[y][k][<span class="number">1</span>][<span class="number">1</span>])%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">0</span>][<span class="number">1</span>]=(f[x][j+k][<span class="number">0</span>][<span class="number">1</span>]+<span class="number">1ll</span>*g[j][<span class="number">0</span>][<span class="number">0</span>]*f[y][k][<span class="number">1</span>][<span class="number">1</span>]%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">1</span>][<span class="number">0</span>]=(f[x][j+k][<span class="number">1</span>][<span class="number">0</span>]+<span class="number">1ll</span>*g[j][<span class="number">1</span>][<span class="number">0</span>]*(f[y][k][<span class="number">0</span>][<span class="number">0</span>]+f[y][k][<span class="number">0</span>][<span class="number">1</span>])%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">1</span>][<span class="number">1</span>]=(f[x][j+k][<span class="number">1</span>][<span class="number">1</span>]+<span class="number">1ll</span>*g[j][<span class="number">1</span>][<span class="number">0</span>]*(f[y][k][<span class="number">1</span>][<span class="number">0</span>]+f[y][k][<span class="number">1</span>][<span class="number">1</span>])%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">1</span>][<span class="number">1</span>]=(f[x][j+k][<span class="number">1</span>][<span class="number">1</span>]+<span class="number">1ll</span>*g[j][<span class="number">1</span>][<span class="number">1</span>]*(<span class="number">1ll</span>*f[y][k][<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1ll</span>*f[y][k][<span class="number">0</span>][<span class="number">1</span>]+<span class="number">1ll</span>*f[y][k][<span class="number">1</span>][<span class="number">0</span>]+<span class="number">1ll</span>*f[y][k][<span class="number">1</span>][<span class="number">1</span>])%mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(f[<span class="number">1</span>][m][<span class="number">0</span>][<span class="number">1</span>]+f[<span class="number">1</span>][m][<span class="number">1</span>][<span class="number">1</span>])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="5-CF1630D-Flipping-Range"><a href="#5-CF1630D-Flipping-Range" class="headerlink" title="5.CF1630D Flipping Range"></a>5.<a href="https://www.luogu.com.cn/problem/CF1630D">CF1630D Flipping Range</a></h4><p>题意简述：给你一个长度为 n 的数组 $A$ 和长度为 $m$ 的数组 $B$，你每次可以选择 $B$ 中的一个数 $b_i$，然后将 $A$ 中一段长度为 $b_i$ 的区间取反，求可能的 $\max{\sum_{i=1}^{n}a_i}$。</p>
<p>首先要转化问题，注意 $B$ 中的一个数 $b_i$ 可以重复选择，那么我们每一次都可以取反长度为 $|b_i-b_j|$ 的区间，容易由<strong>更相减损术</strong>转化为我们每次都选取一段长度为 $\gcd_{i=1}^{m}b_i$ 的区间。</p>
<p>那么问题就很简单了，用 $DP$ 将模 $\gcd_{i=1}^{m}b_i$ 的余数和其奇偶性记录进状态就可以很好转移了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m,a[N],b[N];</span><br><span class="line">ll f[N][<span class="number">2</span>],ans1,ans2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x==<span class="number">0</span>?y:<span class="built_in">gcd</span>(y%x,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(n,m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">read</span>(a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			<span class="built_in">read</span>(b[i]);</span><br><span class="line">		<span class="type">int</span> g=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			g=<span class="built_in">gcd</span>(g,b[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)</span><br><span class="line">			f[i][<span class="number">0</span>]=<span class="number">0</span>,f[i][<span class="number">1</span>]=-INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ll res1=f[i%g][<span class="number">0</span>],res2=f[i%g][<span class="number">1</span>];</span><br><span class="line">			f[i%g][<span class="number">0</span>]=<span class="built_in">max</span>(res1+a[i],res2-a[i]);</span><br><span class="line">			f[i%g][<span class="number">1</span>]=<span class="built_in">max</span>(res1-a[i],res2+a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		ans1=ans2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)</span><br><span class="line">			ans1+=f[i][<span class="number">0</span>],ans2+=f[i][<span class="number">1</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">max</span>(ans1,ans2));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="6-P2150-NOI2015-寿司晚宴"><a href="#6-P2150-NOI2015-寿司晚宴" class="headerlink" title="6.P2150 [NOI2015] 寿司晚宴"></a>6.<a href="https://www.luogu.com.cn/problem/P2150">P2150 [NOI2015] 寿司晚宴</a></h4><p>容易想到以所选数的质因数的集合为状态进行 DP，设 $f_{s_1,s_2}$ 为小 G 和小 W 所选数的质因数的集合分别为 $s_1,s_2$ 的方案数。但 $\le 500$ 的质因数太多了，无法全部记录。</p>
<p>注意一个关键点，$\le 500$ 的数最多有一个 $p\ge 23$ 的质因数，我们可以按照质因数 $p$ 对所有数进行分类，那么我们只需要考虑 $p$ 对同类数之间的限制即可。</p>
<p>考虑 $f1_{s_1,s_2},f2_{s_1,s_2}$，分别为小 G 和 小 W 选 $p$ 的方案数，而 $f’_{s_1,s_2}=f1_{s_1,s_2}+f2_{s_1,s_2}-f_{s_1,s_2}$。</p>
<p>于是我们只需要记录前面 $8$ 个质数即可。DP 过程中枚举 $s_2$ 时枚举 $s_1$ 补集的子集即可，时间复杂度为 $\mathcal O(3^8n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,S=(<span class="number">1</span>&lt;&lt;<span class="number">8</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Num</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s,d;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Num &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d&lt;t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line"><span class="type">int</span> cnt,prime[N],vis[N];</span><br><span class="line"><span class="type">int</span> f[N][N],f1[N][N],f2[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            prime[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j]))<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>&amp;&amp;x&gt;=prime[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(x%prime[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            a[now].s|=<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(x&amp;&amp;!(x%prime[i]))x/=prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[now].d=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,p);</span><br><span class="line">    <span class="built_in">prework</span>(N<span class="number">-10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">get</span>(i);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">2</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].d==<span class="number">1</span>||a[i].d!=a[i<span class="number">-1</span>].d)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(f1,f,<span class="built_in">sizeof</span>(f));</span><br><span class="line">            <span class="built_in">memcpy</span>(f2,f,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s1=S;~s1;s1--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c=S^s1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> s2=c;s2;s2=(s2<span class="number">-1</span>)&amp;c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(a[i].s&amp;s2))f1[s1|a[i].s][s2]=(f1[s1|a[i].s][s2]+f1[s1][s2])%p;</span><br><span class="line">                <span class="keyword">if</span>(!(a[i].s&amp;s1))f2[s1][s2|a[i].s]=(f2[s1][s2|a[i].s]+f2[s1][s2])%p;</span><br><span class="line">            &#125;</span><br><span class="line">            f1[s1|a[i].s][<span class="number">0</span>]=(f1[s1|a[i].s][<span class="number">0</span>]+f1[s1][<span class="number">0</span>])%p;</span><br><span class="line">            <span class="keyword">if</span>(!(a[i].s&amp;s1))f2[s1][a[i].s]=(f2[s1][a[i].s]+f2[s1][<span class="number">0</span>])%p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i].d==<span class="number">1</span>||a[i].d!=a[i+<span class="number">1</span>].d)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> s1=<span class="number">0</span>;s1&lt;=S;s1++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> c=S^s1;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> s2=c;s2;s2=(s2<span class="number">-1</span>)&amp;c)</span><br><span class="line">                    f[s1][s2]=((f1[s1][s2]+f2[s1][s2])%p-f[s1][s2]+p)%p;</span><br><span class="line">                f[s1][<span class="number">0</span>]=((f1[s1][<span class="number">0</span>]+f2[s1][<span class="number">0</span>])%p-f[s1][<span class="number">0</span>]+p)%p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s1=<span class="number">0</span>;s1&lt;=S;s1++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c=S^s1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s2=c;s2;s2=(s2<span class="number">-1</span>)&amp;c)</span><br><span class="line">            ans=(ans+f[s1][s2])%p;</span><br><span class="line">        ans=(ans+f[s1][<span class="number">0</span>])%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>​    </p>
<h4 id="7-CF777E-Hanoi-Factory"><a href="#7-CF777E-Hanoi-Factory" class="headerlink" title="7.CF777E Hanoi Factory"></a>7.<a href="https://www.luogu.com.cn/problem/CF777E">CF777E Hanoi Factory</a></h4><p>比较简单的题目，首先以<strong>外径</strong>为关键字进行排序，保证遍历时外径是有序的。再维护一个栈，直接模拟题意，当栈顶元素的内径 $\ge$ 当前元素的外径，将栈顶元素弹去。同时维护答案即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ring</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    ll h;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(ring x,ring y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x.b!=y.b)<span class="keyword">return</span> x.b&gt;y.b;</span><br><span class="line">        <span class="keyword">return</span> x.a&gt;y.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;k[N],sta[N];</span><br><span class="line"><span class="type">int</span> n,top;</span><br><span class="line">ll f[N],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(k[i].a,k[i].b,k[i].h);</span><br><span class="line">    <span class="built_in">sort</span>(k+<span class="number">1</span>,k+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;k[i].b&lt;=sta[top].a)top--;</span><br><span class="line">        sta[++top]=k[i];</span><br><span class="line">        sta[top].h+=sta[top<span class="number">-1</span>].h;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,sta[top].h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="8-CF475D-CGCDSSQ"><a href="#8-CF475D-CGCDSSQ" class="headerlink" title="8.CF475D CGCDSSQ"></a>8.<a href="https://www.luogu.com.cn/problem/CF475D">CF475D CGCDSSQ</a></h4><p>在线算法不容易实现，我们直接考虑对全局暴力求出所有公约数，用一个 $\text{map}$ 存储答案。只需要考虑优化。</p>
<p>比较简单地有：若 $l\le r&lt;n$，则有 $ \gcd_{i=l}^{r}\le \gcd_{i=l}^{r+1}$。这就意味当左端点固定时，随着右端点递增，$\gcd$ 单调递减。并且 $\gcd$ 种类数是 $\mathcal O(\log V)$ 的</p>
<p>这样就很简单了，我们只需要枚举左端点，对右端点进行二分或者倍增就可以了。ST 表查询 $\gcd$ 的时间是 $\mathcal O(\log V)$，其中 $V$ 为值域。</p>
<p>时间复杂度 $\mathcal O(n\log n\log^2 V+q\log n)$：</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> Log[N],st[N][<span class="number">25</span>];</span><br><span class="line">map&lt;<span class="type">int</span>,ll&gt;ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x?<span class="built_in">gcd</span>(y%x,x):y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        st[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=Log[n];j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">            st[i][j]=<span class="built_in">gcd</span>(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=Log[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len,<span class="type">int</span> g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=x+len,r=n,res=x;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    	<span class="type">int</span> now=<span class="built_in">query</span>(x,mid);</span><br><span class="line">    	<span class="keyword">if</span>(now==g)res=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res-x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=x,r=x;</span><br><span class="line">    <span class="keyword">while</span>(r&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> g=<span class="built_in">query</span>(x,l);</span><br><span class="line">        r=x+<span class="built_in">find</span>(x,l-x,g);</span><br><span class="line">        ans[g]+=r-l;</span><br><span class="line">        l=r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        Log[i]=Log[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="9-P3411-序列变换"><a href="#9-P3411-序列变换" class="headerlink" title="9.P3411 序列变换"></a>9.<a href="https://www.luogu.com.cn/problem/P3411">P3411 序列变换</a></h4><p>学会转化问题，与其考虑变，我们不如将目光放到哪些不变上。手动模拟，我们发现一个长度为 $n$ 的序列无论如何只需要最多 $n-1$ 次操作，我们考虑最优情况哪些数不会被操作。</p>
<p>这下就更简单了，我们只需要找到一条<strong>带重复元素的最长无缝上升子序列</strong>，设其长度为 $len$，因为穿插在这个子序列中的数总是能够被按一定顺序移到两端去从而变得有序。答案就是 $n-len$ 。</p>
<p>然而至今笔者未在网上找到靠谱的<strong>带重复元素的最长无缝上升子序列</strong>解法，现有有两组hack：</p>
<p><code>input1:
4
3 1 2 3
output1:
1</code><br><code>input2:
6
4 2 3 4 1 5
output2:
3</code></p>
<p>希望读者有新的思考，随时可以联系笔者。</p>
<details class="failure"><summary><i class="fa fa-times fa-fw"></i>Code1 100pts<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">int</span> a[N],b[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),b[i]=a[i];</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+len,a[i])-b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[a[i]]=(f[a[i]]?f[a[i]]:f[a[i]<span class="number">-1</span>])+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<details class="failure"><summary><i class="fa fa-times fa-fw"></i>Code2 90pts<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">int</span> a[N],b[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),b[i]=a[i];</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+len,a[i])-b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[a[i]]=<span class="built_in">max</span>(f[a[i]],f[a[i]<span class="number">-1</span>])+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="10-P1730-最小密度路径"><a href="#10-P1730-最小密度路径" class="headerlink" title="10.P1730 最小密度路径"></a>10.<a href="https://www.luogu.com.cn/problem/P1730">P1730 最小密度路径</a></h4><p>注意到关键：<strong>有向无环图</strong>。这意味一条路径最多只会经过 $n-1$ 次。再者 $1\le n\le 50$，我们考虑直接跑一遍 Floyd，并且将走过的边数记录进状态就可以实现类似于<strong>背包</strong>的转移。稍想便知，我们并不需要枚举边的决策点，有状态转移方程：</p>
<p>$f_{t,i,j}=\min f_{t-1,i,j}+f_{1,k,j}$</p>
<p>最直接遍历一遍 $f$ 数组计算出所有答案即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50</span>+<span class="number">10</span>,M=<span class="number">1e3</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> f[N][N][N];</span><br><span class="line"><span class="type">double</span> ans[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            ans[i][j]=<span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        f[<span class="number">1</span>][u][v]=<span class="built_in">min</span>(f[<span class="number">1</span>][u][v],w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">2</span>;t&lt;=n;t++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(k!=i&amp;&amp;k!=j&amp;&amp;i!=j)</span><br><span class="line">                        f[t][i][j]=<span class="built_in">min</span>(f[t][i][j],f[t<span class="number">-1</span>][i][k]+f[<span class="number">1</span>][k][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n;t++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(f[t][i][j]&lt;INF)</span><br><span class="line">                    ans[i][j]=<span class="built_in">min</span>(ans[i][j],f[t][i][j]*<span class="number">1.0</span>/t);</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(ans[x][y]&lt;INF)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,ans[x][y]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;OMG!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="11-P1485-火枪打怪"><a href="#11-P1485-火枪打怪" class="headerlink" title="11.P1485 火枪打怪"></a>11.<a href="https://www.luogu.com.cn/problem/P1485">P1485 火枪打怪</a></h4><p>很明显的二分，直接选择二分 $p$，重点在于如何写 $check(p)$ 函数。</p>
<p>首先考虑暴力，这样 $check(p)$ 时间复杂度是 $O(n^2)$ 的，尝试推一下性质。</p>
<p>很容易得到：</p>
<p>$\sum p-(i-j)^2=\sum p-\sum i^2+2\sum i\cdot j-\sum j^2=sum\cdot p-sum_{i^2}+2\cdot sum_i\cdot j-sum\cdot j$ </p>
<p>我们只需要维护，$sum,sum_i,sum_{i^2}$ 就可以直接计算出前面对当前的影响。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll a[N],c[N],h[N];</span><br><span class="line">ll l,r=<span class="number">1e12</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>,len=<span class="built_in">sqrt</span>(p),s=<span class="number">0</span>,si=<span class="number">0</span>,si2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        c[i]=a[i],h[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i]-=s*p-si2+<span class="number">2</span>*si*i-s*i*i;</span><br><span class="line">        <span class="keyword">if</span>(c[i]&gt;=<span class="number">0</span>)</span><br><span class="line">            h[i]=c[i]/p+<span class="number">1</span>,cnt+=h[i];</span><br><span class="line">        s+=h[i];</span><br><span class="line">        si+=h[i]*i;</span><br><span class="line">        si2+=h[i]*i*i;</span><br><span class="line">        <span class="keyword">if</span>(i-len&gt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s-=h[i-len];</span><br><span class="line">            si-=h[i-len]*(i-len);</span><br><span class="line">            si2-=h[i-len]*(i-len)*(i-len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;k)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[n-i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="12-CF1000G-Two-Paths"><a href="#12-CF1000G-Two-Paths" class="headerlink" title="12.CF1000G Two-Paths "></a>12.<a href="https://www.luogu.com.cn/problem/CF1000G">CF1000G Two-Paths </a></h4><p>有难度的倍增题目，比较有趣。</p>
<p>首先用DP预处理出数组 $pr_x$ 为遍历节点 $x$ 的子树获得的最大权值。先考虑从节点向根走，尝试求出 $f_{x,i}$ 为从点 $x$ 出发走到它的第 $2^i$ 辈祖先。只不过不能想当然地进行转移，考虑一下容斥，得到：</p>
<p>$f_{x,i}=f_{x,i-1}+f_{fa_{x,i-1},i-1}-pr_{fa_{x,i-1}}$</p>
<p>同时需要注意 $f_{x,0}$ 的值，需要判断 $x$ 的父亲节点是否选取了 $x$ 作为答案。</p>
<p>我们接着就可以使用倍增向上跳并累加答案 $f_{x,i}-pr_x$。但需要注意的是，我们最后只是会跳到 $LCA$ 处，实际上从 $LCA$ 还可以往上跳继续寻找答案。为了累加这个答案，我们可以再用一个 $g_x$ 表示从 $x$ 向上走能够获得的最大权值，从 $x$ 的父节点就可以很好地转移。最后统计答案时加上 $g_{LCA}$ 就行了。记得最后加上原来端点的 $pr_x$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>,M=<span class="number">6e5</span>+<span class="number">10</span>,K=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q,rt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">ll pr[N],g[N];</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">30</span>],d[N];</span><br><span class="line">ll f[N][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr[x]+=a[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ver[i]==fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(ver[i],x);</span><br><span class="line">        pr[x]+=<span class="built_in">max</span>(<span class="number">0ll</span>,pr[ver[i]]<span class="number">-2</span>*e[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		f[x][i]=f[x][i<span class="number">-1</span>]+f[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>]-pr[fa[x][i<span class="number">-1</span>]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(d[ver[i]])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        d[ver[i]]=d[x]+<span class="number">1</span>;</span><br><span class="line">        fa[ver[i]][<span class="number">0</span>]=x;</span><br><span class="line">		f[ver[i]][<span class="number">0</span>]=pr[ver[i]]+pr[x]-e[i]-(pr[ver[i]]<span class="number">-2</span>*e[i]&gt;<span class="number">0</span>?pr[ver[i]]<span class="number">-2</span>*e[i]:<span class="number">0</span>);</span><br><span class="line">		g[ver[i]]=<span class="built_in">max</span>(<span class="number">0ll</span>,g[x]+f[ver[i]][<span class="number">0</span>]-e[i]-pr[ver[i]]);</span><br><span class="line">		<span class="built_in">dfs</span>(ver[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="type">int</span> u=x,v=y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(d[fa[x][i]]&gt;=d[y])</span><br><span class="line">        &#123;</span><br><span class="line">            res+=f[x][i]-pr[x];</span><br><span class="line">            x=fa[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y)</span><br><span class="line">        <span class="keyword">return</span> res+pr[u]+g[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            res+=f[x][i]-pr[x]+f[y][i]-pr[y];</span><br><span class="line">            x=fa[x][i],y=fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> lca=fa[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> res+f[x][<span class="number">0</span>]-pr[x]+f[y][<span class="number">0</span>]-pr[y]-pr[lca]+pr[u]+pr[v]+g[lca];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(rt,<span class="number">0</span>);</span><br><span class="line">    d[rt]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="13-AT4837-ABC150E-Change-a-Little-Bit"><a href="#13-AT4837-ABC150E-Change-a-Little-Bit" class="headerlink" title="13.AT4837 [ABC150E] Change a Little Bit"></a>13.<a href="https://www.luogu.com.cn/problem/AT4837">AT4837 [ABC150E] Change a Little Bit</a></h4><p>推式子为主。</p>
<p>首先很明显应该贪心，先将 $C_i$ 进行排序。并很容易得出答案为：</p>
<p>$2^n\cdot (\sum_{i=1}^{n}2^{i-1}\cdot C_i\cdot \sum_{j=0}^{n-i}\begin{pmatrix} n-i\\ j\end{pmatrix}\cdot(j+1))$</p>
<p>对后面这一坨尝试进行变换：$\sum_{j=0}^{n-i} \begin{pmatrix} n-i \\ j \end{pmatrix} \cdot(j+1) = \sum_{j=0}^{n-i}\begin{pmatrix} n-i \\ j \end{pmatrix} \cdot j+2^{n-i}$</p>
<p>运用<strong>吸收恒等式</strong>：$\begin{pmatrix} i  \\ j \end{pmatrix}\cdot j = \begin{pmatrix} i-1 \\ j-1 \end{pmatrix} \cdot i$，对第一项进行变换：</p>
<p>$\sum_{j=0}^{n-i} \begin{pmatrix} n-i \\ j\end{pmatrix} \cdot j =  \sum_{j=0}^{n-i} \begin{pmatrix} n-i-1 \\ j-1 \end{pmatrix} \cdot (n-i) = (n-i) \cdot2^{n-i-1}$</p>
<p>所以得到最终式子：</p>
<p>$2^n\cdot (\sum_{i=1}^{n}2^{i-1} \cdot C_i \cdot ((n-i) \cdot 2^{n-i-1}+2^{n-i}))$</p>
<p>直接计算即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans,c[N],p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+n);</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=(p[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=(ans+p[i<span class="number">-1</span>]*c[i]%mod*((n-i)*p[n-i<span class="number">-1</span>]%mod+p[n-i]))%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans*p[n]%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="14-P4804-CCC-2016-生命中的圆"><a href="#14-P4804-CCC-2016-生命中的圆" class="headerlink" title="14.P4804 [CCC 2016]生命中的圆"></a>14.<a href="https://www.luogu.com.cn/problem/P4804">P4804 [CCC 2016]生命中的圆</a></h4><p>容易得到：$f_{i,j}=f_{i-1,x-1}⊕f_{i-1,j+1}$。</p>
<p>然后<del>稍加思索</del>，便得到：$f_{i,j}=f_{i-2^k,x-2^k}⊕f_{i-2^k,j+2^k}$。</p>
<p>然后就直接将 $T$ 按照二进制拆开计算就可以了，时间复杂度 $\mathcal O(n\log T)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,K=<span class="number">60</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll t;</span><br><span class="line"><span class="type">int</span> p,f[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;f[p][i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=K;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t&amp;(<span class="number">1ll</span>&lt;&lt;k))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=(<span class="number">1ll</span>&lt;&lt;k)%n,l=(n-r)%n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[p^<span class="number">1</span>][i]=f[p][l]^f[p][r];</span><br><span class="line">                <span class="keyword">if</span>(++l&gt;=n)l-=n;</span><br><span class="line">                <span class="keyword">if</span>(++r&gt;=n)r-=n;</span><br><span class="line">            &#125;</span><br><span class="line">            p^=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[p][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="15-P3097-USACO13DEC-Optimal-Milking-G"><a href="#15-P3097-USACO13DEC-Optimal-Milking-G" class="headerlink" title="15.P3097 [USACO13DEC]Optimal Milking G"></a>15.<a href="https://www.luogu.com.cn/problem/P3097">P3097 [USACO13DEC]Optimal Milking G</a></h4><p>单点修改求最大独立集。尝试使用线段树来维护，左右端点各自取或不取所得到的区间最大值就可以了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll v[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll a[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].v[<span class="number">0</span>][<span class="number">0</span>]=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    tr[x].v[<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    tr[x].v[<span class="number">0</span>][<span class="number">1</span>]=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>],<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>],tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">    tr[x].v[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>],<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>],tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].v[<span class="number">1</span>][<span class="number">1</span>]=a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l==tr[x].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].v[<span class="number">1</span>][<span class="number">1</span>]=k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,pos,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        ans+=<span class="built_in">max</span>(<span class="built_in">max</span>(tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],tr[<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]),<span class="built_in">max</span>(tr[<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>],tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="16-P6845-CEOI2019-Dynamic-Diameter"><a href="#16-P6845-CEOI2019-Dynamic-Diameter" class="headerlink" title="16.P6845 [CEOI2019] Dynamic Diameter"></a>16.<a href="https://www.luogu.com.cn/problem/P6845">P6845 [CEOI2019] Dynamic Diameter</a></h4><p>单边修改求树上直径。很厉害的一道题，一开始根本没有思路，看题解也想了一会儿才弄懂。</p>
<p>先考虑把树上问题向区间问题转换。还记得我们如何将 LCA 问题进行转化的吗？对，这道题我们就是需要尝试用<strong>欧拉序</strong>进行转换。我们需要求的：$\max_{l,r\in [1,N]} {dep_l+dep_r-2*dep_{lca(l,r)}}$ </p>
<p>就变为了：$\max_{1\le l \le r \le 2N-1}\{dep_l+dep_r- 2\times\min_{l\le mid\le r}{dep_{mid}}$。</p>
<p>考虑怎么维护这个东西，考虑分多个值：</p>
<p>1.区间深度最大值（作为 $dep_l$ 或 $dep_r$）。</p>
<p>2.区间深度最小值（作为 $dep_{lca}$）。</p>
<p>3.左端点与 LCA 合并的最大值，和右端点与 LCA 合并的最大值。</p>
<p>4.区间内直径最大值。</p>
<p>而修改操作就是欧拉序上的一段区间修改，这道题就完美解决了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q,rt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],ne[M];</span><br><span class="line"><span class="type">int</span> cnt,num[N&lt;&lt;<span class="number">1</span>],in[N],out[N],pos[N];</span><br><span class="line">ll w,e[M],val[N],d[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll maxd,mind,lm,mr,lmr;</span><br><span class="line">    ll tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num[in[x]=++cnt]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ver[i]==fa)<span class="keyword">continue</span>;</span><br><span class="line">        d[ver[i]]=d[x]+e[i];</span><br><span class="line">        pos[i+<span class="number">1</span>&gt;&gt;<span class="number">1</span>]=ver[i];</span><br><span class="line">        <span class="built_in">dfs</span>(ver[i],x);</span><br><span class="line">        num[++cnt]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    out[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].maxd=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].maxd,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].maxd);</span><br><span class="line">    tr[x].mind=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].mind,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mind);</span><br><span class="line">    tr[x].lm=<span class="built_in">max</span>(<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].lm,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lm),tr[x&lt;&lt;<span class="number">1</span>].maxd+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mind);</span><br><span class="line">    tr[x].mr=<span class="built_in">max</span>(<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].mr,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mr),tr[x&lt;&lt;<span class="number">1</span>].mind+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].maxd);</span><br><span class="line">    tr[x].lmr=<span class="built_in">max</span>(<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].lmr,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lmr),<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].lm+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].maxd,tr[x&lt;&lt;<span class="number">1</span>].maxd+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].maxd+=k;</span><br><span class="line">    tr[x].mind-=<span class="number">2</span>*k;</span><br><span class="line">    tr[x].lm-=k;</span><br><span class="line">    tr[x].mr-=k;</span><br><span class="line">    tr[x].tag+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].maxd=d[num[l]];</span><br><span class="line">        tr[x].mind=<span class="number">-2</span>*d[num[l]];</span><br><span class="line">        tr[x].lm=tr[x].mr=-d[num[l]];</span><br><span class="line">        tr[x].lmr=<span class="number">0</span>;</span><br><span class="line">        tr[x].tag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].tag)</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q,w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v,val[i]);</span><br><span class="line">        <span class="built_in">add</span>(u,v,val[i]);</span><br><span class="line">        <span class="built_in">add</span>(v,u,val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        ll k;</span><br><span class="line">        <span class="built_in">read</span>(x,k);</span><br><span class="line">        x=(x+ans%(n<span class="number">-1</span>))%(n<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">        k=(k+ans%w)%w;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,in[pos[x]],out[pos[x]],k-val[x]);</span><br><span class="line">        val[x]=k;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans=tr[<span class="number">1</span>].lmr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="17-AT4835-ABC141F-Xor-Sum-3"><a href="#17-AT4835-ABC141F-Xor-Sum-3" class="headerlink" title="17.AT4835 [ABC141F] Xor Sum 3"></a>17.<a href="https://www.luogu.com.cn/problem/AT4835">AT4835 [ABC141F] Xor Sum 3</a></h4><p>按照每一位来考虑，设 $sum$ 为其所有数的异或和，其中 $sum_i$ 表示其二进制下的第 $i$ 位，考虑其奇偶性，有：</p>
<p>1.$sum_i$ 为 $1$，则分为两组的异或和的贡献一定为 $2^i$。</p>
<p>2.$sum_i$ 为 $0$ ，则分为两组的异或和第 $i$ 位一定相同。</p>
<p>第一种情况可以直接累加上答案，于是我们只需要考虑第二种情况就可以了。由第二条性质可以得到：仅考虑 $sum_i=0$ 的情况下,分为两组的异或和一定是相等的，于是我们直接用<strong>线性基</strong>算之后将答案乘二即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll sum,ans,res,a[N],p[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(x&gt;&gt;i&amp;<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p[i])</span><br><span class="line">        &#123;</span><br><span class="line">            p[i]=x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x^=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),sum^=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=<span class="number">1ll</span>&lt;&lt;i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(a[j]&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                    a[j]^=<span class="number">1ll</span>&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        res=<span class="built_in">max</span>(res,res^p[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans+<span class="number">2ll</span>*res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="18-CF460C-Present"><a href="#18-CF460C-Present" class="headerlink" title="18.CF460C Present"></a>18.<a href="https://www.luogu.com.cn/problem/CF460C">CF460C Present</a></h4><p>最小值最大，很明显考虑二分。$check(i)$ 用线段树修改查询就可以了。</p>
<p>看题解后，发现还是做复杂了，可以直接差分，做到 $\mathcal O(n)$  $check(i)$ 。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll val,tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,w;</span><br><span class="line">ll a[N];</span><br><span class="line">ll l=INF,r;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x&lt;&lt;<span class="number">1</span>].tag+=tr[x].tag;</span><br><span class="line">    tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tag+=tr[x].tag;</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].val=a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].tag+=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].tag)<span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l==tr[x].r)</span><br><span class="line">        <span class="keyword">return</span> tr[x].val+tr[x].tag;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].tag)</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>,pos);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(n&lt;&lt;<span class="number">2</span>);i++)</span><br><span class="line">        tr[i].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res=<span class="built_in">query</span>(<span class="number">1</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(res&lt;x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,i,i+w<span class="number">-1</span>,x-res);</span><br><span class="line">            cnt+=x-res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),l=<span class="built_in">min</span>(l,a[i]),r+=a[i];</span><br><span class="line">    r=(r+<span class="number">1ll</span>*m*w)/n;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    ll ans=l;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">            l=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="19-CF282E-Sausage-Maximization"><a href="#19-CF282E-Sausage-Maximization" class="headerlink" title="19.CF282E Sausage Maximization"></a>19.<a href="https://www.luogu.com.cn/problem/CF282E">CF282E Sausage Maximization</a></h4><p>直接将所有后缀异或和插入进 <strong>01Trie</strong>，再查询每个前缀异或和所能得到最大值就可以了。</p>
<p>还有 <strong>01Trie</strong> 记得将空间开大。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,cnt,t[N&lt;&lt;<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line">ll a[N],ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">63</span>;~i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=(x&gt;&gt;i&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!t[p][num])</span><br><span class="line">            t[p][num]=++cnt;</span><br><span class="line">        p=t[p][num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">63</span>;~i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=(x&gt;&gt;i&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(t[p][num^<span class="number">1</span>])</span><br><span class="line">            sum+=<span class="number">1ll</span>&lt;&lt;i,p=t[p][num^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> p=t[p][num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        res^=a[i];</span><br><span class="line">        <span class="built_in">insert</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res^=a[i];</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="20-P4068-SDOI2016-数字配对"><a href="#20-P4068-SDOI2016-数字配对" class="headerlink" title="20.P4068 [SDOI2016]数字配对"></a>20.<a href="https://www.luogu.com.cn/problem/P4068">P4068 [SDOI2016]数字配对</a></h4><p>因为每次我们需要贪心地考虑选择获得价值<strong>最大</strong>的数字进行 配对，考虑使用<strong>费用流</strong>，我们来看看怎么建模。</p>
<p>一定要想到将其转化为<strong>二分图</strong>，它是我们最好解决的了。我们对每个数进行质因数分解，将 $i$ 其分解成 $cnt_i$ 个质因数。再考虑将这些点其按照 $cnt_i$ 的<strong>奇偶性</strong>分为<strong>左部</strong>和<strong>右部</strong>的点，再将能够配对的点连起来，剩下的建图就很显然了。</p>
<p>注意这里我们需要写的是<strong>最大费用最大流</strong>。但又有一些不一样，我们只有在<strong>费用</strong>大于0的情况下才能继续继续增广，改一下就好了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">4e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,s,t,maxflow;</span><br><span class="line"><span class="type">int</span> a[N],b[N],cnt[N];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> incf[N],pre[N],vis[N];</span><br><span class="line">ll maxcost,c[N],cost[M],d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    cost[tot]=c;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add_edge</span>(u,v,w,c);</span><br><span class="line">    <span class="built_in">add_edge</span>(v,u,<span class="number">0</span>,-c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t;i++)</span><br><span class="line">        d[i]=<span class="number">-1e18</span>,vis[i]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    incf[s]=INF;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!e[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y]&lt;d[x]+cost[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[y]=d[x]+cost[i];</span><br><span class="line">                incf[y]=<span class="built_in">min</span>(incf[x],e[i]);</span><br><span class="line">                pre[y]=i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y])</span><br><span class="line">                    vis[y]=<span class="number">1</span>,q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[t]&gt;<span class="number">-1e18</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll now=d[t]*incf[t];</span><br><span class="line">    <span class="keyword">if</span>(maxcost+now&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        maxflow+=maxcost/(-d[t]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxcost+=now;</span><br><span class="line">    maxflow+=incf[t];</span><br><span class="line">    <span class="type">int</span> x=t;</span><br><span class="line">    <span class="keyword">while</span>(x!=s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i=pre[x];</span><br><span class="line">        e[i]-=incf[t];</span><br><span class="line">        e[i^<span class="number">1</span>]+=incf[t];</span><br><span class="line">        x=ver[i^<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!(x%i))</span><br><span class="line">            x/=i,res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    s=n+<span class="number">1</span>,t=s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),cnt[i]=<span class="built_in">divide</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(b[i]);</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]&amp;<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">add</span>(s,i,b[i],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(i,t,b[i],<span class="number">0</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((a[i]%a[j]==<span class="number">0</span>&amp;&amp;cnt[i]==cnt[j]+<span class="number">1</span>)||(a[j]%a[i]==<span class="number">0</span>&amp;&amp;cnt[j]==cnt[i]+<span class="number">1</span>))</span><br><span class="line">                    <span class="built_in">add</span>(i,j,INF,<span class="number">1ll</span>*c[i]*c[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA</span>()&amp;&amp;<span class="built_in">update</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="21-CF442C-Artem-and-Array"><a href="#21-CF442C-Artem-and-Array" class="headerlink" title="21.CF442C Artem and Array"></a>21.<a href="https://www.luogu.com.cn/problem/CF442C">CF442C Artem and Array</a></h4><p>第一眼是一个<strong>区间DP</strong>，但是数据范围很明显不能让我们通过，我们没法DP直接考虑<strong>贪心</strong>。</p>
<p>很明显，若 $a_i&lt;a_{i-1}$ 且 $a_i&lt;a_{i+1}$ ，我们一定会将 $a_i$ 删去。</p>
<p>我们直接将其放入一个<strong>单调栈</strong>中进行维护并统计，最后得到的序列一定是<strong>单峰</strong>的。然后我们直接在剩下的 $m$ 个数中取最小的 $m-2$ 个就可以得到答案（因为最大的两个数不可能被取到）。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> top,sta[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(top&gt;=<span class="number">2</span>&amp;&amp;sta[top]&lt;=sta[top<span class="number">-1</span>]&amp;&amp;sta[top]&lt;=x)</span><br><span class="line">            ans+=<span class="built_in">min</span>(sta[top<span class="number">-1</span>],x),top--;</span><br><span class="line">        sta[++top]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sta+<span class="number">1</span>,sta+<span class="number">1</span>+top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top<span class="number">-2</span>;i++)</span><br><span class="line">        ans+=sta[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="22-AT4434-ARC103D-Distance-Sums"><a href="#22-AT4434-ARC103D-Distance-Sums" class="headerlink" title="22.AT4434 [ARC103D] Distance Sums"></a>22.<a href="https://www.luogu.com.cn/problem/AT4434">AT4434 [ARC103D] Distance Sums</a></h4><p>比较清新的构造题（？）。</p>
<p>我们尝试从每个点的 $D_i$ 之间的关系入手。很明显 $D_i$ 值最大的节点必定为<strong>叶子</strong>，$D_i$ 值最小的节点必定为<strong>树的重心</strong>（<del>可似乎没什么用</del>），还记得之前的<strong>换根DP</strong>吗？若 $v$ 为 $u$ 的子节点，我们很明显有：$D_v=D_u-2\times size_v+n$。变换一下得到 $D_u=D_v+2\times size_v-n$。我们把两者结合一下，尝试用<strong>叶子节点</strong>逐渐构造其祖先。我们先将其排序，从 $D_i$ 值最大的开始处理，大致分为这几步：</p>
<p>1、计算用当前节点计算父节点的 $D$ 值。 2、父节点的 $D$ 值在给定的 $D_i$ 中进行二分查找。找到了则新加一条边计入答案，并且计算父节点的 $size_u$；若未找到直接输出 $-1$ 。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    ll d;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node x,<span class="type">const</span> Node y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.d&lt;y.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n,si[N];</span><br><span class="line"><span class="type">int</span> cnt,u[N],v[N];</span><br><span class="line">ll dis;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i].d),a[i].id=i,si[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll d=a[i].d-n+(si[i]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> k=<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,(Node)&#123;<span class="number">0</span>,d&#125;)-a;</span><br><span class="line">        <span class="keyword">if</span>(a[k].d!=d)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        u[i]=a[i].id;</span><br><span class="line">        v[i]=a[k].id;</span><br><span class="line">        si[k]+=si[i];</span><br><span class="line">        dis+=si[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis!=a[<span class="number">1</span>].d)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,u[i],v[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="23-AT3621-ARC084B-Small-Multiple"><a href="#23-AT3621-ARC084B-Small-Multiple" class="headerlink" title="23.AT3621 [ARC084B] Small Multiple"></a>23.<a href="https://www.luogu.com.cn/problem/AT3621">AT3621 [ARC084B] Small Multiple</a></h4><p>直接枚举 $k$ 的正整数倍并不是明智之举，我们并不能找到较好的条件或方式来优化。我们考虑直接对其进行搜索，再判断其是否为 $k$ 的倍数。</p>
<p>在搜索过程中，很明显每次只有两种分支：$\times 10$ 或 $+1$。而其花费分别为 $0$ 和 $1$。很自然想到了双端队列 BFS。并且我们在搜索过程中直接对数进行取模就行。时间复杂度 $\mathcal O(k)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num,val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">bitset&lt;N&gt;vis;</span><br><span class="line">deque&lt;Node&gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push_back</span>((Node)&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>().num,y=q.<span class="built_in">front</span>().val;</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,y);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!vis[x*<span class="number">10</span>%k])</span><br><span class="line">            q.<span class="built_in">push_front</span>((Node)&#123;x*<span class="number">10</span>%k,y&#125;);</span><br><span class="line">        <span class="keyword">if</span>(!vis[(x+<span class="number">1</span>)%k])</span><br><span class="line">            q.<span class="built_in">push_back</span>((Node)&#123;(x+<span class="number">1</span>)%k,y+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(k);</span><br><span class="line">    <span class="built_in">BFS</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="24-AT5361-ABC158E-Divisible-Substring"><a href="#24-AT5361-ABC158E-Divisible-Substring" class="headerlink" title="24.AT5361 [ABC158E] Divisible Substring"></a>24.<a href="https://www.luogu.com.cn/problem/AT5361">AT5361 [ABC158E] Divisible Substring</a></h4><p>很明显应当从低位向高位考虑。每次从后面枚举，得到它后缀 $\mod p$ 的余数，很明显用该后缀减去之前所枚举的所有满足 $\mod p$ 的余数与其相等的后缀，所得到的字串一定被 $p$ 整除。这就很好办了，直接拿一个数组 $f_i$ 来存 $\mod p$ 的余数为 $i$ 的后缀数量，并且在枚举后缀时累加答案即可。</p>
<p>注意特判 $p=2,5$ 时的情况。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,M=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> sum,t=<span class="number">1</span>,a[N],f[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,a+i);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">2</span>||p==<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            ans+=a[i]%p?<span class="number">0</span>:i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;  </span><br><span class="line">        sum=(sum+t*a[i])%p;</span><br><span class="line">        ans+=f[sum];</span><br><span class="line">        f[sum]++;</span><br><span class="line">        t=t*<span class="number">10</span>%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="25-AT5242-ABC163E-Active-Infants"><a href="#25-AT5242-ABC163E-Active-Infants" class="headerlink" title="25.AT5242 [ABC163E] Active Infants"></a>25.<a href="https://www.luogu.com.cn/problem/AT5242">AT5242 [ABC163E] Active Infants</a></h4><p>开始本来以为是贪心，但发现并不能总是得到最优解。</p>
<p>有端联想，我们似乎可以直接上<strong>费用流</strong>，建图很显然，直接上<strong>最大费用最大流</strong>跑就可以了，确实可以过，但是效率并不高。</p>
<p>我们逐渐想到<strong>区间DP</strong>，但是直接搞的话 $\mathcal O(n^3)$ 的。我们每次只能考虑从端点转移。</p>
<p>于是我们尝试将<strong>区间DP</strong>与<strong>贪心</strong>结合，直觉告诉我们对于 $a_i$ 较大的，应当将它尽可能排在一段区间的两端，而非中间，这样产生的贡献才大。<del>然后乱搞</del>，现将数组按照 $a_i$ 为第一关键字排序，并记录其初始位置 $pos_i$。对于区间 $[l,r]$ 我们只需要将前 $r-l+1$ 个数填进去，这样来满足贪心即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val,pos;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> val&lt;t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i].val),a[i].pos=i;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        f[i][i]=<span class="number">1ll</span>*<span class="built_in">abs</span>(a[<span class="number">1</span>].pos-i)*a[<span class="number">1</span>].val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+i<span class="number">-1</span>&lt;=n;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=l+i<span class="number">-1</span>;</span><br><span class="line">            f[l][r]=<span class="built_in">max</span>(f[l+<span class="number">1</span>][r]+<span class="number">1ll</span>*<span class="built_in">abs</span>(a[i].pos-l)*a[i].val,f[l][r<span class="number">-1</span>]+<span class="number">1ll</span>*<span class="built_in">abs</span>(a[i].pos-r)*a[i].val);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="26-CF360B-Levko-and-Array"><a href="#26-CF360B-Levko-and-Array" class="headerlink" title="26.CF360B Levko and Array"></a>26.<a href="https://www.luogu.com.cn/problem/CF360B">CF360B Levko and Array</a></h4><p>使最大值最小，直接二分答案。我们需要研究 $check$ 函数应该如何写，设二分答案为 $lim$。</p>
<p>容易看出来是个 DP。可是直接 DP 明显很难做到 $\mathcal O(n^2)$。这就很难搞了。我们必须转换思路进行 DP。</p>
<p>经典正难则反，我们直接考虑计算 $[1,i]$ 中最多有多少个可以不变。可是似乎还是不太好转移。又该怎么办？只有当满足 $mid\times (i-j)\ge |a_i-a_j|$ 时，才可能有 $a_j$  不改变，通过改变 $(j,i]$ 得到合法方案。最后判断其中是否存在某个 $i$ 使得 $n-dp_i\le k$ 即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll a[N];</span><br><span class="line">ll l,r,f[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lim*(i-j)&gt;=<span class="built_in">abs</span>(a[i]-a[j]))</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[i]+k&gt;=n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        r=<span class="built_in">max</span>(r,<span class="built_in">abs</span>(a[i]-a[i+<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">            r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="27-CF573B-Bear-and-Blocks"><a href="#27-CF573B-Bear-and-Blocks" class="headerlink" title="27.CF573B Bear and Blocks"></a>27.<a href="https://www.luogu.com.cn/problem/CF573B">CF573B Bear and Blocks</a></h4><p>简单题，分别从左和从右模拟一次就可以了</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">int</span> h[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(h[i]);</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        f[i]=<span class="built_in">min</span>(f[i<span class="number">-1</span>]+<span class="number">1</span>,h[i]);</span><br><span class="line">    f[n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i;i--)</span><br><span class="line">        f[i]=<span class="built_in">min</span>(f[i+<span class="number">1</span>]+<span class="number">1</span>,f[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="28-AT2368-AGC013B-Hamiltonish-Path"><a href="#28-AT2368-AGC013B-Hamiltonish-Path" class="headerlink" title="28.AT2368 [AGC013B] Hamiltonish Path"></a>28.<a href="https://www.luogu.com.cn/problem/AT2368">AT2368 [AGC013B] Hamiltonish Path</a></h4><p>又是简单题，两遍 dfs 即可</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M&lt;&lt;<span class="number">1</span>],ne[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="type">int</span> cnt1,cnt2,ans1[N],ans2[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[ver[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[ver[i]]=<span class="number">1</span>;</span><br><span class="line">            ans1[++cnt1]=ver[i];</span><br><span class="line">            <span class="built_in">dfs1</span>(ver[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[ver[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[ver[i]]=<span class="number">1</span>;</span><br><span class="line">            ans2[++cnt2]=ver[i];</span><br><span class="line">            <span class="built_in">dfs2</span>(ver[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt1+cnt2+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cnt1;i;i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans1[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt2;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans2[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="29-AT923-IOI饅頭（IOI-Manju）"><a href="#29-AT923-IOI饅頭（IOI-Manju）" class="headerlink" title="29.AT923 IOI饅頭（IOI Manju）"></a>29.<a href="https://www.luogu.com.cn/problem/AT923">AT923 IOI饅頭（IOI Manju）</a></h4><p>还是简单题（大雾）。排序后直接 01背包 就可以了，然后注意细节。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,M=<span class="number">1e4</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> c[N],e[N];</span><br><span class="line">ll p[M],f[M],ans;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(m,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">read</span>(p[i]);</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">        p[i]+=p[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i],e[i]),c[i]=<span class="built_in">min</span>(c[i],m);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=c[i];j--)</span><br><span class="line">            f[j]=<span class="built_in">min</span>(f[j],f[j-c[i]]+e[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            f[j]=<span class="built_in">min</span>(f[j],f[j+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ll res=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,p[i]-f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="30-CF242E-XOR-on-Segment"><a href="#30-CF242E-XOR-on-Segment" class="headerlink" title="30.CF242E XOR on Segment"></a>30.<a href="https://www.luogu.com.cn/problem/CF242E">CF242E XOR on Segment</a></h4><p>小清新数据结构题，<del>比较水</del>。看到位运算很容易想到按位拆开来算，毕竟时限本来就很宽松（<del>以至于暴力用循环展开都可以卡过去</del>）。对于线段树中每个节点维护一个数组 $sum_i$，表示在此区间中有多少个数第 $i$ 位为 $1$。查询和修改大力维护就可以了。时间复杂度 $\mathcal O(m\log n\log V)$，其中 $V$ 为值域。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,K=<span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> sum[<span class="number">32</span>],tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K;i++)</span><br><span class="line">        tr[x].sum[i]=tr[x&lt;&lt;<span class="number">1</span>].sum[i]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].tag^=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K;i++)</span><br><span class="line">        <span class="keyword">if</span>(k&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">            tr[x].sum[i]=(tr[x].r-tr[x].l+<span class="number">1</span>-tr[x].sum[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[x].tag)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K;i++)</span><br><span class="line">            tr[x].sum[i]=(a[l]&gt;&gt;i&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K;i++)</span><br><span class="line">            res+=<span class="number">1ll</span>*tr[x].sum[i]&lt;&lt;i;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)res+=<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)res+=<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,l,r;</span><br><span class="line">        <span class="built_in">read</span>(op,l,r);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,l,r));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="31-CF444A-DZY-Loves-Physics"><a href="#31-CF444A-DZY-Loves-Physics" class="headerlink" title="31.CF444A DZY Loves Physics"></a>31.<a href="https://www.luogu.com.cn/problem/CF444A">CF444A DZY Loves Physics</a></h4><p>第一眼觉得很神秘。但是我们容易发现最优方案似乎只有一条边。因为加入选取一条密度最大的边后，选取其它边只会是密度变小。</p>
<p><del>然后就过了？</del></p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">double</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,(a[u]+a[v])*<span class="number">1.0</span>/w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="32-AT3559-Squeezing-Slimes"><a href="#32-AT3559-Squeezing-Slimes" class="headerlink" title="32.AT3559 Squeezing Slimes"></a>32.<a href="https://www.luogu.com.cn/problem/AT3559">AT3559 Squeezing Slimes</a></h4><p>考虑假如每次将一个数拆成两半，最少会进行 $\lceil\log_2 n\rceil$ 次。一个贪心的想法是一次尽可能选尽量多的数进行操作。我们只用考虑一段单峰区间的最大操作次数就行了。每次只需要记录上一个数的操作次数就行了。</p>
<p>但是这样似乎很容易被 Hack：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3 3 3</span><br><span class="line">out:2</span><br><span class="line">ans:3</span><br><span class="line">3 3 3 -&gt; 1 2 2 1 3 -&gt; 1 1 1 1 1 1 3 -&gt; 1 1 1 1 1 1 1 2 -&gt;</span><br><span class="line">1 1 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure>
<p>原因很显然，可能存在并不能将多个数一起操作的情况。但是没有关系，这种情况只可能存在于需要上取整的情况。对于此种情况，如果前面的操作次数比它小，我们就将其看做已经对其执行了一次操作，使它变成了较小的另一半。这样继续贪心就没有问题了。</p>
<p>这样看来似乎有一点奇怪，但仔细想想这确实是没有问题的。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,res,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,d;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        d=<span class="built_in">log2</span>(x);</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;d)&lt;x&amp;&amp;d&gt;=res)</span><br><span class="line">            d++;</span><br><span class="line">        <span class="keyword">if</span>(d&gt;res)ans+=d-res;</span><br><span class="line">        res=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="33-CF14D-Two-Paths"><a href="#33-CF14D-Two-Paths" class="headerlink" title="33.CF14D Two Paths"></a>33.<a href="https://www.luogu.com.cn/problem/CF14D">CF14D Two Paths</a></h4><p>水题，暴力断开一条边，然后对剩下的两棵树分别求直径。最后求最大值就可以。时间复杂度 $\mathcal O(n^2)$。</p>
<p>难道就这样吗？</p>
<p>不如看看加强版 <a href="https://www.luogu.com.cn/problem/SP6717">SP6717 TWOPATHS - Two Paths</a>（<del>但还是虚高题</del>）。</p>
<p>我们考虑 $\mathcal O(n)$ 的做法。</p>
<p>update on 2022.11.13。原题解被 @zhanghenglei 所 Hack。现在已将解法修正，如果仍有问题，欢迎指出qwq。</p>
<p>不难想到用 $f_x,g_x$ 分别表示以 $x$ 为根的子树内和子树外最长链的长度。答案就是 $\max\{f_x\times g_x\}$。$f_x$ 很容易求，考虑 $g_x$ 怎么求。</p>
<p>$g_x$ 可以从父亲节点转移过来，这启发我们可以类似于换根 DP 的方法来求 $g_x$。</p>
<p>考虑怎么构成一条子树外的链。无非是从父节点往上延伸，或者从父节点往下延伸的链。再将他们最长的两段在父节点拼起来成为一个答案。</p>
<p>但是我们选取的两段链不能在 $x$ 的子树中。这就意味着我们需要先求出，从父节点往下延伸的链的最大值、亚大值和次大值，以及对应的子节点。转移时判断一下所选的链有没有在 $x$ 的子树中就行。</p>
<p>从该节点 $x$ 往上延伸的最长链也可以通过最大值和亚大值通过换根 DP 来求出，也比较简单。</p>
<p>但是这样解是有漏洞的，$g_x$ 求出来只是恰好经过其父节点的最长链，而不是整棵树中除去该子树的最长链，就像这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/93kgatph.png" alt=""></p>
<p><code>output : 30</code> \<br><code>answer : 36</code></p>
<p>所以我们需要再多记一个 $h_x$ 表示该节点的父节点的子树之外的最长链，转移与上面类似。</p>
<p>具体可看看代码，有一些注释。有点繁琐，但还是比较好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[N][<span class="number">3</span>],l[N],t[N][<span class="number">3</span>],f[N],g[N],h[N];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">2</span>]=d[x][<span class="number">1</span>],t[x][<span class="number">2</span>]=t[x][<span class="number">1</span>];</span><br><span class="line">            d[x][<span class="number">1</span>]=d[x][<span class="number">0</span>],t[x][<span class="number">1</span>]=t[x][<span class="number">0</span>];</span><br><span class="line">            d[x][<span class="number">0</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">0</span>]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">2</span>]=d[x][<span class="number">1</span>],t[x][<span class="number">2</span>]=t[x][<span class="number">1</span>];</span><br><span class="line">            d[x][<span class="number">1</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">1</span>]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">2</span>])</span><br><span class="line">            d[x][<span class="number">2</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">2</span>]=y;</span><br><span class="line">        <span class="comment">//处理出从该节点往下延伸的链的最大值、亚大值和次大值</span></span><br><span class="line">        <span class="comment">//以及其所对应的儿子</span></span><br><span class="line">        f[x]=<span class="built_in">max</span>(f[x],f[y]);<span class="comment">//从子节点转移</span></span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=<span class="built_in">max</span>(f[x],d[x][<span class="number">0</span>]+d[x][<span class="number">1</span>]);<span class="comment">//从自己转移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,<span class="number">1ll</span>*f[x]*<span class="built_in">max</span>(g[x],h[x]));<span class="comment">//统计答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        l[y]=l[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[x][<span class="number">0</span>]&amp;&amp;t[x][<span class="number">0</span>]!=y)</span><br><span class="line">            l[y]=<span class="built_in">max</span>(l[x],d[x][<span class="number">0</span>])+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[x][<span class="number">1</span>])</span><br><span class="line">            l[y]=<span class="built_in">max</span>(l[x],d[x][<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//转移从该节点向上延伸的最长链</span></span><br><span class="line">        <span class="type">int</span> res[<span class="number">4</span>];</span><br><span class="line">        res[<span class="number">0</span>]=t[x][<span class="number">0</span>]!=y?d[x][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>]=t[x][<span class="number">1</span>]!=y?d[x][<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">2</span>]=t[x][<span class="number">2</span>]!=y?d[x][<span class="number">2</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">3</span>]=l[x];</span><br><span class="line">        <span class="built_in">sort</span>(res,res+<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//从四条链中选取合法的最长的两条</span></span><br><span class="line">        g[y]=<span class="built_in">max</span>(g[x],res[<span class="number">2</span>]+res[<span class="number">3</span>]);</span><br><span class="line">        h[y]=h[x];</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x);</span><br><span class="line">        res[<span class="number">0</span>]=t[y][<span class="number">0</span>]!=y?d[y][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>]=t[y][<span class="number">1</span>]!=y?d[y][<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">2</span>]=t[y][<span class="number">2</span>]!=y?d[y][<span class="number">2</span>]:<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(res,res+<span class="number">3</span>);</span><br><span class="line">        h[x]=<span class="built_in">max</span>(h[x],res[<span class="number">1</span>]+res[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//转移该节点的父节点的子树之外的最长链</span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="34-P5078-Tweetuzki-爱军训"><a href="#34-P5078-Tweetuzki-爱军训" class="headerlink" title="34.P5078 Tweetuzki 爱军训"></a>34.<a href="https://www.luogu.com.cn/problem/P5078">P5078 Tweetuzki 爱军训</a></h4><p>考虑贪心。我们依次考虑，将每个点放在左端或者右端。</p>
<p>而是对于每个点，我们考虑拆贡献。设放在前面的点 $[1,l]$ 的和为 $sum_1$，放在后面的点 $ [r,n]$ 的和为 $sum_2$，所有点和为 $sum$，那么：</p>
<p>1.放在前面的点，对其后面的点贡献为 $sum-sum_1$。</p>
<p>2.放在后面的点，对其后面的点贡献为 $sum_2$。而他前面还有 $r-l+1$ 个点未计算贡献，而这部分贡献为 $a_i\times (r-l+1)$。</p>
<p>注意，我们直接统计贡献是会有重复的。但是这样贪心的话，我们能保证对于之后的决策都会是更优的。真正的的贡献直接统计就好了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> l,r,ans[N];</span><br><span class="line">ll sum1,sum2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),sum1+=a[i];</span><br><span class="line">    l=<span class="number">1</span>,r=n;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum1&gt;=<span class="number">1ll</span>*a[i]*(r-l+<span class="number">1</span>)+sum2)</span><br><span class="line">            res+=<span class="number">1ll</span>*a[i]*l,ans[l++]=a[i],sum1-=a[i];</span><br><span class="line">        <span class="keyword">else</span> res+=<span class="number">1ll</span>*a[i]*r,ans[r--]=a[i],sum2+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="35-CF1305F-Kuroni-and-the-Punishment"><a href="#35-CF1305F-Kuroni-and-the-Punishment" class="headerlink" title="35.CF1305F Kuroni and the Punishment"></a>35.<a href="https://www.luogu.com.cn/problem/CF1305F">CF1305F Kuroni and the Punishment</a></h4><p>神秘题。随机化题目都没怎么做过，所以根本不会。。。</p>
<p>考虑两个结论：</p>
<p>1.操作次数 $&lt; n$。</p>
<p>2.操作超过两次的数 $\le \frac{n}{2}$。</p>
<p>那么随机化做法就来了，我们每次随机选取一个数 $x$，并将 $x-1,x,x+1$ 都分解质因数，放入一个 set 里。我们一共选取 50 次，这样最多有约 600 个质数。</p>
<p>然后我们暴力枚举每个质因数 $p$，计算 $\gcd=p$ 时的操作次数是多少。取最小值就可以了。</p>
<p>我们每次都有至少 $\frac{1}{2}$ 的概率选中操作次数小于等于一次的数。所以错误的概率只为 $\frac{1}{2^{50}}$。</p>
<p>注意每个数不能为 $0$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line">ll a[N];</span><br><span class="line">set&lt;ll&gt;prime;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">divide</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(x%i))</span><br><span class="line">        &#123;</span><br><span class="line">            prime.<span class="built_in">insert</span>(i);</span><br><span class="line">            <span class="keyword">while</span>(!(x%i))x/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>)prime.<span class="built_in">insert</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos=<span class="built_in">rand</span>()*<span class="built_in">rand</span>()%n+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">divide</span>(a[pos]<span class="number">-1</span>),<span class="built_in">divide</span>(a[pos]),<span class="built_in">divide</span>(a[pos]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    set&lt;ll&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it=prime.<span class="built_in">begin</span>();it!=prime.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;*it)</span><br><span class="line">                res+=<span class="built_in">min</span>(a[i]%*it,(*it-a[i]%*it));</span><br><span class="line">            <span class="keyword">else</span> res+=*it-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="36-AT3911-Forest"><a href="#36-AT3911-Forest" class="headerlink" title="36.AT3911 Forest"></a>36.<a href="https://www.luogu.com.cn/problem/AT3911">AT3911 Forest</a></h4><p>假如有 $cnt$ 个连通块，那么我们需要连 $cnt-1$ 条边，那么就要选取 $2\times cnt-2$ 个点。现在每个连通块里选一个最小的，再贪心地在所以里面再选 $cnt-2$ 个最小的即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> a[N],fa[N],v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),fa[i]=i,v[i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        fa[<span class="built_in">find</span>(v+<span class="number">1</span>)]=<span class="built_in">find</span>(u+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        v[<span class="built_in">find</span>(i)]=<span class="built_in">min</span>(v[<span class="built_in">find</span>(i)],a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==v[<span class="built_in">find</span>(i)])</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=a[i];</span><br><span class="line">            cnt++;</span><br><span class="line">            v[<span class="built_in">find</span>(i)]=INF;</span><br><span class="line">            a[i]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt<span class="number">-2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==INF)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="37-CF351A-Jeff-and-Rounding"><a href="#37-CF351A-Jeff-and-Rounding" class="headerlink" title="37.CF351A Jeff and Rounding"></a>37.<a href="https://www.luogu.com.cn/problem/CF351A">CF351A Jeff and Rounding</a></h4><p>如果没有整数的话，答案就是一定的。我们只需要枚举将多少个整数上取整即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N],sum,ans=INF;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i]);</span><br><span class="line">        a[i]=a[i]-<span class="built_in">int</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=eps)cnt++;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">max</span>(cnt-n,<span class="number">0</span>);i&lt;=<span class="built_in">min</span>(cnt,n);i++)</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(sum-n+i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="38-CF448C-Painting-Fence"><a href="#38-CF448C-Painting-Fence" class="headerlink" title="38.CF448C Painting Fence"></a>38.<a href="https://www.luogu.com.cn/problem/CF448C">CF448C Painting Fence</a></h4><p>分治求解即可。每次考虑将区间内高度最小的横着刷，将其分成多个小区间再求解。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> <span class="built_in">min</span>(<span class="number">1</span>,a[l]-h);</span><br><span class="line">    <span class="type">int</span> minx=INF,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        minx=<span class="built_in">min</span>(minx,a[i]);</span><br><span class="line">    <span class="type">int</span> pre=l,res=minx-h;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==minx)</span><br><span class="line">            res+=<span class="built_in">solve</span>(pre,i<span class="number">-1</span>,minx),pre=i+<span class="number">1</span>;</span><br><span class="line">    res+=<span class="built_in">solve</span>(pre,r,minx);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(<span class="number">1</span>,n,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>虽然这样已经做可以通过此题，但这并不影响我们对更优解的思考。我们发现时间都浪费在找最小值上，我们可以用笛卡尔树来做（本题的形式就是笛卡尔树的经典模型）。这样很容易做到 $\mathcal O(n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> top,sta[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">solve</span>(l,pos<span class="number">-1</span>,tr[pos].l,tr[pos].val)+</span><br><span class="line">            <span class="built_in">solve</span>(pos+<span class="number">1</span>,r,tr[pos].r,tr[pos].val)+tr[pos].val-h;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(tr[i].val);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=top;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;tr[sta[p]].val&gt;tr[i].val)</span><br><span class="line">            p--;</span><br><span class="line">        <span class="keyword">if</span>(p)tr[sta[p]].r=i;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;top)tr[i].l=sta[p+<span class="number">1</span>];</span><br><span class="line">        sta[++p]=i;</span><br><span class="line">        top=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(<span class="number">1</span>,n,sta[<span class="number">1</span>],<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="39-Manga-Market"><a href="#39-Manga-Market" class="headerlink" title="39.Manga Market"></a>39.<a href="https://www.luogu.com.cn/problem/AT_hitachi2020_d">Manga Market</a></h4><p>先考虑贪心，考虑微扰法，假设有 $i$ 与 $j$，他们的花费分别为 $(a_i+1)\times (a_j\times t+b_j+t+1)+b_i$ 与 $(a_j+1)\times (a_i\times t+b_i+t+1)+b_j$，两式相减即可得到 $a_i\times b_j +a_i- a_j\times b_i -a_j$，于是我们按照 $\frac{a_i}{b_i+1}&lt;\frac{a_j}{b_j+1}$ 的顺序排序即可。</p>
<p>确定顺序后考虑 DP，$f_{i,j}$ 为考虑前 $i$ 个点选取 $j$ 个点，很容易有转移方程 $f_{i,j}=\min \{f_{i-1,j},(f_{i-1,j-1}+1)*(a_i+1)+b_i\}$。</p>
<p>这样状态已经是 $\mathcal O(n^2)$ 的。但是我们注意当 $a_i\ge 1$ 时，时间是按照指数级别增长，那么我们最多就只能选取 $\log t$ 个点，状态就变为 $\mathcal O(n\log t)$ 了。过程中还可以使用滚动数组优化。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,K=<span class="number">40</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">    ll k,b;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n,t,ans,tot;</span><br><span class="line">ll c[N],f[N][K];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Line x,Line y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y.k*(x.b+<span class="number">1</span>)&lt;x.k*(y.b+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i].k,a[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a[i].k==<span class="number">0</span>)</span><br><span class="line">            c[++tot]=a[i].b,a[i].k=INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            f[i][j]=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            f[i][j]=<span class="built_in">min</span>(f[i][j<span class="number">-1</span>],(f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>)*(a[j].k+<span class="number">1</span>)+a[j].b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">        c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> j=tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n&amp;&amp;f[i][n]&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;f[i][n]+c[j]&gt;t)j--;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,i+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="40-AGC033C-Removing-Coins"><a href="#40-AGC033C-Removing-Coins" class="headerlink" title="40.[AGC033C] Removing Coins"></a>40.<a href="https://www.luogu.com.cn/problem/AT_agc033_c">[AGC033C] Removing Coins</a></h4><p>考虑每一次操作的本质就是断开该节点以外的所有叶子。于是考虑树的直径 $len$，简单博弈就可以得到当 $len \equiv 2\mod3$ 时才是 <code>Second</code>。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> len,d[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        len=<span class="built_in">max</span>(len,d[x]+d[y]+<span class="number">1</span>);</span><br><span class="line">        d[x]=<span class="built_in">max</span>(d[x],d[y]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    len++;</span><br><span class="line">    <span class="built_in">puts</span>(len%<span class="number">3</span>!=<span class="number">2</span>?<span class="string">&quot;First&quot;</span>:<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="41-Polycarp-and-Div-3"><a href="#41-Polycarp-and-Div-3" class="headerlink" title="41.Polycarp and Div 3"></a>41.<a href="https://www.luogu.com.cn/problem/CF1005D">Polycarp and Div 3</a></h4><p>简单题，前缀和然后 DP 就完了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">int</span> a[N],sum[N],f[N],pre[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;a[++n])!=EOF)</span><br><span class="line">        sum[n]=sum[n<span class="number">-1</span>]+a[n];</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>],f[pre[sum[i]%<span class="number">3</span>]]+(pre[sum[i]%<span class="number">3</span>]||sum[i]%<span class="number">3</span>==<span class="number">0</span>));</span><br><span class="line">        pre[sum[i]%<span class="number">3</span>]=i;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="42-P6835-Cnoi2020-线形生物"><a href="#42-P6835-Cnoi2020-线形生物" class="headerlink" title="42.P6835 [Cnoi2020]线形生物"></a>42.<a href="https://www.luogu.com.cn/problem/P6835">P6835 [Cnoi2020]线形生物</a></h4><p>考虑 $f_x$ 为从点 $x$ 走到 $x+1$ 的期望步数。$\deg_x$ 为 $x$ 的出度那么有：</p>
<p>$f_x=1+\frac{\sum_y \sum_{i=y}^{x} f_i}{\deg_x}$ </p>
<p>使用对 $f$ 做前缀和得到：</p>
<p>$f_x=\frac{\deg_x+(\deg_x-1)\times sum_x-\sum sum_{y-1}}{\deg_x}$</p>
<p>将 $sum_x$ 替换为 $sum_{x-1}+f_x$ 得：</p>
<p>$f_x=\deg_x+(\deg_x-1)\times sum_{x-1}-\sum sum_{y-1}$</p>
<p>线性递推即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,id;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],ne[M];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line">ll f[N],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(id,n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        deg[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">            f[x]=(f[x]+sum[ver[i]<span class="number">-1</span>])%mod;</span><br><span class="line">        f[x]=((deg[x]+<span class="number">1</span>+deg[x]*sum[x<span class="number">-1</span>]%mod-f[x])%mod+mod)%mod;</span><br><span class="line">        sum[x]=(sum[x<span class="number">-1</span>]+f[x])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="43-Pudding-Monsters"><a href="#43-Pudding-Monsters" class="headerlink" title="43.Pudding Monsters"></a>43.<a href="https://www.luogu.com.cn/problem/CF526F">Pudding Monsters</a></h4><p>将问题转化为一维，等价于求 $max-min=r-l$  的区间个数。</p>
<p>考虑枚举左端点 $l$，求出满足答案的右端点 $r$，并且用线段树维护 $max-min-r+l$ 的最小值及其个数。每次移动左端点 $l$ 时，用单调栈维护最小值和最大值，消除前面的影响即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> val,cnt,tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> top1,top2,sta1[N],sta2[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val=<span class="built_in">min</span>(tr[x&lt;&lt;<span class="number">1</span>].val,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val);</span><br><span class="line">    tr[x].cnt=(tr[x&lt;&lt;<span class="number">1</span>].val==tr[x].val)*tr[x&lt;&lt;<span class="number">1</span>].cnt</span><br><span class="line">            +(tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val==tr[x].val)*tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val+=k;</span><br><span class="line">    tr[x].tag+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[x].tag)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].val=l,tr[x].cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        a[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top1&amp;&amp;a[i]&lt;a[sta1[top1]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,sta1[top1<span class="number">-1</span>]+<span class="number">1</span>,sta1[top1],-(a[i]-a[sta1[top1]]));</span><br><span class="line">            top1--;</span><br><span class="line">        &#125;</span><br><span class="line">        sta1[++top1]=i;</span><br><span class="line">        <span class="keyword">while</span>(top2&amp;&amp;a[i]&gt;a[sta2[top2]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,sta2[top2<span class="number">-1</span>]+<span class="number">1</span>,sta2[top2],a[i]-a[sta2[top2]]);</span><br><span class="line">            top2--;</span><br><span class="line">        &#125;</span><br><span class="line">        sta2[++top2]=i;</span><br><span class="line">        ans+=tr[<span class="number">1</span>].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="44-P3609-USACO17JAN-Hoof-Paper-Scissor-G"><a href="#44-P3609-USACO17JAN-Hoof-Paper-Scissor-G" class="headerlink" title="44.P3609 [USACO17JAN]Hoof, Paper, Scissor G"></a>44.<a href="https://www.luogu.com.cn/problem/P3609">P3609 [USACO17JAN]Hoof, Paper, Scissor G</a></h4><p>直接DP。$f_{i,j,k}$ 表示到第 $i$ 轮变换 $j$ 次变成手势 $k$ 时最多赢的次数。时间复杂度 $\mathcal O(nk)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][M][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((x==<span class="number">0</span>&amp;&amp;y==<span class="number">1</span>)||(x==<span class="number">1</span>&amp;&amp;y==<span class="number">2</span>)||(x==<span class="number">2</span>&amp;&amp;y==<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch);</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>]==<span class="string">&#x27;H&#x27;</span>)a[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>)a[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> a[i]=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>][i]=<span class="built_in">h</span>(i,a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;<span class="number">3</span>;l++)</span><br><span class="line">                    f[i][j][k]=<span class="built_in">max</span>(f[i][j][k],<span class="built_in">max</span>(f[i<span class="number">-1</span>][j][k],(j-(k!=l)&gt;=<span class="number">0</span>)?f[i<span class="number">-1</span>][j-(k!=l)][l]:<span class="number">0</span>)+<span class="built_in">h</span>(k,a[i]));</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,f[n][i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="44-X-or-mas-Tree"><a href="#44-X-or-mas-Tree" class="headerlink" title="44.X(or)-mas Tree"></a>44.<a href="https://www.luogu.com.cn/problem/CF1615D">X(or)-mas Tree</a></h4><p>小清新构造题。</p>
<p>注意观察，其实我们只需要将边权按照 popcount 的奇偶全部转为 $0,1$ 即可。我们再通过边的限制维护两个点集，表示两个点集中的元素互相之间边权异或和为 $1$，而点集内部的点之间的边权异或和为 $0$。这个可以直接用扩展域并查集维护即可。</p>
<p>需要注意的是最后输出方案时也需要把新加的边权加进限制里面。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> u[N],v[N],w[N];</span><br><span class="line"><span class="type">int</span> fa[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x==fa[x])?x:fa[x]=<span class="built_in">get</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="built_in">get</span>(x),y=<span class="built_in">get</span>(y);</span><br><span class="line">	fa[y]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++)</span><br><span class="line">		fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(u[i],v[i],w[i]);</span><br><span class="line">		<span class="keyword">if</span>(!~w[i])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> x=__builtin_popcount(w[i])&amp;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(x)<span class="built_in">merge</span>(u[i]+n,v[i]),<span class="built_in">merge</span>(u[i],v[i]+n);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">merge</span>(u[i],v[i]),<span class="built_in">merge</span>(u[i]+n,v[i]+n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">read</span>(u,v,w);</span><br><span class="line">		<span class="keyword">if</span>(w)<span class="built_in">merge</span>(u+n,v),<span class="built_in">merge</span>(u,v+n);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">merge</span>(u,v),<span class="built_in">merge</span>(u+n,v+n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">get</span>(i)==<span class="built_in">get</span>(i+n))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!~w[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">get</span>(u[i])!=<span class="built_in">get</span>(v[i]))w[i]=<span class="number">1</span>,<span class="built_in">merge</span>(u[i]+n,v[i]),<span class="built_in">merge</span>(u[i],v[i]+n);</span><br><span class="line">			<span class="keyword">else</span> w[i]=<span class="number">0</span>,<span class="built_in">merge</span>(u[i],v[i]),<span class="built_in">merge</span>(u[i]+n,v[i]+n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,u[i],v[i],w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="45-ABC131F-Must-Be-Rectangular"><a href="#45-ABC131F-Must-Be-Rectangular" class="headerlink" title="45.[ABC131F] Must Be Rectangular!"></a>45.<a href="https://www.luogu.com.cn/problem/AT_abc131_f">[ABC131F] Must Be Rectangular!</a></h4><p>感觉自己的人类智慧又不够用了。</p>
<p>通过简单动手画图，如果将每个点向所有和它同行或同列的点连边，我们发现只要形成连通块，那么可以按照这个连通块的最大长与宽把这个长方形填满。维护连通性？我们可以用并查集。</p>
<p>我们有一种比较巧妙的方法来维护。我们将一个点的坐标拆成 $x$ 和 $y$ 单独的两个点，并且将每个点的第 $x$ 行与第 $y$ 列合并。最后统计根节点的长与宽就行了，代码很简洁。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="type">int</span> fa[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[N&lt;&lt;<span class="number">1</span>],g[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">get</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="built_in">get</span>(x),y=<span class="built_in">get</span>(y);</span><br><span class="line">	fa[y]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m&lt;&lt;<span class="number">1</span>;i++)</span><br><span class="line">		fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">read</span>(x,y);</span><br><span class="line">		<span class="built_in">merge</span>(x,y+m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)f[<span class="built_in">get</span>(i)]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)g[<span class="built_in">get</span>(i+m)]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m&lt;&lt;<span class="number">1</span>;i++)</span><br><span class="line">		ans+=<span class="number">1ll</span>*f[i]*g[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans-n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="46-GCD等于XOR-GCD-XOR"><a href="#46-GCD等于XOR-GCD-XOR" class="headerlink" title="46.GCD等于XOR GCD XOR"></a>46.<a href="https://www.luogu.com.cn/problem/UVA12716">GCD等于XOR GCD XOR</a></h4><p>有点意思的结论题。</p>
<p>直接给结论，设 $a&gt;b$，则 $a-b=a\oplus b$。</p>
<p>简单证明：</p>
<p>先考虑一个结论 $a-b\le a\oplus b$，</p>
<p>又因为 $\gcd(a,b)\ge a-b$。</p>
<p>就有了上面的结论。</p>
<p>剩下的直接枚举就行了，时间复杂度 $\mathcal O(n\ln n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*i;j&lt;=n;j+=i)</span><br><span class="line">			<span class="keyword">if</span>(((j-i)^j)==i)</span><br><span class="line">				sum[j]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">prework</span>(N<span class="number">-10</span>);</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		<span class="built_in">read</span>(x);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case %d: %lld\n&quot;</span>,t,sum[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="47-CF258D-Little-Elephant-and-Broken-Sorting"><a href="#47-CF258D-Little-Elephant-and-Broken-Sorting" class="headerlink" title="47.CF258D Little Elephant and Broken Sorting"></a>47.<a href="https://www.luogu.com.cn/problem/CF258D">CF258D Little Elephant and Broken Sorting</a></h4><p>有意思的一道题。</p>
<p>直接 DP，但是似乎不好设计出好转移的状态。这里就比较关键，直接设 $f_{i,j}$ 表示位置 $i$ 与 位置 $j$ 上的数满足偏序关系的期望。这样就对于每一个交换操作我们可以 $\mathcal O(n)$ 求出其贡献，而预处理和统计答案的时间为 $\mathcal O(n^2)$。总时间复杂度为 $\mathcal O(n^2+qn)$。</p>
<p>代码十分好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">double</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j)<span class="keyword">continue</span>;</span><br><span class="line">            f[i][j]=(a[i]&lt;a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==x||i==y)<span class="keyword">continue</span>;</span><br><span class="line">            f[x][i]=f[y][i]=f[x][i]*<span class="number">0.5</span>+f[y][i]*<span class="number">0.5</span>;</span><br><span class="line">            f[i][x]=f[i][y]=f[i][x]*<span class="number">0.5</span>+f[i][y]*<span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[x][y]=f[y][x]=f[x][y]*<span class="number">0.5</span>+f[y][x]*<span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            ans+=f[j][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>脑子里并没有另一个人的记忆</title>
    <url>/2023/01/15/%E8%84%91%E5%AD%90%E9%87%8C%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E8%AE%B0%E5%BF%86/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="18ffc29d707d3591fdf4c70f44b28d641a17f342fe9de0db2344df352626ee7f">ffc2a1a8d5dd2c8af5bcfcf7b828bee0cb524c044d024bc4843593b6a590981848eaae75129507fd7a1b3574b6c6c609c3ba37bbb90bd8dc46ead3468cc68a5ad8e99ced4f8e797217fdbf9ec8f60e730524708200cb811af10d56077d1fabd8ba4651e156fe4e179546ccafe37686fa151c2d54d68606b16715b1c27217ebf4fca4a762c5793bd96dbe88c80717eca13ae1df66429006e68c23303daf2548d557e56a6d60a9ff4cce568e1771db98bd677def74789a178eb9195b427743863e86a64ef866de7b63b4b63be6c4cfe3ff3e023865932cc8e2ee5d2212b5320ef526831af3723a73e036d58b9dcc9ece2f0be31a989814c362f5796f85af51d7339c5c61933d65639aa839431368b9b631113beb746c6d41acaec6f324d7264a47132438bf4959cf80348cdd958fab995828d06423a58acccc66f895bcc678322a0c67c7213208341b3a5cfa085ab1f2b0fd0f280f6b1e11e63100ac63664a19355a390e48b90ec747567a0b03d14dbf196ddc18b4c769a563afcb4c5e030c8c71a1bfd2c98d14e8229c4e7b686d9531320a047c48fdc13544808e3acf046d05fd3b78ceafd3f220d46c736866df9f9b3f8aace2eebe7dd78c43c3048cac205a1607d5dfea04e5144f789e552ecd605198e3a943f15f60c0eaf158f08a44e6c93e927a8e3c3515cada3b93984c7a6b005d872cb33098cf5cac20386d59ae215443bd730ca24e9176b472270635e105bc095a0cf767c73fe6c596b86d3431b410ac006e30d53b4b064d3fcb0e48655f5fc9d8c17609859b3780f065340e7741173f1d9d5451ac306ba4ba43aa687d278ec3c9f3427460fa965b5ed28ce7a3f5a7c74b9aea66f6faa08e7ebd84a028dc73af47c98268cf7985820270efc469760cccacad9b74c6b665f263b0b9cc77163b6e42dba24d68e789867763ddaf53a05df685b0c355c63260cdb97961e7d72532cb436b75a2179185f07106452c2422526c760eb516908f49a6dca8c6f7ad0e599f304520fc245472ac652fcfbca2866c9fbb3e3ee9f56b49b715c79ad3f7ae8e89c97bf7dbc0f9aaed86179b1e6af4abde3a2852dcc897e6787a8f04f88a5e1dd3a25972b8ad211e37ae24d087a3bab769622e1e8337c03329e08504046db2eccd2568d53c3c4fc13a65531ddb476d85b7ff25dd0266f555518f4c089b70b27d6bcbc1fbda5599506d61f69b2b40d43013ca626a3f75767ae98d5773d5804e89de12644a3325c140cc5e33b16e1bec67b76c6501f2b8354e80ae77777526c6bb6f32782fdef4dab57094bb2ab1bab12119a8a8e5373978f01c2d048accfcc58c334d3f0888d368e08e741941a9b76973e3ed0c3e771cdd7ed027a1d52d66ae8fad43fa5796ef5758505fabbb40f297023d1d9c786db9229c103e056f47a9f0a8ba70ef71770e8cd7be2fa07f1c4e35834cac4c5a41a885c089c85cb8214c12721a641e75cb0606dc08d5bab954978740b0f4da15a6a7c4e605a92dc8cae4cec04e9f762dd90c608f8298348b6c06805febaf51eed3aa1a557412f59e6aad936b1d9159257775079a624bc20edb6cc20e35ac38ea7de1f335adbd74c823b1c79295</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">I am.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1616G Just Add an Edge</title>
    <url>/2023/01/26/CF1616G-Just-Add-an-Edge/</url>
    <content><![CDATA[<p>妙妙图论题。</p>
<span id="more"></span>
<p>*3500 的牛逼题。</p>
<p>如果原图已有哈密顿回路，那么一定是 $1\to 2\to \dots \to n$，这种情况下的答案为 $\binom{n}{2}$。</p>
<p>考虑更一般的情况，发现添加返祖边 $(v,u)$ 的哈密顿回路一定形如：</p>
<script type="math/tex; mode=display">
1\overset{+1}{\longrightarrow}u-1\to \dots \to v\to u\to \dots \to v+1\overset{+1}{\longrightarrow}n</script><p>这是因为在经过之后 $u-1$ 之后是不能回到 $&lt;u$ 的点的。问题转化为，找到不交的 $1\to v$ 与 $u\to n$ ，并且两条路径覆盖 $\{1,\dots, n\}$。 </p>
<p>我们新建 $0,n+1$ 两个点，并分别 $0$ 向所有点连边，所有点向 $n+1$ 连边，这样回路的起点与终点就固定了， 方便计算。</p>
<p>考虑暴力做法，考虑枚举 $u$ 然后进行 DP，设 $f_{x,0/1}$ 表示当前点分别在两条链上是否有合法方案。只考虑，前一个点与当前点所在的不同即可。得到 $\mathcal O(n^2)$ 做法。</p>
<details class="failure"><summary><i class="fa fa-times fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.5e5</span>+<span class="number">10</span>,M=<span class="number">1.5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">int</span> pre[N],suf[N];</span><br><span class="line"><span class="type">bool</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> flag[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;rev[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rev[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)rev[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="built_in">add</span>(<span class="number">0</span>,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="built_in">add</span>(i,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="keyword">if</span>(u+<span class="number">1</span>==v)flag[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    flag[<span class="number">1</span>]=flag[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">0</span>,suf[n+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)pre[i]=flag[i]?pre[i<span class="number">-1</span>]:i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;~i;i--)suf[i]=flag[i+<span class="number">1</span>]?suf[i+<span class="number">1</span>]:i;</span><br><span class="line">    <span class="keyword">if</span>(!pre[n+<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*n*(n<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=suf[<span class="number">0</span>]+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:rev[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">                    f[j][t]|=((suf[v+<span class="number">1</span>]&gt;=j<span class="number">-1</span>)&amp;f[v+<span class="number">1</span>][t^<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=pre[n+<span class="number">1</span>];j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            ans+=f[j][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(suf[<span class="number">0</span>]+<span class="number">1</span>==pre[n+<span class="number">1</span>])ans--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

</details>
<p>注意到关键性质，如果原图没有哈密顿回路的话，一定存在一个最小的 $p$，满足 $p$ 未向 $p+1$ 连边，于是 $p+1$ 将哈密顿回路分割成两部分 $[0,p+1],[p+2,n+1]$。转移的过程中不会跨过 $p+1$，所以这两个部分是相互独立的。于是我们可以分开计算，再将两段合并即可。但是注意到可能会出现 $f_{u,0}=f_{u,1}=f_{v,0}=f_{v,1}=1$ ，按照上述计算方式会被算两次，但实际上只存在一种连边方式，对于这一部分注意减掉就好了。</p>
<p>似乎比较好写但是还是要注意很多细节，所以必须要清楚 DP 数组的具体含义。具体也可以看看代码：</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.5e5</span>+<span class="number">10</span>,M=<span class="number">1.5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> p,q;</span><br><span class="line"><span class="type">int</span> pre[N],suf[N];</span><br><span class="line"><span class="type">bool</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> flag[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;rev[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rev[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)rev[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="built_in">add</span>(<span class="number">0</span>,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="built_in">add</span>(i,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);    </span><br><span class="line">        <span class="keyword">if</span>(u+<span class="number">1</span>==v)flag[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    flag[<span class="number">1</span>]=flag[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">0</span>,suf[n+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)pre[i]=flag[i]?pre[i<span class="number">-1</span>]:i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;~i;i--)suf[i]=flag[i+<span class="number">1</span>]?suf[i+<span class="number">1</span>]:i;</span><br><span class="line">    <span class="keyword">if</span>(!pre[n+<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*n*(n<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    p=suf[<span class="number">0</span>],q=pre[n+<span class="number">1</span>];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    f[p+<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:rev[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">                f[i][t]|=((suf[v+<span class="number">1</span>]&gt;=i<span class="number">-1</span>)&amp;f[v+<span class="number">1</span>][t^<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>;~i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:rev[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">                f[v+<span class="number">1</span>][t]|=((suf[v+<span class="number">1</span>]&gt;=i<span class="number">-1</span>)&amp;f[i][t^<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> lcnt,rcnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        lcnt=<span class="number">0</span>,rcnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=p+<span class="number">1</span>;i++)lcnt+=f[i][t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=q;i&lt;=n+<span class="number">1</span>;i++)rcnt+=f[i][t];</span><br><span class="line">        ans+=<span class="number">1ll</span>*lcnt*rcnt;</span><br><span class="line">    &#125;</span><br><span class="line">    lcnt=<span class="number">0</span>,rcnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=p;i++)lcnt+=f[i][<span class="number">0</span>]&amp;f[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q;i&lt;=n+<span class="number">1</span>;i++)rcnt+=f[i][<span class="number">0</span>]&amp;f[i][<span class="number">1</span>];</span><br><span class="line">    ans-=<span class="number">1ll</span>*lcnt*rcnt;</span><br><span class="line">    <span class="keyword">if</span>(p+<span class="number">1</span>==q)ans--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>集合幂级数</title>
    <url>/2023/02/19/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/</url>
    <content><![CDATA[<p>快速莫比乌斯变换 FMT 与 快速沃尔什变换 FWT。</p>
<span id="more"></span>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>一个长度为 $2^n$ 的序列 $f(i)$，有一个生成函数 $F(x)=\sum_{i=0}^{2^n-1}f(i) x^i$，那么，这个生成函数叫做集合幂级数。</p>
<p>这和集合有什么关系呢？将集合 $\{0,1,\cdots,n-1 \}$ 的一个子集状态压缩后就对应着原序列的一个下标 $i$。</p>
<p>其卷积形式大多为 $c(i)=\sum_{j\oplus k=i}a(j)*b(k)$，这里的 $\oplus$ 指代某种运算，其大多是位运算。</p>
<p>直接暴力求卷积是 $\mathcal O(4^n)$ 的，考虑更优的做法。</p>
<h3 id="2-快速莫比乌斯变换-FMT"><a href="#2-快速莫比乌斯变换-FMT" class="headerlink" title="2.快速莫比乌斯变换 FMT"></a>2.快速莫比乌斯变换 FMT</h3><p>用来求高维前缀和。高维前缀和就是对 $n$ 维数组求前缀和，不过每一维只有 $0,1$ 两个下标。本质上就是子集和 $b(i)=\sum_{j|i=i} a(j)$。暴力枚举子集来求的时间复杂度是 $\mathcal O(3^n)$ 的。</p>
<p>是实际上我们可以对每一维单独来做遍前缀和，容易发现这样做是正确的。于是是时间复杂度 为 $\mathcal O(n2^n)$。</p>
<p>其实这样做法也可以从子集和或者另外的角度来理解。而高维后缀和同理。</p>
<details class="code" open><summary><i class="fab fa-code fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1</span>&lt;&lt;n;j++)</span><br><span class="line">        <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">            a[j]+=a[j^(<span class="number">1</span>&lt;&lt;i)];</span><br></pre></td></tr></table></figure>

</details>
<h3 id="3-快速沃尔什变换-FWT"><a href="#3-快速沃尔什变换-FWT" class="headerlink" title="3.快速沃尔什变换 FWT"></a>3.快速沃尔什变换 FWT</h3><p>用于求异或卷积，在下面说。</p>
<h3 id="4-卷积"><a href="#4-卷积" class="headerlink" title="4.卷积"></a>4.卷积</h3><p>为了让卷积 $c(i)=\sum_{j\oplus k=i}a(i)*b(i)$ 更快计算，我们需要用 FMT/FWT 将 $a,b$ 进行变换，再 $\mathcal O(n)$ 求出变换后的 $c$，再对其进行逆变换就可以求出原本的 $c$。</p>
<h4 id="1-或卷积"><a href="#1-或卷积" class="headerlink" title="1.或卷积"></a>1.或卷积</h4><p>求卷积 $c_i=\sum_{j|k=i} a_j*b_k$。</p>
<p>考虑构造出变换 $FMT(c)_x=FMT(a)_x*FMT(b)_x$。</p>
<p>证明如下：</p>
<script type="math/tex; mode=display">
\begin{align}
FMT(a)_x*FMT(b)_x&=\sum_{i|x=x} a(i)*\sum_{i|x=x}b(i)\\
&=\sum_{i|x=x}\sum_{j|x=x} a(i)*b(j)\\
&=\sum_{i|x=x}c(i)\\
&=FMT(c)_x
\end{align}</script><p>于是先对 $a,b$ 做一次高维前缀和，相乘后做一次逆变换即得到了 $c$。</p>
<h4 id="2-与卷积"><a href="#2-与卷积" class="headerlink" title="2.与卷积"></a>2.与卷积</h4><p>和或卷积类似，将高维前缀和变为高维后缀和即可。</p>
<h4 id="3-异或卷积"><a href="#3-异或卷积" class="headerlink" title="3.异或卷积"></a>3.异或卷积</h4><p>求卷积 $c_i=\sum_{j\oplus k=i} a_j*b_k$。</p>
<p>我们设对序列 $a$ 变换为 $FWT(a)_x=\sum_{i=0}^{n-1} g(x,i)a_i$。</p>
<p>我们要想使 </p>
<script type="math/tex; mode=display">
FWT(c)_x=FWT(a)_x*FWT(b)_x</script><p>尝试变换一下：</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=0}^{n-1} g(x,i)c_i=\sum_{i=0}^{n-1} g(x,i)a_i *\sum_{i=0}^{n-1} g(x,i)b_i
\\
\sum_{i=0}^{n-1} g(x,i)\sum_{j\oplus k=i} a_j*b_k=\sum_{i=0}^{n-1} g(x,i)a_i \sum_{i=0}^{n-1} *g(x,i)b_i
\\
\sum_{i=0}^{n-1}\sum_{j\oplus k=i} g(x,i) a_j*b_k=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1} g(x,i)g(x,j)a_i*b_j
\\
\sum_{i=0}^{n-1}\sum_{j=0}^{n-1} g(x,i\oplus j)a_i*b_j=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1} g(x,i)g(x,j)a_i*b_j
\end{align}</script><p>于是得到：</p>
<script type="math/tex; mode=display">
g(x,i\oplus j)=g(x,i)g(x,j)</script><p>我们需要构造的式子需要满足上面这个等式，并且能够快速得到 $FWT(a)$。前人的智慧告诉我们应当为 $g(x,i)=(-1)^{|i\odot x|}$，因为有 $(i\oplus j)\odot x=(i\odot x)\oplus (j\odot x)$。所以 FWT 的式子就是：</p>
<script type="math/tex; mode=display">
FWT(a)_x=(-1)^{|i\odot x|}a_i</script><p>至于如何快速求出 $FWT(a)$，考虑一个类似于蝶形运算的过程，具体可见代码，这里不再赘述。这样总的时间复杂度为 $\mathcal O(n2^n)$。</p>
<details class="code" open><summary><i class="fab fa-code fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=x+y,a[i+j+mid]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IFWT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=x+y&gt;&gt;<span class="number">1</span>,a[i+j+mid]=x-y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>发现此过程和 NTT 非常相似。</p>
<h4 id="4-子集卷积"><a href="#4-子集卷积" class="headerlink" title="4.子集卷积"></a>4.子集卷积</h4><p>求 $c_i=\sum_{j\odot k=0,j|k=i} a_j*b_k$。</p>
<p>注意到 $j,k$ 对 $j|k$ 有贡献，当且仅当 $\mid j\mid +\mid k\mid =\mid j|k\mid $。这启发我们按照集合的大小来进行分类。</p>
<p>将原序列扩展到二维为 $A_{x,i}=a_i[|i|=x]$，于是有：</p>
<script type="math/tex; mode=display">
\begin{align}
C_{|x|,x}=\sum_{i|j=x,|i|+|j|=|x|} A_{|i|,i}*B_{|j|,j}\\
FMT(C_{|x|})=\sum_{|i|}(FMT(A_{|i|})*FMT(B_{|x|-|i|}))
\end{align}</script><p>这里我们同时对两边做 FMT，这显然是成立的。我们先处理出 $FMT (A_{|i|}),FMT(B_{|i|})$，求出 $FMT(C_{|x|})$ 后做 $IFMT$ 即可。时间复杂度为 $\mathcal O(n^22^n)$。</p>
 <details class="code" open><summary><i class="fab fa-code fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">FMT</span>(n,a[i]),<span class="built_in">FMT</span>(n,b[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n-i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;tot;x++)</span><br><span class="line">            c[i+j][x]=<span class="built_in">adj</span>(c[i+j][x]+<span class="number">1ll</span>*a[i][x]*b[j][x]%mod);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">IFMT</span>(n,c[i]);</span><br></pre></td></tr></table></figure>

</details>
<h3 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h3><h4 id="1-CF914G-Sum-the-Fibonacci"><a href="#1-CF914G-Sum-the-Fibonacci" class="headerlink" title="1.CF914G Sum the Fibonacci"></a>1.<a href="https://codeforces.com/problemset/problem/914/G">CF914G Sum the Fibonacci</a></h4><p>模板题。</p>
 <details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> popcnt __builtin_popcount</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">17</span>,M=<span class="number">1</span>&lt;&lt;N,mod=<span class="number">1e9</span>+<span class="number">7</span>,inv=mod+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,tot;</span><br><span class="line"><span class="type">int</span> f[M],A[M];</span><br><span class="line"><span class="type">int</span> a[N+<span class="number">1</span>][M],b[N+<span class="number">1</span>][M],c[M],d[M],e[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FMT</span><span class="params">(<span class="type">int</span> op,<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">if</span>(!op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j]=<span class="built_in">adj</span>(a[j]+a[j^(<span class="number">1</span>&lt;&lt;i)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j^(<span class="number">1</span>&lt;&lt;i)]=<span class="built_in">adj</span>(a[j]+a[j^(<span class="number">1</span>&lt;&lt;i)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IFMT</span><span class="params">(<span class="type">int</span> op,<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">if</span>(!op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=tot<span class="number">-1</span>;~j;j--)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j]=<span class="built_in">adj</span>(a[j]-a[j^(<span class="number">1</span>&lt;&lt;i)]+mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=tot<span class="number">-1</span>;~j;j--)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j^(<span class="number">1</span>&lt;&lt;i)]=<span class="built_in">adj</span>(a[j^(<span class="number">1</span>&lt;&lt;i)]-a[j]+mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=<span class="built_in">adj</span>(x+y),a[i+j+mid]=<span class="built_in">adj</span>(x-y+mod);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IFWT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=<span class="number">1ll</span>*<span class="built_in">adj</span>(x+y)*inv%mod,a[i+j+mid]=<span class="number">1ll</span>*<span class="built_in">adj</span>(x-y+mod)*inv%mod;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        A[x]++,tot=<span class="built_in">max</span>(tot,x);</span><br><span class="line">    &#125;</span><br><span class="line">    tot++;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;n)&lt;tot)n++;</span><br><span class="line">    tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>,f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;tot;i++)</span><br><span class="line">        f[i]=<span class="built_in">adj</span>(f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//subset</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        a[<span class="built_in">popcnt</span>(i)][i]=A[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="built_in">FMT</span>(<span class="number">0</span>,n,a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n-i;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;tot;x++)</span><br><span class="line">                b[i+j][x]=<span class="built_in">adj</span>(b[i+j][x]+<span class="number">1ll</span>*a[i][x]*a[j][x]%mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">IFMT</span>(<span class="number">0</span>,n,b[i]);</span><br><span class="line">    <span class="comment">//xor</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c,A,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">FWT</span>(n,c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        c[i]=<span class="number">1ll</span>*c[i]*c[i]%mod;</span><br><span class="line">    <span class="built_in">IFWT</span>(n,c);</span><br><span class="line">    <span class="comment">//and</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        d[i]=<span class="number">1ll</span>*b[<span class="built_in">popcnt</span>(i)][i]*f[i]%mod;</span><br><span class="line">    <span class="built_in">memcpy</span>(e,A,<span class="built_in">sizeof</span>(e));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        c[i]=<span class="number">1ll</span>*c[i]*f[i]%mod,e[i]=<span class="number">1ll</span>*e[i]*f[i]%mod;</span><br><span class="line">    <span class="built_in">FMT</span>(<span class="number">1</span>,n,c),<span class="built_in">FMT</span>(<span class="number">1</span>,n,d),<span class="built_in">FMT</span>(<span class="number">1</span>,n,e);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        c[i]=<span class="number">1ll</span>*c[i]*d[i]%mod*e[i]%mod;</span><br><span class="line">    <span class="built_in">IFMT</span>(<span class="number">1</span>,n,c);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+c[<span class="number">1</span>&lt;&lt;i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数学</tag>
        <tag>集合幂级数</tag>
      </tags>
  </entry>
  <entry>
    <title>容斥原理</title>
    <url>/2023/02/26/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>容斥是门学问。</p>
<span id="more"></span>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>集合 $U$ 中的元素有 $n$ 种不同的属性，而第 $i$ 种属性称为 $P_i$，拥有属性 $P_i$ 的元素构成的集合为 $S_i$，那么：</p>
<script type="math/tex; mode=display">
\begin{align}
\bigcup_{i=1}^n S_i=& \sum_i |S_i|-\sum_{i<j} |S_i\bigcap S_j|+\sum_{i<j<k}|S_i\bigcap S_j\bigcap S_k|-\dots\\
&+(-1)^{m-1}\sum_{a_i<a_{i+1}}\bigcap_{i=1}^m S_{a_i}+\dots+(-1)^{n-1}|S_1\cap S_2\cap \dots S_n|
\end{align}</script><p>即：</p>
<script type="math/tex; mode=display">
\begin{align}
\bigcup_{i=1}^n S_i=\sum_{m=1}^{n}(-1)^{m-1}\sum_{a_i<a_{i+1}}\bigcap_{i=1}^m S_{a_i}
\end{align}</script><p>对于证明，我们需要证明每个元素恰好出现一次，把所有出现该元素的集合拿出来，来算其出现次数。设其出现的集合个数为 $m$：</p>
<script type="math/tex; mode=display">
\begin{align}
cnt&=\binom{m}{1}-\binom{m}{2}+\binom{m}{3}-\dots +(-1)^{m-1}\binom{m}{m}\\
&=\binom{m}{0}-\sum_{i=0}^{m}\binom {m}{i}\\
&=1-(1+(-1))^m=1
\end{align}</script><p>另外，集合的并可以用全集减去补集的并得到，即：</p>
<script type="math/tex; mode=display">
\begin{align}
\bigcap_{i=1}^{n}S_i=|U|-\bigcup_{i=1}^{n} \overline{S_i}
\end{align}</script><p>对右边容斥即可。</p>
<h3 id="2-容斥原理一般化"><a href="#2-容斥原理一般化" class="headerlink" title="2.容斥原理一般化"></a>2.容斥原理一般化</h3><p>容斥原理是解决计数问题的利器，对于两个集合的函数 $f(S),g(S)$，若：</p>
<script type="math/tex; mode=display">
\begin{align}
f(S)=\sum_{T\subseteq S}g(T)
\end{align}</script><p>那么有：</p>
<script type="math/tex; mode=display">
g(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|} f(T)</script><p>同样的对于</p>
<script type="math/tex; mode=display">
\begin{align}
f(T)=\sum_{T\subseteq S}g(S)
\end{align}</script><p>那么有：</p>
<script type="math/tex; mode=display">
\begin{align}
g(T)=\sum_{T\subseteq S}(-1)^{|S|-|T|} f(S)
\end{align}</script><p>我们发现上述的 $f(S),g(S)$，可以对应为 “至多/至少” 与 “恰好”。</p>
<h3 id="3-min-max-容斥"><a href="#3-min-max-容斥" class="headerlink" title="3.min-max 容斥"></a>3.min-max 容斥</h3><p>对于集合 $S,T$ 且 $T\subseteq S$，那么有：</p>
<script type="math/tex; mode=display">
\begin{align}
\max_{i\in S}a_i=\sum_{T\subseteq S}(-1)^{|T|+1}\min_{i\in S}a_i\\
\min_{i\in S}a_i=\sum_{T\subseteq S}(-1)^{|T|+1}\max_{i\in S}a_i
\end{align}</script><p>更加重要的是，这个式子在期望意义下也是成立的，即：</p>
<script type="math/tex; mode=display">
\begin{align}
E(\max_{i\in S}a_i)=\sum_{T\subseteq S}(-1)^{|T|+1}E(\min_{i\in S}a_i)\\
E(\min_{i\in S}a_i)=\sum_{T\subseteq S}(-1)^{|T|+1}E(\max_{i\in S}a_i)
\end{align}</script><p>这就比较好了，因为对于 $(13)$ 式子中，大多数情况下 $\displaystyle E(\min_{a_i\in S}a_i)$ 是相对好求的。</p>
<p>还有更强的：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{kth}\max_{ i\in S}a_i=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}\min_{i\in T} a_i\\
\text{kth}\min_{ i\in S}a_i=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}\max_{i\in T} a_i
\end{align}</script><p>同样对于期望意义下也是成立的：</p>
<script type="math/tex; mode=display">
\begin{align}
E(\text{kth}\max_{ i\in S}a_i)=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}E(\min_{i\in T} a_i)\\
E(\text{kth}\min_{ i\in S}a_i)=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}E(\max_{i\in T} a_i)
\end{align}</script><p>长得很像二项式反演！其实确实可以从二项式反演的角度证明以上等式。</p>
<h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><h4 id="1-AGC005D-K-Perm-Counting"><a href="#1-AGC005D-K-Perm-Counting" class="headerlink" title="1.AGC005D ~K Perm Counting"></a>1.<a href="https://atcoder.jp/contests/agc005/tasks/agc005_d">AGC005D ~K Perm Counting</a></h4><p>是个错位排列的扩展。我们尝试用类似的做法解决。设 $f(n)$ 表示钦定 $n$ 个元素满足 $|p_i-i|= k$ 的方案数，相当于求恰好有 $0 $ 个元素满足 $|p_i-i|= k$，利用式子 $(10)$ ，容斥得到答案为：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n (-1)^i (n-i)!f(i)</script><p>$f(n)$ 怎么求？钦定 $n$ 个元素满足 $p_i=i\pm k$，显然只有 $\bmod 2k$ 的同余类之间才会产生冲突。于是把每个同余类单独拿出来，需要在 $n$ 个点中选 $m$ 个点。将排列转化为二分图上的匹配。我们根据上面的限制对于每个同余类建出来的图是形如一条链的，问题就变为 $n$ 条匹配选 $m$ 条有多少种方案。相当于要求不能有匹配相邻。我们只要选择一条匹配则其后面的一条一定不能选，通过组合数得到方案数为 $\displaystyle \binom{n-m+1}{m}$。再使用背包进行合并不同同余类即可。这样暴力做是 $\mathcal O(n^2)$ 的，足以通过。但其实这个过程我们完全可以用生成函数来做，直接求其卷积即可，时间复杂度就为 $\mathcal O(n\log n)$。</p>
<p>此处为暴力 $\mathcal O(n^2)$ 代码。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,mod=<span class="number">924844033</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> fac[N],ifac[N];</span><br><span class="line"><span class="type">int</span> f[N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n||m&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;~i;i--)ifac[i]=<span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="built_in">prework</span>(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=<span class="built_in">min</span>(n,k&lt;&lt;<span class="number">1</span>);t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m=(t&gt;k)+((n-t)/k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;~i;i--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,m);j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> res=<span class="built_in">C</span>(m-j+<span class="number">1</span>,j);</span><br><span class="line">                f[i]=<span class="built_in">adj</span>(f[i]+<span class="number">1ll</span>*f[i-j]*res%mod);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+(i&amp;<span class="number">1</span>?mod<span class="number">-1ll</span>*f[i]*fac[n-i]%mod:<span class="number">1ll</span>*f[i]*fac[n-i]%mod));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数学</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#2542. 「PKUWC2018」随机游走</title>
    <url>/2023/03/05/LOJ-2542-%E3%80%8CPKUWC2018%E3%80%8D%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/</url>
    <content><![CDATA[<p>min-max 容斥 练手题。</p>
<span id="more"></span>
<p>发现要求的是： </p>
<script type="math/tex; mode=display">
E(\max_{i\in S} t_i)</script><p>使用 min-max 容斥得到：</p>
<script type="math/tex; mode=display">
E(\max_{i\in S} t_i)=\sum_{T\subseteq S}(-1)^{|T|-1} E(\min_{i\in T} t_i)</script><p>注意到 $n\le 18$，于是考虑直接暴力容斥，求出每个子集 $S$ 的 $\displaystyle E(\min_{i\in S} t_i) $。</p>
<p>设计状态 $f(i)$ 表示从 $i$ 走到第一次走到 $S$ 中任意点的期望步数，</p>
<p>1.对于 $i\in S$，有 $f(i)=0$。</p>
<p>2.对于 $i\notin S$，有 $\displaystyle f(i)=1+\frac{1}{\deg(i)}\sum_{(i,j)\in E} f(j)$。</p>
<p>可以高斯消元，但是时间复杂度就变成 $\mathcal O(n^3 2^n)$ 的，不能接受。</p>
<p>先考虑叶子节点 $i$，它们的值只会与父亲有关（或者 $f(i)=0$），有 $f(i)=A_i f(p_i) +B_i$，其中 $A_i=1,B_i=1$。而我们接着考虑叶子的父亲节点 $i$：</p>
<script type="math/tex; mode=display">
f(i)=1+\frac{1}{\deg_i}\sum_j{(A_j f(i)+b_j)} + \frac{1}{\deg_i}f(p_i)</script><p>变换一下：</p>
<script type="math/tex; mode=display">
f(i)=\frac{1}{\deg(i)-\sum_j{A_j}}f(p_i) + \frac{\deg(i)+\sum_j B_j}{\deg(i)-\sum_j A_j}</script><p>于是我们将叶子的父亲节点 $i$ 也表示成了类似于 $\displaystyle f(i)=A_i f(p_i) +B_i$ 的形式，其中 $\displaystyle A_i=\frac{1}{\deg(i)-\sum_j{A_j}},B_i=\frac{\deg(i)+\sum_j B_j}{\deg(i)-\sum_j A_j}$。</p>
<p>以此类推，我们从下往上可以推出所有节点的 $A_i,B_i$，我们直接以 $x$ 为根，因为 $x$ 没有父节点，所以：</p>
<script type="math/tex; mode=display">
f(x)=B_x</script><p>于是对与每个 $S$ dfs 一遍即可求出对应的 $f(x)$，时间复杂度为 $\mathcal O(n2^n)$。</p>
<p>但是我们要求的是 $\displaystyle \sum_{T\subseteq S}(-1)^{|T|-1} E(\min_{i\in T} t_i)$，对于每个询问求一次是 $\mathcal O(2^n)$ 的。对于这个式子，我们显然可以在预处理出所有 $\displaystyle (-1)^{|T|-1} E(\min_{i\in T} t_i)$ 后，做一次 FMT，即可 $\mathcal O(1)$ 回答询问。</p>
<p>代码非常好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> popcnt __builtin_popcount</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">18</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q,rt;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> s,deg[N],a[N],b[N];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s&gt;&gt;x&amp;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a[x]=<span class="number">0</span>,b[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> suma=<span class="number">0</span>,sumb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        suma=<span class="built_in">adj</span>(suma+a[y]),sumb=<span class="built_in">adj</span>(sumb+b[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[x]=<span class="built_in">qpow</span>(<span class="built_in">adj</span>(deg[x]-suma+mod));</span><br><span class="line">    b[x]=<span class="number">1ll</span>*<span class="built_in">adj</span>(deg[x]+sumb)*<span class="built_in">qpow</span>(<span class="built_in">adj</span>(deg[x]-suma+mod))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FMT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j]=<span class="built_in">adj</span>(a[j]+a[j^(<span class="number">1</span>&lt;&lt;i)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q,rt);</span><br><span class="line">    rt--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        u--,v--;</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">        deg[u]++,deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op=(<span class="built_in">popcnt</span>(s)&amp;<span class="number">1</span>)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(rt,<span class="number">-1</span>);</span><br><span class="line">        f[s]=<span class="built_in">adj</span>(op*b[rt]+mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FMT</span>(n,f);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="built_in">read</span>(k);</span><br><span class="line">        s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            x--;</span><br><span class="line">            s+=<span class="number">1</span>&lt;&lt;x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[s]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>集合幂级数</tag>
        <tag>容斥</tag>
        <tag>min-max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2022 全题解</title>
    <url>/2023/03/10/CSP-S-2022-%E5%85%A8%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>隔了好久好久。。。</p>
<span id="more"></span>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>题意：给定 $n$ 个点 $m$ 条边的无向图，每个点上有权值 $v_i$，现在从点 $1$ 走到另外 $4$ 个点再返回点 $1$，要求另外点与点之间的路程需小于等于 $k+1$，求另外四个点的权值和最大值。$n\le 2500,m\le 10000$。</p>
<p>乱搞，考虑处理出每个点在 $k+1$ 步内能到达的所有点，以及这些点中的最大值，亚大值，次大值。然后枚举中间两个点即可。时间复杂度 $\mathcal O(nm+n^2)$。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>题意：给定两个长度分别为 $n,m$ 数组 $A,B$，有 $q$ 次询问 $l_1,r_1,l_2,r_2$，表示在小 L 先在数组 $A$ 的 $[l_1,r_1]$ 中选一个数 $a_x$，小 Q 再在数组 $B$ 的 $[l_2,r_2]$ 中选一个数 $b_y$，每一轮的得分为 $a_x\times b_y$ 。小 L 想使得分最大，小 Q 想使其最小。两人都是足够聪明的玩家，每次都会采用最优的策略。求得分是多少。$n,m,q\le 10^5$。</p>
<p>注意到是小 L 先选，小 Q 后选，很容易根据正负关系分类讨论，接着用 ST 表或者线段树维护即可，此处不再赘述。时间复杂度 $\mathcal O(n\log n+q\log n)$，此处视 $n,m$ 同阶。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>题意：给定 $n$ 个点 $m$ 条边的有向图，有 $q$ 次操作，操作有 $4$ 种类型：1.禁用边  $(u,v)$；2.禁用 $u$ 所有的入边；3.激活边  $(u,v)$；4.激活 $u$ 所有的入边。要求判断每次操作后的图是否为一棵基环树。</p>
<p>判断基环树即为判断每个点是否有且仅有一条出边。显然合法的入边总数应当为 $n$，即满足 $\displaystyle \sum_{i=1}^n in_i=n$。但是这样显然很大可能有多组解。于是尝试 Hash 一下。</p>
<p>尝试赋给每个点一个随机权值 $v_i$，并且使 $\displaystyle in_i=\sum_{(j,i)\in E} v_j$，现在我们只需要判断其是否满足 $\displaystyle \sum_{i=1}^{n} in_i=\sum_{i=1}^n k_i v_i=\sum_{i=1}^{n} v_i$。因为这个方程极大可能只有一组解 $k_1=1,k_2=1\dots k_n=1$。并且对于修改操作，我们只需要简单维护 $in_i$ 即可。时间复杂度 $\mathcal O(n+q)$。</p>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>题意：给定一棵 $n$ 个节点的树，每个点上有权值 $v_i$。给定常数 $k$，有 $q$ 次询问 $u,v$，对于一条路径 $p_1\to \dots \to p_w,p_1=u,p_w=v$，需要满足 $\forall dis(p_i,p_{i+1})\le k$，路径的权值为 $\displaystyle \sum_{i=1}^w v_i$，询问最小的权值为多少。$n,q\le 2\times 10^5,k\le 3$。</p>
<p>先考虑 $k=1,2$ 的情况。$k=1$ 时，直接输出 $u\to v$ 上所有点的权值和即可，倍增处理。$k=2$ 时，我们发现路径 $p_1\to \dots \to p_w$ 依然是在 $u\to v $ 上的，但并不是所有点都要取。设计 $(x,t)$ 表示到 $x$ 已经走了多少步没有选点。还是考虑倍增处理，设计倍增数组 $f_{x,k,p,q}$ 表示从 $(x,p)$ 到 $(fa_{x,k},q)$ 最小权值和，这是容易预处理以及计算的。</p>
<p>有了 $k=1,2$ 的启发，我们还是尝试倍增。我们发现完全可以沿用 $k=2$ 中倍增数组 $f_{x,k,p,q}$ 的设计。但是需要考虑的是，现在是可以走到 $u\to v$ 之外的点的。但是简单观察发现，是只可能绕过 $u\to v$ 上某个点，转而去到与之相邻的 $v_i$ 最小的点上，再回到 $u\to v$ 上。那么现在 $f_{x,k,p,q}$ 也是容易预处理的了。</p>
<p>但需要注意的是计算时，将 $u\to \text{LCA}$ 与 $\text{LCA}\to v$ 拼在一起时的两种特殊情况：1.若 $p=0,q=0$，则 $v_{\text{LCA}}$ 会被计算两次，需要减去。2.若 $p=2,q=2$，则 $v_{\text{LCA}}$ 被少算，需要加上。</p>
<p>时间复杂度 $\mathcal O(n\log n+q\log n)$。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP 2022 全题解</title>
    <url>/2023/03/10/NOIP-2022-%E5%85%A8%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>隔了好久好久。。。</p>
<span id="more"></span>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>题意：给定一棵 $n\times m$ 的 01 矩阵，问有多少个由 1 组成形如 <code>C</code> 和形如 <code>F</code> 的图案。</p>
<p><code>C</code> 与 <code>F</code> 做法是类似的，此处只讨论 <code>F</code>。</p>
<p>考虑处理出每个位置向右延伸以及向下延伸的最大值。再枚举每一列统计答案即可，时间复杂度 $\mathcal O(nm)$。</p>
<p>最后注意乘上给定常数 $C,F$。<del>（警钟敲烂）</del></p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p><a href="https://kevinlive.github.io/2023/03/13/LOJ-3897-%E3%80%8CNOIP2022%E3%80%8D%E5%96%B5%E4%BA%86%E4%B8%AA%E5%96%B5/#more">在这里看</a></p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p><a href="https://kevinlive.github.io/2022/12/05/P8867-NOIP2022-%E5%BB%BA%E9%80%A0%E5%86%9B%E8%90%A5/#more">在这里看</a></p>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>题意：给定两个长度为 $n$ 的序列 $A,B$。有 $q$ 次询问 $l,r$，每次询问 $\sum_{l\le p\le q\le r} \max_{i=p}^q A_i\times \max_{i=p}^q B_i$。</p>
<p>考虑将询问离线下来，对右端点 $r$ 直接扫描线，每次将其放进单调栈里，找到最远能影响到的位置。继而维护前面每个位置的答案。</p>
<p>现在就相当于需要维护答案的历史版本之和。我们需要支持三种操作：</p>
<p>1.将 $a$ 区间滚平为 $x$；</p>
<p>2.将 $b$ 区间滚平为 $x$；</p>
<p>3.每个位置加上 $a_i\times b_i$。</p>
<p>但是具体如何用线段树维护？线段树节点上我们需要维护答案 $sum$，以及 $sumx,sumy,sumxy$ 表示 $\sum x,\sum y,\sum xy$。tag 上我们需要维护 $sx,sy$ 表示区间滚平，以及 $addx,addy,addxy,addz$ 表示 $sum’=sum+addx\times sumx+addy\times sumy+addxy\times sumxy+addz\times len$。tag 的意义即为当前节点的 $sum$ 需要加上 $sumx,sumy,sumxy,len$ 分别乘上其 tag 上所对应的系数的和。根据这个意义可以写出 tag 的合并方式。需要注意到是要先累加后滚平。具体代码可以看 <a href="https://loj.ac/s/1720904">https://loj.ac/s/1720904</a> 。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3897. 「NOIP2022」喵了个喵</title>
    <url>/2023/03/13/LOJ-3897-%E3%80%8CNOIP2022%E3%80%8D%E5%96%B5%E4%BA%86%E4%B8%AA%E5%96%B5/</url>
    <content><![CDATA[<p>再次敲响警钟。</p>
<span id="more"></span>
<p>先考虑 $k=2n-2$，我们把 $n-1$ 栈上放上互不相同的 $2n-2$ 种牌。接下来新来的一张牌如果在栈顶出现过，我们放在对应的栈上消去；如果在栈底出现过，我们就将它放在空栈上，再将该栈底消去即可。</p>
<p>再考虑 $k=2n-1$，我们还是把 $n-1$ 栈上放上互不相同的 $2n-2$ 种牌，并且维护一个空栈（否则栈底很可能无法被消除）。接下来新来的一张牌可能是新的第 $2n-1$ 种牌。而这个时候我们就不太好放了。因为放在前 $n-1$ 个栈上，可能会影响到栈顶的消除；放在空栈上，无法及时消去会影响到栈底的消除。</p>
<p>我们尝试放到一个不会影响之后消除的位置上。经过思考，我们考虑这样的过程：</p>
<ol>
<li><p>$n-1$ 个栈上有 $2n-2$ 种不同的牌。</p>
</li>
<li><p>当前要放的第 $2n-1$ 种牌先待定。</p>
</li>
<li><p>找到之后出现的栈底种类之一（或者第 $2n-1$ 种）的第一张牌。</p>
</li>
<li><p>该栈的栈顶牌型出现次数的奇偶性进行讨论：</p>
<p>1.偶数次：将第 $2n-1$ 种牌放在空栈上，消去该栈上的所有牌，并将其作为新的空栈。</p>
<p>2.奇数次：将第 $2n-1$ 种牌放在该栈上，最后利用空栈将栈底消去。</p>
</li>
</ol>
<p>实现起来相当繁琐，可能因为小细节挂掉。。。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300</span>+<span class="number">10</span>,M=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res&lt;<span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),res=-res;</span><br><span class="line">    <span class="keyword">if</span>(res&gt;<span class="number">9</span>)<span class="built_in">write</span>(res/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(res%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;<span class="built_in">putchar</span>(c);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> </span>&#123;<span class="keyword">while</span>(*s)<span class="built_in">putchar</span>(*s++);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> ...ARC&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T res, ARC ...com)</span></span>&#123;<span class="built_in">write</span>(res),<span class="built_in">write</span>(com...);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Op</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> op,x,y;</span><br><span class="line">&#125;ans[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> T,n,m,k;</span><br><span class="line"><span class="type">int</span> a[M];</span><br><span class="line"><span class="type">int</span> now,em;</span><br><span class="line"><span class="type">int</span> vis[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt;sta[N],q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(now&lt;=m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[a[now]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[a[now]]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> i=vis[a[now]];</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                sta[i].<span class="built_in">pop_back</span>();</span><br><span class="line">                q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                vis[a[now]]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> i=-vis[a[now]];</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">2</span>,i,em&#125;;</span><br><span class="line">                sta[i].<span class="built_in">pop_front</span>();</span><br><span class="line">                q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                vis[a[now]]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(sta[i].<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">                    vis[sta[i].<span class="built_in">front</span>()]=-i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">            sta[i].<span class="built_in">push_back</span>(a[now]);</span><br><span class="line">            <span class="keyword">if</span>(sta[i].<span class="built_in">size</span>()==<span class="number">1</span>)vis[a[now]]=-i;</span><br><span class="line">            <span class="keyword">else</span> vis[a[now]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        now++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    now=<span class="number">1</span>,em=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        q.<span class="built_in">push_back</span>(i),q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">work</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos=now+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos&lt;=m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[a[pos]]&lt;<span class="number">0</span>||a[pos]==a[now])<span class="keyword">break</span>;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[pos]==a[now])</span><br><span class="line">        &#123;</span><br><span class="line">            ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=now+<span class="number">1</span>;t&lt;pos;t++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> i=vis[a[t]];</span><br><span class="line">                <span class="keyword">if</span>(i)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                    sta[i].<span class="built_in">pop_back</span>();</span><br><span class="line">                    q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    vis[a[t]]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop_front</span>();</span><br><span class="line">                    ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                    sta[i].<span class="built_in">push_back</span>(a[t]);</span><br><span class="line">                    vis[a[t]]=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">            now=pos+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">1</span>,top=sta[-vis[a[pos]]].<span class="built_in">back</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=now+<span class="number">1</span>;t&lt;pos;t++)</span><br><span class="line">                <span class="keyword">if</span>(a[t]==top)cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,-vis[a[pos]],<span class="number">0</span>&#125;; </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=now+<span class="number">1</span>;t&lt;pos;t++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> i=vis[a[t]];</span><br><span class="line">                    <span class="keyword">if</span>(a[t]==top)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,-vis[a[pos]],<span class="number">0</span>&#125;;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                        sta[i].<span class="built_in">pop_back</span>();</span><br><span class="line">                        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                        vis[a[t]]=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">                        q.<span class="built_in">pop_front</span>();</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                        sta[i].<span class="built_in">push_back</span>(a[t]);</span><br><span class="line">                        vis[a[t]]=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">2</span>,-vis[a[pos]],em&#125;;</span><br><span class="line">                sta[-vis[a[pos]]].<span class="built_in">pop_front</span>();</span><br><span class="line">                sta[-vis[a[pos]]].<span class="built_in">push_back</span>(a[now]);</span><br><span class="line">                vis[a[pos]]=<span class="number">0</span>;</span><br><span class="line">                vis[a[now]]=vis[top];</span><br><span class="line">                vis[top]=-vis[top];</span><br><span class="line">                now=pos+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=now+<span class="number">1</span>;t&lt;pos;t++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> i=vis[a[t]];</span><br><span class="line">                    <span class="keyword">if</span>(a[t]==top)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,-vis[a[pos]],<span class="number">0</span>&#125;;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                        sta[i].<span class="built_in">pop_back</span>();</span><br><span class="line">                        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                        vis[a[t]]=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">                        q.<span class="built_in">pop_front</span>();</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                        sta[i].<span class="built_in">push_back</span>(a[t]);</span><br><span class="line">                        vis[a[t]]=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,-vis[a[pos]],<span class="number">0</span>&#125;;</span><br><span class="line">                vis[a[now]]=-em;</span><br><span class="line">                sta[em].<span class="built_in">push_back</span>(a[now]);</span><br><span class="line">                q.<span class="built_in">push_back</span>(em);</span><br><span class="line">                sta[-vis[a[pos]]].<span class="built_in">clear</span>();</span><br><span class="line">                em=-vis[a[pos]];</span><br><span class="line">                vis[top]=vis[a[pos]]=<span class="number">0</span>;</span><br><span class="line">                now=pos+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(tot,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i].op,<span class="string">&#x27; &#x27;</span>,ans[i].x);</span><br><span class="line">        <span class="keyword">if</span>(ans[i].op==<span class="number">2</span>)<span class="built_in">write</span>(<span class="string">&#x27; &#x27;</span>,ans[i].y);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;meow.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;meow.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1616H Keep XOR Low</title>
    <url>/2023/03/16/CF1616H-Keep-XOR-Low/</url>
    <content><![CDATA[<p>Trie 树上进行 01 分治。</p>
<span id="more"></span>
<p>感觉之前也考类似的题，于是记一下。</p>
<p>显然按照每一位进行考虑，将 Trie 树建出来。我们设置函数 $f(x,y,i)$ 表示前 $i-1$ 位的限制全部卡满，在 $x$ 节点与 $y$ 节点上分别选取两个子集，两个子集之间的元素满足 $x_i\oplus y_i\le k$，考虑当前位：</p>
<ol>
<li>第 $i$ 位为 $0$，那么 $x,y$ 必须选取同一侧的子树，即 $f(x_0,y_0,i-1),f(x_1,y_1,i-1)$。再加上 $x,y$ 分别在各自子树之中可以任意选的方案（因为前面的位数都会变成 $0$，对第 $i$ 位就没有限制了）。</li>
<li>第 $i$ 位为 $1$，那么 $x,y$ 选同侧的话，就不需要满足被卡满的限制，不符合我们的定义，我们是一定要卡满的。而我们需要走 $x,y$ 的异侧。并且容易发现 $f(x_0,y_1),f(x_1,y_0)$ 之间是相互独立的，意思是 $x_0,x_1$ 之间与 $y_0,y_1$ 之间是没有限制的（两个都选相当于走同侧），所以直接就是 $f(x_0,y_1)\times f(x_1,y_0)$。</li>
</ol>
<p>每个节点只会被计算一次，时间复杂度 $\mathcal O(n\log V)$，其中 $V$ 为值域。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.5e5</span>+<span class="number">10</span>,K=<span class="number">30</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,ch[N&lt;&lt;<span class="number">5</span>][<span class="number">2</span>],si[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">1</span>;si[u]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> v=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][v])ch[u][v]=++tot;</span><br><span class="line">        si[u=ch[u][v]]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x=<span class="number">1</span>,<span class="type">int</span> y=<span class="number">1</span>,<span class="type">int</span> i=<span class="number">30</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y)<span class="keyword">return</span> p[si[x]+si[y]];</span><br><span class="line">    <span class="keyword">if</span>(!(x^y))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!~i)<span class="keyword">return</span> p[si[x]];</span><br><span class="line">        <span class="keyword">if</span>(k&gt;&gt;i&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">solve</span>(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>],i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">adj</span>(<span class="built_in">solve</span>(ch[x][<span class="number">0</span>],ch[x][<span class="number">0</span>],i<span class="number">-1</span>)+<span class="built_in">solve</span>(ch[x][<span class="number">1</span>],ch[x][<span class="number">1</span>],i<span class="number">-1</span>)<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!~i)<span class="keyword">return</span> p[si[x]+si[y]];</span><br><span class="line">    <span class="keyword">if</span>(k&gt;&gt;i&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1ll</span>*<span class="built_in">solve</span>(ch[x][<span class="number">0</span>],ch[y][<span class="number">1</span>],i<span class="number">-1</span>)*<span class="built_in">solve</span>(ch[x][<span class="number">1</span>],ch[y][<span class="number">0</span>],i<span class="number">-1</span>)%mod;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">adj</span>(<span class="built_in">adj</span>(<span class="built_in">solve</span>(ch[x][<span class="number">0</span>],ch[y][<span class="number">0</span>],i<span class="number">-1</span>)+<span class="built_in">solve</span>(ch[x][<span class="number">1</span>],ch[y][<span class="number">1</span>],i<span class="number">-1</span>)<span class="number">-1</span>)+</span><br><span class="line">    <span class="built_in">adj</span>(<span class="number">1ll</span>*(p[si[ch[x][<span class="number">0</span>]]]<span class="number">-1</span>)*(p[si[ch[x][<span class="number">1</span>]]]<span class="number">-1</span>)%mod+<span class="number">1ll</span>*(p[si[ch[y][<span class="number">0</span>]]]<span class="number">-1</span>)*(p[si[ch[y][<span class="number">1</span>]]]<span class="number">-1</span>)%mod));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)p[i]=<span class="built_in">adj</span>(p[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>二项式反演</title>
    <url>/2023/03/16/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<p>经典有用的反演。</p>
<span id="more"></span>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>有这么几个比较重要的式子：</p>
<script type="math/tex; mode=display">
\begin{align}
f(n)=\sum_{i=0}^n (-1)^i \binom{n}{i} g(i)&\Longleftrightarrow g(n)=\sum_{i=0}^n (-1)^i \binom{n}{i} f(i)\\
f(n)=\sum_{i=0}^n \binom{n}{i} g(i)&\Longleftrightarrow g(n)=\sum_{i=0}^n (-1)^{n-i} \binom{n}{i} f(i)\\
f(n)=\sum_{i=n}^m (-1)^i \binom{i}{n} g(i)&\Longleftrightarrow g(n)=\sum_{i=n}^m (-1)^i \binom{i}{n} f(i)\\
f(n)=\sum_{i=n}^m \binom{i}{n} g(i)&\Longleftrightarrow g(n)=\sum_{i=n}^m (-1)^{i-n} \binom{i}{n} f(i)
\end{align}</script><p>这些正是我们进行二项式反演的基础式子，似乎能看到一些容斥的影子。但是公式的运用是浅显的，更加重要的是关于模型的构建。</p>
<h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2.例题"></a>2.例题</h3><h4 id="1-P4859-已经没有什么好害怕的了"><a href="#1-P4859-已经没有什么好害怕的了" class="headerlink" title="1.P4859 已经没有什么好害怕的了"></a>1.<a href="https://www.luogu.com.cn/problem/P4859">P4859 已经没有什么好害怕的了</a></h4><p>相当求使 $a&gt;b$ 恰好有 $k$ 对的方案数。注意到 ”恰好“，联想到转化为 “至少” 来求解（”至少“ 限制更宽松，在多数情况下是相对更好求的）。设计 $f(n)$ 表示至少 $n$ 个满足 $a&gt;b$ 的方案数， $g(n)$ 表示恰好 $n$ 个满足  $a&gt;b$ 的方案数。我们要求的就是 $g(k)$。对于这两个函数，我们有关系式：</p>
<script type="math/tex; mode=display">
f(k)=\sum_{i=k}^n \binom{i}{k} g(i)</script><p>使用式子 $(4)$ 进行二项式反演：</p>
<script type="math/tex; mode=display">
g(k)=\sum_{i=k}^n (-1)^{i-k} \binom{i}{k} f(i)</script><p>考虑设 $f_{i,j}$ 表示前 $i$ 个之中选出 $j$ 组满足 $a&gt;b$，相当于钦定了 $j$ 组 $a&gt;b$，剩下的可以随便选。先将 $A,B$ 排序，处理出 $b_j&lt;a_i$ 的个数 $cnt_i$。并且仍然按照此顺序进行 DP，容易得到转移方程：</p>
<script type="math/tex; mode=display">
f_{i,j}={f_{i-1,j}+(cnt_i-j+1)\times f_{i-1,j-1}}</script><p>而我们要求的 $f(i)=(n-i)! f_{n,i}$。然后带入二项式反演的式子即可得到 $g(k)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[N],b[N],cnt[N];</span><br><span class="line"><span class="type">int</span> fac[N],ifac[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">if</span>(n+k&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    k=n+k&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(b[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n),<span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p+<span class="number">1</span>&lt;=n&amp;&amp;a[i]&gt;b[p+<span class="number">1</span>])p++;</span><br><span class="line">        cnt[i]=p;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod,ifac[i]=<span class="built_in">qpow</span>(fac[i]);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">min</span>(i,cnt[i]);j;j--)</span><br><span class="line">            f[j]=<span class="built_in">adj</span>(f[j]+<span class="number">1ll</span>*(cnt[i]-j+<span class="number">1</span>)*f[j<span class="number">-1</span>]%mod);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=(i-k&amp;<span class="number">1</span>)?mod<span class="number">-1ll</span>*f[i]*fac[n-i]%mod*<span class="built_in">C</span>(i,k)%mod:</span><br><span class="line">                <span class="number">1ll</span>*f[i]*fac[n-i]%mod*<span class="built_in">C</span>(i,k)%mod;</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="2-P6478-NOI-Online-2-提高组-游戏"><a href="#2-P6478-NOI-Online-2-提高组-游戏" class="headerlink" title="2.P6478 [NOI Online #2 提高组]游戏"></a>2.<a href="https://www.luogu.com.cn/problem/P6478">P6478 [NOI Online #2 提高组]游戏</a></h4><p>再次注意到 ”恰好“ 的限制条件。考虑像上一道题一样转化为 ”至少“。考虑设计 $f(i)$ 表示至少 $i$ 个非平局回合， $g(i)$ 表示恰好 $i$ 个非平局回合。还是用上面的式子进行二项式反演。考虑用 DP 求出 $f(i)$。</p>
<p>考虑树上背包，设计 $f_{x,i}$ 表示以 $x$ 为根的子树中钦定了 $i$ 个非平局回合，容易得到转移方程：</p>
<script type="math/tex; mode=display">
\begin{align}
f'_{x,i}&\gets \sum_{j=0}^{i} f_{x,i-j}\times f_{y,j}\notag\\
f'_{x,i}&\gets (size_{0/1}[x]-(i-1))\times f_{x,i-1}\notag
\end{align}</script><p>$f(i)$ 即为 $(n-i)!f_{1,i}$，带入公式即可求出 $g(i)$。总时间复杂度 $\mathcal O(n^2)$。</p>
<p>需要注意的是背包转移时的细节：转移形式是加法卷积，对于初始的 $f’_{x,i}$ 应当为 $f_{x,i}\times f_{y,0}$，而非 $f_{x,i}\times (f_{y,0}+1)$，因为我们必须选完 $y$ 子树里的点（只不过没有非平局回合）。更为保险的做法是开一个副本作为计算当前答案，算完再复制一遍。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> col[N],si[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> f[N][N],fac[N],ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="type">int</span> six=<span class="built_in">min</span>(si[x][<span class="number">0</span>],si[x][<span class="number">1</span>]),siy=<span class="built_in">min</span>(si[y][<span class="number">0</span>],si[y][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=six+siy;~j;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="built_in">max</span>(j-six,<span class="number">0</span>);k&lt;=<span class="built_in">min</span>(siy,j);k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!k)f[x][j]=<span class="number">1ll</span>*f[x][j]*f[y][<span class="number">0</span>]%mod;</span><br><span class="line">                <span class="keyword">else</span> f[x][j]=<span class="built_in">adj</span>(f[x][j]+<span class="number">1ll</span>*f[x][j-k]*f[y][k]%mod);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        si[x][<span class="number">0</span>]+=si[y][<span class="number">0</span>],si[x][<span class="number">1</span>]+=si[y][<span class="number">1</span>];    </span><br><span class="line">    &#125;</span><br><span class="line">    si[x][col[x]]++;</span><br><span class="line">    <span class="type">int</span> six=<span class="built_in">min</span>(si[x][<span class="number">0</span>],si[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=six;i;i--)</span><br><span class="line">        f[x][i]=<span class="built_in">adj</span>(f[x][i]+<span class="number">1ll</span>*(si[x][col[x]^<span class="number">1</span>]-(i<span class="number">-1</span>))*f[x][i<span class="number">-1</span>]%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;col[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod,ifac[i]=<span class="built_in">qpow</span>(fac[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> res=(j-i&amp;<span class="number">1</span>)?mod<span class="number">-1ll</span>*f[<span class="number">1</span>][j]*fac[n-j]%mod*<span class="built_in">C</span>(j,i)%mod:</span><br><span class="line">            <span class="number">1ll</span>*f[<span class="number">1</span>][j]*fac[n-j]%mod*<span class="built_in">C</span>(j,i)%mod;</span><br><span class="line">            ans=<span class="built_in">adj</span>(ans+res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>通过上面两个例题，容易发现很多情况下我们能够通过二项式反演将 ”恰好“ 的限制转化为 ”至少“ 的限制，再进一步求解。这也是解决这一类题的基本思路。换个角度来看，是一个当函数与集合具体有哪些元素无关，而与其中元素个数有关的情况下，进行的一个容斥。这一点能很好的将二者而这联系起来。</p>
<h4 id="3-CF1707D-Partial-Virtual-Trees"><a href="#3-CF1707D-Partial-Virtual-Trees" class="headerlink" title="3.CF1707D Partial Virtual Trees"></a>3.<a href="https://codeforces.com/problemset/problem/1707/D">CF1707D Partial Virtual Trees</a></h4><p>先考虑直接 DP，但发现并不好做。为什么？因为每次操作必须删除一个点，但是合并子树时只要有一棵子树在这一次操作内进行删点就行了。</p>
<p>于是考虑如何去掉这个限制。设计 $f(i)$ 表示至多进行 $i$ 次操作将树删空的方案数，或者换一种说法，进行的 $i$ 次操作其中有操作可以不删点，但是最终仍需要删空。设计 $g(i)$ 表示恰好进行 $i$ 次操作将树删空的方案数。通过枚举进行删点的 $i$ 次操作，我们可以得到：</p>
<script type="math/tex; mode=display">
f(n)=\sum_{i=0}^n \binom{n}{i}g(i)</script><p>这恰是二项式反演的形式！我们使用式子 $(2)$ 得到：</p>
<script type="math/tex; mode=display">
g(n)=\sum_{i=0}^n (-1)^{n-i} f(i)</script><p>还是考虑 DP 求出来 $f(i)$，设计 $f_{x,i}$ 表示将子树 $x$ 内操作 $i$ 次（可以不删点）之后为空的方案数。考虑两种情况：1.将所有子节点删完后，删除 $x$；2.将所有子节点删到只有 $1$ 棵子树 $y$ 中有点，再删去 $x$，再将剩下的节点删完。于是有转移方程：</p>
<script type="math/tex; mode=display">
\begin{align}
f_{x,i}&\gets \prod_y \sum_{j=1}^i f_{y,j}\notag\\
f_{x,i}&\gets \sum_y f_{y,i}\times \sum_{k=1}^{i-1} \ \prod_{t\ne y}\sum_{j=1}^k f_{t,j}\notag
\end{align}</script><p>前缀和一下辅助转移，这一部分是 $\mathcal O(n^2)$ 的。所以总的时间复杂度是 $\mathcal O(n^2)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,mod;</span><br><span class="line"><span class="type">int</span> fac[N],ifac[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> sum[N][N],pre[N][N],suf[N][N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> si=e[x].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)pre[i][j]=suf[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)pre[i][j]=suf[i][j]=sum[y][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;si;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            pre[i][j]=<span class="number">1ll</span>*pre[i<span class="number">-1</span>][j]*pre[i][j]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=si<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            suf[i][j]=<span class="number">1ll</span>*suf[i+<span class="number">1</span>][j]*suf[i][j]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[x][i]=<span class="built_in">adj</span>(f[x][i]+pre[si<span class="number">-1</span>][i]);</span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=e[x][i];</span><br><span class="line">            <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[x][j]=<span class="built_in">adj</span>(f[x][j]+<span class="number">1ll</span>*f[y][j]*res%mod);</span><br><span class="line">                res=<span class="built_in">adj</span>(res+<span class="number">1ll</span>*((i)?pre[i<span class="number">-1</span>][j]:<span class="number">1</span>)*((i+<span class="number">1</span>&lt;si)?suf[i+<span class="number">1</span>][j]:<span class="number">1</span>)%mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sum[x][i]=<span class="built_in">adj</span>(f[x][i]+sum[x][i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod,ifac[i]=<span class="built_in">qpow</span>(fac[i]);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> res=(i-j&amp;<span class="number">1</span>)?mod<span class="number">-1ll</span>*f[<span class="number">1</span>][j]*<span class="built_in">C</span>(i,j)%mod:</span><br><span class="line">            <span class="number">1ll</span>*f[<span class="number">1</span>][j]*<span class="built_in">C</span>(i,j)%mod;</span><br><span class="line">            ans=<span class="built_in">adj</span>(ans+res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
</search>
