<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[AGC043B] 123 Triangle</title>
    <url>/2022/09/19/AGC043B-123-Triangle/</url>
    <content><![CDATA[<p> mydcwfy 提供的题目。</p>
<span id="more"></span>
<p>很显然对于 $n&gt;1$ 的情况答案一定不为 $2$，特判即可。其他情况我们先做一次操作。</p>
<p>接着我们手动模拟，大胆猜测：若序列中有 $1$，则答案一定不为 $2$。似乎也比较显然，因为只要 $1$ 与 $2$ 在操作过程中相遇，那么 $2$ 就会被消掉，而 $1$ 并不会。对于只有 $2$ 的情况，我们可以把整个序列 $\div 2$ 就和 $0-1$ 序列的情况一样了，最后答案 $\times 2$ 即可。</p>
<p>实际上我们只需要判断答案奇偶，操作也变成了模 $2$ 意义下的。比较重要的是：$f_{k,x}=f_{k-1,x}-f_{k-1,x-1}=f_{k-1,x}+f_{k-1,x-1} \mod 2$。这很像组合数，我们进一步可以得到：$f_{n,1}=\sum_{i=1}^{n} a_i \cdot \binom{n-1}{i-1} \mod 2$。使用 Lucas 定理或者 <code>[n&amp;m==m]</code> 判断奇偶都可以。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;<span class="keyword">return</span> (n&amp;m)==m;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=<span class="built_in">abs</span>(a[i]-a[i+<span class="number">1</span>]),flag|=(a[i]==<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            a[i]&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    flag^=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans^=<span class="built_in">C</span>(n<span class="number">-1</span>,i<span class="number">-1</span>)*(a[i]&amp;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans&lt;&lt;flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC056B] Range Argmax</title>
    <url>/2023/06/25/AGC056B-Range-Argmax/</url>
    <content><![CDATA[<p>妙妙 DP 题。</p>
<span id="more"></span>
<p>因为一个 $x$ 可能会对应着不同的 $p$，所以直接对 $x$ 进行计数是十分困难。所以我们尝试对于特定的 $p$ 与 $x$ 建立双射关系。我们尝试用 $x$ 来构造 $p$。</p>
<p>假设已知 $x$，求一个对应的 $p$。我们从大到小考虑每个数。若剩下的经过 $i$ 的区间都有 $x=i$ ，我们称 $i$ 为可行位置。我们每次将当前 $n$ 放在最靠左的一个可行位置上，然后删去所有经过 $i$ 的区间。一直的重复直到区间删完。但是，这样可能存在一些位置没有被选到。于是为了确定唯一的 $p$，我们加入新的 $n$ 个区间 $[i,i],i\in [1,n]$。</p>
<p>显然这样生成的排列 $p$ 与 $x$ 构成双射关系。并且 $x$ 当且仅当可以生成 $p$ 时合法。问题转化为对排列 $p$ 的计数。</p>
<p>观察限制条件：在删去经过该点的区间后，左右两侧的区间之间是相互独立的。对于右侧区间是没有影响的，但是对于左侧区间有影响。经过该点的区间中必然存在一个区间包含当前最大值与左边的最大值。证明很简单，如果没有这样的区间的话，我们直接选择左侧的区间即可，当前情况就不合法了。所以说我们需要限制左侧区间的 $x$ 大于 经过该点的区间的最左端点。</p>
<p>于是 DP 就很显然了。设计 $f(l,r,k)$ 表示 $[l,r]$ 的 $x\ge k$ 的方案数，容易得到转移方程：</p>
<script type="math/tex; mode=display">
f(l,r,k)=f(l,r,k+1)+f(l,k-1,pos_{l,r,k})\times f(k+1,r,k+1)</script><p>其中 $pos_{l,r,k}$ 为在 $[l,r]$ 之内的区间且包含 $k$ 的最左端点。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> pos[N][N][N],f[N][N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">                pos[i][j][k]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">read</span>(l,r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;=r;j++)pos[l][r][j]=<span class="built_in">min</span>(pos[l][r][j],l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j;k++)</span><br><span class="line">                pos[i][j][k]=<span class="built_in">min</span>(pos[i][j][k],<span class="built_in">min</span>(pos[i+<span class="number">1</span>][j][k],pos[i][j<span class="number">-1</span>][k]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            f[i][i<span class="number">-1</span>][j]=<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j;k&gt;=i;k--)</span><br><span class="line">                f[i][j][k]=<span class="built_in">adj</span>(f[i][j][k+<span class="number">1</span>]+<span class="number">1ll</span>*f[i][k<span class="number">-1</span>][pos[i][j][k]]*f[k+<span class="number">1</span>][j][k+<span class="number">1</span>]%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[<span class="number">1</span>][n][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[ARC093F] Dark Horse</title>
    <url>/2023/05/21/ARC093F-Dark-Horse/</url>
    <content><![CDATA[<p>容斥经典好题。</p>
<span id="more"></span>
<p>感觉思路反而很自然。将满二叉树画出来，是这样的：<img src="image1.png" alt=""></p>
<p>我们容易发现只需要保证，图上的 所有子树中编号最小值 都不为 $a_i$ 即可，因为只有子树中编号最小的人才会与 $1$ 交手。</p>
<p>考虑容斥，钦定子树集合 $S$ 的最小值都是 $a_i$，其余子树任意选。然后利用 $\displaystyle g(S)=\sum_{T\subseteq S} (-1)^{|T|+1} f(T)$ 进行容斥得到答案即可。</p>
<p>我们从大到小依次考虑 $a_i$，因为我们只关心子树中的最小值是否为 $a_i$，从大到小恰好可以满足当前枚举的 $a_i$ 是最小的。设计状态 $f_{i,S}$ 表示 选取到第 $i$，钦定集合为 $S$，转移很容易得到。DP时可以直接将容斥系数数算进去，再乘上组合数即可。时间复杂度 $\mathcal O(nm2^n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">17</span>,M=<span class="number">1</span>&lt;&lt;N,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"><span class="type">int</span> fac[M],ifac[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> j=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        j&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)ifac[i<span class="number">-1</span>]=<span class="number">1ll</span>*ifac[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    f[m][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-1</span>;~i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);s++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][s]=<span class="built_in">adj</span>(f[i][s]+f[i+<span class="number">1</span>][s]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                <span class="keyword">if</span>(!(s&gt;&gt;j&amp;<span class="number">1</span>))</span><br><span class="line">                    f[i][s|(<span class="number">1</span>&lt;&lt;j)]=<span class="built_in">adj</span>(f[i][s|(<span class="number">1</span>&lt;&lt;j)]+<span class="number">1ll</span>*<span class="built_in">C</span>((<span class="number">1</span>&lt;&lt;n)-a[i]-s,(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>)*(mod-f[i+<span class="number">1</span>][s])%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(s&gt;&gt;i&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*fac[<span class="number">1</span>&lt;&lt;i]%mod;</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*res*fac[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>-s]%mod*f[<span class="number">0</span>][s]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1ll</span>*ans*(<span class="number">1</span>&lt;&lt;n)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC044C] Strange Dance</title>
    <url>/2023/06/23/AGC044C-Strange-Dance/</url>
    <content><![CDATA[<p>Trie 树的 全局 +1 操作 trick。</p>
<span id="more"></span>
<p>比较经典的 trick。我们容易发现按照 Trie 常规建法从高位向低位建不好进行该操作。于是从低位向高位建 Trie。而我们现在只需要直接交换当前节点的儿子即可。如何考虑进位呢？进位只会发生在交换后的该位为 $0$ 的儿子上。于是我们直接不停地交换儿子，再沿着 $0$ 链走。<a href="https://www.luogu.com.cn/problem/P6623">P6623 [省选联考 2020 A 卷] 树</a> 就可以利用这个 trick 比较简单地解决。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,K=<span class="number">12</span>,C=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[M];</span><br><span class="line"><span class="type">int</span> pw[K],ans[N];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,ch[N][<span class="number">3</span>],tag[N],val[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> d,<span class="type">int</span> x,<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&gt;=n)<span class="keyword">return</span> val[x]=now,<span class="built_in">void</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;C;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ch[x][i]=++tot;</span><br><span class="line">        <span class="built_in">build</span>(d+<span class="number">1</span>,ch[x][i],now+i*pw[d]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tag[x])<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">swap</span>(ch[x][<span class="number">1</span>],ch[x][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;C;i++)tag[ch[x][i]]^=<span class="number">1</span>;</span><br><span class="line">    tag[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> d,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&gt;=n)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> tmp=ch[x][<span class="number">2</span>];</span><br><span class="line">    ch[x][<span class="number">2</span>]=ch[x][<span class="number">1</span>];</span><br><span class="line">    ch[x][<span class="number">1</span>]=ch[x][<span class="number">0</span>];</span><br><span class="line">    ch[x][<span class="number">0</span>]=tmp;</span><br><span class="line">    <span class="built_in">modify</span>(d+<span class="number">1</span>,ch[x][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> d,<span class="type">int</span> x,<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&gt;=n)<span class="keyword">return</span> ans[val[x]]=now,<span class="built_in">void</span>();</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;C;i++)<span class="built_in">get</span>(d+<span class="number">1</span>,ch[x][i],now+i*pw[d]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">    m=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pw[i]=pw[i<span class="number">-1</span>]*C;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;S&#x27;</span>)tag[<span class="number">1</span>]^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pw[n];i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>[ABC242Ex] Random Painting</title>
    <url>/2023/03/24/ABC242Ex-Random-Painting/</url>
    <content><![CDATA[<p>很好的 min-max 容斥。</p>
<span id="more"></span>
<p>之前 ZR 考了原题，不会。于是就去学了 min-max 容斥，现在重新来看这道题。</p>
<p>设每个位置被覆盖的时间为 $t_i$，我们要求的是：</p>
<script type="math/tex; mode=display">
E(\max_{i\in S} t_i)</script><p>直接 min-max 容斥，得到：</p>
<script type="math/tex; mode=display">
E(\max_{i\in S} t_i)=\sum_{T\subseteq S} (-1)^{|T|+1} E(\min_{i\in T} t_i)</script><p>考虑求如何求 $\displaystyle E(\min_{i\in S} t_i)$，设有 $f(S)$ 个区间能够覆盖 $S$ 中任意一个位置，容易得到 $\displaystyle E(\min_{i\in S}t_i)=\frac{m}{f(S)}$，于是考虑用 DP 求出 $\displaystyle \sum_{f(S)=i} (-1)^{|S|+1}$。</p>
<p>设计状态 $f_{i,j}$ 表示上一个加的位置为 $i$ ，有 $j$ 个区间覆盖 $S\subseteq{1,2,\dots,i}$。转移时枚举新加的位置 $p$，与 $[i,p)$ 有交的区间都可以覆盖当前点集 $S’$。因为集合 $S$ 中只多选了一个点，转移时直接将容斥系数乘 $-1$ 即可。时间复杂度 $\mathcal O(n^2m)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> cnt[N][N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">read</span>(l,r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;l;j++)</span><br><span class="line">            cnt[j][l]++,cnt[j][r+<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            cnt[i][j]+=cnt[i][j<span class="number">-1</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=mod<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[i][j])<span class="keyword">continue</span>;</span><br><span class="line">            res=<span class="built_in">adj</span>(res+<span class="number">1ll</span>*m*<span class="built_in">qpow</span>(j)%mod*f[i][j]%mod);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i+<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">                f[k][j+cnt[i][k]]=<span class="built_in">adj</span>(f[k][j+cnt[i][k]]-f[i][j]+mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>数据加强到 $n,m\le 3000$ 呢？原来我们统计的是能覆盖的区间。方便起见，我们考虑统计不覆盖点集中任意点的的区间 $\displaystyle \sum_{f(S)=i} (-1)^{|S|+1}$（此处的朴素转移方程也是类似的。利用原来的定义也可以，只是稍显麻烦）。</p>
<p>设多项式 $f_i(x)$，其中 $[x_j]f_i(x)$，表示只考虑 $[1,i]$，其中有 $j$ 个区间不覆盖点集中任意点的方案数。我们对于每个区间 $[l,r]$ 枚举其右端点，分别考虑。发现未加入该区间时有转移 $\displaystyle f_r(x)=(-1)\times\sum_{1\le i&lt;r} f_i(x)$，而加入一个新的区间，就会有 $1\le i\le l-1$，从 $[x_j]f_{i}$ 转移到 $[x_{j+1}]f’_i$ 上，即为 $\displaystyle f_i(x)=f’_i(x)\times x$。用线段树维护这个转移，具体可看看代码。时间复杂度 $\mathcal O(nm\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e3</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">poly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line">    poly <span class="keyword">operator</span>+(<span class="type">const</span> poly &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        poly res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">            res.a[i]=<span class="built_in">adj</span>(a[i]+t.a[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    poly sum;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].sum=tr[x&lt;&lt;<span class="number">1</span>].sum+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=k;i--)tr[x].sum.a[i]=tr[x].sum.a[i-k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)tr[x].sum.a[i]=<span class="number">0</span>;</span><br><span class="line">    tr[x].tag+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[x].tag)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag),<span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">add</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">add</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos,<span class="type">const</span> poly &amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l==tr[x].r)<span class="keyword">return</span>  tr[x].sum=k,<span class="built_in">void</span>();</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,pos,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">read</span>(l,r);</span><br><span class="line">        v[r].<span class="built_in">push_back</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,n);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">0</span>,(poly)&#123;mod<span class="number">-1</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        poly res=tr[<span class="number">1</span>].sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:v[i])<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">0</span>,j<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)res.a[j]=mod-res.a[j];</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,i,res);</span><br><span class="line">    &#125;</span><br><span class="line">    poly res=tr[<span class="number">1</span>].sum;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*res.a[i]*<span class="built_in">qpow</span>(m-i)%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1ll</span>*ans*m%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>容斥</tag>
        <tag>min-max 容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1093F Vasya and Array</title>
    <url>/2023/06/28/CF1093F-Vasya-and-Array/</url>
    <content><![CDATA[<p>比较简单的 DP 题目。</p>
<span id="more"></span>
<p>数的值域很小，考虑将其压入状态。设计 $f(i,j)$ 表示第 $i$ 为 $j$ 的合法方案数。$sum(i)=\sum_{j=0}^k f(i,j)$。需要预处理该点往前最长可能的连续段的长度 $pre_{i,j}$。若 $pre_{i,j}<len$，那么可以随便选，直接为 $sum(i-1)$。若 $pre_{i,j}\ge k$，那么考虑用 $sum(i-1)$ 减去不合法的方案，为 $sum(i-len)$，但是这样会减去长度 $>k$ 连续段的，但是这些连续段在之前就已经被减去了，所以需要加上 $f(i-len,j)$。时间复杂度 $\mathcal O(nk)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">100</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> pre[N][M];</span><br><span class="line"><span class="type">int</span> f[N][M],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x+=y;x=<span class="built_in">adj</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span>(~a[i])pre[i][a[i]]=pre[i<span class="number">-1</span>][a[i]]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">                pre[i][j]=pre[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=j&amp;&amp;a[i]!=<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            f[i][j]=sum[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(pre[i][j]&gt;=k)<span class="built_in">upd</span>(f[i][j],<span class="built_in">adj</span>(-sum[i-k]+f[i-k][j]+mod));</span><br><span class="line">            <span class="built_in">upd</span>(sum[i],f[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>BEAST</title>
    <url>/2023/05/17/BEAST/</url>
    <content><![CDATA[<p>Inspired by BEASTAR.</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1585F Non-equal Neighbours</title>
    <url>/2023/06/28/CF1585F-Non-equal-Neighbours/</url>
    <content><![CDATA[<p>比较自然的容斥 + DP。</p>
<span id="more"></span>
<p>$b_i\neq b_{i+1}$ 不好做。于是考虑容斥，求至少有 $k$ 对 $b_i=b_{i+1}$ 的方案数。最终答案为：</p>
<script type="math/tex; mode=display">
\sum_{k=0}^{n}(-1)^k f(k)</script><p>$a_i$ 值域很大，一位一位地做是没有前途的。注意到有 $k$ 对相等的数会形成 $n-k$ 个连续段。考虑对此计数，设 $f(i,j)$  表示当前位置为 $i$，形成至多 $k$ 个连续段的方案数，得到朴素的状态转移方程。</p>
<script type="math/tex; mode=display">
f(i,j)=\sum_{k=1}^{i}\min_{k\le t\le i}a_t\times  f(k-1,j-1)</script><p>由于容斥系数，所以说只需要记录 $j$ 的奇偶即可，转移不变，时间复杂度为 $\mathcal O(n^2)$。</p>
<p>尝试优化转移 。考虑新加入的 $a_i$ 有何贡献。设上一个比它小的数为 $a_p$。容易发现对于 $p&lt; k\le i$ 的贡献为 $a_i$。对于 $1\le k\le p$，位置 $i$ 与位置 $p$ 贡献相同，继承即可。</p>
<script type="math/tex; mode=display">
f(i,j)=f(p,j)+a_i\times \sum_{k=p}^{i-1} f(k,j-1)</script><p>$p$ 由单调栈求出。前缀和辅助转移即可。时间复杂度 $\mathcal O(n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> top,sta[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;a[sta[top]]&gt;=a[i])top--;</span><br><span class="line">        <span class="type">int</span> j=sta[top];</span><br><span class="line">        <span class="keyword">if</span>(!j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][<span class="number">0</span>]=<span class="number">1ll</span>*a[i]*(f[i<span class="number">-1</span>][<span class="number">1</span>])%mod;</span><br><span class="line">            f[i][<span class="number">1</span>]=<span class="number">1ll</span>*a[i]*(f[i<span class="number">-1</span>][<span class="number">0</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[i][<span class="number">0</span>]=<span class="built_in">adj</span>(<span class="built_in">adj</span>(f[j][<span class="number">0</span>]-f[j<span class="number">-1</span>][<span class="number">0</span>]+mod)+<span class="number">1ll</span>*a[i]*<span class="built_in">adj</span>(f[i<span class="number">-1</span>][<span class="number">1</span>]-f[j<span class="number">-1</span>][<span class="number">1</span>]+mod)%mod);</span><br><span class="line">            f[i][<span class="number">1</span>]=<span class="built_in">adj</span>(<span class="built_in">adj</span>(f[j][<span class="number">1</span>]-f[j<span class="number">-1</span>][<span class="number">1</span>]+mod)+<span class="number">1ll</span>*a[i]*<span class="built_in">adj</span>(f[i<span class="number">-1</span>][<span class="number">0</span>]-f[j<span class="number">-1</span>][<span class="number">0</span>]+mod)%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        f[i][<span class="number">0</span>]=<span class="built_in">adj</span>(f[i][<span class="number">0</span>]+f[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">        f[i][<span class="number">1</span>]=<span class="built_in">adj</span>(f[i][<span class="number">1</span>]+f[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        sta[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans0=<span class="built_in">adj</span>(f[n][<span class="number">0</span>]-f[n<span class="number">-1</span>][<span class="number">0</span>]+mod),ans1=<span class="built_in">adj</span>(f[n][<span class="number">1</span>]-f[n<span class="number">-1</span>][<span class="number">1</span>]+mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(n&amp;<span class="number">1</span>)?<span class="built_in">adj</span>(ans1-ans0+mod):<span class="built_in">adj</span>(ans0-ans1+mod));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1606F Tree Queries</title>
    <url>/2023/05/06/CF1606F-Tree-Queries/</url>
    <content><![CDATA[<p>记一个看似暴力但是比较巧妙的解法。</p>
<span id="more"></span>
<p>设 $f_{x,k}$ 表示当删点代价为 $k$，以 $x$ 为根的子树能得到的答案。容易列出状态转移方程 $f_{x,k}\gets \max(1,f_{y,k}-k)$。直接做是 $\mathcal O(n^2)$ 的。显然 $f_{y,k}&gt;k$ 的时候节点 $y$ 才可能被选择。所以当 $k$ 越大时，有用的状态更少。</p>
<p>固定 $k$ 来研究有用的状态数。我们根据状态的转移将原树划分成若干棵森林。这些森林除了叶子之外，其它都是有用的状态。考虑森林中任意一个大小为 $m$ 的树。仔细观察每从叶子往上走，每有一个有用状态答案都会减少 $k$。那么有用的状态数最多为 $\lfloor \frac{m}{k} \rfloor$，对于原树而言有用的状态数就最多为 $\lfloor \frac{n}{k} \rfloor$。那么对于所有的 $k$，有用的状态数的总和为 $\displaystyle \sum_{k=1}^n \lfloor n/k \rfloor$，这就是个调和级数。于是总的状态数为 $\mathcal O(n\ln n)$。</p>
<p>于是我们直接暴力 DP 就好了，过程中只保留有用的状态即可。时间复杂度与空间复杂度均为 $\mathcal O(n\ln n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt[N],si[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        si[x]++;</span><br><span class="line">        cnt[x]=<span class="built_in">max</span>(cnt[x],cnt[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[x]=<span class="built_in">max</span>(cnt[x],si[x]<span class="number">-1</span>);</span><br><span class="line">    f[x].<span class="built_in">resize</span>(cnt[x]+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=cnt[x];i++)f[x][i]=si[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=cnt[y];j++)</span><br><span class="line">            f[x][j]+=<span class="built_in">max</span>(<span class="number">0</span>,f[y][j]-j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;cnt[x]&amp;&amp;f[x][i]&gt;=i+<span class="number">1</span>)i++;</span><br><span class="line">    cnt[x]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,k;</span><br><span class="line">        <span class="built_in">read</span>(x,k);</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=f[x].<span class="built_in">size</span>()<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[x][k]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,si[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1540B Tree Array</title>
    <url>/2023/06/27/CF1540B-Tree-Array/</url>
    <content><![CDATA[<p>有点意思的树上期望问题。</p>
<span id="more"></span>
<p>直接做的话发现给当前已经选了的连通块定位是比较困难的，但是我们的答案和这个息息相关。于是我们尝试直接钦定一个点为选择的第一个点，并且以这个点为根进行计算，最终将答案之和除以 $n$ 即可。</p>
<p>我们枚举两个点，逆序对与它们加入连通块的顺序有关。连通块必然是从 $\text{LCA}(x,y)$ 处向 $x,y$ 延申。不妨设 $x&lt;y$，那么答案就是 $\text{LCA}(x,y)$ 先到达 $y$ 的期望。这个只与 $x,y$ 分别到 $\text{LCA}(x,y)$ 的距离有关，可以 $\mathcal O(n^2)$ 预处理。总的时间复杂度为 $\mathcal O(n^3\log n)$。也可以预处理 $\text{LCA}(x,y)$，或者用 $\mathcal O(n\log n)-\mathcal O(1)$ 的求 $\text{LCA}(x,y)$ 的方法去掉 $\log$。下面是前一种实现。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e3</span>+<span class="number">10</span>,K=<span class="number">8</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>,inv=(mod+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[N],fa[N][K+<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[x]=d[fa[x][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">        fa[y][<span class="number">0</span>]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=K;j++)fa[y][j]=fa[fa[y][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)</span><br><span class="line">        <span class="keyword">if</span>(d[fa[x][i]]&gt;=d[y])</span><br><span class="line">            x=fa[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])</span><br><span class="line">            x=fa[x][i],y=fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(fa[x],<span class="number">0</span>,<span class="built_in">sizeof</span>(fa[x]));</span><br><span class="line">    <span class="built_in">dfs</span>(x);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> lca=<span class="built_in">LCA</span>(i,j);</span><br><span class="line">            ans=<span class="built_in">adj</span>(ans+f[d[i]-d[lca]][d[j]-d[lca]]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)<span class="built_in">read</span>(u,v),<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            f[i][j]=<span class="number">1ll</span>*<span class="built_in">adj</span>(f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>])*inv%mod;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ans=<span class="built_in">adj</span>(ans+<span class="built_in">calc</span>(i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1ll</span>*ans*<span class="built_in">qpow</span>(n)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1616G Just Add an Edge</title>
    <url>/2023/01/26/CF1616G-Just-Add-an-Edge/</url>
    <content><![CDATA[<p>妙妙图论题。</p>
<span id="more"></span>
<p>*3500 的牛逼题。</p>
<p>如果原图已有哈密顿回路，那么一定是 $1\to 2\to \dots \to n$，这种情况下的答案为 $\binom{n}{2}$。</p>
<p>考虑更一般的情况，发现添加返祖边 $(v,u)$ 的哈密顿回路一定形如：</p>
<script type="math/tex; mode=display">
1\overset{+1}{\longrightarrow}u-1\to \dots \to v\to u\to \dots \to v+1\overset{+1}{\longrightarrow}n</script><p>这是因为在经过之后 $u-1$ 之后是不能回到 $&lt;u$ 的点的。问题转化为，找到不交的 $1\to v$ 与 $u\to n$ ，并且两条路径覆盖 ${1,\dots, n}$。 </p>
<p>我们新建 $0,n+1$ 两个点，并分别 $0$ 向所有点连边，所有点向 $n+1$ 连边，这样回路的起点与终点就固定了， 方便计算。</p>
<p>考虑暴力做法，考虑枚举 $u$ 然后进行 DP，设 $f_{x,0/1}$ 表示当前点分别在两条链上是否有合法方案。只考虑，前一个点与当前点所在的不同即可。得到 $\mathcal O(n^2)$ 做法。</p>
<details class="failure"><summary><i class="fa fa-times fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.5e5</span>+<span class="number">10</span>,M=<span class="number">1.5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">int</span> pre[N],suf[N];</span><br><span class="line"><span class="type">bool</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> flag[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;rev[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rev[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)rev[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="built_in">add</span>(<span class="number">0</span>,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="built_in">add</span>(i,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="keyword">if</span>(u+<span class="number">1</span>==v)flag[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    flag[<span class="number">1</span>]=flag[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">0</span>,suf[n+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)pre[i]=flag[i]?pre[i<span class="number">-1</span>]:i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;~i;i--)suf[i]=flag[i+<span class="number">1</span>]?suf[i+<span class="number">1</span>]:i;</span><br><span class="line">    <span class="keyword">if</span>(!pre[n+<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*n*(n<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=suf[<span class="number">0</span>]+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:rev[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">                    f[j][t]|=((suf[v+<span class="number">1</span>]&gt;=j<span class="number">-1</span>)&amp;f[v+<span class="number">1</span>][t^<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=pre[n+<span class="number">1</span>];j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            ans+=f[j][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(suf[<span class="number">0</span>]+<span class="number">1</span>==pre[n+<span class="number">1</span>])ans--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

</details>
<p>注意到关键性质，如果原图没有哈密顿回路的话，一定存在一个最小的 $p$，满足 $p$ 未向 $p+1$ 连边，于是 $p+1$ 将哈密顿回路分割成两部分 $[0,p+1],[p+2,n+1]$。转移的过程中不会跨过 $p+1$，所以这两个部分是相互独立的。于是我们可以分开计算，再将两段合并即可。但是注意到可能会出现 $f_{u,0}=f_{u,1}=f_{v,0}=f_{v,1}=1$ ，按照上述计算方式会被算两次，但实际上只存在一种连边方式，对于这一部分注意减掉就好了。</p>
<p>似乎比较好写但是还是要注意很多细节。具体也可以看看代码：</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.5e5</span>+<span class="number">10</span>,M=<span class="number">1.5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> p,q;</span><br><span class="line"><span class="type">int</span> pre[N],suf[N];</span><br><span class="line"><span class="type">bool</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> flag[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;rev[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rev[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)rev[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="built_in">add</span>(<span class="number">0</span>,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="built_in">add</span>(i,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);    </span><br><span class="line">        <span class="keyword">if</span>(u+<span class="number">1</span>==v)flag[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    flag[<span class="number">1</span>]=flag[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">0</span>,suf[n+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)pre[i]=flag[i]?pre[i<span class="number">-1</span>]:i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;~i;i--)suf[i]=flag[i+<span class="number">1</span>]?suf[i+<span class="number">1</span>]:i;</span><br><span class="line">    <span class="keyword">if</span>(!pre[n+<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*n*(n<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    p=suf[<span class="number">0</span>],q=pre[n+<span class="number">1</span>];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    f[p+<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:rev[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)c4</span><br><span class="line">                f[i][t]|=((suf[v+<span class="number">1</span>]&gt;=i<span class="number">-1</span>)&amp;f[v+<span class="number">1</span>][t^<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>;~i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:rev[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">                f[v+<span class="number">1</span>][t]|=((suf[v+<span class="number">1</span>]&gt;=i<span class="number">-1</span>)&amp;f[i][t^<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> lcnt,rcnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        lcnt=<span class="number">0</span>,rcnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=p+<span class="number">1</span>;i++)lcnt+=f[i][t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=q;i&lt;=n+<span class="number">1</span>;i++)rcnt+=f[i][t];</span><br><span class="line">        ans+=<span class="number">1ll</span>*lcnt*rcnt;</span><br><span class="line">    &#125;</span><br><span class="line">    lcnt=<span class="number">0</span>,rcnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=p;i++)lcnt+=f[i][<span class="number">0</span>]&amp;f[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q;i&lt;=n+<span class="number">1</span>;i++)rcnt+=f[i][<span class="number">0</span>]&amp;f[i][<span class="number">1</span>];</span><br><span class="line">    ans-=<span class="number">1ll</span>*lcnt*rcnt;</span><br><span class="line">    <span class="keyword">if</span>(p+<span class="number">1</span>==q)ans--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1616H Keep XOR Low</title>
    <url>/2023/03/16/CF1616H-Keep-XOR-Low/</url>
    <content><![CDATA[<p>Trie 树上进行 01 分治。</p>
<span id="more"></span>
<p>感觉之前也考类似的题，于是记一下。</p>
<p>显然按照每一位进行考虑，将 Trie 树建出来。我们设置函数 $f(x,y,i)$ 表示前 $i-1$ 位的限制全部卡满，在 $x$ 节点与 $y$ 节点上分别选取两个子集，两个子集之间的元素满足 $x_i\oplus y_i\le k$，考虑当前位：</p>
<ol>
<li>第 $i$ 位为 $0$，那么 $x,y$ 必须选取同一侧的子树，即 $f(x_0,y_0,i-1),f(x_1,y_1,i-1)$。再加上 $x,y$ 分别在各自子树之中可以任意选的方案（因为前面的位数都会变成 $0$，对第 $i$ 位就没有限制了）。</li>
<li>第 $i$ 位为 $1$，那么 $x,y$ 选同侧的话，就不需要满足被卡满的限制，不符合我们的定义，我们是一定要卡满的，所以不需要递归下去计算，因为这种情况的贡献会在当前节点产生。而我们需要走 $x,y$ 的异侧。并且容易发现 $f(x_0,y_1),f(x_1,y_0)$ 之间是相互独立的，意思是 $x_0,x_1$ 之间与 $y_0,y_1$ 之间是没有限制的（两个都选相当于走同侧），两种情况的贡献就算在一起了，所以直接就是 $f(x_0,y_1)\times f(x_1,y_0)$。</li>
</ol>
<p>每个节点只会被计算一次，时间复杂度 $\mathcal O(n\log V)$，其中 $V$ 为值域。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.5e5</span>+<span class="number">10</span>,K=<span class="number">30</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,ch[N&lt;&lt;<span class="number">5</span>][<span class="number">2</span>],si[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">1</span>;si[u]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> v=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][v])ch[u][v]=++tot;</span><br><span class="line">        si[u=ch[u][v]]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x=<span class="number">1</span>,<span class="type">int</span> y=<span class="number">1</span>,<span class="type">int</span> i=<span class="number">30</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y)<span class="keyword">return</span> p[si[x]+si[y]];</span><br><span class="line">    <span class="keyword">if</span>(!(x^y))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!~i)<span class="keyword">return</span> p[si[x]];</span><br><span class="line">        <span class="keyword">if</span>(k&gt;&gt;i&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">solve</span>(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>],i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">adj</span>(<span class="built_in">solve</span>(ch[x][<span class="number">0</span>],ch[x][<span class="number">0</span>],i<span class="number">-1</span>)+<span class="built_in">solve</span>(ch[x][<span class="number">1</span>],ch[x][<span class="number">1</span>],i<span class="number">-1</span>)<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!~i)<span class="keyword">return</span> p[si[x]+si[y]];</span><br><span class="line">    <span class="keyword">if</span>(k&gt;&gt;i&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1ll</span>*<span class="built_in">solve</span>(ch[x][<span class="number">0</span>],ch[y][<span class="number">1</span>],i<span class="number">-1</span>)*<span class="built_in">solve</span>(ch[x][<span class="number">1</span>],ch[y][<span class="number">0</span>],i<span class="number">-1</span>)%mod;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">adj</span>(<span class="built_in">adj</span>(<span class="built_in">solve</span>(ch[x][<span class="number">0</span>],ch[y][<span class="number">0</span>],i<span class="number">-1</span>)+<span class="built_in">solve</span>(ch[x][<span class="number">1</span>],ch[y][<span class="number">1</span>],i<span class="number">-1</span>)<span class="number">-1</span>)+</span><br><span class="line">    <span class="built_in">adj</span>(<span class="number">1ll</span>*(p[si[ch[x][<span class="number">0</span>]]]<span class="number">-1</span>)*(p[si[ch[x][<span class="number">1</span>]]]<span class="number">-1</span>)%mod+<span class="number">1ll</span>*(p[si[ch[y][<span class="number">0</span>]]]<span class="number">-1</span>)*(p[si[ch[y][<span class="number">1</span>]]]<span class="number">-1</span>)%mod));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)p[i]=<span class="built_in">adj</span>(p[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>CF348D Turtles</title>
    <url>/2023/04/17/CF348D-Turtles/</url>
    <content><![CDATA[<p>经典题。</p>
<span id="more"></span>
<p>容易发现两条不相交的路径一定是 $(1,2)\to (n-1,m)$ 和 $(2,1)\to (n,m-1)$。但是这只具有充分性，似乎并没有什么帮助。</p>
<p>这个时候巧妙的来了，我们发现 $(1,2)\to (n,m-1)$ 与 $(2,1)\to (n-1,m)$ 是一定有交的。并且每一种方案恰好对应着原来 $(1,2)\to (n-1,m)$ 和 $(2,1)\to (n,m-1)$ 有交的一种方案（在每个交点改变两条路径连向就可以得到原来有交的一种方案）。于是直接减去这一部分就得到了没有交的路径方案数。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[x1][y1]=a[x1][y1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x1;i&lt;=x2;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=y1;j&lt;=y2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((i==x1&amp;&amp;j==y1)||!a[i][j])<span class="keyword">continue</span>;</span><br><span class="line">            f[i][j]=<span class="built_in">adj</span>(f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x2][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch[N];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)a[i][j]=(ch[j]==<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">adj</span>(<span class="number">1ll</span>*<span class="built_in">calc</span>(<span class="number">1</span>,<span class="number">2</span>,n<span class="number">-1</span>,m)*<span class="built_in">calc</span>(<span class="number">2</span>,<span class="number">1</span>,n,m<span class="number">-1</span>)%mod<span class="number">-1ll</span>*<span class="built_in">calc</span>(<span class="number">1</span>,<span class="number">2</span>,n,m<span class="number">-1</span>)*<span class="built_in">calc</span>(<span class="number">2</span>,<span class="number">1</span>,n<span class="number">-1</span>,m)%mod+mod));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>CF708C Centroids</title>
    <url>/2022/10/17/CF708C-Centroids/</url>
    <content><![CDATA[<p>有一点思维的换根DP。</p>
<span id="more"></span>
<p>如果一个点不是重心，我们则考虑将它其中某一个子树断开在接到这个节点上。于是我们需要在以该节点为根的树中，找一个 $size\le {n\over2}$ 的最大子树。</p>
<p>接下来很容易想到换根 DP。注意到换根时 $f_x$ 的决策点可能就是 $y$。还应该维护预处理次大值。</p>
<p>随便放个代码。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tot,head[maxn],ver[<span class="number">2</span>*maxn],ne[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="type">int</span> si[maxn],d[maxn][<span class="number">2</span>],f[maxn],pre[maxn],maxsize[maxn];</span><br><span class="line"><span class="type">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(to,x);</span><br><span class="line">        si[x]+=si[to];</span><br><span class="line">        <span class="keyword">if</span>(si[to]&gt;si[maxsize[x]])maxsize[x]=to;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">if</span>(si[to]&lt;=n/<span class="number">2</span>)v=si[to];</span><br><span class="line">        <span class="keyword">else</span> v=d[to][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(d[x][<span class="number">0</span>]&lt;v)</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">1</span>]=d[x][<span class="number">0</span>];</span><br><span class="line">            d[x][<span class="number">0</span>]=v;</span><br><span class="line">            pre[x]=to;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[x][<span class="number">1</span>]&lt;v)d[x][<span class="number">1</span>]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(si[maxsize[x]]&gt;n/<span class="number">2</span>) ans[x]=(si[maxsize[x]]-d[maxsize[x]][<span class="number">0</span>]&lt;=n/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n-si[x]&gt;n/<span class="number">2</span>) ans[x]=(n-si[x]-f[x]&lt;=n/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=ver[i];</span><br><span class="line">		<span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">		<span class="keyword">if</span>(n-si[x]&gt;n/<span class="number">2</span>)v=f[x];</span><br><span class="line">		<span class="keyword">else</span> v=n-si[x];</span><br><span class="line">		f[to]=<span class="built_in">max</span>(f[to],v);</span><br><span class="line">		<span class="keyword">if</span>(pre[x]==to)f[to]=<span class="built_in">max</span>(f[to],d[x][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">else</span> f[to]=<span class="built_in">max</span>(f[to],d[x][<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">dfs</span>(to,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>换根DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF671D Roads in Yusland</title>
    <url>/2023/01/04/CF671D-Roads-in-Yusland/</url>
    <content><![CDATA[<p>线段树合并优化 DP。</p>
<span id="more"></span>
<p>考虑与 NOI2020 D1T2 命运 类似的方法，设计状态 $f_{x,i}$ 为以 $x$ 为根的子树中的边全部被覆盖，并且被覆盖的路径向上延伸至深度为 $i$ 的节点，所需要的最小花费。状态转移方程：$f_{x,i}=f_{x,i}+ \min_{j\ge i} {f_{y,j},f_{y,i}}+\min_{j\ge i}{f_{x,j}}$。这个方程中两边状态都与下标 $i$ 相同 ，并且信息也是线段树好维护的，于是可以用线段树合并来优化。</p>
<p>注意一些细节。（<del>笔者因为不咋写动态开点误将</del> <code>ql,qr</code>  <del>写成</del> <code>l,r</code> <del>调了将近一天，敲个警钟</del>）。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ll INF=<span class="number">1e16</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    ll val,tag;</span><br><span class="line">&#125;tr[N*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt,rt[N],d[N];</span><br><span class="line"><span class="type">int</span> top,sta[N*<span class="number">20</span>];</span><br><span class="line">vector&lt;Edge&gt;vec[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sta[++top]=x;</span><br><span class="line">    tr[x].lc=tr[x].rc=<span class="number">0</span>;</span><br><span class="line">    tr[x].val=INF,tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top)<span class="keyword">return</span> sta[top--];</span><br><span class="line">    tr[++cnt].val=INF;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val=<span class="built_in">min</span>(tr[tr[x].lc].val,tr[tr[x].rc].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val+=k,tr[x].tag+=k;</span><br><span class="line">    tr[x].val=<span class="built_in">min</span>(tr[x].val,INF);</span><br><span class="line">    tr[x].tag=<span class="built_in">min</span>(tr[x].tag,INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[x].tag)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">update</span>(tr[x].lc,tr[x].tag);</span><br><span class="line">    <span class="built_in">update</span>(tr[x].rc,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)x=<span class="built_in">newnode</span>();</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].val=<span class="built_in">min</span>(tr[x].val,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(tr[x].lc,l,mid,pos,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||(l&gt;=ql&amp;&amp;r&lt;=qr))<span class="keyword">return</span> tr[x].val;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll res=INF;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(tr[x].lc,l,mid,ql,qr));</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(tr[x].rc,mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r,ll resx,ll resy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x&amp;&amp;!y)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!x)<span class="keyword">return</span> <span class="built_in">update</span>(y,resx),y;</span><br><span class="line">    <span class="keyword">if</span>(!y)<span class="keyword">return</span> <span class="built_in">update</span>(x,resy),x;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].val=<span class="built_in">min</span>(&#123;tr[x].val+resy,tr[y].val+resx,INF&#125;);</span><br><span class="line">        <span class="built_in">del</span>(y);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x),<span class="built_in">pushdown</span>(y);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[x].lc=<span class="built_in">merge</span>(tr[x].lc,tr[y].lc,l,mid,resx,resy);</span><br><span class="line">    tr[x].rc=<span class="built_in">merge</span>(tr[x].rc,tr[y].rc,mid+<span class="number">1</span>,r,resx,resy);</span><br><span class="line">    <span class="built_in">del</span>(y);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        flag=<span class="number">1</span>,d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(!rt[x])</span><br><span class="line">        &#123;</span><br><span class="line">            rt[x]=rt[y];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll resx=<span class="built_in">query</span>(rt[x],<span class="number">1</span>,n,<span class="number">1</span>,d[x]),resy=<span class="built_in">query</span>(rt[y],<span class="number">1</span>,n,<span class="number">1</span>,d[x]);</span><br><span class="line">        rt[x]=<span class="built_in">merge</span>(rt[x],rt[y],<span class="number">1</span>,n,resx,resy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)<span class="built_in">modify</span>(rt[x],<span class="number">1</span>,n,d[x],<span class="number">0</span>);</span><br><span class="line">    ll res=<span class="built_in">query</span>(rt[x],<span class="number">1</span>,n,<span class="number">1</span>,d[x]);</span><br><span class="line">    <span class="keyword">if</span>(res&gt;=INF)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:vec[x])</span><br><span class="line">        <span class="built_in">modify</span>(rt[x],<span class="number">1</span>,n,d[y.v],res+y.w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">read</span>(x,y,z);</span><br><span class="line">        vec[x].<span class="built_in">push_back</span>(&#123;y,z&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>,tr[<span class="number">0</span>].val=INF;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ll ans=<span class="built_in">query</span>(rt[<span class="number">1</span>],<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans&gt;=INF)?<span class="number">-1</span>:ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>整体DP</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2022 全题解</title>
    <url>/2023/03/10/CSP-S-2022-%E5%85%A8%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>隔了好久好久。。。</p>
<span id="more"></span>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>题意：给定 $n$ 个点 $m$ 条边的无向图，每个点上有权值 $v_i$，现在从点 $1$ 走到另外 $4$ 个点再返回点 $1$，要求另外点与点之间的路程需小于等于 $k+1$，求另外四个点的权值和最大值。$n\le 2500,m\le 10000$。</p>
<p>乱搞，考虑处理出每个点在 $k+1$ 步内能到达的所有点，以及这些点中的最大值，亚大值，次大值。然后枚举中间两个点即可。时间复杂度 $\mathcal O(nm+n^2)$。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>题意：给定两个长度分别为 $n,m$ 数组 $A,B$，有 $q$ 次询问 $l_1,r_1,l_2,r_2$，表示在小 L 先在数组 $A$ 的 $[l_1,r_1]$ 中选一个数 $a_x$，小 Q 再在数组 $B$ 的 $[l_2,r_2]$ 中选一个数 $b_y$，每一轮的得分为 $a_x\times b_y$ 。小 L 想使得分最大，小 Q 想使其最小。两人都是足够聪明的玩家，每次都会采用最优的策略。求得分是多少。$n,m,q\le 10^5$。</p>
<p>注意到是小 L 先选，小 Q 后选，很容易根据正负关系分类讨论，接着用 ST 表或者线段树维护即可，此处不再赘述。时间复杂度 $\mathcal O(n\log n+q\log n)$，此处视 $n,m$ 同阶。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>题意：给定 $n$ 个点 $m$ 条边的有向图，有 $q$ 次操作，操作有 $4$ 种类型：1.禁用边  $(u,v)$；2.禁用 $u$ 所有的入边；3.激活边  $(u,v)$；4.激活 $u$ 所有的入边。要求判断每次操作后的图是否为一棵基环树。</p>
<p>判断基环树即为判断每个点是否有且仅有一条出边。显然合法的入边总数应当为 $n$，即满足 $\displaystyle \sum_{i=1}^n in_i=n$。但是这样显然很大可能有多组解。于是尝试 Hash 一下。</p>
<p>尝试赋给每个点一个随机权值 $v_i$，并且使 $\displaystyle in_i=\sum_{(j,i)\in E} v_j$，现在我们只需要判断其是否满足 $\displaystyle \sum_{i=1}^{n} in_i=\sum_{i=1}^n k_i v_i=\sum_{i=1}^{n} v_i$。因为这个方程极大可能只有一组解 $k_1=1,k_2=1\dots k_n=1$。并且对于修改操作，我们只需要简单维护 $in_i$ 即可。时间复杂度 $\mathcal O(n+q)$。</p>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>题意：给定一棵 $n$ 个节点的树，每个点上有权值 $v_i$。给定常数 $k$，有 $q$ 次询问 $u,v$，对于一条路径 $p_1\to \dots \to p_w,p_1=u,p_w=v$，需要满足 $\forall dis(p_i,p_{i+1})\le k$，路径的权值为 $\displaystyle \sum_{i=1}^w v_i$，询问最小的权值为多少。$n,q\le 2\times 10^5,k\le 3$。</p>
<p>先考虑 $k=1,2$ 的情况。$k=1$ 时，直接输出 $u\to v$ 上所有点的权值和即可，倍增处理。$k=2$ 时，我们发现路径 $p_1\to \dots \to p_w$ 依然是在 $u\to v $ 上的，但并不是所有点都要取。设计 $(x,t)$ 表示到 $x$ 已经走了多少步没有选点。还是考虑倍增处理，设计倍增数组 $f_{x,k,p,q}$ 表示从 $(x,p)$ 到 $(fa_{x,k},q)$ 最小权值和，这是容易预处理以及计算的。</p>
<p>有了 $k=1,2$ 的启发，我们还是尝试倍增。我们发现完全可以沿用 $k=2$ 中倍增数组 $f_{x,k,p,q}$ 的设计。但是需要考虑的是，现在是可以走到 $u\to v$ 之外的点的。但是简单观察发现，是只可能绕过 $u\to v$ 上某个点，转而去到与之相邻的 $v_i$ 最小的点上，再回到 $u\to v$ 上。那么现在 $f_{x,k,p,q}$ 也是容易预处理的了。</p>
<p>但需要注意的是计算时，将 $u\to \text{LCA}$ 与 $\text{LCA}\to v$ 拼在一起时的两种特殊情况：1.若 $p=0,q=0$，则 $v_{\text{LCA}}$ 会被计算两次，需要减去。2.若 $p=2,q=2$，则 $v_{\text{LCA}}$ 被少算，需要加上。</p>
<p>时间复杂度 $\mathcal O(n\log n+q\log n)$。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 游记</title>
    <url>/2022/10/27/CSP-S-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>爆炸。</p>
<span id="more"></span>
<h4 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h4><p>连续两天 ZR 模拟赛爆炸，心态也有些爆炸。总感觉自己很不自信，总觉得自己写不出来（多半是后遗症 ），一些实际上不难的题都没有做出来，于是被吊打，极其难受。</p>
<p>到考场上我又应该怎么办呢？T1 不会我应该采取怎么样的策略？或许我的担心也是不必要的，我可能也改变不了最后的结局。</p>
<h4 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h4><p>上午神仙讲课，半懂不通的，又被吊打。</p>
<p>下午去试了下机子，帮老师调试虚拟机。然后用搞来的出门条出去吃了顿华莱士，回机房继续学习了一会。还是很紧张。晚上早早睡了。</p>
<h4 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h4><p>上午复习了会板子，又颓废了一会。心态稍微稳定一点。似乎这次考试也其实并不那么重要了，还不如当成刷经验值来。</p>
<p>到了考场，发现身份证忘带了，幸好还是准时进去了。很紧张，不敢动鼠标键盘。</p>
<p>题发下来，看了 T1，感觉瞬间寄了，想了几个比较正经的写法都寄了，怎么办？也想过要不要开始乱搞（还并没有意识到这题就是乱搞），于是直接就去看 T2，此时大约 15:00。</p>
<p>然后就发现 T2 很简单，是个分讨加上数据结构，于是直接开始大力写，写了四棵线段树，然后调了十多分钟，感觉过了大样例就差不多了。</p>
<p>看到 T3 题面又臭又长，只有写 $\mathcal O(nq)$ 暴力。T4 看起来暴力都不想写，此时已经过去两个多小时。</p>
<p>写完 T3 暴力接着想 T1，脑子里依然是用什么什么算法来做，结果仍然没有头绪。也只好在原来 $\mathcal O(n^3)$ 的基础上再写个 $k=1$ 的 sub。</p>
<p>中间甚至还有一段乌龙，我以为 18:00 就考完了，于是从 17:30 就开始检查，<del>然后发现 T2 大样例其实没过</del>，又赶快改了十多分钟。监考老师提醒时间的时候才意识到还有半个小时。早知道把 T4 暴力写完的！！！</p>
<p>随着广播里的提示考试结束，我也只好接受自己爆炸的现实。出来一看就我 T1 没切，还说什么呢，只能是技不如人了。。。</p>
<p>晚上选手数据发了下来，然后去测了下，大概还是 190 pts 左右，还是爆炸。</p>
<p>然后迷迷糊糊就睡了。</p>
<p>赛后感觉 T3 T4 巨多部分分且好写，并且 T3 正解很短，T4 正解也比较好想，但是还是寄的离谱。。。</p>
<h4 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h4><p>成绩出来了，60 + 100 + 40 = 200 pts。已经无所谓了，只是希望能够更认真地准备 NOIP 吧。</p>
<p>就这样。</p>
<h4 id="Day-20"><a href="#Day-20" class="headerlink" title="Day 20"></a>Day 20</h4><p>分数线 195 pts，混了个没 B 用的 1=。</p>
<p>真的就这样了么。。。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>DP 专项训练</title>
    <url>/2022/08/26/DP-%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p>可以说是 DP 乱做。</p>
<span id="more"></span>
<p>先做几道真题。</p>
<h4 id="1-P7077-CSP-S2020-函数调用"><a href="#1-P7077-CSP-S2020-函数调用" class="headerlink" title="1.P7077 [CSP-S2020] 函数调用"></a>1.<a href="https://www.luogu.com.cn/problem/P7077">P7077 [CSP-S2020] 函数调用</a></h4><p>很明显各个函数的调用关系是一张 DAG。假如只有函数 2，我们就只需要 dfs 一遍就可以求出所有函数的 $mul_i$。我们并不好处理先进行函数 1 再进行函数 2 的情况。于是我们考虑再求出一个 $add_i$ 表示调用完所有函数后第 $i$ 个数的增量。</p>
<p>容易想到在拓扑序 DP 来求这个东西。其实想要求 $add$ 数组很简单，乘 $k$ 也看作将该函数被执行 $k$ 次，我们只需要求出每个函数被执行了多少次，这个我们用 $f_i$ 表示函数 $i$ 被执行了多少次。</p>
<p>因为我们是按照拓扑序来考虑每个函数，而非函数本来的执行顺序。所以我们需要先考虑 $f$ 的初值。$res$ 是一个动态维护的值，表示在第 $i$ 个执行的函数被执行了 $res$ 次（注意上文所说的“被执行”）。对于三种类型的函数分开讨论：1.直接加上 $res$；2.用 $res$ 乘上 $mul_{fuc_i}$（不用加上 $res$，因为我们们根本不关心函数 2 的 $f$ 值）；3.先加上 $res$ ，再用 $res$ 乘上 $mul_{fuc_i}$。</p>
<p>接着我们考虑 DP，设当前节点为 $x$。还是对于三种类型的函数分开讨论：1.直接计算 $add_{pos_x}$；2.根本不用管；3.我们尝试倒序遍历其所有出点，就像上面求初值一样来处理所有出点的 $f$ 值，只不过不需要讨论类型，还有最开始的 $res$ 的值应该为 $f_x$ 。</p>
<p>似乎就这样做完了。。。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>)<span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;<span class="built_in">putchar</span>(c);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>&#123;<span class="keyword">while</span>(*s)<span class="built_in">putchar</span>(*s++);&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x,T1 ...x1)</span></span>&#123;<span class="built_in">write</span>(x),<span class="built_in">write</span>(x1...);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N],fuc[N];</span><br><span class="line"><span class="type">int</span> type[N],pos[N],val[N];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line">ll mul[N],f[N],add[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mul[x]=(type[x]==<span class="number">2</span>)?val[x]:<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> si=e[x].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!~mul[y])<span class="built_in">dfs</span>(y);</span><br><span class="line">        mul[x]=mul[x]*mul[y]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">topo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(!deg[i])</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(type[x]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            add[pos[x]]=(add[pos[x]]+val[x]*f[x])%mod;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll res=f[x];</span><br><span class="line">        <span class="type">int</span> si=e[x].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=si<span class="number">-1</span>;~i;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=e[x][i];</span><br><span class="line">            f[y]=(f[y]+res)%mod;</span><br><span class="line">            res=res*mul[y]%mod;</span><br><span class="line">            <span class="keyword">if</span>(!--deg[y])q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(type[i]);</span><br><span class="line">        mul[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(type[i]==<span class="number">1</span>)<span class="built_in">read</span>(pos[i],val[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type[i]==<span class="number">2</span>)<span class="built_in">read</span>(val[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c;</span><br><span class="line">            <span class="built_in">read</span>(c);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x;</span><br><span class="line">                <span class="built_in">read</span>(x);</span><br><span class="line">                e[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">                deg[x]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(!deg[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        <span class="built_in">read</span>(fuc[i]);</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q;i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=fuc[i];</span><br><span class="line">        <span class="keyword">if</span>(type[x]==<span class="number">1</span>)f[x]=(f[x]+res)%mod;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type[x]==<span class="number">2</span>)res=res*mul[x]%mod;</span><br><span class="line">        <span class="keyword">else</span> f[x]=(f[x]+res)%mod,res=res*mul[x]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">write</span>((<span class="number">1ll</span>*a[i]*res+add[i])%mod,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="2-P7961-NOIP2021-数列"><a href="#2-P7961-NOIP2021-数列" class="headerlink" title="2.P7961 [NOIP2021] 数列"></a>2.<a href="https://www.luogu.com.cn/problem/P7961">P7961 [NOIP2021] 数列</a></h4><p>注意到 $n,m$ 的范围，应该是个高维 DP。</p>
<p>先设计状态，将我们不太好处理的东西直接记录入状态：比如 $1$ 的个数和进位的问题，设 $f_{i,j,k,p}$，意为前 $i$ 个数选取 $j$，$1$ 的个数为 $k$，先高一位进位 $p$ 的方案数。</p>
<p>从之前的状态转移到当前状态显然不好搞，所以考虑从当前状态向之后的状态进行转移。同时最后一层枚举 $t$，表示选  $t$  个 $i$。似乎很容易得到状态的转移：</p>
<script type="math/tex; mode=display">
f_{i,j,k,p}\to f_{i+1,j+t,k+(t+p)\\\&1,\frac{(t+p)}{2}}</script><p>因为权值是一个乘积和的形式，我们也可以尝试拆贡献，也可以比较容易得到：$v_i^t\times C_{n-j}^{t}$。然后就转移就可以了。时间复杂度$\mathcal O(n^4m)$。</p>
<p>其实还可以用滚动数组优化一下，但影响不大。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">40</span>,M=<span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a,pos=<span class="number">1</span>;</span><br><span class="line">ll ans;</span><br><span class="line">ll v[M],sum[M][N],C[N][N];</span><br><span class="line">ll f[<span class="number">2</span>][N][N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">popcnt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)res+=x&amp;<span class="number">1</span>,x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">read</span>(n,m,a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(v[i]);</span><br><span class="line">        sum[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            sum[i][j]=sum[i][j<span class="number">-1</span>]*v[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f[pos],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[pos]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=a;k++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;=n&gt;&gt;<span class="number">1</span>;p++)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=n-j;t++)</span><br><span class="line">                        f[pos][j+t][k+(t+p&amp;<span class="number">1</span>)][t+p&gt;&gt;<span class="number">1</span>]=(f[pos][j+t][k+(t+p&amp;<span class="number">1</span>)][t+p&gt;&gt;<span class="number">1</span>]</span><br><span class="line">                            +f[pos^<span class="number">1</span>][j][k][p]*sum[i][t]%mod*C[n-j][t]%mod)%mod;</span><br><span class="line">        pos^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=a;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;=n&gt;&gt;<span class="number">1</span>;p++)</span><br><span class="line">            <span class="keyword">if</span>(k+<span class="built_in">popcnt</span>(p)&lt;=a)</span><br><span class="line">                ans=(ans+f[pos^<span class="number">1</span>][n][k][p])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="3-P3953-NOIP2017-提高组-逛公园"><a href="#3-P3953-NOIP2017-提高组-逛公园" class="headerlink" title="3.P3953 [NOIP2017 提高组] 逛公园"></a>3.<a href="https://www.luogu.com.cn/problem/P3953">P3953 [NOIP2017 提高组] 逛公园</a></h4><p>我们很容易想到用 DP，并且注意观察 $k$ 的值很小，考虑可以将其记录进状态。设 $f_{x,k}$ 表示从 $1$ 走到点 $x$ ，长度为最短路 $+k$ 的路径数量。 考虑建反图然后记忆化搜索。设边为 $(x,y,z)$，转移很显然有：</p>
<script type="math/tex; mode=display">
f_{x,k}=\sum_y f_{y,dis_x+k-dis_y-z}</script><p>如何判 $0$ 环呢，只需要开一个数组判断一下会不会递归到我们需要求解的状态就可以了。</p>
<p>其实似乎也可以递推求解，状态与上面相似，需要按照 $dis$ 从小到大的顺序转移。只不过对于有 $0$ 的边，需要以拓扑序为第二关键字进行转移。稍微麻烦一点。</p>
<p>下面是记忆化搜索的代码。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,K=<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> T,n,m,k,p;</span><br><span class="line">vector&lt;Edge&gt;e1[N],e2[N];</span><br><span class="line"><span class="type">int</span> dis[N],vis[N];</span><br><span class="line"><span class="type">int</span> flag,f[N][K],v[N][K];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>,vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> si=e1[x].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=e1[x][i].v,z=e1[x][i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+z&lt;dis[y])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y]=dis[x]+z;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y])q.<span class="built_in">push</span>(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">0</span>||flag)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(v[x][k])</span><br><span class="line">    &#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[x][k])<span class="keyword">return</span> f[x][k];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,si=e2[x].<span class="built_in">size</span>();</span><br><span class="line">    v[x][k]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e2[x][i].v,z=e2[x][i].w;</span><br><span class="line">        ans=(ans+<span class="built_in">dp</span>(y,dis[x]+k-dis[y]-z))%p;</span><br><span class="line">    &#125;</span><br><span class="line">    v[x][k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> f[x][k]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(n,m,k,p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            e1[i].<span class="built_in">clear</span>(),e2[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u,v,w;</span><br><span class="line">            <span class="built_in">read</span>(u,v,w);</span><br><span class="line">            e1[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">            e2[v].<span class="built_in">push_back</span>(&#123;u,w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">SPFA</span>();</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//注意这个细节，是用来判 0 环的</span></span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//因为我们需要赋初值，但是赋完我们就不能判断经过 1 的 0 环了，所以上面需要先跑一遍</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">            ans=(ans+<span class="built_in">dp</span>(n,i))%p;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Dilworth 定理</title>
    <url>/2023/06/27/Dilworth%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>感觉有些时候比较有用。</p>
<span id="more"></span>
<h3 id="1-内容"><a href="#1-内容" class="headerlink" title="1.内容"></a>1.内容</h3><p>先说明<strong>偏序集</strong>。我们定义两个元素的比较关系。可以存在部分元素无法比较。需要满足以下三个条件：</p>
<p>1.自反性，$\forall a\in S$，有 $a\le a$.。</p>
<p>2.对称性，$\forall a,b\in S$，若 $a\le b$，有 $b\ge a$。</p>
<p>3.传递性，$\forall a,b,c\in S$，若 $a\le b,b\le c$，有 $a\le c$。</p>
<p>我们将偏序集中的元素按照比较关系建图，容易发现会得到一张 DAG。而<strong>最小链划分</strong>就是将 DAG 划分成最少条链。<strong>反链</strong>为集合中一个一集满足该子集中所有元素都无法比较，其长度即为集合大小。</p>
<p>容易发现<strong>最小链剖分</strong>，直接求是不好求的。$\text{Dilworth}$ 定理描述的就是其与反链的关系：</p>
<p><strong>偏序集</strong>上<strong>最小链划分</strong>中链的数量等于其<strong>反链</strong>长度的最大值。</p>
<h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2.例题"></a>2.例题</h3><h4 id="1-P1020-NOIP1999-普及组-导弹拦截"><a href="#1-P1020-NOIP1999-普及组-导弹拦截" class="headerlink" title="1.P1020 [NOIP1999 普及组] 导弹拦截"></a>1.<a href="https://www.luogu.com.cn/problem/P1020">P1020 [NOIP1999 普及组] 导弹拦截</a></h4><p>关于第二问的解法。比较简单的是贪心。但是可以从 $\text{Dilworth}$ 定理的角度思考。</p>
<p>对于每一个位置用一个二元组 $(x,y)$，其中 $x$ 代表该位置的下标，$y$ 表示高度。定义 $(x_1,y_1)\le (x_2,y_2)$ 当且仅当 $x_1\le x_2,y_1\ge y_2$。一个最长上升子序列对应的就是 DAG 上的一条链，于是就转化为<strong>最小链剖分</strong>的问题，而<strong>反链</strong>就是两两满足 $x_1&lt; x_2,y_2&lt; y_2$ 的元素的集合。所以答案就是最长上升子序列。</p>
<h4 id="2-P3974-TJOI2015-组合数学"><a href="#2-P3974-TJOI2015-组合数学" class="headerlink" title="2.P3974 [TJOI2015] 组合数学"></a>2.<a href="https://www.luogu.com.cn/problem/P3974">P3974 [TJOI2015] 组合数学</a></h4><p>还是考虑建立偏序关系。对于每个位置设 $(x,y)$ 表示其坐标。定义 $(x_1,y_1)\le (x_2,y_2)$ 当且仅当 $x_1\le x_2,y_1\le y_2$。并且将每个位置的权值 $v_{i,j}$ 拆成 $v_{i,j}$ 个点。求的就是 DAG 上的<strong>最小链剖分</strong>。即满足 $x_1&lt; x_2,y_1&lt; y_2$ 的集合大小的最大值。从右下角到左上角进行 DP 即可求出。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP 字符串匹配</title>
    <url>/2023/05/01/KMP-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>来补一下。</p>
<span id="more"></span>
<h2 id="1-KMP-字符串匹配"><a href="#1-KMP-字符串匹配" class="headerlink" title="1.KMP 字符串匹配"></a>1.KMP 字符串匹配</h2><p>KMP 常用来求单文本串与单模式串的匹配问题。大致分为两步，求出前缀函数与进行匹配。下面分别介绍。</p>
<h3 id="1-1-前缀函数"><a href="#1-1-前缀函数" class="headerlink" title="1.1.前缀函数"></a>1.1.前缀函数</h3><p>第一步：求出模式串的前缀函数。</p>
<p>先介绍 Border 的概念，对于字符串 $s[1\dots n]$，所有满足 $s[1\dots i]=s[n-i+1 \dots n]$ 且 $i \neq 1$ 的前缀为 $s[1\dots n]$ 的一个Border。</p>
<p>字符串 $s[1 \dots n]$ 的前缀函数 $\pi[i]$ 定义为字串 $s[1 \dots i]$ 的最长 Border 的长度，不存在任何 Boder 时值为 $0$。</p>
<h4 id="1-1-1-性质"><a href="#1-1-1-性质" class="headerlink" title="1.1.1.性质"></a>1.1.1.性质</h4><p>$(1)$.若 $s[\pi[i]+1]=s[i+1]$ ，则 $\pi[i+1]=\pi[i]+1$。</p>
<p>$(2)$.$s[1 \dots i]$ 的 Border 的 Border 是 $s[1 \dots i]$ 的 Border。</p>
<p>$(3)$.$s[1 \dots i]$ 的 Border 集合为 $s[1\dots \pi[i]],s[i\dots \pi[\pi[i]]],\cdots$。</p>
<p>通过性质 $(2)$ 以及 $\pi[i]$ 的最长性，通过反证法容易得到性质 $(3)$。</p>
<h4 id="1-1-2-计算"><a href="#1-1-2-计算" class="headerlink" title="1.1.2.计算"></a>1.1.2.计算</h4><p>假设当前情况下，我们根据上面三条性质来求尝试计算 $\pi[i+1]$ 。</p>
<p>根据性质 $(2)$，我们只需要将 $s[i+1]$ 与 $s[1 \dots i]$ 所有 Border 的后面一位进行匹配即可。根据性质 $(3)$，我们在适配时不断将 $i$ 跳到 $\pi[i]$ 即可遍历所有后缀。再根据性质 $(1)$，这样即可求出 $\pi[i+1]$。</p>
<p>这样的是时间复杂度是多少？设 $j$ 为之前已匹配的最大长度，即 $\pi[i]$。注意到 $j$ 每一次最多只能增加 $1$ ，那么 $j$ 的增量最多为 $n$，所以失配时跳到 $\pi[i]$ 的次数为 $\mathcal O(n)$。于是时间复杂度为 $\mathcal O(n)$。</p>
<details class="code" open><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;t[i]!=t[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">    <span class="keyword">if</span>(t[i]==t[j+<span class="number">1</span>])j++;</span><br><span class="line">    ne[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-2-匹配"><a href="#1-2-匹配" class="headerlink" title="1.2.匹配"></a>1.2.匹配</h3><p>第二步：在文本串中进行匹配。</p>
<p>通过上一步的过程，我们已经可以看到，KMP 核心思想是 利用之前匹配好的信息，就是与之匹配的 Border，继续进行匹配。而在第二部中也是如此。我们还是利用不停地跳 $\pi[i]$ 遍历 $s[1 \dots i]$ 的所有 Border，与上面的过程十分相似，此处不再赘述。</p>
<details class="code" open><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;s[i]!=t[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i]==t[j+<span class="number">1</span>])j++;</span><br><span class="line">    <span class="comment">// if(j==m)printf(&quot;%d\n&quot;,i-m+1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-3-应用"><a href="#1-3-应用" class="headerlink" title="1.3.应用"></a>1.3.应用</h3><p>我们发现前缀函数 $\pi[i]$ 有一些很好的性质，于是衍生出更多的应用。下面是一些简单的例子。 </p>
<h4 id="1-UVA1328-Period"><a href="#1-UVA1328-Period" class="headerlink" title="1.UVA1328 Period"></a>1.<a href="https://www.luogu.com.cn/problem/UVA1328">UVA1328 Period</a></h4><p>经典问题，求一个字符串的所有前缀的最大周期长度。仔细观察，设存在 $s[1 \dots j]$ 为 $s[1 \dots i]$ 的最小周期，其充要条件是 $j|i$ 且 $j=i-\pi[i]$。也比较好证明。画个图更好理解。于是我们只需要求一遍 $\pi[i]$ 即可。</p>
<h4 id="2-P3435-POI2006-OKR-Periods-of-Words"><a href="#2-P3435-POI2006-OKR-Periods-of-Words" class="headerlink" title="2.P3435 [POI2006] OKR-Periods of Words"></a>2.<a href="https://www.luogu.com.cn/problem/P3435">P3435 [POI2006] OKR-Periods of Words</a></h4><p>设 $s[1 \dots j]$ 为 $s[1 \dots i]$ 的长度最小的一个 Border，容易发现 $s[i-j+1 \dots i]$ 的长度即为所求。于是不停跳 $\pi[i]$ 找到最短的 Border 长度即可。但是对于每一个子串暴力跳的话 $j$ 的变化次数是 $\mathcal O(n^2)$ 的，时间复杂度也是 $\mathcal O(n^2)$ 的。考虑一个小优化，我们每次跳完 就将 $\pi[i]$ 赋为 $j$，注意到 Border 之间是呈现一个树形结构，于是这个优化可以类似于并查集的路径压缩，所以对于每个前缀最多只需要跳一次。这样做的时间复杂度就是 $\mathcal O(n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n,ne[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>])j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">2</span>;i&lt;=n;i++,j=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ne[j])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(j)ne[i]=j,ans+=i-j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="3-P3426-POI2005-SZA-Template"><a href="#3-P3426-POI2005-SZA-Template" class="headerlink" title="3.P3426 [POI2005]SZA-Template"></a>3.<a href="P3426 [POI2005]SZA-Template">P3426 [POI2005]SZA-Template</a></h4><p>不妨直接设记 $f_i$ 表示以 $i$ 结尾的字符串的答案。进行仔细观察，答案必须为字符串的一个 Border 或者字符串本身。更进一步地，答案只可能为 $f_{\pi[i]}$ 或者 $i$。因为不可能存在一个可以表示 $s[1 \dots i]$ 但无法表示 $s[1 \dots \pi[i]]$ 的 Border。这意味着结尾与前面部分最多只能接上 $s[1 \dots \pi[i]]$ 这一段，前面部分也需要有这个结构构成，于是我们要找到一个 $j$，满足 $f_j=f_{\pi[i]}$ 且 $i-j \le \pi[i]$，那么其值为 $f_{\pi[i]}$，否则为 $i$。这个过程可以用一个桶简单实现。</p>
<h2 id="2-Z-函数"><a href="#2-Z-函数" class="headerlink" title="2.Z 函数"></a>2.Z 函数</h2><p>Z 函数也称扩展 KMP，求法与 KMP 很类似。</p>
<h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1.定义"></a>2.1.定义</h3><p>对于字符串 $s[1 \dots n]$，定义函数 $z[i]$ 表示 $s$ 与 $s[i\dots n]$ 的最长公共前缀 LCP 的长度，$z$ 被称为 $s$ 的 Z 函数。</p>
<h3 id="2-2-求法"><a href="#2-2-求法" class="headerlink" title="2.2.求法"></a>2.2.求法</h3><p>核心思想还是利用好之前已经匹配好的信息。我们设 $s[l\dots r]$ 是当前 $r$ 最大的一个匹配段，分为两种情况讨论：</p>
<ul>
<li>如果 $i&lt;r$，因为有 $s[i,r]=s[i-l+1,r-l+1]$，所以得到 $z[i]\ge \min (z[i-l+1],r-i+1)$。于是分为两种情况：<ul>
<li>$z[i-l+1]&lt;r-i+1$，直接令 $z[i]=z[i-l+1]$。</li>
<li>$z[i-l+1]\le r-i+1$，从 $r$ 开始暴力向右进行扩展。</li>
</ul>
</li>
</ul>
<p>具体实现如下：</p>
<details class="code" open><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=r)z[i]=<span class="built_in">min</span>(z[i-l+<span class="number">1</span>],r-i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(i+z[i]&lt;=n&amp;&amp;s[i+z[i]]==s[z[i]+<span class="number">1</span>])z[i]++;</span><br><span class="line">    <span class="keyword">if</span>(i+z[i]<span class="number">-1</span>&gt;r)l=i,r=i+z[i]<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p><code>while</code> 中每次向后扩展一位都至少会使 $r$ 增加 $1$，所以总共最多只会执行 $\mathcal O(n)$ 次，外层循环只有一层遍历。所以总的时间复杂度为 $\mathcal O(n)$。</p>
<p>同样类似于上一步以及 KMP 的匹配过程，Z 函数还可以用来求模板串与文本串的每一个后缀的 LCP 长度数组。这里不再赘述。</p>
 <details class="code" open><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=r)p[i]=<span class="built_in">min</span>(z[i-l+<span class="number">1</span>],r-i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(i+p[i]&lt;=n&amp;&amp;s[i+p[i]]==t[p[i]+<span class="number">1</span>])p[i]++;</span><br><span class="line">    <span class="keyword">if</span>(i+p[i]<span class="number">-1</span>&gt;r)l=i,r=i+p[i]<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="2-3-应用"><a href="#2-3-应用" class="headerlink" title="2.3.应用"></a>2.3.应用</h3><p>通过上面我们逐渐认识到前缀函数 $\pi[i]$ 与 Z 函数 $z[i]$ 是相似的。$\pi[i]$ 是以 $i$ 结尾，$z[i]$ 则是以 $i$ 开头。所以二者的应用也是类似的。但不同情况下的方便程度也不一样。</p>
<h4 id="1-P8112-Cnoi2021-符文破译"><a href="#1-P8112-Cnoi2021-符文破译" class="headerlink" title="1.P8112 [Cnoi2021]符文破译"></a>1.<a href="https://www.luogu.com.cn/problem/P8112">P8112 [Cnoi2021]符文破译</a></h4><p><a href="https://kevinlive.github.io/2022/08/18/P8112-Cnoi2021-%E7%AC%A6%E6%96%87%E7%A0%B4%E8%AF%91/">在这里看</a></p>
<h4 id="2-P7114-NOIP2020-字符串匹配"><a href="#2-P7114-NOIP2020-字符串匹配" class="headerlink" title="2.P7114 [NOIP2020] 字符串匹配"></a>2.<a href="https://www.luogu.com.cn/problem/P7114">P7114 [NOIP2020] 字符串匹配</a></h4><p>经典题，不再赘述。</p>
<h2 id="3-失配树"><a href="#3-失配树" class="headerlink" title="3.失配树"></a>3.失配树</h2><p>KMP 的小扩展，我们很容易发现根据前缀函数 $\pi[i]$ 发现 Border 之间呈现一个树形结构。于是关于一些关于 Border 的问题我们可以通过将这棵树具体地建出来，在进行处理，这棵树就是失配树。同时这个在 AC 自动机上也有应用。</p>
<h4 id="1-P5829-【模板】失配树"><a href="#1-P5829-【模板】失配树" class="headerlink" title="1.P5829 【模板】失配树"></a>1.<a href="https://www.luogu.com.cn/problem/P5829">P5829 【模板】失配树</a></h4><p>模板题，按照上面所说，直接求 LCA 即可。</p>
 <details class="code" open><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> pi[N];</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N],ne[N];</span><br><span class="line"><span class="type">int</span> d[N],si[N],son[N],fa[N],top[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    son[x]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>,fa[y]=x;</span><br><span class="line">        <span class="built_in">dfs1</span>(y);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        <span class="keyword">if</span>(son[x]==<span class="number">-1</span>||si[son[x]]&lt;si[y])son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x]=t;</span><br><span class="line">    <span class="keyword">if</span>(~son[x])<span class="built_in">dfs2</span>(son[x],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span>(ver[i]!=son[x])</span><br><span class="line">            <span class="built_in">dfs2</span>(ver[i],ver[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[top[x]]&lt;d[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&gt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[j+<span class="number">1</span>]!=s[i])j=pi[j];</span><br><span class="line">        <span class="keyword">if</span>(s[j+<span class="number">1</span>]==s[i])j++;</span><br><span class="line">        pi[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pi[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">add</span>(pi[i],i);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">LCA</span>(fa[x],fa[y]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>应用感觉也不多，不太找得到。但上面很多题目都可以用失配树完成。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>KMP</tag>
        <tag>Z函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Kruskal 重构树</title>
    <url>/2022/08/25/Kruskal-%E9%87%8D%E6%9E%84%E6%A0%91/</url>
    <content><![CDATA[<p>Kruskal 生成树算法的扩展应用。</p>
<span id="more"></span>
<h3 id="Kruskal-重构树"><a href="#Kruskal-重构树" class="headerlink" title="Kruskal 重构树"></a>Kruskal 重构树</h3><p>考虑一下该算法的过程：一开始 Kruskal 重构树只有 $n$ 个点，没有边。还是类似 Kruskal，我们将所有边从大到小进行考虑。对于每一条边 $(u,v,w)$，若 $u,v$ 不联通，我们就在 Kruskal 重构树上新建一个 $t$。将 $u,v$ 在重构树上的根节点 $rt_u,rt_v$ 作为 $t$ 的左右儿子，并且令 $t$ 点的权值为 $val_t=w$。</p>
<p>建了这样一棵树，我们很明显有这几个性质：</p>
<p>1.一般情况下他是一棵二叉树。</p>
<p>2.原图的节点都是重构树的叶子节点。</p>
<p>3.对于任意节点 $u$ 其祖先 $v$，$val_u$ 与 $val_v$ 满足相同偏序关系。</p>
<p>咕咕咕。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>笔记</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#2127. 「HAOI2015」按位或</title>
    <url>/2023/04/01/LOJ-2127-%E3%80%8CHAOI2015%E3%80%8D%E6%8C%89%E4%BD%8D%E6%88%96/</url>
    <content><![CDATA[<p>min-max 容斥入门题。</p>
<span id="more"></span>
<p>相当于求每个位置的期望次数的最大值，用 min-max 容斥得到：</p>
<script type="math/tex; mode=display">
E(\max_{i\in S}{t_i})=\sum_{T\subseteq S}(-1)^{|T-1|} E(\min_{i\in T}t_i)</script><p>考虑如何求 $\displaystyle E(\min_{i\in S}t_i)$，考虑期望的离散计算方式，设 $f(S)$ 表示选中不覆盖 $S$ 中任意位置的概率，有 $\displaystyle E(\min_{i\in S} t_i)=(1-f(S))\cdot\sum_{k=1}k\cdot f(S)^{k-1}$。后面一部分推一下：</p>
<script type="math/tex; mode=display">
\begin{align}
f(S) \cdot\sum_{k=1}k\cdot f(S)^{k-1} &= \sum_{k=2}(k-1)\cdot f(S)^{k-1}\notag\\
&=\sum_{k=1}k\cdot f(S)^{k-1}-\sum_{k=0}f(S)^k\\

\sum_{k=1}k\cdot f(S)^{k-1} &= \frac{\sum_{k=0}f(S)^k}{1-f(S)}\notag\\

\end{align}</script><p>于是得到：</p>
<script type="math/tex; mode=display">
E(\min_{i\in S} t_i)=\sum_{k=0}f(S)^k=\frac{1}{1-f(S)}</script><p>但其实上面推的式子是完全没有必要的，补集转换就可以得到上式。</p>
<p>对于 $f(S)$ 可以用 FMT 求出，总时间复杂度为 $\mathcal O(n2^n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> popcnt __builtin_popcount</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">21</span>,M=<span class="number">1</span>&lt;&lt;N;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,tot;</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="type">double</span> ans,f[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FMT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                f[j]+=f[j^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;f[i]),sum|=(f[i]!=<span class="number">0</span>)?i:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum!=tot<span class="number">-1</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;INF&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FMT</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;tot;i++)ans+=(<span class="built_in">popcnt</span>(i)&amp;<span class="number">1</span>?<span class="number">1</span>:<span class="number">-1</span>)*(<span class="number">1.0</span>/(<span class="number">1</span>-f[tot<span class="number">-1</span>^i]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>按位或</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#2115. 「HNOI2015」落忆枫音</title>
    <url>/2022/11/09/LOJ-2115-%E3%80%8CHNOI2015%E3%80%8D%E8%90%BD%E5%BF%86%E6%9E%AB%E9%9F%B3/</url>
    <content><![CDATA[<p>拓扑序DP。</p>
<span id="more"></span>
<p>考虑有向无环图，答案显然为 $\prod_i \deg_i$。但是加了一条边可能会出现环，产生不合法的方案。我们考虑将不合法的方案减去。</p>
<p>把环从图中剖出来，那么剩下点的 $\prod_i \deg_i$ 就是该环不合法的方案数。理由很简单，这个环没有入度的，而其它所有点都可以随便选父亲。于是我们将环上点的 $\deg_i$ 除掉即可。</p>
<p>可能会出现多个环。但其实 $a$ 与 $b$ 一定会出现在环上的。此过程可以 DP，计算 $f_i$ 为从 $b$ 到 $i$ 的方案数，最终用原答案减去  $f_a$ 即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],ne[M];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line">ll ans=<span class="number">1</span>,sum=<span class="number">1</span>,f[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mod-(mod/x)*<span class="built_in">inv</span>(mod%x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[x])</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(x==b)</span><br><span class="line">    &#123;</span><br><span class="line">        f[x]=sum*<span class="built_in">inv</span>(deg[x])%mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        f[x]=(f[x]+f[y])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=f[x]*<span class="built_in">inv</span>(deg[x])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">        deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    deg[<span class="number">1</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==b)ans=ans*(deg[i]+<span class="number">1</span>)%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=ans*deg[i]%mod;</span><br><span class="line">        sum=sum*deg[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans+mod-f[a])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#2542. 「PKUWC2018」随机游走</title>
    <url>/2023/03/05/LOJ-2542-%E3%80%8CPKUWC2018%E3%80%8D%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/</url>
    <content><![CDATA[<p>min-max 容斥 练手题。</p>
<span id="more"></span>
<p>发现要求的是： </p>
<script type="math/tex; mode=display">
E(\max_{i\in S} t_i)</script><p>使用 min-max 容斥得到：</p>
<script type="math/tex; mode=display">
E(\max_{i\in S} t_i)=\sum_{T\subseteq S}(-1)^{|T|-1} E(\min_{i\in T} t_i)</script><p>注意到 $n\le 18$，于是考虑直接暴力容斥，求出每个子集 $S$ 的 $\displaystyle E(\min_{i\in S} t_i) $。</p>
<p>设计状态 $f(i)$ 表示从 $i$ 走到第一次走到 $S$ 中任意点的期望步数，</p>
<p>1.对于 $i\in S$，有 $f(i)=0$。</p>
<p>2.对于 $i\notin S$，有 $\displaystyle f(i)=1+\frac{1}{\deg(i)}\sum_{(i,j)\in E} f(j)$。</p>
<p>可以高斯消元，但是时间复杂度就变成 $\mathcal O(n^3 2^n)$ 的，不能接受。</p>
<p>先考虑叶子节点 $i$，它们的值只会与父亲有关（或者 $f(i)=0$），有 $f(i)=A_i f(p_i) +B_i$，其中 $A_i=1,B_i=1$。而我们接着考虑叶子的父亲节点 $i$：</p>
<script type="math/tex; mode=display">
f(i)=1+\frac{1}{\deg_i}\sum_j{(A_j f(i)+b_j)} + \frac{1}{\deg_i}f(p_i)</script><p>变换一下：</p>
<script type="math/tex; mode=display">
f(i)=\frac{1}{\deg(i)-\sum_j{A_j}}f(p_i) + \frac{\deg(i)+\sum_j B_j}{\deg(i)-\sum_j A_j}</script><p>于是我们将叶子的父亲节点 $i$ 也表示成了类似于 $\displaystyle f(i)=A_i f(p_i) +B_i$ 的形式，其中 $\displaystyle A_i=\frac{1}{\deg(i)-\sum_j{A_j}},B_i=\frac{\deg(i)+\sum_j B_j}{\deg(i)-\sum_j A_j}$。</p>
<p>以此类推，我们从下往上可以推出所有节点的 $A_i,B_i$，我们直接以 $x$ 为根，因为 $x$ 没有父节点，所以：</p>
<script type="math/tex; mode=display">
f(x)=B_x</script><p>于是对与每个 $S$ dfs 一遍即可求出对应的 $f(x)$，时间复杂度为 $\mathcal O(n2^n)$。</p>
<p>但是我们要求的是 $\displaystyle \sum_{T\subseteq S}(-1)^{|T|-1} E(\min_{i\in T} t_i)$，对于每个询问求一次是 $\mathcal O(2^n)$ 的。对于这个式子，我们显然可以在预处理出所有 $\displaystyle (-1)^{|T|-1} E(\min_{i\in T} t_i)$ 后，做一次 FMT，即可 $\mathcal O(1)$ 回答询问。</p>
<p>代码非常好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> popcnt __builtin_popcount</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">18</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q,rt;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> s,deg[N],a[N],b[N];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s&gt;&gt;x&amp;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a[x]=<span class="number">0</span>,b[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> suma=<span class="number">0</span>,sumb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        suma=<span class="built_in">adj</span>(suma+a[y]),sumb=<span class="built_in">adj</span>(sumb+b[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[x]=<span class="built_in">qpow</span>(<span class="built_in">adj</span>(deg[x]-suma+mod));</span><br><span class="line">    b[x]=<span class="number">1ll</span>*<span class="built_in">adj</span>(deg[x]+sumb)*<span class="built_in">qpow</span>(<span class="built_in">adj</span>(deg[x]-suma+mod))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FMT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j]=<span class="built_in">adj</span>(a[j]+a[j^(<span class="number">1</span>&lt;&lt;i)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q,rt);</span><br><span class="line">    rt--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        u--,v--;</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">        deg[u]++,deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op=(<span class="built_in">popcnt</span>(s)&amp;<span class="number">1</span>)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(rt,<span class="number">-1</span>);</span><br><span class="line">        f[s]=<span class="built_in">adj</span>(op*b[rt]+mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FMT</span>(n,f);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="built_in">read</span>(k);</span><br><span class="line">        s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            x--;</span><br><span class="line">            s+=<span class="number">1</span>&lt;&lt;x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[s]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>容斥</tag>
        <tag>min-max 容斥</tag>
        <tag>集合幂级数</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#2743. 「JOI Open 2016」摩天大楼</title>
    <url>/2022/09/02/LOJ-2743-%E3%80%8CJOI-Open-2016%E3%80%8D%E6%91%A9%E5%A4%A9%E5%A4%A7%E6%A5%BC/</url>
    <content><![CDATA[<p>经典 DP，费用提前计算的思想。</p>
<span id="more"></span>
<p>对于序列类型的 DP 题，我们可以想到用分段型 DP，每次将当前的数插入进去，求解方案数。但是这道题的并费用不好直接计算。</p>
<p>先将 $a$ 排序，并从小到大插入。对于 $i&lt;j$ ，有 $|a_i-a_j|=\sum_{k=i}^{j-1}(a_{k+1}-a_k)$。根据这个我们可以尝试进行<strong>费用提前计算</strong>。对于之后每个插在当前的 $k$ 个端点上的数，会一共产生 $(a_{i+1}-a_{i})\times k$ 的费用。</p>
<p>状态转移比较套路。注意边界上是没有花费的，所以还需要将边界上填了多少个记录进状态。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">10</span>,M=<span class="number">1e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">ll f[N][N][M][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>;d&lt;=<span class="number">2</span>;d++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> t=k+(a[i+<span class="number">1</span>]-a[i])*(<span class="number">2</span>*j-d);</span><br><span class="line">                    <span class="keyword">if</span>(t&gt;m||!f[i][j][k][d])<span class="keyword">continue</span>;</span><br><span class="line">                    f[i+<span class="number">1</span>][j+<span class="number">1</span>][t][d]=(f[i+<span class="number">1</span>][j+<span class="number">1</span>][t][d]+f[i][j][k][d]*(j+<span class="number">1</span>-d))%mod;</span><br><span class="line">                    <span class="keyword">if</span>(j)f[i+<span class="number">1</span>][j<span class="number">-1</span>][t][d]=(f[i+<span class="number">1</span>][j<span class="number">-1</span>][t][d]+f[i][j][k][d]*(j<span class="number">-1</span>))%mod;</span><br><span class="line">                    <span class="keyword">if</span>(j)f[i+<span class="number">1</span>][j][t][d]=(f[i+<span class="number">1</span>][j][t][d]+f[i][j][k][d]*(<span class="number">2</span>*j-d))%mod;</span><br><span class="line">                    <span class="keyword">if</span>(d&lt;<span class="number">2</span>)f[i+<span class="number">1</span>][j+<span class="number">1</span>][t][d+<span class="number">1</span>]=(f[i+<span class="number">1</span>][j+<span class="number">1</span>][t][d+<span class="number">1</span>]+f[i][j][k][d]*(<span class="number">2</span>-d))%mod;</span><br><span class="line">                    <span class="keyword">if</span>(j&amp;&amp;d&lt;<span class="number">2</span>)f[i+<span class="number">1</span>][j][t][d+<span class="number">1</span>]=(f[i+<span class="number">1</span>][j][t][d+<span class="number">1</span>]+f[i][j][k][d]*(<span class="number">2</span>-d))%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        ans=(ans+f[n][<span class="number">1</span>][i][<span class="number">2</span>])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3339. 「NOI2020」美食家</title>
    <url>/2022/12/25/LOJ-3339-%E3%80%8CNOI2020%E3%80%8D%E7%BE%8E%E9%A3%9F%E5%AE%B6/</url>
    <content><![CDATA[<p>一些小 trick。</p>
<span id="more"></span>
<p>注意到 $T$ 很大，并且 $n,m$ 都比较小，并且求的是恰好 $T$ 时刻。想到用矩阵快速幂来做。</p>
<p>如何处理路径长度？因为 $w_i$ 很小，我们可以考虑拆边，这样总点数是 $n+5m$ 的，不太能接受。实际上我们可以考虑拆点，这样总点数是 $5n$ 的，可以接受。另外还需要将点权转化为边权。</p>
<p>如何处理美食节？我们可以将美食节按照时间进行排序，每次计算时间之差内愉悦值变化，再加上美食节额外的愉悦值即可。</p>
<p>但是这样暴力快速幂做是 $\mathcal O(n^3k\log T)$ 的，无法通过所有数据。其实我们只需要保留矩阵的第一行即可。于是可以预处理原始矩阵的次幂，在求解过程中倍增计算。于是时间复杂度就降到了 $\mathcal O(n^3\log T+n^2k\log T)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">250</span>+<span class="number">10</span>,M=<span class="number">5e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    ll e[N][N];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;<span class="built_in">memset</span>(e,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(e));&#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix a,<span class="type">const</span> Matrix b)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix c;</span><br><span class="line">        c.x=a.x,c.y=b.y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a.x;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=b.y;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a.y;k++)</span><br><span class="line">                    c.e[i][j]=<span class="built_in">max</span>(c.e[i][j],a.e[i][k]+b.e[k][j]);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;f[<span class="number">50</span>],ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Festival</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t,x,y;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Festival a,<span class="type">const</span> Festival b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.t&lt;b.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n,m,t,k;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i<span class="number">-1</span>)*<span class="number">5</span>+j+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;delicacy.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;delicacy.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(n,m,t,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">            f[<span class="number">0</span>].e[<span class="built_in">num</span>(i,j)][<span class="built_in">num</span>(i,j+<span class="number">1</span>)]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        f[<span class="number">0</span>].e[<span class="built_in">num</span>(u,w<span class="number">-1</span>)][<span class="built_in">num</span>(v,<span class="number">0</span>)]=c[v];</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>].x=<span class="number">5</span>*n,f[<span class="number">0</span>].y=<span class="number">5</span>*n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">31</span>;i++)</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]*f[i<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i].t,a[i].x,a[i].y);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+k);</span><br><span class="line">    a[<span class="number">0</span>]=(Festival)&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    a[k+<span class="number">1</span>]=(Festival)&#123;t,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    ans.e[<span class="number">1</span>][<span class="number">1</span>]=c[<span class="number">1</span>];</span><br><span class="line">    ans.x=<span class="number">1</span>,ans.y=<span class="number">5</span>*n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d=a[i].t-a[i<span class="number">-1</span>].t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;~i;i--)</span><br><span class="line">            <span class="keyword">if</span>(d&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                ans=ans*f[i];</span><br><span class="line">        ans.e[<span class="number">1</span>][<span class="built_in">num</span>(a[i].x,<span class="number">0</span>)]+=a[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.e[<span class="number">1</span>][<span class="number">1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans.e[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3340. 「NOI2020」命运</title>
    <url>/2022/12/25/LOJ-3340-%E3%80%8CNOI2020%E3%80%8D%E5%91%BD%E8%BF%90/</url>
    <content><![CDATA[<p>线段树合并优化 DP。</p>
<span id="more"></span>
<p>注意到对于所有 $(u,v)\in \mathcal Q$ 的 $v$ 只需要深度最深的 $u$ 满足即可。考虑设计状态 $f_{x,i}$ 表示以 $x$ 为根的子树中未满足条件的 $u$ 深度最大为 $i$ 的方案数。考虑 $(x,y)$ 为连向子树的边，选取该条边为 $1$ 的贡献是 $\sum_{j=0}^{dep_x} f_{x,i}\times f_{y,j}$，不选取的贡献是 $\sum_{j=0}^{i} f_{x,i}\times f_{y,j}+\sum_{j=0}^{i-1} f_{x,j}\times f_{y,i}$。用前缀和优化，得到总的转移方程：</p>
<script type="math/tex; mode=display">
f_{x,i}=f_{x,i}\times (sum_y(dep_x)+sum_y(i))+f_{y,i}\times sum_x(i-1)</script><p>这样做到 $\mathcal O(n^2)$，对深度离散化可以做到 $\mathcal O(n\min{n,m})$，建虚树可以做到 $\mathcal O((\min{n,m})^2)$。</p>
<p>观察式子，先不管 $sum_y(dep_x)$，剩下的项全都和下标 $i$ 有关，求区间和。而且真正有用的状态数是 $\mathcal O(m)$ 的，于是考虑整体 DP。整个过程用线段树合并来维护，合并过程中维护 $sum_x,sum_y$，先合并左子树，再合并右子树。$sum_y(dep_x)$ 在线段树上查一下就行了。时间复杂度 $\mathcal O(n \log n)$。</p>
<p>全都和下标 $i$ 有关这一点提醒我们也可以用启发式合并，但是感觉比较难写，是 $\mathcal O(n\log^2 n)$，有被卡的风险。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    ll sum,tag;</span><br><span class="line">&#125;tr[N*<span class="number">80</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> rt[N],d[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].sum=(tr[tr[x].lc].sum+tr[tr[x].rc].sum)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].sum=tr[x].sum*k%mod;</span><br><span class="line">    tr[x].tag=tr[x].tag*k%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].tag==<span class="number">1</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].lc)<span class="built_in">update</span>(tr[x].lc,tr[x].tag);</span><br><span class="line">    <span class="keyword">if</span>(tr[x].rc)<span class="built_in">update</span>(tr[x].rc,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=++cnt;</span><br><span class="line">    tr[x].sum=tr[x].tag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">insert</span>(tr[x].lc,l,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||r&lt;=pos)<span class="keyword">return</span> tr[x].sum;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(tr[x].lc,l,mid,pos);</span><br><span class="line">    <span class="keyword">return</span> (tr[tr[x].lc].sum+<span class="built_in">query</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r,ll &amp;sumx,ll &amp;sumy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x&amp;&amp;!y)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">    &#123;</span><br><span class="line">        sumy=(sumy+tr[y].sum)%mod;</span><br><span class="line">        <span class="built_in">update</span>(y,sumx);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!y)</span><br><span class="line">    &#123;</span><br><span class="line">        sumx=(sumx+tr[x].sum)%mod;</span><br><span class="line">        <span class="built_in">update</span>(x,sumy);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        sumx=(sumx+tr[x].sum)%mod;</span><br><span class="line">        sumy=(sumy+tr[y].sum)%mod;</span><br><span class="line">        tr[x].sum=(tr[x].sum*sumy%mod+tr[y].sum*((sumx+mod-tr[x].sum)%mod)%mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x),<span class="built_in">pushdown</span>(y);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[x].lc=<span class="built_in">merge</span>(tr[x].lc,tr[y].lc,l,mid,sumx,sumy);</span><br><span class="line">    tr[x].rc=<span class="built_in">merge</span>(tr[x].rc,tr[y].rc,mid+<span class="number">1</span>,r,sumx,sumy);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:vec[x])</span><br><span class="line">        res=<span class="built_in">max</span>(res,d[y]);</span><br><span class="line">    <span class="built_in">insert</span>(rt[x],<span class="number">0</span>,n<span class="number">-1</span>,res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        ll sumx=<span class="number">0</span>,sumy=<span class="built_in">query</span>(rt[y],<span class="number">0</span>,n<span class="number">-1</span>,d[x]);</span><br><span class="line">        rt[x]=<span class="built_in">merge</span>(rt[x],rt[y],<span class="number">0</span>,n<span class="number">-1</span>,sumx,sumy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;destiny.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;destiny.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        vec[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(rt[<span class="number">1</span>],<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>整体DP</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3737. 「LNOI2022」吃</title>
    <url>/2023/03/31/LOJ-3737-%E3%80%8CLNOI2022%E3%80%8D%E5%90%83/</url>
    <content><![CDATA[<p>有趣的贪心。</p>
<span id="more"></span>
<p>显然先加后乘是最优的。我们考虑将 $a_i=1$ 的 $b_i$ 加起来。考虑 $a_i\ge 2$ 的情况，发现最多甚至会选取一个 $b_i$。因为假如选取 $b_i\ge b_j$，那么选取 $a_j$ 就有 $b_i\times a_j\ge b_i+b_j$。枚举一遍即可。时间复杂度 $\mathcal O(n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line">ll sum=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> prod=<span class="number">1</span>,pos;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(b[i]),(a[i]==<span class="number">1</span>)?sum+=b[i]:prod=<span class="number">1ll</span>*prod*a[i]%mod;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">1</span>||b[i]&lt;=sum)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1ll</span>*(sum+b[pos])*a[i]&lt;=<span class="number">1ll</span>*(sum+b[i])*a[pos])pos=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos)sum=(sum+b[pos])%mod*<span class="built_in">qpow</span>(a[pos]);</span><br><span class="line">    sum%=mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*sum*prod%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3897. 「NOIP2022」喵了个喵</title>
    <url>/2023/03/13/LOJ-3897-%E3%80%8CNOIP2022%E3%80%8D%E5%96%B5%E4%BA%86%E4%B8%AA%E5%96%B5/</url>
    <content><![CDATA[<p>再次敲响警钟。</p>
<span id="more"></span>
<p>先考虑 $k=2n-2$，我们把 $n-1$ 栈上放上互不相同的 $2n-2$ 种牌。接下来新来的一张牌如果在栈顶出现过，我们放在对应的栈上消去；如果在栈底出现过，我们就将它放在空栈上，再将该栈底消去即可。</p>
<p>再考虑 $k=2n-1$，我们还是把 $n-1$ 栈上放上互不相同的 $2n-2$ 种牌，并且维护一个空栈（否则栈底很可能无法被消除）。接下来新来的一张牌可能是新的第 $2n-1$ 种牌。而这个时候我们就不太好放了。因为放在前 $n-1$ 个栈上，可能会影响到栈顶的消除；放在空栈上，无法及时消去会影响到栈底的消除。</p>
<p>我们尝试放到一个不会影响之后消除的位置上。经过思考，我们考虑这样的过程：</p>
<ol>
<li><p>$n-1$ 个栈上有 $2n-2$ 种不同的牌。</p>
</li>
<li><p>当前要放的第 $2n-1$ 种牌先待定。</p>
</li>
<li><p>找到之后出现的栈底种类之一（或者第 $2n-1$ 种）的第一张牌。</p>
</li>
<li><p>该栈的栈顶牌型出现次数的奇偶性进行讨论：</p>
<p>1.偶数次：将第 $2n-1$ 种牌放在空栈上，消去该栈上的所有牌，并将其作为新的空栈。</p>
<p>2.奇数次：将第 $2n-1$ 种牌放在该栈上，最后利用空栈将栈底消去。</p>
</li>
</ol>
<p>实现起来相当繁琐，可能因为小细节挂掉。。。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300</span>+<span class="number">10</span>,M=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res&lt;<span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),res=-res;</span><br><span class="line">    <span class="keyword">if</span>(res&gt;<span class="number">9</span>)<span class="built_in">write</span>(res/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(res%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;<span class="built_in">putchar</span>(c);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> </span>&#123;<span class="keyword">while</span>(*s)<span class="built_in">putchar</span>(*s++);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> ...ARC&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T res, ARC ...com)</span></span>&#123;<span class="built_in">write</span>(res),<span class="built_in">write</span>(com...);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Op</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> op,x,y;</span><br><span class="line">&#125;ans[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> T,n,m,k;</span><br><span class="line"><span class="type">int</span> a[M];</span><br><span class="line"><span class="type">int</span> now,em;</span><br><span class="line"><span class="type">int</span> vis[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt;sta[N],q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(now&lt;=m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[a[now]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[a[now]]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> i=vis[a[now]];</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                sta[i].<span class="built_in">pop_back</span>();</span><br><span class="line">                q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                vis[a[now]]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> i=-vis[a[now]];</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">2</span>,i,em&#125;;</span><br><span class="line">                sta[i].<span class="built_in">pop_front</span>();</span><br><span class="line">                q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                vis[a[now]]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(sta[i].<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">                    vis[sta[i].<span class="built_in">front</span>()]=-i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">            sta[i].<span class="built_in">push_back</span>(a[now]);</span><br><span class="line">            <span class="keyword">if</span>(sta[i].<span class="built_in">size</span>()==<span class="number">1</span>)vis[a[now]]=-i;</span><br><span class="line">            <span class="keyword">else</span> vis[a[now]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        now++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    now=<span class="number">1</span>,em=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        q.<span class="built_in">push_back</span>(i),q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">work</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos=now+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos&lt;=m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[a[pos]]&lt;<span class="number">0</span>||a[pos]==a[now])<span class="keyword">break</span>;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[pos]==a[now])</span><br><span class="line">        &#123;</span><br><span class="line">            ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=now+<span class="number">1</span>;t&lt;pos;t++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> i=vis[a[t]];</span><br><span class="line">                <span class="keyword">if</span>(i)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                    sta[i].<span class="built_in">pop_back</span>();</span><br><span class="line">                    q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    vis[a[t]]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop_front</span>();</span><br><span class="line">                    ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                    sta[i].<span class="built_in">push_back</span>(a[t]);</span><br><span class="line">                    vis[a[t]]=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">            now=pos+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">1</span>,top=sta[-vis[a[pos]]].<span class="built_in">back</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=now+<span class="number">1</span>;t&lt;pos;t++)</span><br><span class="line">                <span class="keyword">if</span>(a[t]==top)cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,-vis[a[pos]],<span class="number">0</span>&#125;; </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=now+<span class="number">1</span>;t&lt;pos;t++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> i=vis[a[t]];</span><br><span class="line">                    <span class="keyword">if</span>(a[t]==top)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,-vis[a[pos]],<span class="number">0</span>&#125;;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                        sta[i].<span class="built_in">pop_back</span>();</span><br><span class="line">                        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                        vis[a[t]]=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">                        q.<span class="built_in">pop_front</span>();</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                        sta[i].<span class="built_in">push_back</span>(a[t]);</span><br><span class="line">                        vis[a[t]]=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">2</span>,-vis[a[pos]],em&#125;;</span><br><span class="line">                sta[-vis[a[pos]]].<span class="built_in">pop_front</span>();</span><br><span class="line">                sta[-vis[a[pos]]].<span class="built_in">push_back</span>(a[now]);</span><br><span class="line">                vis[a[pos]]=<span class="number">0</span>;</span><br><span class="line">                vis[a[now]]=vis[top];</span><br><span class="line">                vis[top]=-vis[top];</span><br><span class="line">                now=pos+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=now+<span class="number">1</span>;t&lt;pos;t++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> i=vis[a[t]];</span><br><span class="line">                    <span class="keyword">if</span>(a[t]==top)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,-vis[a[pos]],<span class="number">0</span>&#125;;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                        sta[i].<span class="built_in">pop_back</span>();</span><br><span class="line">                        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                        vis[a[t]]=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">                        q.<span class="built_in">pop_front</span>();</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                        sta[i].<span class="built_in">push_back</span>(a[t]);</span><br><span class="line">                        vis[a[t]]=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,-vis[a[pos]],<span class="number">0</span>&#125;;</span><br><span class="line">                vis[a[now]]=-em;</span><br><span class="line">                sta[em].<span class="built_in">push_back</span>(a[now]);</span><br><span class="line">                q.<span class="built_in">push_back</span>(em);</span><br><span class="line">                sta[-vis[a[pos]]].<span class="built_in">clear</span>();</span><br><span class="line">                em=-vis[a[pos]];</span><br><span class="line">                vis[top]=vis[a[pos]]=<span class="number">0</span>;</span><br><span class="line">                now=pos+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(tot,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i].op,<span class="string">&#x27; &#x27;</span>,ans[i].x);</span><br><span class="line">        <span class="keyword">if</span>(ans[i].op==<span class="number">2</span>)<span class="built_in">write</span>(<span class="string">&#x27; &#x27;</span>,ans[i].y);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;meow.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;meow.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP 游记</title>
    <url>/2022/11/24/NOIP%20%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>与诸君共勉。</p>
<span id="more"></span>
<h4 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h4><p>上午考试，T1 做了很久，后面的题也没时间想解法，关键 T1 大样例很水，又挂了分，有点爆炸。</p>
<p>NOIP 就在眼前了，有时候感觉自己或许也比以前进步了很多，但还是达不到真正有水平。我还在犹豫什么呢？我曾经觉得这些考试决定了我人生的轨迹。而我，如今，和各位前途光明的 OIers 坐在同一个机房，并试图说服自己也是他们中的一员，却不断地在空想中迷茫。</p>
<p>可至少和大家一起还是很快乐的吧？大不了考完就退役滚去学文化课，似乎也没什么了，只不过我还是很喜欢 OI 罢了。</p>
<h4 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h4><p>感觉自己很颓废，机房里大家都在耍。而我只是颓废得很，简直不知道干什么。早上 T1 又挂分，在垫底间徘徊。又在洛谷上开了个之前讲过的题，想不出来解法了。这时才感觉到自己真的是废物一个。</p>
<p>晚上打算复习一下板子，其余就都没了。</p>
<h4 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h4><p>睡得不太好。做完核酸就去考试。</p>
<p>开题，T1 形式化的题面让人感觉很不友好，把全部题看完还是决定按照顺序开题。</p>
<p>T1 按照每一列来算，乘法原理计算就可以了，9:20 才写完，然后看 T2。感觉很阴间，想了一个似乎正确的做法，然后感觉比较难写。实际开始写的时候感觉比想象中难写一百倍。写了 20 min 连第一步怎么处理的没写完。决定看后面的题。</p>
<p>然后发现 T3 暴力也不太好写，只有 T4 数据结构题暴力比较好写。</p>
<p>当时已经知道 T3 大概是个边双 + 树形 DP，感觉可能比较难做。但是做出了本场最错误的决定——我选择猛冲 T2，直接放弃 T3。</p>
<p>然后就寄了，甚至连 $k=2\times n-2$ 的解法的写对没有都不清楚，也没时间写 SPJ 了。12:50 写完乱搞，最后检查一遍就结束了。</p>
<p>最后走出了考场，大家都想骂出题人。机房里除了 Dyd 和 mydcwfy 都考得不尽人意（毕竟只有这两位神仙看出来 T3 并不困难），Dyd T1 挂分但是 T3 切掉了，mydcwfy T3 挂分但是 T4 84pts。</p>
<p>那么我呢？甚至 T1 忘记乘上 $c,f$ 一定会挂 7pts，而且前缀和数组在做乘法的时候忘记强制转换了，被 InfOJ 卡到 64pts（InfOJ 的数据真的很强！）。T2 T3 都报零，T4 20pts 暴力。</p>
<p>InfOJ： 64 + 0 + 0 + 20 = 84 pts</p>
<p>luogu：93 + 0 + 0 + 20 = 113 pts</p>
<p>考完感觉整个人都是处于红温状态，回寝室睡得也并不好，</p>
<h4 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h4><p>早上起来整个人都是恍恍惚惚的，昨日仿佛如梦一般，我所认为的很重要的一天就过去。</p>
<p>如果我 T1 没有挂分，看出来 T3 比 T2 更加可做的话，结局是否会改变呢？我得不到答案，我觉得我的水平仍然未达到我想要的高度，仍然不能使我自己变得足够优秀。我只能尽力提升自己，并且希望，能够在明年此时，不会因为当初做的决定而后悔。</p>
<p>新的一天又开始了呢。。。</p>
<h4 id="Day-2-8"><a href="#Day-2-8" class="headerlink" title="Day 2~8"></a>Day 2~8</h4><p>在学文化课，摆了很多常规作业，感觉有点累（NOIP前都没有这般感觉），不知道为什么突然十分迫切地想要放假回去休息。</p>
<p>其实也想明白一些事情吧，或许当我有一天也离开了 OI 这门我所热爱的学科，我也会继续有着自己的生活，继续走着自己的路，只是从万千平凡的 OIer 变成万千平凡的 whker。回忆仍然让我们感到快乐。</p>
<p>分数也不重要了，反正 1= 肯定没戏了。更重要的是好好地走完这一段不知长短的路。</p>
<h4 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h4><p>出分了。没什么感觉。</p>
<p>总分： 93 + 0 + 0 + 20 = 113 pts</p>
<p>一等奖线就是 120 pts，而我差的就是那挂掉的 7 pts。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>我们的故事仍未结束，甚至，才刚刚开始。。。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>Nobody tells.</title>
    <url>/2023/05/01/Nobody-tells/</url>
    <content><![CDATA[<p>5 月 1 日闲话。</p>
<span id="more"></span>
<p>“意义“的问题总是无可避免的。事物的意义是我所赋予的，但是为什么如此模糊而又矛盾？本心是否也会自相矛盾？但是他却告诉我要坚持本心。对一次一次的一乐后的空虚落寞感到懊恼，更加不明白自己到底想要什么。现在还是未来的现在？过去不断交织，我不懂，反而越发沉迷于那些遗憾与快乐。照镜子的过程中逐渐变成不敢直视自己的魔鬼 。</p>
]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP 2022 全题解</title>
    <url>/2023/03/10/NOIP-2022-%E5%85%A8%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>隔了好久好久。。。</p>
<span id="more"></span>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>题意：给定一棵 $n\times m$ 的 01 矩阵，问有多少个由 1 组成形如 <code>C</code> 和形如 <code>F</code> 的图案。</p>
<p><code>C</code> 与 <code>F</code> 做法是类似的，此处只讨论 <code>F</code>。</p>
<p>考虑处理出每个位置向右延伸以及向下延伸的最大值。再枚举每一列统计答案即可，时间复杂度 $\mathcal O(nm)$。</p>
<p>最后注意乘上给定常数 $C,F$。<del>（警钟敲烂）</del></p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p><a href="https://kevinlive.github.io/2023/03/13/LOJ-3897-%E3%80%8CNOIP2022%E3%80%8D%E5%96%B5%E4%BA%86%E4%B8%AA%E5%96%B5/#more">在这里看</a></p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p><a href="https://kevinlive.github.io/2022/12/05/P8867-NOIP2022-%E5%BB%BA%E9%80%A0%E5%86%9B%E8%90%A5/#more">在这里看</a></p>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>题意：给定两个长度为 $n$ 的序列 $A,B$。有 $q$ 次询问 $l,r$，每次询问 $\sum_{l\le p\le q\le r} \max_{i=p}^q A_i\times \max_{i=p}^q B_i$。</p>
<p>考虑将询问离线下来，对右端点 $r$ 直接扫描线，每次将其放进单调栈里，找到最远能影响到的位置。继而维护前面每个位置的答案。</p>
<p>现在就相当于需要维护答案的历史版本之和。我们需要支持三种操作：</p>
<p>1.将 $a$ 区间滚平为 $x$；</p>
<p>2.将 $b$ 区间滚平为 $x$；</p>
<p>3.每个位置加上 $a_i\times b_i$。</p>
<p>但是具体如何用线段树维护？线段树节点上我们需要维护答案 $sum$，以及 $sumx,sumy,sumxy$ 表示 $\sum x,\sum y,\sum xy$。tag 上我们需要维护 $sx,sy$ 表示区间滚平，以及 $addx,addy,addxy,addz$ 表示 $sum’=sum+addx\times sumx+addy\times sumy+addxy\times sumxy+addz\times len$。tag 的意义即为当前节点的 $sum$ 需要加上 $sumx,sumy,sumxy,len$ 分别乘上其 tag 上所对应的系数的和。根据这个意义可以写出 tag 的合并方式。需要注意到是要先累加后滚平。具体代码可以看 <a href="https://loj.ac/s/1720904">https://loj.ac/s/1720904</a> 。还有一种写法即为写成矩阵的形式，不过常数会大一些。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>OI日记</title>
    <url>/2022/08/19/OI%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="82b061bf5d41fd73ab16e86af5850707b8a44a8cd317a5bc4514474dbb28648a">6333146992d1960170704a0dfad69583847809dc3c2f675101e538cf9f82e80b8e5664514d76bd3dcb241ed48fd6185c9939373ed1a1dbc349457a49a9845b3d7b0b3bb7bd3aae5d34db10b20a9ae31ecc37009465aabd291eac1ef74b7fa48edbce0fb02e9ce0d0bd3a51d664d58e5baeddc23d3f7ada7c06c4fbf655b4dd1cc26aca7a95cc6e00efde7202aa065cf25dd2662733f183c90a437089b031167f2b544d344976df9cf245f7a22bd73b5337ae8684c25f5aaf660e5d844aca7a6281de19ac568f89096f87838af6b10d49378049f6ce6be60c6e403a683128a54f5c1dea17ee777af3a9abff9e57cacb347e556a6f5153f12450264250e163fd7aee2b57cb3b53c436f645fbc3a8f967c84d8ba4866c672ef8c0d3bd508036ad8f86646751ef3f21e2807c7c3c3d0aab571c8ad5cff4efa62943bb0742545f3b7ad5766dd666ef8c29240534645429a87da63eb9c94c038d7c85831cb0019790e5d3a98495f07f6bb97a00831eed7c5c9b568e0b062fb892e5a6ecb69b95566e09e5a5f0c8fbfe8c4920eef4e71f35043742b1a923a7600b4f7f0fb2e7af0287e92dd56cd8296261c524e91139225217eb1adb19677429f22431370444f4265f15ec37cb250009d90007316056c01970ea70cfc2f08990ba056666924b2cfcb852b4a651a22e908cc9a8bfe13fb77278423c6dc372efc8a63ff6a4dcf7d634baef612a55b4a7e9374b29cf8888c8197d6c7c2610b967ee928433af1899b61927f351d2a7b3b9b5982178b8e98c1f26b72cac96edab3f41f92e80d4b41782bbe3355e9f247e842d8040821849f50b328e60e4b75f730ede876bb0fa0f1256b034ed6bb219c07bce968991a36681a7d775e9ddde41c30e1caa7759d8e359cc3ad2b73abcdd9bf3eb213b694089090717c1d62c2f6f28100995933c7b52cb021180b9894a4b1881324a1e32ff1d0b96e1980bf5c64d2782c350d7b4824cb09a9b11658f0c9e90d24822ba670d6eb90efb2d9ada102a5d0dc7c2a881da74669da6bcb50a9c1c7195c59cdcdcf51d29373a68f4dd1da9799495f8adf70f909c32f7b7f077039e0a0325fbe597086c65ebb45c480947ef62f4d566e97e409b7b2a8e368ef31019f35a5bd6220cb390faad09d0a24365fa0d73be805ac04fc9ba3a5242a876ce5ee811b643a6a1047ae953ab147ceb17afbce669a28f7c7fc595bb86955e0cd2092859c14e27f9c4b307ea11746c82b4046c8a3ebb2ba102a8dd2cb6361cf76caa2c1bd36082f05d31d942573abb4bf37b85800601f7f418a6dfaae8da84a06b4b1cd9a3a916a8948ad98e7d7e77ba21d1d0da4d395ac381c37f0de923f51bd59186eafedcc6db350ebe143befc5702727d2ee88f6c89e65dda5379d971cf35165568518e4e0d5f843618d1d5008cceca7f39e6314e771ede8110ebcfcb0ef3a3faecc95b58e53de56dee49d11cafa6ba5ab00e5c82f229e16f3f23d00cf72811c898ba551fcf3b8be3a184a6d4b429a488511a5c54f40dd4b3bf429eff446404110ad925b31d2f51ff7449a229806db591f7f2b4e7a01312b8cbd49ee5f23d611f87d6e800bd7099f770698c7a7e2a9e01ad5b699ac9502207554351efd44dac8d77befec67d817e5b100dbd24e7235d854096faffe4c87074066686b4a405ba5645ae9ec798854904b2da750adc4db67dbaeeebe0765b7596dc10cff8e16d106951bedfdf53b91e523d39a0f0114ea0d6ac45d12455b78162aa74791000b57ca3c3a26234da476fb3e09c49cb13388579c198af2c6693457e96a297ea23fa8dfd4398c466970793facc9eb34ae377eaf9a291694f37d698b76f2ba13b1871f07c37ee02169db02f5c5d1fe0b59bbc9edbdabad3161807fa3af1e59a87571d3af1c3e7d302d709449ecb23ace8757d4af48e85656fb62cc64cce2561bdccd9c3ddc66ca1c43d81cafb93f1d230284da30728cd0e8ded5613df6b54b6fcb0119f41acb1e4433c2aca8acfb9592ec62c74b01d63f2f4bfb0df2268807a548be90353642f8924ed24d974825b04ca18dccaf40db4ceffbceaca7b22b23a3926bafd3f57cf1f515d797962ec16d8102ca8858f04968d7f599e6ad600820f0bb4f7c8b668cb3e872dfd365bc98a5b651cfa4da73a7bd467843fdb55a56ae616511fac7452aad76b2bdbc3289e2489a0dd7c34cc3068cbae758a92ce7b1a8c01f09096f7b4870bd5f339c97a34f9521aed2cd55c02d3441aa2917ed09f728e70801ff4ef2c19de2185f46b03a1733156c3e38e1f00faecd100d21569e9dfd9afcd137672d55bc4f911b8216138157fd4bfd821e09f750075ba12e37ce6f50933c30721627250ecaabd9b22f5de13fea6a4fb29f5090400acb95154c35fb0829f9f375394e6aa4ae99ddf1a18dc4b40fc50d638a70940499543fcc22381e6d826dd14c67093d86cda16cd33dd617a7005f92afb5f7c432756a0c711e22f3773cab0e00765bad80dde64e91956f82cbe8997012f9804e85627ae0bcd6d29c3fbd14e6e9651bcabeb2210668ce572403e2d61e579d4063118682b849c3caa992f4627fee4c3bee664f34591602265783940f73ffbd85d497709f4b9813106a041f173794004cc560d96ac66e7536a8dcc49bdc48bd55eb334fef62bdf96890d512845892e4cbccd62bceed7b38656db14481625bb41234c1b8b99954770462b9148f4448afa53fd685cee0c07316494896fbf883c1ffeb48bdebfbbf480b9f671b925ad797b2016bd48c33ed4a23b7263155b894eb6744e68a83f37abd7405cec637831cf562c957a95e18f98b3f37d75283a6bbb544f484fafa32529eaf90032dff6c4c3af86e24ddf33748025cf474be5a7ee7182ac6b95bc773d11d5fe0b983a5623e18bf1bc0c64aad58ce4ff596e6e2f5bf762ecec7ef8becf5bf8affb485ea5177b24f01bff0e84a3d48bf160deef5a7626cc4e1fe429e091767a2ddab241930cf6c05672593dfc451740b9dec677d4f2c7becb95c9772642410732ba574cef481a3d51f95f87e158fcd24fda4584b87dfef30d9bf0b89f935e8df49b691d28e9d13c1e017f397626f636aacbd107f67b4b0ccb644c78a37dc4bfdd35c1f0908be894d32abadfd700881baf8de0f91523000649a96bfcd8ba11916664f53e3158f35033a4ffc0ceffffd15cda492d0647628a92fa0979c16d7cbd38838ff93a35d0906bdca177d466052635d562571addec8334a495d56d3a5611ef3317518770fe35bcb47a9245f48f3d3c398a465fdf91f1f0a43b3bfc7458a6675ce713be4c97ab89c6af26967c63708f7bcb43a77f1785dcd4455e96bbc1a08fbbe18806ece9b450760a6aa081aefc8cec8428f227451c22e1fa4a92f8cd757db7ef0fc3b92da5e9be13b6c3abad2623b3b54dfd6cd99659656373a88ae952a422b172aabe5561812ac7dfed78024cb2f7a3c9c8714d44317c46e5421c62cce5278e5f8204765d20df77c1cac16aed0baf02f715be4d5925e2a0dce13559418d1a6ef417477d81becff17c7707f3a29bf9092a37cf434b74675e0ea2f9e4ddd900c122b91a8eca90c76cd148d9f782a3824dcf5c66cb329652f2bdb71a01f400d58b86756f676bdcc8ecaf9c84e918dfdd4849dc62bc88f9b5904a7e2ee458708995325ff47c38ddd57b7696f5c5ed9a0992ae71fecc824d92e5e7d5330060cd6d693abad65f11985577a68fdf00444d826869c613dcfa01096a37294518ccff35b36f749a137245db78848d166bcc7cbc347f151ebdc6c1fa5c7564a2f617452b3736109ffbf064cd0beb87056e28bef905d9ac7a50635b9091a3a2f2f3b094360370f7d4a07b1f31f4924e97c6c0bfdb9135e72f3cf5f899e5232ed5cbac9f8cefb87cc51c9df5251a7fcdc080df387545d8e6b4cabde3343c358a5a7c0a4a40fe6f13fe054c5f3b97fc8ed60278bfafc752486ebc178d73ef4fa2c30e6e83e2df1b90c71479e7ab4c3c03b364085c0ddaa79d7bd09db8f5e38dc45743ba574f1fc9269e4245e126b33f91ffae6bc23282ab3a4ddc64458b6fbd80f79e2fca8a21b7369fd89f8b1452429a3eeda617e1d73ca5f9c9f3b3faf086d61699ccc2bbc949c0b1867b36c808a95715bea3ad2f2595de031e34115277d0f83e7333763f29513fed211287d1dc76f49ee5ca5bbc40379aeb42de63575485d299e546e98567f797ea5329f59b6ecf60c9bdfcb410def89a51963e07357c35f4a688c2fc26eaef80d246e97880a8fbf192cd9ead918cc1240da6295e293be01e2ae95620a2ee78d4d01c32d72e2118e635eab1f1b683345530e0b465fb4352eb76768c6976fd61742382e0591e379f203b80fa4a5bdcd849b3fb3078fb630adfcc50c300c8592a87d116ae534e4d679cd1eee9b4a478088faed079c811373aa4d2445532ce54a2a03b4b138e5080ab9d4d41787a52a9ecc517dc8f9aa166e34f7783b7dd07f42eecf81efae51fef3c2e60e17408b8aaeed22f7e1273c076e04ce84c959494ab17fb4c48b82e9ed5e37eb2075f693d1203c628aca26f0282df523b9ce9b3d669c9491a27d568c10137784c1c79e88d9e3d95a97fb0c2975fc06a52f524f8e0b621fa3ee2525b33f378ea8881e7871a5cc098434796d8ce29a3c7fd391442bcade23e9c339014e3112ca47f96d1b16f4458c6464ad18cc92af4011374f02aa9c96f29bec2674970285e912594e90736c41872bf1582ac298b5295090508fab8d297665926ab053da7beed292fc423665a5ab8a17d30097258a662e14220f7c3e63335055e47afd56a5db8ce09b5c0f496cb74fd713d64f71d18a14c8d6a4668db24a127ca111cbe6fa507658bdd7341cafb7906647f9f51c7f540d4022362c6db5c4869ce770d8514408dd66f1516a81c3601c9ab92f841a7853fb31b008c7279a14c478135756160d69d2be43dfe9883b4ceac91febcb53ad49f336211a01aa647f28190e169ead2e6c63cd39e10a02ffc9de9a95b4aa92c2773b66ac7a184bd228924e4a4bf5a1b5d8e8967e50b43d385b851f47061b8f9ec09a2bf6c72f6e2d552821523f46911e562ff275170463481eb997828e8d3b02284a52c62504ad7818975a2aae8c85ed22a9fc312114ab30b6de118fe08d2e9735f68daa447fd439c855773f292d94f83b996bbd1160ebc11c986130b7338c182e38ba8dcbcb4d91a218d73591166000bfa4acf23ab14c9616e77963ec8397c51defa86f2898afcff66d1c9e99bdc8392f5523ce6d82df9bdfff5dbf45f0042b10abae0b1884ae7e343e7f3ebcb9361b5aa24d6ce621796e16a1c4f83ff5ebd1886e08f5209d084d5737ee0a249d9cdb0fae53e27822f35ea100a6fda84f1563d15189b8c64a899932f33c8b8bcb95b351efcdccd5af8995ebac7c3eadf29e4b1366cd36c7de8c25a2edcddd583f6f57d6f728ff77215f1f0973831c501e6558bcbd27d1f4c93ef8cb9913eb51571d4313d45f322aa8ccfad529b04105c9f9df86e6b0d74e815b9a611952d0d2c7b70c7edac0be77aa20d923d23bfe487dab1b74b4eb601330eef4a2c4e0aed381920886dfca68fb28ff5216ccde2716335473df23b96b404cbf8b23c3bc4ef11c72c9d63ca0d6b8dc9d0d1d6da0bd45a451b81238f6b1b050b23f2a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">? 竞赛 : 生活</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>P1829 [国家集训队]Crash的数字表格 / JZPTAB</title>
    <url>/2023/01/05/P1829-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC-JZPTAB/</url>
    <content><![CDATA[<p>不错的莫反练手题，可以说把大部分套路都涵盖了。</p>
<span id="more"></span>
<p>不妨令 $n\le m$，让我们求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{j=1}^{m} \text{lcm}(i,j)</script><p>先转换为我们熟悉的 $\gcd$：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{j=1}^{m} \frac{i\cdot j}{\gcd(i,j)}</script><p>枚举 $\gcd(i,j)$：</p>
<script type="math/tex; mode=display">
\sum_{k=1}^{n} \sum_{i=1}^n \sum_{j=1}^{m} \frac{i\cdot j \cdot [\gcd(i,j)=k]}{k}</script><p>变换为 $[\gcd(i,j)=1]$ 的形式：</p>
<script type="math/tex; mode=display">
\sum_ {k=1} ^ {n} \sum_ {i=1} ^ {\lfloor \frac{n}{k}\rfloor} \sum_ {j=1} ^ {\lfloor \frac{m}{k}\rfloor} {i\cdot j \cdot k \cdot [\gcd(i,j)=1]}</script><p>根据经典式子 $[\gcd(i,j)=1]=\sum\limits_{d|\gcd(i,j)} \mu(d)$，进一步得到：</p>
<script type="math/tex; mode=display">
\sum_ {k=1} ^ {n} \sum_ {i=1} ^ {\lfloor \frac{n}{k}\rfloor} \sum_ {j=1} ^ {\lfloor \frac{m}{k}\rfloor} \sum_{d|\gcd(i,j)} \mu(d) \cdot {i\cdot j \cdot k }</script><p>把 $d$ 提到前面去，尝试枚举 $d$：</p>
<script type="math/tex; mode=display">
\sum_ {k=1} ^ {n}  \sum_{d=1}^{\lfloor\frac{n}{k}\rfloor} \mu(d) \cdot k \cdot d^2\sum_ {i=1} ^ {\lfloor\frac {n}{kd}\rfloor} \sum_ {j=1} ^ {\lfloor\frac{m}{kd}\rfloor}{i\cdot j}</script><p>把 $kd$  看做一个整体，设 $kd=T$，又得到：</p>
<script type="math/tex; mode=display">
\sum_ {T=1} ^ {n}  T\sum_{d|T}\mu(d) \cdot d\sum_ {i=1} ^ {\lfloor\frac {n}{T}\rfloor} \sum_ {j=1} ^ {\lfloor\frac{m}{T}\rfloor}{i\cdot j}</script><p>最后面是个等差数列求和，并且可以整数分块做。考虑如何求 $f(x)=\sum\limits_{d|x}\mu(d)\cdot d$，很容易知道这是个积性函数，考虑在线性筛的过程中如何求，设 $x=i\cdot j$ ，其中 $j$ 为 $x$ 最小的质因子：</p>
<p>1.$x\in \text{prime}$ ，$f(x)=-x+1$。</p>
<p>2.$j$ 为 $i$ 的质因子，那么 $j$ 对 $f(x)$ 是没有贡献的，$f(x)=f(i)$。</p>
<p>3.$j$ 不为 $i$ 的质因子，那么根据积性函数的定义，$f(x)=f(i)\cdot f(j)$。</p>
<p>时间复杂度 $\mathcal O(n+T\sqrt n)$，$T$ 为询问总数，<del>不过洛谷上这道题只有一个询问</del>。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>,mod=<span class="number">20101009</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> cnt,prime[N],vis[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            f[i]=mod-i+<span class="number">1</span>,prime[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;<span class="number">1ll</span>*i*prime[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                f[i*prime[j]]=f[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i*prime[j]]=<span class="number">1ll</span>*f[i]*f[prime[j]]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">       f[i]=<span class="built_in">adj</span>(f[i<span class="number">-1</span>]+<span class="number">1ll</span>*f[i]*i%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1ll</span>*(x+<span class="number">1</span>)*x/<span class="number">2</span>)%mod*(<span class="number">1ll</span>*(y+<span class="number">1</span>)*y/<span class="number">2</span>%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=<span class="built_in">min</span>(n/(n/l),m/(m/l));</span><br><span class="line">        res=<span class="built_in">adj</span>(res+<span class="number">1ll</span>*<span class="built_in">adj</span>(f[r]-f[l<span class="number">-1</span>]+mod)*<span class="built_in">sum</span>(n/l,m/l)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span>(N<span class="number">-10</span>);</span><br><span class="line">    T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(n,m);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;m)<span class="built_in">swap</span>(n,m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(n,m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>P2048 [NOI2010] 超级钢琴</title>
    <url>/2023/05/09/P2048-NOI2010-%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4/</url>
    <content><![CDATA[<p>经典题。</p>
<span id="more"></span>
<p>需要求出前 $k$ 大的长度在 $[l,r]$ 之间的子段和。需要考虑如何删去已经选过的子段。将每个点 $p$ 单独对应一个候选区间 $[l_p,r_p]$，设 $x$ 该区间中的最优解的位置贡献为 $sum[x]-sum[p-1]$，$sum[]$ 为原数组前缀和，$x$ 可以通过 ST 表 查询区间最大值的位置得到。选取之后考虑将候选区间 $[l_p,r_p]$ 分为 $[l_p,x-1]$ 和 $[x+1,r_p]$，这样就不会取到重复的区间了。整个过程用优先队列来维护，选 $k$ 次即可。时间复杂度 $\mathcal O(n\log n+k\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,K=<span class="number">21</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k,l,r;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">int</span> st[N][K];</span><br><span class="line"><span class="type">int</span> Log[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p,l,r,x;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;t)<span class="type">const</span>&#123;<span class="keyword">return</span> sum[x]-sum[p<span class="number">-1</span>]&lt;sum[t.x]-sum[t.p<span class="number">-1</span>];&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Node&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)st[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=Log[n];j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">            sum[st[i][j<span class="number">-1</span>]]&gt;=sum[st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]]?st[i][j]=st[i][j<span class="number">-1</span>]:st[i][j]=st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=Log[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> sum[st[l][t]]&gt;=sum[st[r-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>][t]]?st[l][t]:st[r-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>][t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k,l,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+x;</span><br><span class="line">    &#125;</span><br><span class="line">    Log[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)Log[i]=Log[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-l+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> L=i+l<span class="number">-1</span>,R=<span class="built_in">min</span>(i+r<span class="number">-1</span>,n);</span><br><span class="line">        q.<span class="built_in">push</span>((Node)&#123;i,L,R,<span class="built_in">query</span>(L,R)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Node now=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=sum[now.x]-sum[now.p<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(now.x&gt;now.l)q.<span class="built_in">push</span>((Node)&#123;now.p,now.l,now.x<span class="number">-1</span>,<span class="built_in">query</span>(now.l,now.x<span class="number">-1</span>)&#125;);</span><br><span class="line">        <span class="keyword">if</span>(now.x&lt;now.r)q.<span class="built_in">push</span>((Node)&#123;now.p,now.x+<span class="number">1</span>,now.r,<span class="built_in">query</span>(now.x+<span class="number">1</span>,now.r)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>ST表</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P2505 [HAOI2012]道路</title>
    <url>/2022/03/05/P2505-HAOI2012-%E9%81%93%E8%B7%AF/</url>
    <content><![CDATA[<p>最短路 DAG。</p>
<span id="more"></span>
<p>首先，我们很容易知道：$i\to j$ 的最短路径的任意子路径 $u\to v$ 都是最短路径，接着我们可以得到另一个结论：若存在一条子路径 $u\to v$ 不是最短路径，那么很明显可以找到一条更短的 $u\to v$ 使得 $i\to j$ 更短。根据这个原则，我们可以得出在固定源点下，存在 $G$ 的一个子图 $G’$，使得 $G’$ 的每一条边都在 $S$ 到其他至少一个点的最短路径上，且 $G’$ 以外的边不在 $S$ 到任意一个点的最短路径上。这里把称 $G’$ 为源点为 $S$  时 $G$ 的<strong>最短路图</strong>。而求出最短路图的方式很简单，就是如果有 $dis_{v_i}=dis_{u_i}+w_i$，我们给这条路打上一个标记就行了。</p>
<p>容易得到这个最短路图是无环的，我们就可以在<strong>最短路图</strong>上进行<strong>拓扑排序</strong>。考虑维护两个数组为 $cnt1_i$ 与 $cnt2_i$ 。接着我们考虑正反两次拓扑分别表示 $i\to u$ 和 $v\to j$ 的最短路径条数，而答案就为 $cnt_1({u_i})*cnt_2({v_i})$ 之和。</p>
<p>使用 Dijkstra 的话时间复杂度应该是 $\mathcal O(nm\log n + n^2)$，只不过这里用了 SPFA。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1500</span>+<span class="number">10</span>,M=<span class="number">5000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> u[M],v[M],w[M];</span><br><span class="line"><span class="type">int</span> dis[N],vis[N];</span><br><span class="line"><span class="type">int</span> flag[M],ans[M];</span><br><span class="line"><span class="type">int</span> len,top[N],deg[N];</span><br><span class="line"><span class="type">int</span> cnt1[N],cnt2[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[now]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[to]&gt;dis[now]+e[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to]=dis[now]+e[i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[to])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[to]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(dis[v[i]]==dis[u[i]]+w[i])</span><br><span class="line">            flag[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">memset</span>(cnt1,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt1));</span><br><span class="line">    <span class="built_in">memset</span>(cnt2,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topo</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(flag[i])deg[v[i]]++;</span><br><span class="line">    cnt1[s]++;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        top[++len]=now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> to=v[i];</span><br><span class="line">            <span class="keyword">if</span>(!--deg[v[i]])q.<span class="built_in">push</span>(to);</span><br><span class="line">            cnt1[to]=(cnt1[to]+cnt1[now])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=top[i];</span><br><span class="line">        cnt2[now]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=head[now];j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> to=ver[j];</span><br><span class="line">            cnt2[now]=(cnt2[now]+cnt2[to])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">SPFA</span>(s);</span><br><span class="line">    <span class="built_in">topo</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(flag[i])</span><br><span class="line">            ans[i]=(ans[i]+cnt1[u[i]]*cnt2[v[i]])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">        <span class="built_in">add</span>(u[i],v[i],w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>P3177 [HAOI2015] 树上染色</title>
    <url>/2022/09/03/P3177-HAOI2015-%E6%A0%91%E4%B8%8A%E6%9F%93%E8%89%B2/</url>
    <content><![CDATA[<p>树上背包。</p>
<span id="more"></span>
<p>从前，我一直认为树上背包是 $\mathcal O(n^2m)$ ，直到这道题，才知道树上背包可以做到 $\mathcal O(nm)$ 的qwq。。。</p>
<p>状态很明显是 $f_{x,i}$，表示在 $x$ 为根的子树中选取 $i$ 个黑点得到的最大贡献。很明显我们不能直接计算，而是应该计算每条边的贡献，计算每条边被路径覆盖的次数并乘上其长度。</p>
<p>考虑覆盖次数。 $cnt=k\times (m-k)+size_y\times (n-m-(size_y-k))$，表示 $x$ 的儿子 $y$ 中选取 $k$ 个黑色节点时，$(x,y)$ 的覆盖次数，这很容易理解。然后就树上背包即可。</p>
<p>注意需要先转移 $k=0$ 的状态。还有需要注意不可行的状态，判一下边界即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,M=<span class="number">4e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> si[N];</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">min</span>(si[x]+si[y],m);~j;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="built_in">max</span>(j-si[x],<span class="number">0</span>);k&lt;=<span class="built_in">min</span>(si[y],j);k++)</span><br><span class="line">            &#123;</span><br><span class="line">                ll cnt=k*(m-k)+(si[y]-k)*(n-m+k-si[y]);</span><br><span class="line">                f[x][j]=<span class="built_in">max</span>(f[x][j],f[x][j-k]+f[y][k]+cnt*e[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    m=<span class="built_in">min</span>(m,n-m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>P3571 [POI2014]SUP-Supercomputer</title>
    <url>/2022/06/16/P3571-POI2014-SUP-Supercomputer/</url>
    <content><![CDATA[<p> 可以用堆做到 $\mathcal O(n\log n)$ ，也可以用更加优秀的斜率优化实现 $\mathcal O(n)$。</p>
<span id="more"></span>
<p><a href="https://www.luogu.com.cn/problem/P3571">题目链接</a></p>
<p>考虑按照 $dep$ 分层。记 $cnt_{dep}$ 表示深度为 $dep$ 的点数。考虑从大到小枚举 $k$，将对于每个 $k$ 的最优解都求出来。</p>
<p>在 $k$ 足够大时，显然一次能且仅能选择同一层的点，即 $ans_k=\max {dep_i}$。当某一时刻，$cnt_i&gt;k$，那么我们无法在一次内选择完第 $i$ 层的点，需要将其中 $cnt_i-k$ 个点挪到下一层选取。</p>
<p>题目中限制了拥有父子关系的两个点无法同时选择，我们需要证明只需要将剩下的点向下挪动一层就能够得到合法解。</p>
<p>假设此时 $cnt_{i-1}\le k$。  </p>
<p>我们需要在第 $i$ 次和第 $i+1$ 共选取 $2k$ 个点其中第 $i$ 层选取 $cnt_i$ 个，第 $i+1$ 层选取 $2k-cnt_i$ 个点。  </p>
<p>1. $cnt_{i+1}&lt;2k-cnt_i$：第 $i+1$ 天未取满 $k$ 个点，并不影响结果。  </p>
<p>2. $cnt_{i+1}&gt;2k-cnt_i$：将第 $i+1$ 层多余的点挪向第 $i+2$ 层，这显然是一个相同的子问题。  </p>
<p>3. $cnt_i&gt;2k$：将第 $i$ 层多余的点和第 $i+1$ 层所有点挪向第 $i+2$ 层，这显然又是一个相同的子问题。  </p>
<p>而这 $2k$ 个点拥有父子关系的点对数 $&lt;k$，故一定能找到合法方案。</p>
<p>也可以感性理解，既然当 $k’&gt;k$ 时，被选中的点可以在当层选择，那么挪到下一层就更容易有合法方案了。</p>
<p>由上面的结论我们可以得到，我们始终可以把操作一次多余的点挪向下一层，保证每层的点数 $\le k$，最多有 $n$ 层。  </p>
<p>这个时候暴力维护是不行的，因为我们并不关心多出来的点来自哪一层，我们尝试将多层放在一起合并后维护。  </p>
<p>我们于是就维护的就是一段区间 $[l,r]$，表示连续 $r-l+1$ 天仅选取第 $[l,r]$ 层的点，且一定取完，即 $\sum_{i=l}^r cnt_i\le (r-l+1)\times k$。  </p>
<p>故我们只需要用维护区间，每次将堆顶不合法区间取出，向下合并即可。</p>
<p>时间复杂度 $\mathcal O(n\log n)$ ，比隔壁斜率优化 $\mathcal O(n)$ 要慢，但也算提供新的思路吧。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1&amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l,r,cnt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;rhs)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (ll)cnt*(rhs.r-rhs.l+<span class="number">1</span>)&lt;(ll)rhs.cnt*(r-l+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (ll)(r-l+<span class="number">1</span>)*k&lt;cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> query[N],ans[N];</span><br><span class="line"><span class="type">int</span> cnt[N],dep[N];</span><br><span class="line"><span class="type">int</span> ed[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">priority_queue&lt;Node&gt;q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    	<span class="built_in">read</span>(query[i]);</span><br><span class="line">    ++cnt[dep[<span class="number">1</span>]=<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">int</span> fa;</span><br><span class="line">    	<span class="built_in">read</span>(fa);</span><br><span class="line">    	++cnt[dep[i]=dep[fa]+<span class="number">1</span>];</span><br><span class="line">    	res=<span class="built_in">max</span>(res,dep[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ed[i]=i;</span><br><span class="line">		q.<span class="built_in">push</span>((Node)&#123;i,i,cnt[i]&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1e6</span>;k&gt;=<span class="number">1</span>;k--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(q.<span class="built_in">top</span>().<span class="built_in">check</span>(k))</span><br><span class="line">		&#123;</span><br><span class="line">			Node x=q.<span class="built_in">top</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span>(vis[x.l])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			vis[x.r+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">			res=<span class="built_in">max</span>(res,ed[x.l]=ed[x.r+<span class="number">1</span>]);</span><br><span class="line">			cnt[x.l]+=cnt[x.r+<span class="number">1</span>];</span><br><span class="line">			q.<span class="built_in">push</span>((Node)&#123;x.l,ed[x.l],cnt[x.l]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		ans[k]=res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[query[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>P3600 随机数生成器</title>
    <url>/2023/05/11/P3600-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p>还是 min-max 容斥加 DP。</p>
<span id="more"></span>
<p>相当于求 $\displaystyle E(\max_{i=1}^q \min_{j=l_i}^{r_i} a_j)$，其中 $a_j$ 是值域为 $[1,m]$ 随机数列。最小值的最大值并不好处理，利用 min-max 容斥转化为最小值的最小值，得到 ：$\displaystyle \sum_{T\subseteq S} (-1)^{|T|+1} E(\min_{i\in T} \min_{j=l_i}^{r_i} a_j)$。注意到后面的部分只和区间集合的区间并的大小有关，这个也可以通过 DP简单求出。主要考虑求容斥系数。将并集大小压进状态，设计状态 $f(i,j)$ 表示选取到位置 $i$，并集长度为 $j$ 的容斥系数。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>min-max 容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>P3193 [HNOI2008]GT考试</title>
    <url>/2022/02/18/P3193-GT%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<p>KMP + 矩阵快速幂。</p>
<span id="more"></span>
<p>首先考虑暴力 DP。</p>
<p>设计状态 $f_{i,j}$ 为长串匹配 $i$ 位，短串最多匹配 $j$ 位时的方案数。</p>
<p>易得转移方程式 $ f_{i,j}=\sum_{k=j}^{m-1} f_{i-1,k}\times g_{k,j}$。</p>
<p>很明显 $g$ 数组是不变的，并且可以通过 KMP 预处理出。</p>
<p>这时我们再观察数据范围 $n$ 很大， $m$ 很小并且 $g$ 数组是不变的，于是我们考虑使用 <strong>矩阵快速幂</strong>。</p>
<p>我们的 $g$ 数组就是我们的构造矩阵，此时直接套上矩阵快速幂即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,mod,ans;</span><br><span class="line"><span class="type">int</span> a[maxn],ne[maxn];</span><br><span class="line"><span class="type">int</span> g[maxn][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;<span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in">sizeof</span>(s));&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix a,<span class="type">const</span> Matrix b)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">                c.s[i][j]=(c.s[i][j]+a.s[i][k]*b.s[k][j])%mod;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KMP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=ne[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(a[j+<span class="number">1</span>]!=a[i]&amp;&amp;j)j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(a[j+<span class="number">1</span>]==a[i])ne[i]=j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp=i;</span><br><span class="line">            <span class="keyword">while</span>(temp&amp;&amp;a[temp+<span class="number">1</span>]!=j)temp=ne[temp];</span><br><span class="line">            <span class="keyword">if</span>(j==a[temp+<span class="number">1</span>])temp++;</span><br><span class="line">            g[i][temp]++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">quickpow</span><span class="params">(Matrix a,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        sum.s[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)sum=sum*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,a+i);</span><br><span class="line">    <span class="built_in">KMP</span>();</span><br><span class="line">    Matrix a,b;</span><br><span class="line">    a.s[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            b.s[i][j]=g[i][j];</span><br><span class="line">    a=a*<span class="built_in">quickpow</span>(b,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        ans=(ans+a.s[<span class="number">0</span>][i])%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>KMP</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>P3960 [NOIP2017 提高组] 列队</title>
    <url>/2022/09/15/P3960-NOIP2017-%E6%8F%90%E9%AB%98%E7%BB%84-%E5%88%97%E9%98%9F/</url>
    <content><![CDATA[<p>平衡树的应用。</p>
<span id="more"></span>
<p>我们很容易将模型抽象成有 $n+1$ 个序列，然后我们对其进行区间移动操作。这似乎很容易用平衡树解决。但是发现空间根本开不下。</p>
<p>一个有用的 trick：我们可以尝试用每个节点储存一个区间。我们需要用这个区间中的子区间时，我们只需要将这个区间拆开就行。这样我们可以保证点的个数始终是 $\mathcal O(n+q)$ 的。</p>
<p>实现用 FHQ-Treap 或 Splay 都可以。FHQ-Treap 写起来似乎要简单一点，但是我却因为某个 merge 中变量写反了而调了很久。。。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll l,r;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> val,cnt;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> tot,rt[N],x,y,z;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].cnt=tr[tr[x].son[<span class="number">0</span>]].cnt+tr[tr[x].son[<span class="number">1</span>]].cnt+(tr[x].r-tr[x].l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">insert</span><span class="params">(ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[++tot].cnt=r-l+<span class="number">1</span>;</span><br><span class="line">    tr[tot].l=l;</span><br><span class="line">    tr[tot].r=r;</span><br><span class="line">    tr[tot].val=<span class="built_in">rand</span>();</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y)<span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].val&lt;tr[y].val)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].son[<span class="number">1</span>]=<span class="built_in">merge</span>(tr[x].son[<span class="number">1</span>],y);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[y].son[<span class="number">0</span>]=<span class="built_in">merge</span>(x,tr[y].son[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">pushup</span>(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> k,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> x=y=<span class="number">0</span>,<span class="built_in">void</span>();</span><br><span class="line">    <span class="keyword">if</span>(tr[tr[p].son[<span class="number">0</span>]].cnt&gt;=k)</span><br><span class="line">        y=p,<span class="built_in">split</span>(tr[p].son[<span class="number">0</span>],k,x,tr[p].son[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=k-tr[tr[p].son[<span class="number">0</span>]].cnt;</span><br><span class="line">        <span class="type">int</span> len=tr[p].r-tr[p].l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(res&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> q=<span class="built_in">insert</span>(tr[p].l+res,tr[p].r);</span><br><span class="line">            tr[p].r=tr[p].l+res<span class="number">-1</span>;</span><br><span class="line">            tr[p].son[<span class="number">1</span>]=<span class="built_in">merge</span>(q,tr[p].son[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">pushup</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        x=p,<span class="built_in">split</span>(tr[p].son[<span class="number">1</span>],res-len,tr[p].son[<span class="number">1</span>],y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        rt[i]=<span class="built_in">insert</span>(<span class="number">1ll</span>*(i<span class="number">-1</span>)*m+<span class="number">1</span>,<span class="number">1ll</span>*i*m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        rt[n+<span class="number">1</span>]=<span class="built_in">merge</span>(rt[n+<span class="number">1</span>],<span class="built_in">insert</span>(<span class="number">1ll</span>*i*m,<span class="number">1ll</span>*i*m));</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">read</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(b==m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">split</span>(rt[n+<span class="number">1</span>],a,x,y);</span><br><span class="line">            <span class="built_in">split</span>(x,a<span class="number">-1</span>,x,z);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,tr[z].l);</span><br><span class="line">            rt[n+<span class="number">1</span>]=<span class="built_in">merge</span>(x,<span class="built_in">merge</span>(y,z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">split</span>(rt[a],b,x,y);</span><br><span class="line">            <span class="built_in">split</span>(x,b<span class="number">-1</span>,x,z);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,tr[z].l);</span><br><span class="line">            <span class="type">int</span> x1,y1,z1;</span><br><span class="line">            <span class="built_in">split</span>(rt[n+<span class="number">1</span>],a,x1,y1);</span><br><span class="line">            <span class="built_in">split</span>(x1,a<span class="number">-1</span>,x1,z1);</span><br><span class="line">            rt[a]=<span class="built_in">merge</span>(x,<span class="built_in">merge</span>(y,z1));</span><br><span class="line">            rt[n+<span class="number">1</span>]=<span class="built_in">merge</span>(x1,<span class="built_in">merge</span>(y1,z));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>FHQ-Treap</tag>
      </tags>
  </entry>
  <entry>
    <title>P4841 [集训队作业2013]城市规划</title>
    <url>/2023/01/12/P4841-%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013-%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>所以，到底用没用了生成函数的知识？</p>
<p>upd on 2023.6.6：现在有指数生成函数做法了，<del>不过不在这里，在“生成函数”一文的例题中</del>。</p>
<span id="more"></span>
<p>之前在蓝书上看到过一点这类题的 DP 做法。结果感觉这题的做法有点类似，只不过变成卷积来求，反而跟生成函数没有太大的联系（？）。</p>
<p>设计两个函数 $f(x),g(x)$ 分别表示有标号的无向图和有标号的无向连通图。考虑这类问题的经典套路，固定点 $1$，枚举点 $1$ 所在连通块大小，可以得到关系式：</p>
<script type="math/tex; mode=display">
g(x)=\sum_{i=1}^x {\binom{x-1}{i-1} f(i)g(x-i)}</script><p>显然有 $g(x)=2^{\binom{x}{2}}$，将其带入并做一些变换：</p>
<script type="math/tex; mode=display">
2^{\binom{x}{2}}=\sum_{i=1}^x {\binom{x-1}{i-1} f(i)2^{\binom{n-i}{2}}}\\
\frac {2^{\binom{x}{2}}}{(n-1)!}=\sum_{i=1}^x {\frac{f(i)2^{\binom{n-i}{2}}}{(i-1)!(n-i)!}}</script><p>这就变成类似卷积的形式了，为了更好的操作，我们另外设计几个函数：</p>
<script type="math/tex; mode=display">
F(x)=\frac{f(x)}{(x-1)!}\\
G(x)=\frac{2^{\binom{n-x}{2}}}{x!}\\
H(x)=\frac{2^{\binom{n-x}{2}}}{(x-1)!}</script><p>我们明显有：</p>
<script type="math/tex; mode=display">
H(x)=F(x)G(X)\\
F(x)=H(x)G^{-1}(x) \mod x^{n+1}</script><p>对 $G(x)$ 求逆再和 $H(x)$ 卷积就得到了 $F(x)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,mod=<span class="number">1004535809</span>,G=<span class="number">3</span>,Gi=<span class="number">334845270</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> fac[N],finv[N];</span><br><span class="line"><span class="type">int</span> bit,tot,rev[N];</span><br><span class="line"><span class="type">int</span> g[N],ginv[N],h[N];</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bit=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;(len&lt;&lt;<span class="number">1</span>))bit++;</span><br><span class="line">	tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;bit<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">		x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		<span class="keyword">if</span>(rev[i]&lt;i)<span class="built_in">swap</span>(a[rev[i]],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> g=<span class="built_in">qpow</span>(inv==<span class="number">1</span>?G:Gi,(mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,cur=<span class="number">1</span>;j&lt;mid;j++,cur=<span class="number">1ll</span>*cur*g%mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x=a[i+j],y=<span class="number">1ll</span>*cur*a[i+j+mid]%mod;</span><br><span class="line">				a[i+j]=<span class="built_in">adj</span>(x+y),a[i+j+mid]=<span class="built_in">adj</span>(x-y+mod);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poly_mul</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">1</span>),<span class="built_in">NTT</span>(b,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		a[i]=<span class="number">1ll</span>*a[i]*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> inv=<span class="built_in">qpow</span>(tot,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		a[i]=<span class="built_in">adj</span>(<span class="number">1ll</span>*a[i]*inv%mod+mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poly_inv</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		b[<span class="number">0</span>]=<span class="built_in">qpow</span>(a[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">poly_inv</span>(a,b,(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">init</span>(len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;i&lt;tot;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		c[i]=(i&lt;len?a[i]:<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">1</span>),<span class="built_in">NTT</span>(c,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		b[i]=<span class="number">1ll</span>*<span class="built_in">adj</span>(<span class="number">2</span><span class="number">-1ll</span>*b[i]*c[i]%mod+mod)*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> inv=<span class="built_in">qpow</span>(tot,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		b[i]=<span class="built_in">adj</span>(<span class="number">1ll</span>*b[i]*inv%mod+mod);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;tot;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	fac[<span class="number">0</span>]=finv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod,finv[i]=<span class="built_in">qpow</span>(fac[i],mod<span class="number">-2</span>);</span><br><span class="line">	g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> res=<span class="built_in">qpow</span>(<span class="number">2</span>,(<span class="number">1ll</span>*i*(i<span class="number">-1</span>)/<span class="number">2</span>)%(mod<span class="number">-1</span>));</span><br><span class="line">		g[i]=<span class="number">1ll</span>*res*finv[i]%mod;</span><br><span class="line">		h[i]=<span class="number">1ll</span>*res*finv[i<span class="number">-1</span>]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	n++;</span><br><span class="line">	<span class="built_in">poly_inv</span>(g,ginv,n);</span><br><span class="line">	<span class="built_in">poly_mul</span>(h,ginv,n);</span><br><span class="line">	n--;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1ll</span>*h[n]*fac[n<span class="number">-1</span>]%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>P4707 重返现世</title>
    <url>/2023/05/10/P4707-%E9%87%8D%E8%BF%94%E7%8E%B0%E4%B8%96/</url>
    <content><![CDATA[<p>巧妙的 DP 题目。</p>
<span id="more"></span>
<p>设 $k’=n-k-1$ ，并接下来都是用 $k’$ 。设每种材料被收集的时间为 $t_i$，相当于求 $\displaystyle E(\text{kth}\max_{i=1}^n t_i)$。max 显然不好直接求，考虑 min-max 容斥得到：</p>
<script type="math/tex; mode=display">
E(\text{kth}\max_{ i\in S}t_i)=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}E(\min_{i\in T} t_i)</script><p>其中 $\displaystyle E(\min_{i\in S} t_i)= \frac{m}{\sum_{i\in S} p_i}$。考虑一个暴力 DP，设状态 $f(i,j)$ 表示选择 $i$ 种材料，$\sum_{i\in S} p_i=j$ 的方案数。因为需要每次枚举所有材料。这样的时间复杂度 $\mathcal O(n^2m)$，不能通过。</p>
<p>注意到 $k$ 是很小的。考虑 $k$ 压进去。于是我们直接求容斥系数 $\displaystyle \sum_{\sum_{i\in S} p_i=j}(-1)^{|T|-k}\binom{|T|-1}{k-1}$。因为需要计算 $\frac{m}{f(S)}$ 的贡献，$\sum_{i\in S} p_i$ 还是需要压进状态里，于是考虑设计状态 $f(i,j,k)$ 表示考虑前 $i$ 个数，$\sum_{i\in S} p_i=j$，关于 $k$ 的容斥系数。但是处理组合数似乎令人头疼，尝试利用 $\binom{n}{m}=\binom{n-1}{m}+\binom{n-1}{m-1}$，拆一下 $|T|,k$ 的容斥系数，得到：</p>
<script type="math/tex; mode=display">
\begin{align}
&(-1)^{|T|-k}\binom{|T|-1}{k-1}\\
=&(-1)^{|T|-k}(\binom{|T|-2}{k-1}+\binom{|T|-2}{k-2})\\
=&-(-1)^{|T|-k-1}\binom{|T|-2}{k-1}+(-1)^{|T|-k}\binom{|T|-2}{k-2}
\end{align}</script><p>拆出来的两个是 $|T|-1,k$ 和 $|T|-1,k-1$ 的容斥系数！这就很棒了，因为这个递推关系与 $|T|$ 具体值无关，我们就不用枚举每一种材料了。我们容易得到状态转移方程：</p>
<script type="math/tex; mode=display">
f(i,j,k)=f(i-1,j,k)-f(i-1,j-p_i,k)+f(i-1,j-p_i,k-1)</script><p>需要注意的是对边界的处理。有用的状态只有 $k&gt;0$。$k=0$ 作为边界，只会被贡献到 $f(i+1,p_i,1)$，新选的产生的容斥系数为 $(-1)^{1-1}\binom{0}{0}=1$，于是边界应为 $f(i,0,0)$。或者换一种角度，从定义出发，$f(i,0,0)=(-1)^{0-0}\binom{-1}{-1}=1$，这里的组合数涉及到负数，需要用到扩展的定义，但依然满足上面的递推式。</p>
<p>滚动数组倒序枚举 $j$ 能够压掉 $i$ 这一维的空间。总的时间复杂度为 $\mathcal O(nmk)$。</p>
<p>代码极短，并且十分好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>,M=<span class="number">1e4</span>+<span class="number">10</span>,K=<span class="number">15</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[M][K];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span>  x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k,m);</span><br><span class="line">    k=n-k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(p[i]);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=p[i];j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=k;l;l--)</span><br><span class="line">                f[j][l]=<span class="built_in">adj</span>(<span class="built_in">adj</span>(f[j][l]+f[j-p[i]][l<span class="number">-1</span>])-f[j-p[i]][l]+mod);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*<span class="built_in">qpow</span>(i)*f[i][k]%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*m*ans%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>min-max 容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>P5574 [CmdOI2019]任务分配问题</title>
    <url>/2022/12/07/P5574-CmdOI2019-%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>决策单调性 + 分治 优化 DP。</p>
<span id="more"></span>
<p>$\mathcal O(k n^2\log n)$ 是比较显然的，暴力 DP 配合树状数组即可。注意到 $w(i,j)+w(i-1,j+1)=w(i-1,j)+w(i,j+1)$ 的经典式子，想到决策单调性。因为贡献是不太好算的，于是我们尝试利用决策单调性直接分治求解，而每次贡献利用树状数组 $\mathcal O(n\log n)$ 求。最后一共求解 $k$ 次即可。时间复杂度为 $\mathcal O(kn\log ^2n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,K=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],t[N];</span><br><span class="line"><span class="type">int</span> f[N],g[N];</span><br><span class="line"><span class="type">int</span> res,tl,tr;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        t[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        res+=t[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tl&gt;l)tl--,res+=<span class="built_in">ask</span>(a[tl]),<span class="built_in">add</span>(a[tl],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(tr&lt;r)tr++,res+=tr-tl-<span class="built_in">ask</span>(a[tr]),<span class="built_in">add</span>(a[tr],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(tl&lt;l)<span class="built_in">add</span>(a[tl],<span class="number">-1</span>),res-=<span class="built_in">ask</span>(a[tl]),tl++;</span><br><span class="line">    <span class="keyword">while</span>(tr&gt;r)<span class="built_in">add</span>(a[tr],<span class="number">-1</span>),res-=tr-tl-<span class="built_in">ask</span>(a[tr]),tr--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,pm=mid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(pr,mid<span class="number">-1</span>);i&gt;=pl;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">calc</span>(i+<span class="number">1</span>,mid);</span><br><span class="line">        <span class="keyword">if</span>(g[i]+res&lt;=f[mid])f[mid]=g[i]+res,pm=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(pl,pm,l,mid<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">solve</span>(pm,pr,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        a[i]=n-a[i]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tl=<span class="number">1</span>,tr=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>]=g[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            g[j]=f[j];</span><br><span class="line">        <span class="built_in">solve</span>(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>决策单调性</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P5999 [CEOI2016] kangaroo</title>
    <url>/2022/09/01/P5999-CEOI2016-kangaroo/</url>
    <content><![CDATA[<p>可能（？）有用的 DP trick。</p>
<span id="more"></span>
<p><a href="https://www.luogu.com.cn/problem/P5999">题目链接</a></p>
<p>先转化题意，我们实际上需要求的就是满足以下条件的 $1\to n$ 排列 $a$ 的个数：</p>
<p>1.$a_1=s,a_n=t$；</p>
<p>2.$\forall i\in [2,n-1],(a_i-a_{i-1})\times (a_i-a_{i+1}) &gt;0$。</p>
<p>如何 DP 呢？这似乎并不好弄，因为我们进行传统的 DP 时我们并不好知道用了哪些数。</p>
<p>于是我们考虑新的思路，尝试分段型 DP。从小到大考虑将每个数插到满足条件的两段之间。这样得到的新段一定是满足条件的，并且不会算重。于是设计状态 $f_{i,j}$ 表示插入了 $i$ 个数，形成了 $j$ 个连续的段的方案数。转移时考虑将 $i$ 插进前面两段之间，或者新建一段就可以了。注意只能将 $s$ 插到最前面，将 $t$ 插到最后面。并且新建一段时不可以将其他数插在 $s$ 之前 $t$ 之后。</p>
<p>或者换一种理解方式，我们将 $f_{i,j}$ 表示使用前 $i$ 个数建了 $j$ 个笛卡尔树。每次转移时，将已有的某两颗笛卡尔树接在当前的 $i$ 上，或者以 $i$ 再建一颗笛卡尔树。容易发现这样构成的笛卡尔树所对应的序列就是满足条件的排列 $a$。</p>
<p>我们这里是将每一段看做相对有序的。其实也可以看成相对无序的，转移方程有所不同。但结果都一样是 $f_{n,1}$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,s,t;</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;s,&amp;t);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=s&amp;&amp;i!=t)</span><br><span class="line">                f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j+<span class="number">1</span>]*j+f[i<span class="number">-1</span>][j<span class="number">-1</span>]*(j-(i&gt;s)-(i&gt;t)))%mod;<span class="comment">//插到中间或新建一段</span></span><br><span class="line">            <span class="keyword">else</span> f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;<span class="comment">//插到两端或新建一段</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P6186 [NOI Online #1 提高组] 冒泡排序</title>
    <url>/2022/08/29/P6186-NOI-Online-1-%E6%8F%90%E9%AB%98%E7%BB%84-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>不错的思维题。</p>
<span id="more"></span>
<p>先考虑进行一轮冒泡排序的结果。我们发现，对于一个数，当且仅当它前面没有大于它的数，它的位置会被后移到第一个大于它的数，并且在之后的每一轮都会后移。并且每轮冒泡排序有 $k$ 个这样的数，那么这一轮减少的逆序对数量就是 $n-k$。更进一步，我们发现：若一个数前面有 $\le k$ 个大于它的数，那么它将在第 $k+1$ 轮冒泡排序时一定会被后移。</p>
<p>于是我们考虑预处理出 $pre_i$ 表示第 $i$ 个数前面有多少个大于它的数，这个很容易可以用树状数组来求。而逆序对个数就是 $\sum_{i=1}^{n} pre_i$。我们再用树状数组来维护 $k$ 轮冒泡排序进行完后的逆序对个数就行了。</p>
<p>对于修改操作也很简单，就是一个差分形式，直接单点修改就可以了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">ll sum,c[N],pre[N],p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        c[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        res+=c[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        pre[i]=i<span class="number">-1</span>-<span class="built_in">ask</span>(a[i]);</span><br><span class="line">        sum+=pre[i],p[pre[i]]++;</span><br><span class="line">        <span class="built_in">add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>,sum);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res+=p[i];</span><br><span class="line">        <span class="built_in">add</span>(i+<span class="number">2</span>,res-n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,x;</span><br><span class="line">        <span class="built_in">read</span>(op,x);</span><br><span class="line">        x=<span class="built_in">min</span>(x,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[x+<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">swap</span>(pre[x],pre[x+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[x]&lt;a[x+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                pre[x]--;</span><br><span class="line">                <span class="built_in">add</span>(pre[x]+<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">add</span>(pre[x+<span class="number">1</span>]+<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">                pre[x+<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask</span>(x+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>P6623 [省选联考 2020 A 卷] 树</title>
    <url>/2023/06/23/P6623-%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2020-A-%E5%8D%B7-%E6%A0%91/</url>
    <content><![CDATA[<p>有比较好想的 Trie 树做法。但是树上差分更巧妙。</p>
<span id="more"></span>
<p>从下往上做。从儿子继承到父亲，使得儿子内所有点到父亲的距离等于儿子内所有点到儿子的距离 $+1$，也就是全局 $+1$ 操作。并且维护的信息是异或和。类似于线段树合并，我们直接 01-Trie 合并即可。时间复杂度 $\mathcal O(n\log V)$。</p>
<p>换种思路，我们对于每一个 $v_i$ 分别考虑其对祖先的贡献。考虑整个 $+1$ 然后进位的过程，对于第 $k$ 位为 $1$，那么对它的祖先的第 $k$ 位贡献 $\underbrace{11\cdots 11}_{2^k-(v_i\text{ mod } 2^k)}\underbrace{00\cdots 00}_{2^k}\underbrace{11\cdots 11}_{2^k}$。根据这一点进行树上差分。给定差分数组 $g[x][i]$ 表示 $x$ 第 $i$ 位的差分。把当前 $v_i$ 每一位的差分往上传递到，把 $g[x][i]$ 的差分到 $g[fa_{x,2^i}][i]$。需要长链剖分求 $k$ 级祖先，时间复杂度 $\mathcal O(n\log n + n\log V)$。常数要小一点。</p>
<p>实际上有更好的实现方式。我们发现对于每个点，产生差分的点的充要条件是 $d_i=x\pmod {2^k}$。我们开一个新的 $p[k][x]$ 表示 $d_i=x\pmod {2^k}$ 的差分。递归之前先去掉已经原来的差分数组，再递归得到子树的贡献，再算出当前点的答案即可。时间复杂度 $\mathcal O(n\log V)$。常数很小。</p>
<p>具体实现参考如下。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5.26e5</span>+<span class="number">10</span>,K=<span class="number">21</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],p[K][N];</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=a[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)res^=p[i][d&amp;((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>)];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        res^=<span class="built_in">dfs</span>(y,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)res^=p[i][d&amp;((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>)];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)p[i][(d+a[x])&amp;((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>)]^=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">    ans+=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,fa;i&lt;=n;i++)<span class="built_in">read</span>(fa),<span class="built_in">add</span>(fa,i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Trie</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>P8112 [Cnoi2021]符文破译</title>
    <url>/2022/08/18/P8112-Cnoi2021-%E7%AC%A6%E6%96%87%E7%A0%B4%E8%AF%91/</url>
    <content><![CDATA[<p>不错的 Z 函数练习题。</p>
<span id="more"></span>
<p>很明显正着做不好搞，因为假如选取了当前某个前缀，很容易影响到后面的选取，并且不好优化。</p>
<p>经典正难则反的思想，考虑从后面逐渐选取模式串的前缀，这样就不会影响到前面前缀的选取。也就意味着，我们每次尝试选取一个文本串的一个后缀，使其等于模式串的前缀，然后进行下一步操作。</p>
<p>这是我们想到什么？ Z 函数不就是用来求出这东西的吗。考虑 DP，我们很容易写出状态转移方程：</p>
<script type="math/tex; mode=display">
f_i=\min_{i+1\le j\le i+p_i}{f_j+1}</script><p>有了这个，直接暴力 DP 是 $\mathcal O(n^2)$ 的，显然可以用线段树来维护，但 $\mathcal O(n\log n)$ 复杂度仍不允许我们通过此题。</p>
<p>还能继续优化吗？注意到对于所以可以转移到的 $f_i$  一定是具有单调性，因为较短的后缀的代价一定不会大于较长的后缀的代价。而且根据 Z 函数 的性质，对于所有可以转移到的 $i$，$i+p_i$ 明显是单调递减的。这就转化为经典模型了，我们很容易用单调队列来优化，于是复杂度就变为了优秀的 $\mathcal O(n)$。</p>
<p>因为 $f_i$ 具有单调性，每次我们直接将其加入队尾就可以了。然后注意一些细节就可以了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> z[N],p[N],f[N];</span><br><span class="line"><span class="type">int</span> l,r,q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Z</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    z[<span class="number">1</span>]=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r)z[i]=<span class="built_in">min</span>(z[i-l+<span class="number">1</span>],r-i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i+z[i]&lt;=n&amp;&amp;s[i+z[i]]==s[z[i]+<span class="number">1</span>])z[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+z[i]<span class="number">-1</span>&gt;r)l=i,r=i+z[i]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exkmp</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n,<span class="type">char</span> *t,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Z</span>(t,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r)p[i]=<span class="built_in">min</span>(z[i-l+<span class="number">1</span>],r-i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i+p[i]&lt;=n&amp;&amp;s[i+p[i]]==t[p[i]+<span class="number">1</span>])p[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+p[i]<span class="number">-1</span>&gt;r)l=i,r=i+p[i]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//Z函数模板</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s %s&quot;</span>,&amp;m,&amp;n,b+<span class="number">1</span>,a+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exkmp</span>(a,n,b,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        j&gt;i+p[i]?p[i]=<span class="number">0</span>:j=i+p[i];<span class="comment">//注意处理不可能转移到的情况</span></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[q[l=r=<span class="number">1</span>]=n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)sa</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!p[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&gt;i+p[i])l++;</span><br><span class="line">        f[i]=f[q[l]]+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// while(l&lt;=r&amp;&amp;f[q[r]]&gt;=f[i])r--;</span></span><br><span class="line">        <span class="comment">//这里直接入队就可以了</span></span><br><span class="line">        q[++r]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[<span class="number">1</span>]&lt;=INF)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Fake&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>希望没有误人子弟 qwq。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>KMP</tag>
        <tag>Z函数</tag>
        <tag>字符串</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P8329 [ZJOI2022] 树</title>
    <url>/2023/06/12/P8329-ZJOI2022-%E6%A0%91/</url>
    <content><![CDATA[<p>好的容斥题目。</p>
<span id="more"></span>
<p>容易发现DP过程中直接钦定叶子是不好做的，并且需要满足并集为全集。很容易想到使用容斥去掉这一条件。我们对于非叶子进行考虑：设 $f(S)$ 表示第一棵树中集合 $S$ 为<strong>非叶子</strong>节点时的方案数， $g(T)$ 表示第二棵树中集合 $T$ 为<strong>非叶子</strong>节点时的方案数，得到答案为：</p>
<script type="math/tex; mode=display">
Ans=\sum_{S\cap T=\emptyset,S\cup T=\{1,2,\cdots,n\}} f(S)g(T)</script><p>直接容斥，设 $f’(S)$ 表示第一棵树中集合 $S’\subseteq S$ 为<strong>非叶子</strong>节点时的方案数， $g(T)$ 表示第二棵树中集合 $T’\subseteq T$ 为<strong>非叶子</strong>节点时的方案数，进一步得到：</p>
<script type="math/tex; mode=display">
\begin{align}
Ans=&\sum_{S\cap T=\emptyset,S\cup T=\{1,2,\cdots,n\}} \sum_{S'\subseteq S,T'\subseteq T}(-1)^{|S|-|S'|+|T|-|T'|} f'(S')g'(T')\notag \\
=&\sum_{S'\cap T'=\emptyset}(-2)^{n-|S'|-|T'|}f'(S')g'(T')\notag \\
\end{align}</script><p>我们成功将“并集为全集”这一条件去掉。并且这是容易DP的。影响决策的只有 $|S’|,|T’|$，将其压入状态，设 $f(x,i,j)$ 表示考虑到 $x$，$S’$ 有 $i$ 个元素，$T’$ 有 $j$ 个的元素带容斥系数的方案数。我们顺序枚举所有元素，将两棵树以不同的顺序 DP，设边界为 $f(1,1,i)=1$，最终答案为 $\sum_i f(n,i,1)\times i$。考虑转移。对于当前枚举的元素 $x$，可以选择 $S’$ 中任意元素作为第一棵树上的父亲，和选择 $T’$ 中任意元素作为第二棵树上的父亲。所以转移系数为 $i\times j$。现在考虑是否将 $x+1$ 放进 $S’,T’$ 里，分类讨论一下：</p>
<p>$(1).x\in S’$，钦定 $x+1$ 为第二棵树的叶子， $i\times j\times f(x,i,j)\to f(x+1,i+1,j)$。</p>
<p>$(2).x\in T’$，钦定 $x+1$ 为第一棵树的叶子， $i\times j\times f(x,i,j)\to f(x+1,i,j-1)$。</p>
<p>$(3).x\notin S’,x\notin T’$，钦定 $x+1$ 为第一棵树的叶子和第二棵树的叶子，$-2\times i\times j\times f(x,i,j)\to f(x+1,i,j)$。</p>
<p>需要滚动数组优化空间。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,mod;</span><br><span class="line"><span class="type">int</span> p,f[<span class="number">2</span>][N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x+=y;x=(x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)f[p][<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;n;x++,p^=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f[p^<span class="number">1</span>],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[p^<span class="number">1</span>]));</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;<span class="built_in">upd</span>(ans,<span class="number">1ll</span>*i*f[p][i][<span class="number">1</span>]%mod),i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n-x;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">upd</span>(f[p^<span class="number">1</span>][i+<span class="number">1</span>][j],<span class="number">1ll</span>*i*j*f[p][i][j]%mod);</span><br><span class="line">                <span class="built_in">upd</span>(f[p^<span class="number">1</span>][i][j<span class="number">-1</span>],<span class="number">1ll</span>*i*j*f[p][i][j]%mod);</span><br><span class="line">                <span class="built_in">upd</span>(f[p^<span class="number">1</span>][i][j],<span class="number">1ll</span>*i*j*(mod<span class="number">-2</span>)%mod*f[p][i][j]%mod);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>P8338 [AHOI2022] 排列</title>
    <url>/2023/06/16/P8338-AHOI2022-%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>并没有用到什么高深的知识。</p>
<span id="more"></span>
<p>对于一个排列，我们从 $i$ 向 $p_i$ 连边，会得到若干个置换环。答案就是新的置换环的大小的 $\text{lcm}$。容易发现 $a_i^{(k)}=j$ 当且仅当 $i,j$ 属于同一个置换环。否则的话，交换 $i,j$，会将 $i,j$ 分属于的两个置换环合并为一个。</p>
<p>答案只与置换环的大小有关。并且大小不同的置换环最多有 $\mathcal O(\sqrt{n})$ 个。所以说可以直接暴力枚举两个置换环的大小。至于求 $\text{lcm}$，我们需要分解质因数来求，因为有值域的限制，利用筛法分解质因数容易做到单次 $\mathcal O(\log n)$。开一个桶来维护所有质因子的最大幂。枚举两个置换环时最多会影响两个值，所以桶中记录前三大的值即可。时间复杂度 $\mathcal O(n\log n)$。</p>
<p>随便写写就好。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,P=<span class="number">5e4</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> cnt,prime[P],g[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="type">int</span> p[P][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> ans,res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!g[i])prime[++cnt]=i,g[i]=cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;<span class="number">1ll</span>*i*prime[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i*prime[j]]=j;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j]))<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=g[x],tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(x%prime[j]))x/=prime[j],tot++;</span><br><span class="line">        <span class="keyword">if</span>(tot&gt;=p[j][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p[j][<span class="number">2</span>]=p[j][<span class="number">1</span>];</span><br><span class="line">            p[j][<span class="number">1</span>]=p[j][<span class="number">0</span>];</span><br><span class="line">            p[j][<span class="number">0</span>]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot&gt;=p[j][<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p[j][<span class="number">2</span>]=p[j][<span class="number">1</span>];</span><br><span class="line">            p[j][<span class="number">1</span>]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot&gt;=p[j][<span class="number">2</span>])</span><br><span class="line">            p[j][<span class="number">2</span>]=tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=g[x],tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(x%prime[j]))x/=prime[j],tot++;</span><br><span class="line">        <span class="keyword">if</span>(tot==p[j][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            res=<span class="number">1ll</span>*res*<span class="built_in">qpow</span>(<span class="built_in">qpow</span>(prime[j],p[j][<span class="number">0</span>]-p[j][<span class="number">1</span>]))%mod;</span><br><span class="line">            p[j][<span class="number">0</span>]=p[j][<span class="number">1</span>];</span><br><span class="line">            p[j][<span class="number">1</span>]=p[j][<span class="number">2</span>];</span><br><span class="line">            p[j][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot==p[j][<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p[j][<span class="number">1</span>]=p[j][<span class="number">2</span>];</span><br><span class="line">            p[j][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot==p[j][<span class="number">2</span>])</span><br><span class="line">            p[j][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;T:&quot;&lt;&lt;T&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in">sizeof</span>(p));</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> x=i,tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;vis[x]=<span class="number">1</span>,x=a[x],tot++;&#125;</span><br><span class="line">        <span class="keyword">while</span>(x!=i);</span><br><span class="line">        b[++m]=tot;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;tot&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=b[i];</span><br><span class="line">        <span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;m:&quot;&lt;&lt;m&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m);</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]!=b[i<span class="number">-1</span>])pos++;</span><br><span class="line">        c[pos]++;</span><br><span class="line">    &#125;</span><br><span class="line">    m=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m)-b<span class="number">-1</span>;</span><br><span class="line">    ans=<span class="number">0</span>,res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)res=<span class="number">1ll</span>*res*<span class="built_in">qpow</span>(prime[i],p[i][<span class="number">0</span>])%mod;</span><br><span class="line">    <span class="type">int</span> clone=res;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;res:&quot;&lt;&lt;res&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;m:&quot;&lt;&lt;m&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> x=b[i]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        res=clone;</span><br><span class="line">        <span class="built_in">del</span>(b[i]),<span class="built_in">del</span>(b[i]);</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=g[x],tot=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!(x%prime[j]))x/=prime[j],tot++;</span><br><span class="line">            <span class="keyword">if</span>(tot&gt;p[j][<span class="number">0</span>])res=<span class="number">1ll</span>*res*<span class="built_in">qpow</span>(prime[j],tot-p[j][<span class="number">0</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">insert</span>(b[i]),<span class="built_in">insert</span>(b[i]);</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*c[i]*(c[i]<span class="number">-1</span>)%mod*b[i]%mod*b[i]%mod*res%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;ans:&quot;&lt;&lt;ans&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=b[i]+b[j];</span><br><span class="line">            res=clone;</span><br><span class="line">            <span class="built_in">del</span>(b[i]),<span class="built_in">del</span>(b[j]);</span><br><span class="line">            <span class="keyword">while</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j=g[x],tot=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(!(x%prime[j]))x/=prime[j],tot++;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;prime[j]&lt;&lt;&quot; &quot;&lt;&lt;tot&lt;&lt;&quot; &quot;&lt;&lt;p[j][0]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">                <span class="keyword">if</span>(tot&gt;p[j][<span class="number">0</span>])res=<span class="number">1ll</span>*res*<span class="built_in">qpow</span>(prime[j],tot-p[j][<span class="number">0</span>])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">insert</span>(b[i]),<span class="built_in">insert</span>(b[j]);</span><br><span class="line">            ans=<span class="built_in">adj</span>(ans+<span class="number">2ll</span>*c[i]*c[j]%mod*b[i]%mod*b[j]%mod*res%mod);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;&quot;done:&quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;b[i]&lt;&lt;&quot; &quot;&lt;&lt;b[j]&lt;&lt;&quot;:&quot;&lt;&lt;res&lt;&lt;&quot; &quot;&lt;&lt;2ll*c[i]*c[j]%mod*res%mod&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">prework</span>(N<span class="number">-10</span>);</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P8386 [PA2021] Od deski do deski</title>
    <url>/2023/06/26/P8386-PA2021-Od-deski-do-deski/</url>
    <content><![CDATA[<p>小清新记数题。</p>
<span id="more"></span>
<p>发现将两段合法的拼接起来计数会有很多重复，因为会有很多种消除方法。于是我们考虑对于一位以为计数，并且将合法性压入状态。</p>
<p>考虑怎样才能够合法。如果对于当前位置选择数字 $x$，需要存在之前的某个位置 $i$ 数字为 $x$，满足 $[1,i-1]$ 合法。前面有满足这样的与 $x$ 相等的都可以选。于是我们考虑将有多少不同的数满足该条件压入状态中。设计状态 $f(i,j),g(i,j)$ 分别表示有 $j$ 不同的数满足该条件，不合法与合法的方案数。</p>
<p>于是我们可以很好的进行转移。得到状态转移方程：</p>
<script type="math/tex; mode=display">
\begin{align}
f(i,j)&\gets f(i-1,j)\times (m-j)\notag\\
f(i,j)&\gets g(i-1,j-1)\times (m-j+1)\notag\\
g(i,j)&\gets f(i-1,j)\times j\notag\\
g(i,j)&\gets g(i-1,j)\times\ j\notag\\
\end{align}</script><p>时间复杂度 $\mathcal O(n\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N][N],g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>]=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(n,m);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=<span class="built_in">adj</span>(f[i][j]+<span class="number">1ll</span>*g[i<span class="number">-1</span>][j<span class="number">-1</span>]*(m-j+<span class="number">1</span>)%mod);</span><br><span class="line">            f[i][j]=<span class="built_in">adj</span>(f[i][j]+<span class="number">1ll</span>*f[i<span class="number">-1</span>][j]*(m-j)%mod);</span><br><span class="line">            g[i][j]=<span class="built_in">adj</span>(g[i][j]+<span class="number">1ll</span>*f[i<span class="number">-1</span>][j]*j%mod);</span><br><span class="line">            g[i][j]=<span class="built_in">adj</span>(g[i][j]+<span class="number">1ll</span>*g[i<span class="number">-1</span>][j]*j%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(m,n);i++)ans=<span class="built_in">adj</span>(ans+g[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P8859 冒泡排序</title>
    <url>/2023/04/16/P8859-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>很早之前看过的趣题。</p>
<span id="more"></span>
<p>先考虑 $\text{type}=1$ 的情况。考虑一个贪心策略，每次操作将该元素操作到一个比它小的元素为止。显然这样是最优的。所以一个元素是前缀最大值时是不用操作的，容易得到 $f(A)=n-\sum_{i=1}^{n} [a_i=\max_{j=1}^ia_j]$。考虑 DP，设 $f_{i,j}$ 表示选取 $i$ 个元素有 $j$ 个元素为前缀最大值，每次插入一个最小的元素进行转移。因为插在最前面才会有贡献，于是容易得到状态转移方程 $f_{i,j}\gets f_{i-1,j-1}+(i-1)\times f_{i-1,j}$。时间复杂度 $\mathcal O(n^2)$。</p>
<p>再考虑 $\text{type}=2$ 的情况。我们不妨直接固定元素 $n$ 为最后一个元素，直接转化为排列的情况。</p>
<p>因为必然会有一个点不会被移动，所以我们可以将前面连续的一段移到序列的末尾，可以视作没有花费，但是这些移到末尾的数是一定会被操作的（因为小于元素 $n$）。这样产生的 $n$ 个新的排列的 $f(A’)$ 的最小值就是原排列的 $f(A)$。</p>
<p>还是设计状态 $f_{i,j}$ 表示选取 $i$ 个元素有 $j$ 个元素不用操作，考虑把最大的元素插入在两段的中间。设前面一段区间有 $p$ 个不用操作，后面一段区间有 $q$ 个不用操作。</p>
<p>我们可以选择直接将该元素插入，那么不用操作的个数为 $p+1$；或者将前面一段区间加上该元素一起移到序列的末尾，这样不用操作的个数应该是 $q$，所以得到状态转移方程 $\displaystyle f_{i,\max {p+1,q}}\gets \binom{i-1}{j} f_{j,p}\times f_{i-j-1,q}$。通过前缀和可以做到 $\mathcal O(n^3)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,type;</span><br><span class="line"><span class="type">int</span> C[N][N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        C[i][j]=<span class="built_in">adj</span>(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,type);</span><br><span class="line">    m=n-m;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">                f[i][j]=<span class="built_in">adj</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1ll</span>*(i<span class="number">-1</span>)*f[i<span class="number">-1</span>][j]%mod);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n--,m--;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[<span class="number">0</span>][i]=f[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">                    f[i][k]=<span class="built_in">adj</span>(f[i][k]+<span class="number">1ll</span>*C[i<span class="number">-1</span>][j]*f[j][k<span class="number">-1</span>]%mod*f[i-j<span class="number">-1</span>][k]%mod);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">adj</span>(f[n][m]-f[n][m<span class="number">-1</span>]+mod));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P8867 [NOIP2022] 建造军营</title>
    <url>/2022/12/05/P8867-NOIP2022-%E5%BB%BA%E9%80%A0%E5%86%9B%E8%90%A5/</url>
    <content><![CDATA[<p>算是敲个警钟。</p>
<span id="more"></span>
<p>题外话：笔者在 NOIP2022 的考场上，因为水平并不高，给了自己一种会做 T2 的错觉，于是直接放弃可做性更强的 T3 选择暴冲 T2 。最终没有能够取得理想成绩。在此警示后人。</p>
<p>提供一种不太一样的 DP（？）。</p>
<p>很容易考虑到双连通分量缩点，再树形DP（不在树上的边我们称之为非树边）。对于 $\mathcal O(n^2)$ 有比较显然的树形背包。</p>
<p>考虑如何做到线性。设计状态 $f_x$ 表示在以 $x$ 为根的子树中，至少选了一个点，且与 $x$ 连通的方案数。设 $sum_x$ 表示以 $x$ 为根的子树中边的总数。考虑每个子节点 $y$ 对 $f_x$ 的贡献：选取的话贡献为 $f_y$，不选取那么子树 $y$ 中的边和 $y\to x$ 这条边可以随便选（但是点不能选），所以贡献为 $2^{sum_y+1}$。再减去一个点不选的方案数 $2^{sum_x}$ 即可。</p>
<p>因为子树外的边（并且除去到父亲节点的边）可以随便选取，所以对答案的贡献就是 $f_x\times2^{m-sum_x-[fa!=0]}$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,head[N],ver[M&lt;&lt;<span class="number">1</span>],ne[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> num,dfn[N],low[N],bri[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt,c[N];</span><br><span class="line"><span class="type">int</span> a[N],b[N],sum[N];</span><br><span class="line">ll f[N],ans,p[N+M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y,i);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]&lt;low[y])</span><br><span class="line">                bri[i]=bri[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i!=(pre^<span class="number">1</span>))</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c[x]=cnt;</span><br><span class="line">    a[cnt]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!c[y]&amp;&amp;!bri[i])</span><br><span class="line">            <span class="built_in">prework</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x]=p[a[x]+b[x]]%mod;<span class="comment">//f[x]初值</span></span><br><span class="line">    sum[x]=b[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        sum[x]+=sum[y]+<span class="number">1</span>;</span><br><span class="line">        f[x]=f[x]*((f[y]+p[sum[y]+<span class="number">1</span>])%mod)%mod;</span><br><span class="line">        <span class="comment">//y对f[x]的贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=(f[x]+mod-p[sum[x]])%mod;<span class="comment">//减去一个点都不选的方案数</span></span><br><span class="line">    ans=(ans+f[x]*p[m-sum[x]-(fa!=<span class="number">0</span>)]%mod)%mod;<span class="comment">//统计总的方案数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Tarjan</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!c[i])</span><br><span class="line">            cnt++,<span class="built_in">prework</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(c[x]==c[y])b[c[x]]++;</span><br><span class="line">            <span class="keyword">else</span> e[c[x]].<span class="built_in">push_back</span>(c[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        b[i]/=<span class="number">2</span>;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)</span><br><span class="line">        p[i]=(p[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>缩点</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>P8907 [USACO22DEC] Making Friends P</title>
    <url>/2023/01/02/P8907-USACO22DEC-Making-Friends-P/</url>
    <content><![CDATA[<p>线段树合并，也可以启发式合并。</p>
<span id="more"></span>
<p>首先，对于一条边 $i \to j$，只有 $i &lt; j$ 时有意义，并且。对于每个点，统计时我们也只统计这样的边。考虑维护每个点与相邻点的点集，而每次将该点的点集合并到 该点的点集中编号最小的点上，仔细思考会发现这样是不重不漏的。</p>
<p>较为简单地可以用 set 启发式合并维护这个点集，时间复杂度 $\mathcal O(n\log^2 n)$。但更加优秀的是用线段树合并来维护，时间复杂度 $\mathcal O(n \log n)$，<del>但是竟然没有前面一种写法跑得快</del>。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> tot,rt[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr[N*<span class="number">80</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].sum=tr[tr[x].lc].sum+tr[tr[x].rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)x=++tot;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> tr[x].sum=<span class="number">1</span>,<span class="built_in">void</span>();</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">insert</span>(tr[x].lc,l,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p||!q)<span class="keyword">return</span> p+q;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum=tr[p].sum|tr[q].sum;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[p].lc=<span class="built_in">merge</span>(tr[p].lc,tr[q].lc,l,mid);</span><br><span class="line">    tr[p].rc=<span class="built_in">merge</span>(tr[p].rc,tr[q].rc,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].lc&amp;&amp;tr[tr[x].lc].sum)<span class="keyword">return</span> <span class="built_in">query</span>(tr[x].lc,l,mid);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(tr[x].rc,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> tr[x].sum=k,<span class="built_in">void</span>();</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(tr[x].lc,l,mid,pos,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="keyword">if</span>(u&gt;v)<span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="built_in">insert</span>(rt[u],<span class="number">1</span>,n,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[rt[x]].sum)<span class="keyword">continue</span>;</span><br><span class="line">        ans+=tr[rt[x]].sum;</span><br><span class="line">        <span class="type">int</span> y=<span class="built_in">query</span>(rt[x],<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">modify</span>(rt[x],<span class="number">1</span>,n,y,<span class="number">0</span>);</span><br><span class="line">        rt[y]=<span class="built_in">merge</span>(rt[y],rt[x],<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans-m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树合并</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>P8917 [DMOI-R2] 风神瞳（Aeolus Hitomi）</title>
    <url>/2022/12/30/P8917-DMOI-R2-%E9%A3%8E%E7%A5%9E%E7%9E%B3%EF%BC%88Aeolus-Hitomi%EF%BC%89/</url>
    <content><![CDATA[<p>比较裸的树上背包。</p>
<span id="more"></span>
<p>最需要处理的就是向叶子节点连续跳 $k$ 步。设计状态 $f_{x,t,i}$ 为从 $x$ 还需要向叶子节点跳 $t$ 步并且收集 $i$ 个风神瞳最少花费。</p>
<p>考虑如何转移。因为这 $t$ 步只能跳一次，转移过程中我们令 $f_{x,t,i}$ 已经使用了这 $t$ 步。而对于子节点 $y$：</p>
<p>1.在 $y$ 上跳这 $t$ 步，那么相当于 $x$ 在之前的子树上需要跳 $0$ 步：$f_{x,t,i}\gets f_{x,0,i-j}+f_{y,t-1,j}+1$。</p>
<p>2.在之前的子树上跳了这 $t$ 步，那么相当 $x$ 在 $y$ 上需要跳 $0$ 步。而我们可以选择直接走到 $y$，或者先向上走 $\le \min {dep_x-1,k}$ 步，再向叶子结点跳 $k$ 步：$f_{x,t,i}\gets f_{x,t,i-j}+ \min {f_{y,0,j}+2,\min_{p=\max {k-dep_x+1,1}}^{k}{k-p+1+f_{y,p-1,j}+1 }}$，后面的式子是一个整体，拿出来单独计算即可。</p>
<p>对于 $t=0$ 单独处理，类似上面的转移。时间复杂度 $\mathcal O(nmk)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,M=<span class="number">5e2</span>+<span class="number">10</span>,K=<span class="number">1e2</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,p,q;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> a[N],si[N],d[N];</span><br><span class="line"><span class="type">int</span> f[N][K][M],ans[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=a[x];</span><br><span class="line">    f[x][<span class="number">0</span>][a[x]]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=si[x]+si[y];~j;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="built_in">max</span>(j-si[x],<span class="number">0</span>);k&lt;=si[y];k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> res=INF;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="built_in">max</span>(p-d[x],<span class="number">1</span>);t&lt;=p;t++)</span><br><span class="line">                    res=<span class="built_in">min</span>(res,(p-t+<span class="number">1</span>)+f[y][t<span class="number">-1</span>][k]+<span class="number">1</span>);</span><br><span class="line">                res=<span class="built_in">min</span>(res,f[y][<span class="number">0</span>][k]+<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=p<span class="number">-1</span>;t++)</span><br><span class="line">                    f[x][t][j]=<span class="built_in">min</span>(&#123;f[x][t][j],f[x][<span class="number">0</span>][j-k]+<span class="number">1</span>+f[y][t<span class="number">-1</span>][k],f[x][t][j-k]+res&#125;);</span><br><span class="line">                f[x][<span class="number">0</span>][j]=<span class="built_in">min</span>(f[x][<span class="number">0</span>][j],f[x][<span class="number">0</span>][j-k]+res);</span><br><span class="line">            &#125;</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,p,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        a[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][m+<span class="number">1</span>]=<span class="number">2</span>*n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=f[<span class="number">1</span>][<span class="number">0</span>][i];j&lt;f[<span class="number">1</span>][<span class="number">0</span>][i+<span class="number">1</span>];j++)</span><br><span class="line">            ans[j]=i;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">2</span>*n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>SP3734 PERIODNI - Periodni</title>
    <url>/2022/09/02/SP3734-PERIODNI-Periodni/</url>
    <content><![CDATA[<p>笛卡尔树上进行 DP。</p>
<span id="more"></span>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506">HDU 1506 最大子矩形</a> 也可以用笛卡尔树来做，具体思路就是对于高度建笛卡尔树，再一遍 dfs 即可计算。注意到这道题，直觉告诉我们也需要从高度最小的考虑。于是我们也考虑建出笛卡尔树进行 DP。</p>
<p>这样就变成一个树上背包计数，我们每一次递归子树的时候考虑    将当前列的高度去掉，只计算之上的，这样就不会影响到当前行。很明显有转移方程：$f_{x,i}\gets f_{x,i-j}\times f_{y,j}$。</p>
<p>再考虑将当前高度，就是计算在 $h_x\times size_x$ 的方格里选取 $k$ 个点的方案数。选 $k$ 行 $\binom{k}{h_x}$，选 $k$ 列 $\binom{k}{size_x}$，并且是无序的，所以方案数就是 $k! \cdot \binom{k}{h_x}\cdot \binom{k}{size_x}$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,M=<span class="number">1e7</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> top,sta[N];</span><br><span class="line">ll fac[M];</span><br><span class="line"><span class="type">int</span> si[N];</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;M;i++)</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (mod-mod/x)*<span class="built_in">inv</span>(mod%x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*<span class="built_in">inv</span>(fac[m])%mod*<span class="built_in">inv</span>(fac[n-m])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>]=si[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=tr[x].l;</span><br><span class="line">        <span class="built_in">dfs</span>(y,tr[x].val);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(si[x],k);~i;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,si[y]);j++)</span><br><span class="line">                f[x][i]=(f[x][i]+f[x][i-j]*f[y][j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=tr[x].r;</span><br><span class="line">        <span class="built_in">dfs</span>(y,tr[x].val);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(si[x],k);~i;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,si[y]);j++)</span><br><span class="line">                f[x][i]=(f[x][i]+f[x][i-j]*f[y][j]%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(si[x],k);~i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,tr[x].val-res);j++)</span><br><span class="line">            f[x][i]=(f[x][i]+f[x][i-j]*fac[j]%mod*<span class="built_in">C</span>(tr[x].val-res,j)%mod*<span class="built_in">C</span>(si[x]-(i-j),j)%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(tr[i].val);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=top;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;tr[sta[p]].val&gt;tr[i].val)</span><br><span class="line">            p--;</span><br><span class="line">        <span class="keyword">if</span>(p)tr[sta[p]].r=i;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;top)tr[i].l=sta[p+<span class="number">1</span>];</span><br><span class="line">        sta[++p]=i;</span><br><span class="line">        top=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(sta[<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[sta[<span class="number">1</span>]][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title>SP6717 TWOPATHS - Two Paths</title>
    <url>/2022/09/05/SP6717-TWOPATHS-Two-Paths/</url>
    <content><![CDATA[<p>比较裸的换根 DP。</p>
<span id="more"></span>
<p><del>虚高题</del>。</p>
<p>update on 2022.11.13。原题解被 @zhanghenglei 所 Hack。现在已将解法修正，如果仍有问题，欢迎指出qwq。</p>
<p>不难想到用 $f_x,g_x$ 分别表示以 $x$ 为根的子树内和子树外最长链的长度。答案就是 $\max{f_x\times g_x}$。$f_x$ 很容易求，考虑 $g_x$ 怎么求。</p>
<p>$g_x$ 可以从父亲节点转移过来，这启发我们可以类似于换根 DP 的方法来求 $g_x$。</p>
<p>考虑怎么构成一条子树外的链。无非是从父节点往上延伸，或者从父节点往下延伸的链。再将他们最长的两段在父节点拼起来成为一个答案。</p>
<p>但是我们选取的两段链不能在 $x$ 的子树中。这就意味着我们需要先求出，从父节点往下延伸的链的最大值、亚大值和次大值，以及对应的子节点。转移时判断一下所选的链有没有在 $x$ 的子树中就行。</p>
<p>从该节点 $x$ 往上延伸的最长链也可以通过最大值和亚大值通过换根 DP 来求出，也比较简单。</p>
<p>但是这样解是有漏洞的，$g_x$ 求出来只是恰好经过其父节点的最长链，而不是整棵树中除去该子树的最长链，就像这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/93kgatph.png" alt=""></p>
<p><code>output : 30</code><br><code>answer : 36</code></p>
<p>所以我们需要再多记一个 $h_x$ 表示该节点的父节点的子树之外的最长链，转移与上面类似。</p>
<p>具体可看看代码，有一些注释。有点繁琐，但还是比较好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[N][<span class="number">3</span>],l[N],t[N][<span class="number">3</span>],f[N],g[N],h[N];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">2</span>]=d[x][<span class="number">1</span>],t[x][<span class="number">2</span>]=t[x][<span class="number">1</span>];</span><br><span class="line">            d[x][<span class="number">1</span>]=d[x][<span class="number">0</span>],t[x][<span class="number">1</span>]=t[x][<span class="number">0</span>];</span><br><span class="line">            d[x][<span class="number">0</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">0</span>]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">2</span>]=d[x][<span class="number">1</span>],t[x][<span class="number">2</span>]=t[x][<span class="number">1</span>];</span><br><span class="line">            d[x][<span class="number">1</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">1</span>]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">2</span>])</span><br><span class="line">            d[x][<span class="number">2</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">2</span>]=y;</span><br><span class="line">        <span class="comment">//处理出从该节点往下延伸的链的最大值、亚大值和次大值</span></span><br><span class="line">        <span class="comment">//以及其所对应的儿子</span></span><br><span class="line">        f[x]=<span class="built_in">max</span>(f[x],f[y]);<span class="comment">//从子节点转移</span></span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=<span class="built_in">max</span>(f[x],d[x][<span class="number">0</span>]+d[x][<span class="number">1</span>]);<span class="comment">//从自己转移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,<span class="number">1ll</span>*f[x]*<span class="built_in">max</span>(g[x],h[x]));<span class="comment">//统计答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        l[y]=l[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[x][<span class="number">0</span>]&amp;&amp;t[x][<span class="number">0</span>]!=y)</span><br><span class="line">            l[y]=<span class="built_in">max</span>(l[x],d[x][<span class="number">0</span>])+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[x][<span class="number">1</span>])</span><br><span class="line">            l[y]=<span class="built_in">max</span>(l[x],d[x][<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//转移从该节点向上延伸的最长链</span></span><br><span class="line">        <span class="type">int</span> res[<span class="number">4</span>];</span><br><span class="line">        res[<span class="number">0</span>]=t[x][<span class="number">0</span>]!=y?d[x][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>]=t[x][<span class="number">1</span>]!=y?d[x][<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">2</span>]=t[x][<span class="number">2</span>]!=y?d[x][<span class="number">2</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">3</span>]=l[x];</span><br><span class="line">        <span class="built_in">sort</span>(res,res+<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//从四条链中选取合法的最长的两条</span></span><br><span class="line">        g[y]=<span class="built_in">max</span>(g[x],res[<span class="number">2</span>]+res[<span class="number">3</span>]);</span><br><span class="line">        h[y]=h[x];</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x);</span><br><span class="line">        res[<span class="number">0</span>]=t[y][<span class="number">0</span>]!=y?d[y][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>]=t[y][<span class="number">1</span>]!=y?d[y][<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">2</span>]=t[y][<span class="number">2</span>]!=y?d[y][<span class="number">2</span>]:<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(res,res+<span class="number">3</span>);</span><br><span class="line">        h[x]=<span class="built_in">max</span>(h[x],res[<span class="number">1</span>]+res[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//转移该节点的父节点的子树之外的最长链</span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>换根DP</tag>
      </tags>
  </entry>
  <entry>
    <title>今昔是何年</title>
    <url>/2023/06/05/%E4%BB%8A%E6%98%94%E6%98%AF%E4%BD%95%E5%B9%B4/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="410acea76d5c0b3c48d45417665a7ead919ab0aba788548fdbf21b9c818b8e93">2469dfd2f0168e6fb8837314fda7e94b61e613d14e7de66be741995c40cd631f00f9a320146712db8371a5ee42af601096e46134ab7dacea4a190d85c3f94cf6e7ab1a6e48dbdd1fd014ad3261416759f7f87d9dc63c989222e9d3fbc792ff551bb27c14b5fc04b3bb6e3517a5c1164e9602fdddf6f4058204e0b8ceebaf5a62b7c08baba23b0f11a370e8ece38fb616b751094b79d324f4544dc3d39f86a8bb4a739397f52c235ccffe2252708e7babb263b88c7fcc3c51c8c71fbf07194607637e0226651c91b98ce5fa3014b0de8fc39c50738e7953122690d4072373369f56bd0f5adb74356159af5563b937e36806026f07f09bbf0b5a40ca0ea4d7877103bdf97d2d5f7d2f76d8e726fbf7ad89b9d7b0462e95d0b96df1325abd4496606ec435ac6e99bdf0cc0923ce500f3f3b286a1249850cf9fd99bdde7c8c46f4a8e3fb6daf2b0e18fd031eef98526f100cac0ca724350829931da6381e21e966f2033c8e2b95423f1d6554f7e458a1fb363b065e9eac8ace5b40d4b1736a8472b31fba9b0257567e84cd5a35d8a57aa7e6095d8ec04443e352be4cce397aaaa1e1ee2a4f0e7e0c7fd23215416ffad731d056cec5706b28004a3667f49fa634781ed8d0958c6ff77f34d7d8c85111d5c1422d2772a3617c2bf46bb96619f0eba901211422bce6afe38ab8998e22e584b19f0e24392f17156c67e8d489af1659e197a0eb9c9d666aa2ef9f599543ae67a8c083eaba58a105a0d022fe384c5b89f4672b7a475a9a4b2ad6ac46d8406fa97663934c8578cc01848b12a735914ddb263741fc1c4567f36b05f589ba5a80dc25506e3b7942b033aca18e2d839847d211016ee674e763b6912a6d773e436f25f4835118623ad211897881adbf45ae6fe41c531b93aa05f682aad030b13d5cba9fdfd67b40db67f168fb0ad61301e237cb67cc4085d6628a6f29cb43866417941aed0f0063509a2a4e2b741ba1d745695aacb1849f893e422ff8b05deaa47e18ce97ad249746d254069b19c1779005e5efbd1bfc403312bd5a9ebdc890c2e23873a34fdb8652686a1741f093ad92d24d726727cf70240640da968a19e4128d06630ff4092db841f7966356c9894ecbadda804252e0d889877acc56745f023e87d8d9d9aaca3a039bb5dd7f5dae427dfec9c71660190333b4115ec8ac7c88a64ff31ff449e0059fa567bb2f73f464b599fac4704c9fe65eeab09880c52e20f0b4b6b00fd6c7f3e3d27ad4e29fe9e0d4df3decd6547266f94644cdf6da6cba22fbd43c4caaf98c3aaa03672f825b74b09317ffb2eb5805561545802fd9c53f3ae6715f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Life.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>其实</title>
    <url>/2023/04/23/%E5%85%B6%E5%AE%9E/</url>
    <content><![CDATA[<p>4 月 23 日闲话。</p>
<span id="more"></span>
<p>即使是摆烂也不失为一种艺术。久而久之也不知是褒义还是贬义。其实我也没那么在乎结果，对吧？那不然，为什么中途那些逸乐是我流连忘返却又似乎不自知？过程中是不是早就不在乎了？我只知道我真的离不开她，是我发了狂。</p>
]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>二项式反演</title>
    <url>/2023/03/16/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<p>经典有用的反演。</p>
<span id="more"></span>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>有这么几个比较重要的式子：</p>
<script type="math/tex; mode=display">
\begin{align}
f(n)=\sum_{i=0}^n (-1)^i \binom{n}{i} g(i)&\Longleftrightarrow g(n)=\sum_{i=0}^n (-1)^i \binom{n}{i} f(i)\\
f(n)=\sum_{i=0}^n \binom{n}{i} g(i)&\Longleftrightarrow g(n)=\sum_{i=0}^n (-1)^{n-i} \binom{n}{i} f(i)\\
f(n)=\sum_{i=n}^m (-1)^i \binom{i}{n} g(i)&\Longleftrightarrow g(n)=\sum_{i=n}^m (-1)^i \binom{i}{n} f(i)\\
f(n)=\sum_{i=n}^m \binom{i}{n} g(i)&\Longleftrightarrow g(n)=\sum_{i=n}^m (-1)^{i-n} \binom{i}{n} f(i)
\end{align}</script><p>这些正是我们进行二项式反演的基础式子，似乎能看到一些容斥的影子。但是公式的运用是浅显的，更加重要的是关于模型的构建。</p>
<p>另外地，利用上式暴力求 $g(1),g(2),\dots,g(n)$ 是 $\mathcal O(n^2)$ 的。但是可以做到更优。我们有：</p>
<script type="math/tex; mode=display">
\begin{align}
f(n)&=\sum_{i=0}^n \binom{n}{i} g(i)\notag\\
\frac{f(n)}{n!}&=\sum_{i=0}^n \frac{1}{(n-i)!}\frac{g(n)}{i!}\notag\\
\end{align}</script><p>设 $F(x),G(x)$ 为 $f(n),g(n)$ 的 EGF。并且有 $\displaystyle e^x=\sum_{n&gt;0}\frac{x_n}{n!}$。我们辨认出卷积的形式，得到：</p>
<script type="math/tex; mode=display">
\begin{align}
F(x)=G(x)*e^x\Longleftrightarrow G(x)=F(x)*e^{-x}
\end{align}</script><p>利用 $(5)$ 式我们可以用 NTT 加速卷积求 $g(1),g(2),\dots,g(n)$，时间复杂度为 $\mathcal O(n\log n)$。</p>
<h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2.例题"></a>2.例题</h3><h4 id="1-P4859-已经没有什么好害怕的了"><a href="#1-P4859-已经没有什么好害怕的了" class="headerlink" title="1.P4859 已经没有什么好害怕的了"></a>1.<a href="https://www.luogu.com.cn/problem/P4859">P4859 已经没有什么好害怕的了</a></h4><p>相当求使 $a&gt;b$ 恰好有 $k$ 对的方案数。注意到 ”恰好“，联想到转化为 “至少” 来求解（”至少“ 限制更宽松，在多数情况下是相对更好求的）。设计 $f(n)$ 表示至少 $n$ 个满足 $a&gt;b$ 的方案数， $g(n)$ 表示恰好 $n$ 个满足  $a&gt;b$ 的方案数。我们要求的就是 $g(k)$。对于这两个函数，我们有关系式：</p>
<script type="math/tex; mode=display">
f(k)=\sum_{i=k}^n \binom{i}{k} g(i)</script><p>使用式子 $(4)$ 进行二项式反演：</p>
<script type="math/tex; mode=display">
g(k)=\sum_{i=k}^n (-1)^{i-k} \binom{i}{k} f(i)</script><p>考虑设 $f_{i,j}$ 表示前 $i$ 个之中选出 $j$ 组满足 $a&gt;b$，相当于钦定了 $j$ 组 $a&gt;b$，剩下的可以随便选。先将 $A,B$ 排序，处理出 $b_j&lt;a_i$ 的个数 $cnt_i$。并且仍然按照此顺序进行 DP，容易得到转移方程：</p>
<script type="math/tex; mode=display">
f_{i,j}={f_{i-1,j}+(cnt_i-j+1)\times f_{i-1,j-1}}</script><p>而我们要求的 $f(i)=(n-i)! f_{n,i}$。然后带入二项式反演的式子即可得到 $g(k)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[N],b[N],cnt[N];</span><br><span class="line"><span class="type">int</span> fac[N],ifac[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">if</span>(n+k&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    k=n+k&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(b[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n),<span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p+<span class="number">1</span>&lt;=n&amp;&amp;a[i]&gt;b[p+<span class="number">1</span>])p++;</span><br><span class="line">        cnt[i]=p;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod,ifac[i]=<span class="built_in">qpow</span>(fac[i]);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">min</span>(i,cnt[i]);j;j--)</span><br><span class="line">            f[j]=<span class="built_in">adj</span>(f[j]+<span class="number">1ll</span>*(cnt[i]-j+<span class="number">1</span>)*f[j<span class="number">-1</span>]%mod);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=(i-k&amp;<span class="number">1</span>)?mod<span class="number">-1ll</span>*f[i]*fac[n-i]%mod*<span class="built_in">C</span>(i,k)%mod:</span><br><span class="line">                <span class="number">1ll</span>*f[i]*fac[n-i]%mod*<span class="built_in">C</span>(i,k)%mod;</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="2-P6478-NOI-Online-2-提高组-游戏"><a href="#2-P6478-NOI-Online-2-提高组-游戏" class="headerlink" title="2.P6478 [NOI Online #2 提高组]游戏"></a>2.<a href="https://www.luogu.com.cn/problem/P6478">P6478 [NOI Online #2 提高组]游戏</a></h4><p>再次注意到 ”恰好“ 的限制条件。考虑像上一道题一样转化为 ”至少“。考虑设计 $f(i)$ 表示至少 $i$ 个非平局回合， $g(i)$ 表示恰好 $i$ 个非平局回合。还是用上面的式子进行二项式反演。考虑用 DP 求出 $f(i)$。</p>
<p>考虑树上背包，设计 $f_{x,i}$ 表示以 $x$ 为根的子树中钦定了 $i$ 个非平局回合，容易得到转移方程：</p>
<script type="math/tex; mode=display">
\begin{align}
f'_{x,i}&\gets \sum_{j=0}^{i} f_{x,i-j}\times f_{y,j}\notag\\
f'_{x,i}&\gets (size_{0/1}[x]-(i-1))\times f_{x,i-1}\notag
\end{align}</script><p>$f(i)$ 即为 $(n-i)!\cdot f_{1,i}$，带入公式即可求出 $g(i)$。总时间复杂度 $\mathcal O(n^2)$。</p>
<p>需要注意的是背包转移时的细节：转移形式是加法卷积，对于初始的 $f’_{x,i}$ 应当为 $f_{x,i}\times f_{y,0}$，而非 $f_{x,i}\times (f_{y,0}+1)$，因为我们必须选完 $y$ 子树里的点（只不过没有非平局回合）。更为保险的做法是开一个副本作为计算当前答案，算完再复制一遍。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> col[N],si[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> f[N][N],fac[N],ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="type">int</span> six=<span class="built_in">min</span>(si[x][<span class="number">0</span>],si[x][<span class="number">1</span>]),siy=<span class="built_in">min</span>(si[y][<span class="number">0</span>],si[y][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=six+siy;~j;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="built_in">max</span>(j-six,<span class="number">0</span>);k&lt;=<span class="built_in">min</span>(siy,j);k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!k)f[x][j]=<span class="number">1ll</span>*f[x][j]*f[y][<span class="number">0</span>]%mod;</span><br><span class="line">                <span class="keyword">else</span> f[x][j]=<span class="built_in">adj</span>(f[x][j]+<span class="number">1ll</span>*f[x][j-k]*f[y][k]%mod);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        si[x][<span class="number">0</span>]+=si[y][<span class="number">0</span>],si[x][<span class="number">1</span>]+=si[y][<span class="number">1</span>];    </span><br><span class="line">    &#125;</span><br><span class="line">    si[x][col[x]]++;</span><br><span class="line">    <span class="type">int</span> six=<span class="built_in">min</span>(si[x][<span class="number">0</span>],si[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=six;i;i--)</span><br><span class="line">        f[x][i]=<span class="built_in">adj</span>(f[x][i]+<span class="number">1ll</span>*(si[x][col[x]^<span class="number">1</span>]-(i<span class="number">-1</span>))*f[x][i<span class="number">-1</span>]%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;col[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod,ifac[i]=<span class="built_in">qpow</span>(fac[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> res=(j-i&amp;<span class="number">1</span>)?mod<span class="number">-1ll</span>*f[<span class="number">1</span>][j]*fac[n-j]%mod*<span class="built_in">C</span>(j,i)%mod:</span><br><span class="line">            <span class="number">1ll</span>*f[<span class="number">1</span>][j]*fac[n-j]%mod*<span class="built_in">C</span>(j,i)%mod;</span><br><span class="line">            ans=<span class="built_in">adj</span>(ans+res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>通过上面两个例题，容易发现很多情况下我们能够通过二项式反演将 ”恰好“ 的限制转化为 ”至少“ 的限制，再进一步求解。这也是解决这一类题的基本思路。换个角度来看，是一个当函数与集合具体有哪些元素无关，而与其中元素个数有关的情况下，进行的一个容斥。这一点能很好的将二者而这联系起来。</p>
<h4 id="3-CF1707D-Partial-Virtual-Trees"><a href="#3-CF1707D-Partial-Virtual-Trees" class="headerlink" title="3.CF1707D Partial Virtual Trees"></a>3.<a href="https://codeforces.com/problemset/problem/1707/D">CF1707D Partial Virtual Trees</a></h4><p>先考虑直接 DP，但发现并不好做。为什么？因为每次操作必须删除一个点，但是合并子树时只要有一棵子树在这一次操作内进行删点就行了。</p>
<p>于是考虑如何去掉这个限制。设计 $f(i)$ 表示至多进行 $i$ 次操作将树删空的方案数，或者换一种说法，进行的 $i$ 次操作其中有操作可以不删点，但是最终仍需要删空。设计 $g(i)$ 表示恰好进行 $i$ 次操作将树删空的方案数。通过枚举进行删点的 $i$ 次操作，我们可以得到：</p>
<script type="math/tex; mode=display">
f(n)=\sum_{i=0}^n \binom{n}{i}g(i)</script><p>这恰是二项式反演的形式！我们使用式子 $(2)$ 得到：</p>
<script type="math/tex; mode=display">
g(n)=\sum_{i=0}^n (-1)^{n-i} f(i)</script><p>还是考虑 DP 求出来 $f(i)$，设计 $f_{x,i}$ 表示将子树 $x$ 内操作 $i$ 次（可以不删点）之后为空的方案数。考虑两种情况：1.将所有子节点删完后，删除 $x$；2.将所有子节点删到只有 $1$ 棵子树 $y$ 中有点，再删去 $x$，再将剩下的节点删完。于是有转移方程：</p>
<script type="math/tex; mode=display">
\begin{align}
f_{x,i}&\gets \prod_y \sum_{j=1}^i f_{y,j}\notag\\
f_{x,i}&\gets \sum_y f_{y,i}\times \sum_{k=1}^{i-1} \ \prod_{t\ne y}\sum_{j=1}^k f_{t,j}\notag
\end{align}</script><p>前缀和一下辅助转移，这一部分是 $\mathcal O(n^2)$ 的。所以总的时间复杂度是 $\mathcal O(n^2)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,mod;</span><br><span class="line"><span class="type">int</span> fac[N],ifac[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> sum[N][N],pre[N][N],suf[N][N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> si=e[x].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)pre[i][j]=suf[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)pre[i][j]=suf[i][j]=sum[y][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;si;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            pre[i][j]=<span class="number">1ll</span>*pre[i<span class="number">-1</span>][j]*pre[i][j]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=si<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            suf[i][j]=<span class="number">1ll</span>*suf[i+<span class="number">1</span>][j]*suf[i][j]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[x][i]=<span class="built_in">adj</span>(f[x][i]+pre[si<span class="number">-1</span>][i]);</span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=e[x][i];</span><br><span class="line">            <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[x][j]=<span class="built_in">adj</span>(f[x][j]+<span class="number">1ll</span>*f[y][j]*res%mod);</span><br><span class="line">                res=<span class="built_in">adj</span>(res+<span class="number">1ll</span>*((i)?pre[i<span class="number">-1</span>][j]:<span class="number">1</span>)*((i+<span class="number">1</span>&lt;si)?suf[i+<span class="number">1</span>][j]:<span class="number">1</span>)%mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sum[x][i]=<span class="built_in">adj</span>(f[x][i]+sum[x][i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod,ifac[i]=<span class="built_in">qpow</span>(fac[i]);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> res=(i-j&amp;<span class="number">1</span>)?mod<span class="number">-1ll</span>*f[<span class="number">1</span>][j]*<span class="built_in">C</span>(i,j)%mod:</span><br><span class="line">            <span class="number">1ll</span>*f[<span class="number">1</span>][j]*<span class="built_in">C</span>(i,j)%mod;</span><br><span class="line">            ans=<span class="built_in">adj</span>(ans+res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/2023/03/24/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<p>博弈论入门及其经典模型，以及关于 SG 函数的理解。</p>
<span id="more"></span>
<h2 id="0-有向图游戏"><a href="#0-有向图游戏" class="headerlink" title="0.有向图游戏"></a>0.有向图游戏</h2><p>给定一个有 $n$ 个点的有向无环图，图中有 $m$ 个的棋子放在图上其中 $m$ 个点上。两名玩家交替地把其中一枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。判断先手必胜。</p>
<p>我们先考虑 $m=1$ 的情况。</p>
<p>首先通过推理,我们有下面三条定理：</p>
<p>​    定理 1：没有后继状态的状态是必败状态。</p>
<p>​    定理 2：一个状态是必胜状态当且仅当存在至少一个必败状态为它的后继状态。</p>
<p>​    定理 3：一个状态是必败状态当且仅当它的所有后继状态均为必胜状态。</p>
<p>那么我们很容易用 DP 简单求解。那么对于更一般的情况呢？我们容易发现每个棋子其实是相互独立的。</p>
<h2 id="1-SG-函数"><a href="#1-SG-函数" class="headerlink" title="1.SG 函数"></a>1.SG 函数</h2><p>SG 函数是用于解决博弈论中公平组合游戏（<strong>I</strong>mpartial <strong>C</strong>ombinatorial <strong>G</strong>ames，<strong>ICG</strong>）问题的一种方法。此处我们主要讨论公平组合游戏。</p>
<h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>设一个状态 $X$，设其后继状态的 SG 函数为 $A={SG(Y_1),SG(Y_2),\dots,SG(Y_n)}$，定义：</p>
<script type="math/tex; mode=display">
SG(A)=\left\{
\begin{align}
&0 & {A = \emptyset}\\
&\text{mex}(A) & {A\ne \emptyset}
\end{align}
\right.
\notag</script><p>其中 $\text{mex}(A)$ 表示未在 $A$ 中出现的最小非负整数。</p>
<h3 id="1-2-性质"><a href="#1-2-性质" class="headerlink" title="1.2 性质"></a>1.2 性质</h3><p>即 SG 定理。设两个互相独立的状态 $X,Y$，状态 $X+Y$ 表示两个状态的组合，有：</p>
<script type="math/tex; mode=display">
SG(X+Y)=SG(X)\oplus SG(Y)</script><p>进一步得到：</p>
<script type="math/tex; mode=display">
SG(X_1+X_2+\dots +X_n)=SG(X_1)\oplus SG(X_2)\oplus \dots \oplus SG(X_n)</script><p>这是我们用 SG 函数求解问题的关键（一定要分清楚后继状态和状态的组合）。</p>
<p>实际上 SG 函数是为了解决 有向图游戏 给出的一种方法。而绝大多数公平组合游戏都可以转化为 有向图游戏。</p>
<h2 id="2-基本模型"><a href="#2-基本模型" class="headerlink" title="2.基本模型"></a>2.基本模型</h2><p>关键在于如何设计 SG 函数，即如何转化为有向图游戏。</p>
<h3 id="2-1-Nim-游戏"><a href="#2-1-Nim-游戏" class="headerlink" title="2.1 Nim 游戏"></a>2.1 Nim 游戏</h3><h3 id="2-2-阶梯模型"><a href="#2-2-阶梯模型" class="headerlink" title="2.2 阶梯模型"></a>2.2 阶梯模型</h3><blockquote>
<p>有 $n$ 层阶梯，编号 $1,\cdots,n$，每层阶梯上有一些石子。</p>
<p>两个玩家轮流操作，每次操作可以将第 $i$ 层上至少一个石子放在第 $i-1$ 层阶梯上。无法操作者判负。</p>
</blockquote>
<p>首先发现偶数层相当于“垃圾桶”，因为如果有一方尝试将偶数层上的石子移向奇数层，那么另一方可以相应的将这些石子移到偶数层，而过程中奇偶行没有发生变化。再考虑奇数层，容易发现可以将任意多的石子扔到“垃圾桶”，完全等价于 Nim 游戏。于是只需要计算奇数层石子个数的异或和即可。</p>
<h4 id="2-2-1-例题"><a href="#2-2-1-例题" class="headerlink" title="2.2.1 例题"></a>2.2.1 例题</h4><h5 id="1-P5363-SDOI2019-移动金币"><a href="#1-P5363-SDOI2019-移动金币" class="headerlink" title="1.P5363 [SDOI2019] 移动金币"></a>1.<a href="https://www.luogu.com.cn/problem/P5363">P5363 [SDOI2019] 移动金币</a></h5><p>考虑转化模型，直接让金币代表阶梯，金币之间的格子代表石子，那么我们转化成与上述模型一样的情况。</p>
<p>于是给定 $n-m$ 个石子，要求分为 $m+1$ 堆，满足偶数堆的石子数异或起来为 $0$ 的方案数。</p>
<p>考虑朴素 DP，设计状态 $f(i,j,k)$ 表示考虑前 $i$ 堆共用了 $j$ 个石子，异或和为 $k$ 的方案数。这样直接做是 $\mathcal O(n^2m)$ 的。</p>
<p>我们显然可以对于异或和的每一位单独考虑。设计 $f(t,i)$ 表示考虑到第 $t$ 位的状态为 $0/1$（前 $t-1$ 位已经全部为 $0$），共用了 $i$ 个石子。于是直接钦定偶数个 $1$ 即可。这样时间复杂度为 $\mathcal O(nm\log n)$，能够通过此题。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.5e5</span>+<span class="number">10</span>,M=<span class="number">50</span>,K=<span class="number">18</span>,mod=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,bit;</span><br><span class="line"><span class="type">int</span> fac[N],ifac[N];</span><br><span class="line"><span class="type">int</span> f[K+<span class="number">5</span>][N];</span><br><span class="line"><span class="type">int</span> all;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x+=y,x=x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)ans=<span class="number">1ll</span>*ans*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)ifac[i<span class="number">-1</span>]=<span class="number">1ll</span>*ifac[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    all=<span class="built_in">C</span>(n,m);</span><br><span class="line">    n-=m,m++;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>&lt;&lt;bit&lt;n)bit++;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;bit;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(m&gt;&gt;<span class="number">1</span>);i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> now=i&lt;&lt;t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n-now;j+=<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">upd</span>(f[t+<span class="number">1</span>][j+now],<span class="number">1ll</span>*f[t][j]*<span class="built_in">C</span>(m&gt;&gt;<span class="number">1</span>,i)%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i+=<span class="number">2</span>)<span class="built_in">upd</span>(ans,<span class="number">1ll</span>*f[bit][i]*<span class="built_in">C</span>(n-i+(m<span class="number">-1</span>&gt;&gt;<span class="number">1</span>),m<span class="number">-1</span>&gt;&gt;<span class="number">1</span>)%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">adj</span>(all+mod-ans));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>考虑继续优化，我们发现答案只关心 $i=n$ 状态。注意对于第 $t$ 位，我们最多放 $m$ 个 $1$，总共是 $m\cdot 2^t$ 个。在依次考虑 $t$ 的过程中，用记录进位了 $i$ 个 $2^t$，$i$ 的范围是 $[1,m]$。用  $g(i)$ 表示将 $i$ 个石子分给 $m$ 堆，每堆之多被分到一个，满足偶数堆总共被分到偶数个，这个我们容易预处理。我们用 $g(i)$ 作为转移的系数。设 $bit$ 为 $n$ 二进制下第 $t$ 位的值。容易得到：</p>
<script type="math/tex; mode=display">
f(t,i)\times g(j)\to f(t+1,\frac{i+j-bit}{2})</script><p>其中需要满足： $i+j\equiv bit\pmod 2$。</p>
<p>这样就可以做到 $\mathcal O(m^2\log n)$。更进一步的，我们发现 $f(t,i),g(i)$ 的转移都具有卷积形式。于是我们可以用 多项式乘法 优化（不过模数是 $1e9+9$，需要用到任意模数多项式乘法）。这样可以做到 $\mathcal O(m\log m\log n)$。</p>
<p>下面是 $\mathcal O(m^2\log n)$ 的做法。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.5e5</span>+<span class="number">10</span>,M=<span class="number">50</span>+<span class="number">10</span>,K=<span class="number">18</span>,mod=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,bit;</span><br><span class="line"><span class="type">int</span> fac[M],ifac[M];</span><br><span class="line"><span class="type">int</span> f[K+<span class="number">5</span>][M],g[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x+=y,x=x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)ans=<span class="number">1ll</span>*ans*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)ifac[i<span class="number">-1</span>]=<span class="number">1ll</span>*ifac[i]*i%mod;</span><br><span class="line">    <span class="type">int</span> p=n&gt;&gt;<span class="number">1</span>,q=n+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=p;j+=<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">upd</span>(g[i],<span class="number">1ll</span>*<span class="built_in">C</span>(p,j)*<span class="built_in">C</span>(q,i-j)%mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    n-=m,m++;</span><br><span class="line">    <span class="built_in">init</span>(m);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>&lt;&lt;bit&lt;n)bit++;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=bit;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=n&gt;&gt;t&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((i+j&amp;<span class="number">1</span>)!=now)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> k=(i+j)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">upd</span>(f[t+<span class="number">1</span>][k],<span class="number">1ll</span>*f[t][i]*g[j]%mod);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m--,n+=m;</span><br><span class="line">    <span class="type">int</span> all=ifac[m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)all=<span class="number">1ll</span>*all*(n-i)%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">adj</span>(all+mod-f[bit+<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h5 id="2-P2575-高手过招"><a href="#2-P2575-高手过招" class="headerlink" title="2.P2575 高手过招"></a>2.<a href="https://www.luogu.com.cn/problem/P2575">P2575 高手过招</a></h5><p>还是转化模型，与上面非常相似。</p>
<h3 id="2-3-翻硬币模型"><a href="#2-3-翻硬币模型" class="headerlink" title="2.3 翻硬币模型"></a>2.3 翻硬币模型</h3><blockquote>
<p>$n$ 个硬币排成一行，每次可以翻连续的若干个，要求最右边的必须从反到正，无法操作的人判负。</p>
</blockquote>
<p>结论：整个游戏的 SG 函数相当于所有反面硬币的 SG 函数的异或和，而位于 $x$ 位置的 SG 函数有规律：$SG(x)=\text{lowbit}(x)$。</p>
<h4 id="CF494E-Sharti"><a href="#CF494E-Sharti" class="headerlink" title="CF494E Sharti"></a><a href="https://codeforces.com/problemset/problem/494/E">CF494E Sharti</a></h4><p>利用上面的模型，我们得到几点：1.每个格子可以作为一个子游戏；2.整个游戏的 SG 函数的值为所有白色棋子的 SG 函数值；3.对于位置 $(x,y)$ 的白色棋子，$SG(x,y)=\min(\text{lowbit}(x),\text{lowbit}(y),\text{greatbit}(k))$。</p>
<p>有了这三点我们相对好做了。因为 $SG(x,y)$ 一定为 $2$ 的次幂。我们对于每个 $c$，求 $SG(x,y)=2^c$ 位置的奇偶性即可。为了更方便一点，我们容斥以下，依次求出 $SG(x,y)\ge 2^c$ 的个数，用 $SG(x,y)\ge 2^{c-1}$ 减去即可得到 $SG(x,y)=2^c$ 的个数。于是我们变换坐标 $(x,y)\to (\lfloor \frac{x}{2^c}\rfloor,\lfloor \frac{y}{2^c}\rfloor)$，扫描线求解即可。总的时间复杂度为 $\mathcal O(n\log^2 n)$。</p>
<h3 id="2-4-斐波那契NIM游戏"><a href="#2-4-斐波那契NIM游戏" class="headerlink" title="2.4 斐波那契NIM游戏"></a>2.4 斐波那契NIM游戏</h3><blockquote>
<p>有 $n$ 枚石子。两位玩家定了如下规则进行游戏： 第一次取石子时可以取走任意多个； 接下来，每次至少要取走一个石子，最多取走上一次取的数量的 $2$ 倍。当然，玩家取走的数量必须不大于目前场上剩余的石子数量。 无法操作的人判负。</p>
</blockquote>
<p>结论：先将 $n$ 写成齐肯多夫表示，即用斐波那契数表示且没有相邻两个都是 1 ，则先手每次取最低位的 1 即可获胜。</p>
<p> 例题：<a href="https://www.luogu.com.cn/problem/P6791">P6791 [SNOI2020] 取石子</a>。</p>
<h3 id="2-5-其它经典博弈"><a href="#2-5-其它经典博弈" class="headerlink" title="2.5 其它经典博弈"></a>2.5 其它经典博弈</h3><h4 id="2-5-1-树（图）上删边博弈"><a href="#2-5-1-树（图）上删边博弈" class="headerlink" title="2.5.1 树（图）上删边博弈"></a>2.5.1 树（图）上删边博弈</h4><blockquote>
<p>在一棵树/图上钦定一个根，每次可以删去一条边，若删边后某部分与根不连通则一并删去，无法操作的人判负。</p>
</blockquote>
<p>考虑已知儿子节点的 $SG(y_i)$ 的值，求根节点的 $SG(x)$。显然割掉 $(x,y_i)$ 并不会对其它 $y_i$ 产生影响。我们显然可以将每棵子树 $y_i$ 再加上节点 $x$ 看成若干个独立的状态，设这样的状态为 $z_i$，下面直接用 $SG(x)$ 表示子树 $x$ 的 SG 函数值。</p>
<p>先考虑单个 $z_i$：我们可以选择割掉 $(x,y_i)$，后继状态 SG 函数值为 0，若割掉子树 $y_i$ 中若干边之后，再割掉 $(x,y_i)$，那么 SG 函数的集合为 ${1,2,\cdots,SG(y_i)-1,SG(y_i)}$。最终对上述集合中值取 $\text{mex}$，得到 $SG(z_i)=SG(y_i)+1$。所以 $SG(x)=\operatorname{mex}_{y_i} SG(y_i)+1$。最终判断 $SG(x)$ 是否为 $0$ 即可。</p>
<p>图的情况：把所有偶环缩成点，所有奇环缩成一个点和一条边（只连他自己那个点），然后当成树来做。</p>
<p>例题：<a href="https://atcoder.jp/contests/AGC017/tasks/agc017_d">[AGC017D] Game on Tree</a>。</p>
<h4 id="2-5-2-威佐夫博弈"><a href="#2-5-2-威佐夫博弈" class="headerlink" title="2.5.2 威佐夫博弈"></a>2.5.2 威佐夫博弈</h4><blockquote>
<p>有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。</p>
</blockquote>
<p>结论：当且仅当两堆石子的数量构成黄金比的时候后手获胜。</p>
<h4 id="2-5-3-二分图博弈"><a href="#2-5-3-二分图博弈" class="headerlink" title="2.5.3 二分图博弈"></a>2.5.3 二分图博弈</h4><blockquote>
<p>在二分图上，两人轮流指定下一步去哪个点，不经过重复的点，无法指定的人输，问谁赢？</p>
</blockquote>
<p>结论：当一个点在所有最大匹配的方案中（少了这个点无法最大匹配），那么先手必胜。</p>
<p>证明：后手不可能选到非匹配点，如果后手选到一个非匹配点，设路径为 $S_1\to S_n$，那么把现在的匹配换成 $S_2\to S_n$，匹配数不变但不包含 $S_1$，与最大匹配一定包含 $S_1$ 矛盾。</p>
<p>扩展到无向图的情况：不指定起点，则有完美匹配后手必胜；否则结论与上面一样。</p>
<h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><p>P5363 [SDOI2019] 移动金币</p>
<p>P2575 高手过招</p>
<p>P4077 [SDOI2016] 硬币游戏</p>
<p>P4576 [CQOI2013] 棋盘游戏</p>
<p>P4363 [九省联考 2018] 一双木棋 chess</p>
<p>[ARC137C] Distinct Numbers</p>
<p>[AGC043C] Giant Graph</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>博弈论</tag>
        <tag>SG函数</tag>
      </tags>
  </entry>
  <entry>
    <title>启发式合并</title>
    <url>/2022/11/20/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>运用广泛的合并信息方式。</p>
<span id="more"></span>
<blockquote>
<p>启发式算法是什么呢？<br>启发式算法是基于人类的经验和直观感觉，对一些算法的优化。</p>
</blockquote>
<p>启发式合并又名 dsu on tree，常常运用在树上信息的合并，常见的并查集的按秩合并就是其中一种。并且常常与树链剖分相结合，从而达到较优的时间复杂度。</p>
<h2 id="1-图论"><a href="#1-图论" class="headerlink" title="1.图论"></a>1.图论</h2><h3 id="1-1-重链剖分"><a href="#1-1-重链剖分" class="headerlink" title="1.1 重链剖分"></a>1.1 重链剖分</h3><h4 id="1-1-1-CF275D-Tree-and-Queries"><a href="#1-1-1-CF275D-Tree-and-Queries" class="headerlink" title="1.1.1 CF275D Tree and Queries"></a>1.1.1 <a href="https://codeforces.com/problemset/problem/375/D">CF275D Tree and Queries</a></h4><p>考虑离线。我们对于一颗子树，先计算它的所有轻儿子的答案，但是删除轻儿子的信息。然后计算重儿子的答案并直接继承重儿子的信息。再暴力将所有轻儿子的信息合并上，最终计算该节点的答案。这样做是 $\mathcal O(n\log n)$。</p>
<p>看起来很不对？我们来分析一波。对于每一个点，到根节点，每有一条轻边就会使该点被暴力计算一次。根据树链剖分经典结论，每个点到根节点的轻边数不会超过 $\mathcal O( \log n)$ 条。那么每个点最多只会被暴力计算  $\mathcal O( \log n)$次，那么时间复杂度就是 $\mathcal O(n\log n)$ 。</p>
<p>当然也可以线段树合并。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> c[N],q[N];</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt,dfn[N],num[N],si[N],son[N];</span><br><span class="line"><span class="type">int</span> col[N],sum[N],ans[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[++col[c[x]]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[col[c[x]]--]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num[dfn[x]=++cnt]=x;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        <span class="keyword">if</span>(si[y]&gt;si[son[x]])</span><br><span class="line">            son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa,<span class="type">bool</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x])</span><br><span class="line">        <span class="built_in">dfs2</span>(son[x],x,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=dfn[y];j&lt;=dfn[y]+si[y]<span class="number">-1</span>;j++)</span><br><span class="line">            <span class="built_in">insert</span>(num[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec[x])</span><br><span class="line">        ans[i]=sum[q[i]];</span><br><span class="line">    <span class="keyword">if</span>(op)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=dfn[x];i&lt;=dfn[x]+si[x]<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="built_in">del</span>(num[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u;</span><br><span class="line">        <span class="built_in">read</span>(u,q[i]);</span><br><span class="line">        vec[u].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>通过上面的例子可以发现，启发式合并需要一个点的贡献很容易加上或者删除。</p>
<h3 id="1-2-长链剖分"><a href="#1-2-长链剖分" class="headerlink" title="1.2 长链剖分"></a>1.2 长链剖分</h3><p>常常用来优化状态包含深度的 DP。</p>
<h4 id="1-2-1-P3565-POI2014-HOT-Hotels"><a href="#1-2-1-P3565-POI2014-HOT-Hotels" class="headerlink" title="1.2.1 P3565 [POI2014]HOT-Hotels"></a>1.2.1 <a href="https://www.luogu.com.cn/problem/P3565">P3565 [POI2014]HOT-Hotels</a></h4><p>设计 DP 状态，$f_{x,k}$ 表示子树 $x$ 中与 $x$ 距离为 $k$ 的点的个数。$g_{x,k}$ 表示 $dis(u,lca)=dis(v,lca)=dis(lca,x)+k$ 的 $(u,v)$ 个数。设 $y,y_1,y_2$ 均为 $x$ 的儿子节点，那么状态转移方程为：</p>
<script type="math/tex; mode=display">
\begin{align}
f_{x,0}&\gets 1\notag\\
f_{x,k}&\gets \sum_{y}f_{y,k-1}\notag\\
g_{x,k}&\gets \sum_{y}g_{y,j+1}\notag\\
g_{x,k}&\gets \sum_{y_1\neq y_2}f_{y_1,k-1}\times f_{y_2,k-1}\notag\\
ans&\gets \sum_{y_1\neq y_2} f_{y_1,k-1}\times g_{y_2,k+1} \notag\\
\end{align}</script><p>通过前缀和容易做到 $\mathcal O(n^2)$。注意到状态与深度有关，于是我们可以用长链剖分优化 DP。对于当前点 $x$，我们直接继承它的长儿子的状态，再其余儿子合并计算。容易发现这样做显然只会计算长链上的每个节点一次，而长链总长度是 $\mathcal O(n)$ 的。所有总的复杂度就是 $\mathcal O(n)$。具体地可以通过指针实现对长儿子信息地直接继承。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> dep[N],son[N];</span><br><span class="line"><span class="type">int</span> *f[N],*g[N],p[N&lt;&lt;<span class="number">2</span>],*o=p;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(dep[son[x]]&lt;dep[y])son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    dep[x]=dep[son[x]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])f[son[x]]=f[x]+<span class="number">1</span>,g[son[x]]=g[x]<span class="number">-1</span>,<span class="built_in">dfs2</span>(son[x],x);</span><br><span class="line">    f[x][<span class="number">0</span>]=<span class="number">1</span>,ans+=g[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        f[y]=o,o+=dep[y]&lt;&lt;<span class="number">1</span>,g[y]=o,o+=dep[y]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=dep[y];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=<span class="number">1ll</span>*g[x][j+<span class="number">1</span>]*f[y][j]+<span class="number">1ll</span>*f[x][j]*g[y][j+<span class="number">1</span>];</span><br><span class="line">            g[x][j]+=g[y][j+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(j)g[x][j]+=f[x][j]*f[y][j<span class="number">-1</span>],f[x][j]+=f[y][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    f[<span class="number">1</span>]=o,o+=dep[<span class="number">1</span>]&lt;&lt;<span class="number">1</span>,g[<span class="number">1</span>]=o,o+=dep[<span class="number">1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><h3 id="2-1-平衡树"><a href="#2-1-平衡树" class="headerlink" title="2.1 平衡树"></a>2.1 平衡树</h3>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>初级图论</title>
    <url>/2022/08/23/%E5%88%9D%E7%BA%A7%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<p>学习和做题笔记，旧的与新的都有。</p>
<span id="more"></span>
<h2 id="1-最短路"><a href="#1-最短路" class="headerlink" title="1.最短路"></a>1.最短路</h2><p>最短路是图论中最基础的一类问题。</p>
<h3 id="1-1-Bellman-Ford"><a href="#1-1-Bellman-Ford" class="headerlink" title="1.1.Bellman-Ford"></a>1.1.Bellman-Ford</h3><p>Bellman-Ford 是一种较为暴力求最短路的算法。</p>
<p>称一轮<strong>松弛</strong>为对于每一条边 $(u,v)$，用 $dis_u+w(u,v)$ 更新 $dis_v$。那么每一轮<strong>松弛</strong>必然会有一个节点的最短路会被更新，只需松弛 $n-1$ 即可。时间复杂度为 $\mathcal O(nm)$。</p>
<p>而我们也可以用该算法来判断<strong>是否存在负环</strong>：若<strong>松弛</strong>超过 $n-1$ 轮仍有节点最短路被更新，那么图中存在负环。</p>
<h3 id="1-2-SPFA"><a href="#1-2-SPFA" class="headerlink" title="1.2.SPFA"></a>1.2.SPFA</h3><p><a href="https://www.luogu.com.cn/problem/P4768">关于SPFA，它死了。</a></p>
<p>本质上是使用队列来优化的 Bellman-Ford。很明显我们每次并不需要枚举所有边，而只需要枚举在上一轮<strong>松弛</strong>中最短路被更新的节点的出边即可。因此每次我们在<strong>松弛</strong>过程中将最短路被更新的加入队列之中。并且可以记录某个节点是否在队列，若是则不用加入。</p>
<p>该算法在随机图上效率很高，但是对于特殊构造的数据，例如<strong>菊花图</strong>，会被卡成与 Bellman-Ford 相同的 $\mathcal O(nm)$。所以对于<strong>非负权图</strong>，应该采用下面即将提到的 Dikjstra 算法。</p>
<p>当然，SPFA 也可以用来判断负环，若<strong>最短路边数</strong>大于 $n-1$，则图中存在负环。（也可以判断每个点的入队次数，不过会稍慢一点）。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">1e3</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> tot,ver[M],e[M],ne[M],head[M];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x15f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!vis[now])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[now]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=ne[i])</span><br><span class="line">            <span class="keyword">if</span>(dis[now]+e[i]&lt;dis[ver[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[ver[i]]=dis[now]+e[i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[ver[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[ver[i]]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(ver[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">SPFA</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-3-Dijkstra"><a href="#1-3-Dijkstra" class="headerlink" title="1.3.Dijkstra"></a>1.3.Dijkstra</h3><p>Dijkstra是基于<strong>贪心</strong>的最短路算法，只适用于<strong>非负权图</strong>。</p>
<p>称<strong>扩展</strong>节点 $u$ 为对于 $u$ 的所有出边 $(u,v)$ ，用 $dis_u+w(u,v)$ 来更新</p>
<p>对于所有当前已经得到最短路的节点，取出所有未扩展节点中 $dis$ 最小的节点并扩展。因为没有负权边，所以取出的节点的 $dis_x$ 必然是<strong>单调不降</strong>的。</p>
<p>注意，这个贪心过程，当每个点被第一次取出时，此时的 $dis$ 就是源点到它的最短路。很容易即可证明这一点。</p>
<p>取出 $dis$ 最小的节点的过程可以用优先队列来实现。每次扩展后将最短路得到更新的节点加入优先队列中。</p>
<p>需要注意的是一个节点可能被扩展多次并多次进入优先队列，这样又会扩展多次，这会使我们的算法退化至 $\mathcal O(m^2\log m)$。但是我们知道每次它第一次被取出时，一定是源点到该节点的最短路。为了避免某个节点扩展多次，我们需要记录该点是否已经从队列中取出（已经得到最短路并扩展），若已经从队列中取出，则直接跳过，否则得到最短路直接扩展并记录。时间复杂度为 $\mathcal O(m\log n)$。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id,dis;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(Node u,Node v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> u.dis&gt;v.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>((Node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().id;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])<span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+e[i]&lt;dis[ver[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[ver[i]]=dis[x]+e[i];</span><br><span class="line">                q.<span class="built_in">push</span>((Node)&#123;ver[i],dis[ver[i]]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-4-Floyd"><a href="#1-4-Floyd" class="headerlink" title="1.4.Floyd"></a>1.4.Floyd</h3><p>用于求<strong>全源最短路</strong>的最常用算法，核心思想是 DP。</p>
<p>主要四步，枚举中转点 $k$，枚举 $i$，枚举 $j$，使用 $dis(i,k)+dis(k,j)$ 来更新 $dis_{i,j}$。</p>
<p>最需要注意的是枚举顺序，需要先枚举中转点 $k$，然后接着枚举 $i,j$ 。该算法正确性很显然，此处不再赘述。</p>
<p>Floyd 常被用来求传递闭包。将内层操作改为 $dis(i,j)\gets dis(i,j) \or (dis(i,k) \and dis(k,j))$ 即可。可用 <code>bitset</code> 来优化。</p>
<p>代码就算了。</p>
<h3 id="1-5-Johnson"><a href="#1-5-Johnson" class="headerlink" title="1.5.Johnson"></a>1.5.Johnson</h3><p>对于<strong>带负权稀疏图的全源最短路</strong>。因为带负权，无法使用 Dijkstra。我们可以直接跑 $n$ 遍 SPFA，但是被卡到 $\mathcal O(n^2m)$ 就直接寄了，我们需要更为优秀的算法。</p>
<p>Johnson 的巧妙之处在于为每个点恰当地赋上<strong>势能</strong> $h_i$，这里的<strong>势能</strong>可以类似于物理上的势能。然后将 $(u,v)$ 的边权变为 $w(u,v)+h_u-h_v$，不难发现 $dis(s,t)=dis’(s,t)-h_s+h_t$，这只与 $s,t$ 有关，并且仍然是原来的最短路。于是我们可以直接在求最短路。</p>
<p>但是我们还没有解决负权的问题。我们需要使得 $w(u,v)+h_u\ge h_v$，联想到<strong>三角形不等式</strong>，如果没负环我们一定可以通过不断松弛使得 $h$ 满足上述关系式。将每个点直接入队（相当于新建一个源点 $0$ 再向每个点连长度为 $0$ 的边），然后跑一遍 SPFA，得出得最短路数组即为 $h$。</p>
<p>其实，这个形式不正是<strong>差分约束</strong>的模型吗？直接跑就可以得到 $h$ 的一组解。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e3</span>+<span class="number">10</span>,M=<span class="number">6e3</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> cnt[N],h[N],dis[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id,d;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d&gt;t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        q.<span class="built_in">push</span>(i),vis[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(h[x]+e[i]&lt;h[y])</span><br><span class="line">            &#123;</span><br><span class="line">                h[y]=h[x]+e[i];</span><br><span class="line">                cnt[y]=cnt[x]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[y]&gt;=n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y])q.<span class="built_in">push</span>(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    priority_queue&lt;Node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    dis[s][s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().id;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])<span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[s][x]+e[i]+h[x]-h[y]&lt;dis[s][y])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[s][y]=dis[s][x]+e[i]+h[x]-h[y];</span><br><span class="line">                q.<span class="built_in">push</span>((Node)&#123;y,dis[s][y]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">SPFA</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">Dijkstra</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i][j]&gt;INF)</span><br><span class="line">                ans+=<span class="number">1ll</span>*j*INF;</span><br><span class="line">            <span class="keyword">else</span> ans+=<span class="number">1ll</span>*j*(dis[i][j]-h[i]+h[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-6-例题"><a href="#1-6-例题" class="headerlink" title="1.6.例题"></a>1.6.例题</h3><h4 id="1-P2505-HAOI2012-道路"><a href="#1-P2505-HAOI2012-道路" class="headerlink" title="1.P2505 [HAOI2012]道路"></a>1.<a href="https://www.luogu.com.cn/problem/P2505">P2505 [HAOI2012]道路</a></h4><p>题目简述：一张有向图，求出每条边被不同最短路径经过的次数， $n\le 1500,m\le 5000$。</p>
<p>经典题，考点：最短路图（或者说 最短路DAG？）。先说一下最短路图的概念：</p>
<p>首先，我们很容易知道：$i\to j$ 的最短路径的任意子路径 $u\to v$ 都是最短路径，接着我们可以得到另一个结论：若存在一条子路径 $u\to v$ 不是最短路径，那么很明显可以找到一条更短的 $u\to v$ 使得 $i\to j$ 更短。根据这个原则，我们可以得出在固定源点下，存在 $G$ 的一个子图 $G’$，使得 $G’$ 的每一条边都在 $S$ 到其他至少一个点的最短路径上，且 $G’$ 以外的边不在 $S$ 到任意一个点的最短路径上。这里把称 $G’$ 为源点为 $S$  时 $G$ 的<strong>最短路图</strong>。而求出最短路图的方式很简单，就是如果有 $dis_{v_i}=dis_{u_i}+w_i$，我们给这条路打上一个标记就行了。</p>
<p>有了这个有什么用呢？容易得到这个最短路图是无环的，我们就可以在<strong>最短路图</strong>上进行<strong>拓扑排序</strong>。考虑维护两个数组为 $cnt1_i$ 与 $cnt2_i$ 。接着我们考虑正反两次拓扑分别表示 $i\to u$ 和 $v\to j$ 的最短路径条数，而答案就为 $cnt_1({u_i})*cnt_2({v_i})$ 之和。</p>
<p>使用 Dijkstra 的话时间复杂度应该是 $\mathcal O(nm\log n + n^2)$，SPFA 也能过。</p>
<h4 id="2-P2680-NOIP2015-提高组-运输计划"><a href="#2-P2680-NOIP2015-提高组-运输计划" class="headerlink" title="2.P2680 [NOIP2015 提高组] 运输计划"></a>2.<a href="https://www.luogu.com.cn/problem/P2680">P2680 [NOIP2015 提高组] 运输计划</a></h4><p><del>还是说几个经典题。</del></p>
<p>注意到需要求的是最后一个完成的任务时间的最小值。最大值最小很容易想到二分答案。设二分值为 $lim$。对于修建的虫洞，其必然经过每个用时大于 $lim$ 的任务，并且用时最多的减去虫洞的长度需要小于 $lim$。</p>
<p>先考虑第一个条件，我们很容易想到<strong>树上差分</strong>，然后通过统计子树和来计算每条边被任务经过的次数。然后我们再统计所有满足第一个条件的边中最长的长度，最后判断一下第二个条件就行了。</p>
<h4 id="3-P4009-汽车加油行驶问题"><a href="#3-P4009-汽车加油行驶问题" class="headerlink" title="3.P4009 汽车加油行驶问题"></a>3.<a href="https://www.luogu.com.cn/problem/P4009">P4009 汽车加油行驶问题</a></h4><p>表面上是一个网络流24题，但直接跑<strong>分层图最短路</strong>就可以了。</p>
<h4 id="4-P7916-CSP-S-2021-交通规划"><a href="#4-P7916-CSP-S-2021-交通规划" class="headerlink" title="4.P7916 [CSP-S 2021] 交通规划"></a>4.<a href="https://www.luogu.com.cn/problem/P7916">P7916 [CSP-S 2021] 交通规划</a></h4><p>第一眼是一个经典最小割模型，直接上 Dinic 有 65pts（<del>真的很多了</del>）。</p>
<p>先考虑 $k=2$ 的情况，不就是 <a href="https://www.luogu.com.cn/problem/P4001">P4001 [ICPC-Beijing 2006] 狼抓兔子</a>吗？直接转成对偶图跑最短路即可。类似的 trick 还有 <a href="https://www.luogu.com.cn/problem/P2046">P2046 [NOI2010] 海拔</a>。</p>
<p>对于 $k&gt;2$ 的情况，我们还是从对偶图最短路的角度进行思考。考虑对于任意两个颜色不同的关键点之间新建一个点。很容易发现对于所有新建的点中，任意两个点的最短路就可以把这张图割成两半。就像这样：<img src="image1.png" alt=""></p>
<p>我们对每个新建的点分别作为源，求与其他点的最短路。因为最优的方案的中的最短路一定不会相交（调整法），于是我们可以尝试断环为链进行区间DP，也就是对其进行两两匹配，最后便可以得出答案。时间复杂度：$\mathcal O(\sum knm\log (nm)+\sum k^3)$。</p>
<h4 id="5-P5304-GXOI-GZOI2019-旅行者"><a href="#5-P5304-GXOI-GZOI2019-旅行者" class="headerlink" title="5.P5304 [GXOI/GZOI2019]旅行者"></a>5.<a href="https://www.luogu.com.cn/problem/P5304">P5304 [GXOI/GZOI2019]旅行者</a></h4><p>首先说一种较为暴力的做法，我们尝试将 $k$ 个关键点分为两组，超级源点 $s$ 向其中一组连边，另一组则向超级汇点 $t$ 连边，很明显 $s\to t$ 的最短路就是不同组之间进行配对的答案 。</p>
<p>介于这个思路，有一个较为暴力做法：每次将点的编号按照二进制中的第 $i$ 位来分为两组，然后按照上述方法跑 $\log k$ 次 $s\to t$ 的最短路，最后取 min 就是答案。这样很显然是正确的，因为最近的一对点的编号本来就是不同的，所以说一定会被统计到。</p>
<p>还有更优秀的做法。我们尝试用 Dijkstra 求出从 $i$ 到最近的关键点的距离 $dis1_i$ 和从最近的关键点到 $i$ 的距离 $dis_2(i)$，并且记录是从哪个关键点转移过来，设为 $f_i$ 和 $g_i$。然后我们枚举每一条边 $(u,v,w)$，若 $f_u$ 不等于 $g_v$，将 $dis_1(u)+w+dis_2(v)$ 计入答案即可。</p>
<p>这样枚举边为什么是正确的呢？这里留给读者思考。想通了这个问题也就不难明白为什么枚举点是错误的。</p>
<h4 id="6-CF843D-Dynamic-Shortest-Path"><a href="#6-CF843D-Dynamic-Shortest-Path" class="headerlink" title="6.CF843D Dynamic Shortest Path"></a>6.<a href="https://codeforces.com/problemset/problem/843/D">CF843D Dynamic Shortest Path</a></h4><p>每次询问直接暴力当然不能够通过。我们考虑先做一次 Dijkstra，然后再计算最短路的增量。</p>
<p>如何计算增量？设原来的最短路为 $dis_i$，考虑类似于 Johnson 的做法，我们把边权变为 $w(u,v)+dis_u-dis_v$，再跑最短路。这样就得到了增量。类似于 Johnson 的边权，这里的边权也一定是非负的。但是为什么这样是正确的呢？还是类似于 Johnson 中最短路的式子，有 $dis’_u=w’(s,p_1)+w’(p_1,p_2)+\dots+w’(p_{l-1},p_l)-dis_u$。于是这里求出的最短路径也是原图上的最短路径。</p>
<p>但是直接用的 Dijkstra 来求增量跟暴力的复杂度没有区别。但是注意到每次的增量最多为 $\min(c,n-1)$，并且最短路是单调不降的，于是我们可以将朴素 Dijkstra 中的堆直接换成桶 ，对于桶的每一个位置开一个队列，再从前往后做就可以了。这样的单次的复杂度就是 $\mathcal O(m)$ 的。</p>
<p>最开始仍然需要做一遍朴素 Dijkstra，总复杂度为 $\mathcal O(m\log n +qm)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e15</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    ll d;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d&gt;t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,T;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>((Node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().id;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])<span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+e[i]&lt;dis[y])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y]=dis[x]+e[i];</span><br><span class="line">                q.<span class="built_in">push</span>((Node)&#123;y,dis[y]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=lim;i++)<span class="keyword">while</span>(!q[i].<span class="built_in">empty</span>())q[i].<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i]=lim;</span><br><span class="line">    q[<span class="number">0</span>].<span class="built_in">push</span>(<span class="number">1</span>),f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=mx;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q[t].<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=q[t].<span class="built_in">front</span>();</span><br><span class="line">            q[t].<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(f[x]&lt;t)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> y=ver[i];</span><br><span class="line">                <span class="keyword">if</span>(f[x]+e[i]+dis[x]-dis[y]&lt;f[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    f[y]=f[x]+e[i]+dis[x]-dis[y];</span><br><span class="line">                    mx=<span class="built_in">max</span>(mx,f[y]);</span><br><span class="line">                    q[f[y]].<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(dis[i]&lt;INF)dis[i]+=f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,c;</span><br><span class="line">        <span class="built_in">read</span>(op,c);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dis[c]&lt;INF?dis[c]:<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=c;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x;</span><br><span class="line">                <span class="built_in">read</span>(x);</span><br><span class="line">                e[x]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">BFS</span>(<span class="built_in">min</span>(c,n<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="2-差分约束"><a href="#2-差分约束" class="headerlink" title="2.差分约束"></a>2.差分约束</h2><h3 id="2-1-算法介绍"><a href="#2-1-算法介绍" class="headerlink" title="2.1.算法介绍"></a>2.1.算法介绍</h3><p>前置芝士：Bellman-Ford 和 SPFA。</p>
<p>差分约束问题为：给出若干形如 $x_a-x_b\le c$ 或 $x_a-x_b\ge c$ 求解任意一组 $x$ 的解。</p>
<p>我们很容易将所有的限制写为 $x_i+c\ge x_j$。这熟悉的形式，让我们想起<strong>三角形不等式</strong>，使得我们可以用最短路求解。我们从 $i\to j$ 连一条长度为 $c$ 的边，然后从超级源点 $s$ 向每个点连长度为 $0$ 的边以防止不连通（或者说一开始令所有的 $dis=0$ 并将所有的点入队），跑最短路，每个点的最短路长度就是一组合法解。</p>
<p>因为 $c$ 一般都有负数，所以用 Bellman-Ford 和 SPFA 求解最短路，此时得到的解为字典序最大解（似乎有些违反直觉，但确实是这样）。显然，若出现负环则无解。</p>
<p>时间复杂度为 $\mathcal O(nm)$。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>,M=<span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> vis[N],dis[N],cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        q.<span class="built_in">push</span>(i),vis[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+e[i]&lt;dis[ver[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[ver[i]]=dis[x]+e[i];</span><br><span class="line">                cnt[ver[i]]=cnt[x]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[ver[i]]&gt;=n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!vis[ver[i]])</span><br><span class="line">                    q.<span class="built_in">push</span>(ver[i]),vis[ver[i]]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">SPFA</span>())</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="2-2-例题"><a href="#2-2-例题" class="headerlink" title="2.2.例题"></a>2.2.例题</h3><h4 id="1-P5590-赛车游戏"><a href="#1-P5590-赛车游戏" class="headerlink" title="1.P5590 赛车游戏"></a>1.<a href="https://www.luogu.com.cn/problem/P5590">P5590 赛车游戏</a></h4><p>每条边的长度我们并不好直接将构造，但很明显我们只需要构造一组合法的 $dis$ 就可以了。</p>
<p>考虑<strong>三角形不等式</strong>，对于每条边 $(u,v)$，满足 $1\le dis_v-dis_u\le 9$。熟悉的形式使我们想到<strong>差分约束</strong>。按照模型将图建出来，得到 $dis$ 的任意一组解即可。</p>
<p>需要注意一下去除与答案无关的边，这些边随便取什么值都可以，正反两遍 dfs 即可判断。</p>
<h4 id="2-P4926-1007-倍杀测量者"><a href="#2-P4926-1007-倍杀测量者" class="headerlink" title="2.P4926 [1007]倍杀测量者"></a>2.<a href="https://www.luogu.com.cn/problem/P4926">P4926 [1007]倍杀测量者</a></h4><p>很明显需要先二分，看起来是个<strong>差分约束</strong>的形式，可是我们需要求的是倍数的形式，而非差分。怎样转换？我们只需要对所有的 $k$ 取对数就可以把乘法转化为加法。这样我们直接上差分约束判断负环就可以了。</p>
<p>注意这里给定了初值，我们从 $0$ 向  $i$ 分别连 $\log x$ 和 $-\log x$ 的边就可以了，相等形式的边都可以这样连（转化为 $x_i\ge x_j$ 且 $x_j\ge x_i$ 即可）。</p>
<h4 id="3-AGC056C-01-Balanced"><a href="#3-AGC056C-01-Balanced" class="headerlink" title="3.[AGC056C] 01 Balanced"></a>3.<a href="https://atcoder.jp/contests/agc056/tasks/agc056_c">[AGC056C] 01 Balanced</a></h4><p>形式就很差分约束，可以直接对前缀和数组进行差分约束，但是这样的复杂度是 $\mathcal O(nm)$，无法通过。</p>
<p>我们发现最令人头疼的是对于 $[l,r]$ 这样的限制，因为我们必须建权值为 $(r-l+1)/2$ 的边。这样我们只能够暴力跑 SPFA。</p>
<p>但是我们可以将 $0$ 看为 $1$，而将 $1$ 看为 $-1$。这样我们对于 $[l,r]$ 这样的限制，只需要建长度为 $0$ 的边即可。相邻点的限制变成了 $|v_i-v_{i-1}|\le 1$。所有边权只剩下 $0,1$，我们可以直接用 01 BFS 跑最短路。因为差分约束求出来的解为字典序最大解，所以求出来就是原问题最小字典序的解。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,M=<span class="number">3e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line">deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i],d=dis[x]+e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[y]&gt;d)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y]=d;</span><br><span class="line">                <span class="keyword">if</span>(!e[i])q.<span class="built_in">push_front</span>(y);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add</span>(i,i<span class="number">-1</span>,<span class="number">1</span>),<span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">read</span>(l,r);</span><br><span class="line">        <span class="built_in">add</span>(r,l<span class="number">-1</span>,<span class="number">0</span>),<span class="built_in">add</span>(l<span class="number">-1</span>,r,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BFS</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dis[i<span class="number">-1</span>]&gt;dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="4-P7515-省选联考-2021-A-卷-矩阵游戏"><a href="#4-P7515-省选联考-2021-A-卷-矩阵游戏" class="headerlink" title="4.P7515 [省选联考 2021 A 卷] 矩阵游戏"></a>4.<a href="https://www.luogu.com.cn/problem/P7515">P7515 [省选联考 2021 A 卷] 矩阵游戏</a></h4><p>最重要的限制是矩阵 $a$ 中每个数的大小 $\le 10^6$。</p>
<p>我们考虑先构造出任意一种 $a$，再对其进行调整即可，我们按照奇偶对行列进行分类对奇数 $\pm 1$，对偶数 $\mp 1$，这样还是能够满足 $b$ 的限制的。转化为 $0\le a_{i,j} +(-1)^i h_{i} +(-1)^j l_{j} \le 10^6$。但是当行与列的奇偶性相同时就会出先和约束，这是我们无法解决的。</p>
<p>考虑如何限制 $(-1)^i,(-1)^j$，使其不会出现符号相同的情况。尝试对其进行黑白染色，限制转化为 $0\le a_{i,j} +(-1)^{i+j} h_{i} +(-1)^{i+j+1} l_{j} \le 10^6$，这样也能够满足 $b$ 的限制，并且可以直接跑差分约束求出 $h,l$ 即可。</p>
<p>可能有一点卡常，据说可以使用寻址更连续 Bellman-Ford 来代替 SPFA，但感觉没啥用。真正有用的是将存图方式从链式前向星改成用 vector 实现的邻接表。因为边的数量很多，并且寻址变得非常连续。笔者的代码在改了之后快了将近 5 倍。</p>
<h2 id="3-最小生成树"><a href="#3-最小生成树" class="headerlink" title="3.最小生成树"></a>3.最小生成树</h2><h3 id="3-1-Kruskal"><a href="#3-1-Kruskal" class="headerlink" title="3.1.Kruskal"></a>3.1.Kruskal</h3><p>最经典且常用的最小生成树算法，非常简单且基础。</p>
<p>现将所有边排序，贪心地从小到大选取，若边的两个端点所属联通块不同，就将该边加入答案，用并查集维护连通性。正确性用反证法就可以很容易证明了。其它应用还有 Kruskal 重构树。</p>
<h3 id="3-2-Prim"><a href="#3-2-Prim" class="headerlink" title="3.2.Prim"></a>3.2.Prim</h3><p>Prim 总是维护 MST 的一部分，每次选取维护的联通块所相连的边中最小的边，将该边加入答案的同时维护联通块。其中选取最小的边用优先队列就可以了，时间复杂度 $\mathcal O(m\log n)$。可以类似于 Dijkstra。</p>
<h3 id="3-3-Boruvka"><a href="#3-3-Boruvka" class="headerlink" title="3.3.Boruvka"></a>3.3.Boruvka</h3><p>从点来考虑，对于每个点而言，与它相邻的边权最小的边必然入选。这一点还是可以通过反证法可以证明。</p>
<p>于是我们每次求出每个点与其相连的最小的边。将所有这些边加入最小生成树中。出去至多 $\frac{n}{2}$ 重边，每条边会使联通块个数 $-1$，因此一次这样过程可以使得联通块的个数严格减少一半。这样对剩余联通块继续上述过程至多 $\log_2 n$ 轮即可求得 MST。时间复杂度为 $\mathcal O(m\log n)$。Boruvka 在解决某类最小生成树问题上非常有用。对于形如给定一张 n 个点的完全图，两点之间的信息可以通过某种关系计算得出，该算法可以较好得求解。</p>
<h3 id="3-4-例题"><a href="#3-4-例题" class="headerlink" title="3.4.例题"></a>3.4.例题</h3><h4 id="1-CF827D-Best-Edge-Weight"><a href="#1-CF827D-Best-Edge-Weight" class="headerlink" title="1.CF827D Best Edge Weight"></a>1.<a href="https://codeforces.com/problemset/problem/827/D">CF827D Best Edge Weight</a></h4><p>显然，我们应该先把最小生成树求出来，然后逐渐考虑每条边。设求出的生成树是 $T$，且下文中的路径都指生成树上的路径。</p>
<p>1.$(u,v,w)\notin T$：如果选取这条边，那么很明显其最大值为路径 $(u,v)$ 上的边的边权最大值。</p>
<p>2.$(u,v,w)\in T$：这种情况稍微复杂一点，这种边的最大值，是所有能覆盖这条边的非树边的最小值。何为能覆盖？就是对于一条非树边 $(x,y,z)$，若某一树边 $(u,v,w)$ 在路径 $(x,y)$ 上，我们则称之为能覆盖。</p>
<p> 于是我们先考虑非树边，求出这条边的答案。然后每次对路径 $(u,v)$ 上的边权与 $w$ 进行取 min 操作。这可以用树链剖分很好的维护。但是有更好的做法，因为我们是按照边权从小到大排过序的，所以对于已经覆盖过的边，其已经是最优答案了，我们并不需要再覆盖它。于是我们可以每次直接暴力覆盖，然后用并查集维护未被覆盖的边就行了。时间复杂度 $\mathcal O(m\log m)$，瓶颈是排序。</p>
<p>代码非常的好写。</p>
<h4 id="2-CF1120D-Power-Tree"><a href="#2-CF1120D-Power-Tree" class="headerlink" title="2.CF1120D Power Tree"></a>2.<a href="https://codeforces.com/problemset/problem/1120/D">CF1120D Power Tree</a></h4><p>考虑将树上操作转化为在 $dfn$ 序上进行操作。子树操作就变成了区间操作。对于区间操作我们又可以考虑用差分将其转化为单点操作。这里的 $dfn$ 序可以只考虑叶子结点。</p>
<p>接着很自然地想到了生成树，对于每个操作 $(dfn_i,dfn_i+size_i,w_i)$，我们都把他转化为 $n$ 个节点的图上的一条边。显然只要使这个图联通我们就可以控制所有点的点权。求一遍 MST 就行了。</p>
<h4 id="3-CF888G-Xor-MST"><a href="#3-CF888G-Xor-MST" class="headerlink" title="3.CF888G Xor-MST"></a>3.<a href="https://codeforces.com/problemset/problem/888/G">CF888G Xor-MST</a></h4><p>考虑 Kruskal，我们每次都是贪心的选取边权最小的边。异或最小值我们可以考虑在 01-Trie 上进行操作。</p>
<p>我们考虑将所有点权放进 01-Trie 上。然后从根节点开始，考虑先递归其子树，使左右子树分别联通，再在 01-Trie 中查找边权最小的边，并将左右子树连起来。过程中计算花费即可。时间复杂度 $\mathcal O(n\log V)$，其中 $V$ 为值域。常数稍微有点大。</p>
<p>另外可以用 Boruvka 做。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1ll</span>&lt;&lt;<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,ch[N&lt;&lt;<span class="number">4</span>][<span class="number">2</span>],ed[N&lt;&lt;<span class="number">4</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;~i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][num])</span><br><span class="line">            ch[u][num]=++tot;</span><br><span class="line">        u=ch[u][num];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[u]=x;</span><br><span class="line">&#125;<span class="comment">//01-Trie</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ed[u]||ed[v])<span class="keyword">return</span> ed[u]^ed[v];</span><br><span class="line">    ll res1=INF,res2=INF;</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>]&amp;&amp;ch[v][<span class="number">0</span>])res1=<span class="built_in">solve</span>(ch[u][<span class="number">0</span>],ch[v][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">1</span>]&amp;&amp;ch[v][<span class="number">1</span>])res2=<span class="built_in">solve</span>(ch[u][<span class="number">1</span>],ch[v][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(res1!=INF||res2!=INF)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(res1,res2);<span class="comment">//贪心，先尝试朝同一方向走</span></span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>]&amp;&amp;ch[v][<span class="number">1</span>])res1=<span class="built_in">solve</span>(ch[u][<span class="number">0</span>],ch[v][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">1</span>]&amp;&amp;ch[v][<span class="number">0</span>])res2=<span class="built_in">solve</span>(ch[u][<span class="number">1</span>],ch[v][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(res1,res2);<span class="comment">//再向不同方向走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>])<span class="built_in">dfs</span>(ch[u][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">1</span>])<span class="built_in">dfs</span>(ch[u][<span class="number">1</span>]);<span class="comment">//先递归，使其子树联通</span></span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>]&amp;&amp;ch[u][<span class="number">1</span>])</span><br><span class="line">        ans+=<span class="built_in">solve</span>(ch[u][<span class="number">0</span>],ch[u][<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//再查找最小边权，将左右子树连起来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="4-Tarjan-与图的连通性"><a href="#4-Tarjan-与图的连通性" class="headerlink" title="4.Tarjan 与图的连通性"></a>4.Tarjan 与图的连通性</h2><h3 id="4-1-算法简介"><a href="#4-1-算法简介" class="headerlink" title="4.1.算法简介"></a>4.1.算法简介</h3><p>无向图的割边（即”桥“）、割点、边双连通分量、点双连通分量，有向图的强连通分量，他们都是图的连通性研究的重要内容，定义此处不再赘述。</p>
<p>Tarjan 利用 dfs 树以及时间戳 $dfn_x$ 追溯值 $low_x$ 来求这些东西。设 $\text{subtree}(x)$ 表示搜索树上以 $x$ 为根的子树，$low_x$ 定义为以下节点的时间戳 $dfn_y$ 的最小值：1.$\text{subtree}(x)$ 中的节点；2.通过一条 $\text{subtree}(x)$ 中的节点上但不属于搜索树上的边，能够到达的节点（不包括）。</p>
<p>我们以割边为例简要阐释其原理。</p>
<h4 id="4-1-1割边判定法则"><a href="#4-1-1割边判定法则" class="headerlink" title="4.1.1割边判定法则"></a>4.1.1割边判定法则</h4><p>无向边 $(x,y)$ 为割边，当且仅当都搜索树上存在 $x$ 的一个子节点 $y$ 满足：</p>
<script type="math/tex; mode=display">
dfn_x<low_y</script><p>先说明充分性，$dfn_x&lt;low_y$，说明从 $\text{subtree}(y)$ 不经过 $(x,y)$ 不可以到达 $x$ 或其之前访问的节点。并且它不可以到达兄弟子树中的节点 。所以若将 $(x,y)$ 删除，那么 $\text{subtree}(y)$ 不再与原图连通，符合割边的定义。</p>
<p>必要性呢？反证，若不存在这样的 $y$ 为搜索树上 $x$ 的子节点满足 $dfn_x&lt;low_y$，那么从 $\text{subtree}(y)$ 不经过 $(x,y)$ 可以到达 $x$ 或其之前访问的节点，删除 $(x,y)$ ，仍可以到达 $x$，不影响图的连通性，此时 $(x,y)$ 自然不为割边。</p>
<h4 id="4-1-1割点判定法则"><a href="#4-1-1割点判定法则" class="headerlink" title="4.1.1割点判定法则"></a>4.1.1割点判定法则</h4><p>若 $x$ 不为搜索树根节点，$x$为割点，当且仅当都搜索树上存在一个 $x$ 的子节点 $y$ 满足：</p>
<script type="math/tex; mode=display">
dfn_x\le low_y</script><p>特别地，若 $x$ 为搜索树根节点，$x$为割点，当且仅当都搜索树上至少存在两个 $x$ 的子节点 $y1,y2$ 满足上述条件。</p>
<p>其证明方法与割边类似。注意到这里是 $dfn_x\le low_y$，我们可以直接将父节点的 $dfn_{fa}$ 算到字节点的 $low_x$ 上。而下面圆方树部分均采用这样的定义。</p>
<h4 id="4-1-1强连通分量判定法则"><a href="#4-1-1强连通分量判定法则" class="headerlink" title="4.1.1强连通分量判定法则"></a>4.1.1强连通分量判定法则</h4><p>在 $x$ 进行回溯之前，$x$ 到栈顶节点形成一个强连通分量，当且仅当 $x$ 满足：</p>
<script type="math/tex; mode=display">
dfn_x=low_x</script><p>此处先不做过多阐述。</p>
<h2 id="5-圆方树"><a href="#5-圆方树" class="headerlink" title="5.圆方树"></a>5.圆方树</h2><h3 id="5-1-算法简介"><a href="#5-1-算法简介" class="headerlink" title="5.1.算法简介"></a>5.1.算法简介</h3><blockquote>
<p>圆方树最初是处理“仙人掌图”（每条边在不超过一个简单环中的无向图）的一种工具，不过发掘它的更多性质， 有时我们可以在一般无向图上使用它。——by OI-wiki</p>
</blockquote>
<p>顾名思义，在圆方树中有两种点——圆点与方点。其中圆点对应原图上的每一个点，方点对应着原图上的每一个点双连通分量。点双连通分量被缩成一个由方点向各圆点连边的菊花图。而这些菊花图通过原图的割点相连。</p>
<p>对于一般的无向图，我们采用类似于求割点的做法。类似于求强连通分量，中途用栈维护来求点双连通分量以及建圆方树。整体实现比较简单。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dfncnt,top,dfn[N],low[N],sta[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_e</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_g</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u!=y;--top)u=sta[top],<span class="built_in">add_g</span>(u,cnt);</span><br><span class="line">    <span class="built_in">add_g</span>(x,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfncnt;</span><br><span class="line">    sta[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]==low[y])<span class="built_in">build</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add_e</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!dfn[i])<span class="built_in">Tarjan</span>(i),top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="5-2-性质"><a href="#5-2-性质" class="headerlink" title="5.2.性质"></a>5.2.性质</h3><h3 id="5-3-例题"><a href="#5-3-例题" class="headerlink" title="5.3.例题"></a>5.3.例题</h3><h4 id="1-P5236-【模板】静态仙人掌"><a href="#1-P5236-【模板】静态仙人掌" class="headerlink" title="1.P5236 【模板】静态仙人掌"></a>1.<a href="https://www.luogu.com.cn/problem/P5236">P5236 【模板】静态仙人掌</a></h4><p>模板题。圆方树的题一般先建出圆方树在树上进行各种算法，过程中可能会将圆点与方点分开进行考虑。这道题类似，我们建出圆方树，求圆方树上 $x,y$ 的 $lca$，设 $dis_u$ 为 $u$ 到根节点的距离。若 $lca$ 为圆点，那么答案为 $dis_x+dis_y-dis_{lca}$。</p>
<p>但是如果 $lca$ 为方点呢？意味着我们倍增过程中跳到了环上。特殊处理，设圆点 $A,B$ 为倍增过程中 $lca$ 的儿子。我们考虑 $A,B$ 之间的最小距离即可。于是我们求出环上每一个点按照一定方向到方点的距离 $s_x$，环的总长为 $stot_x$，那么答案为 $dis_x+dis_y-dis_A-dis_B+\min(|s_A-s_B|,stot_A-|s_A-s_B|)$。</p>
<p>如何在求点双的过程中合理地为每个圆点连向方点赋上边权？直接赋为到割点 $x$ 地最小距离即可。容易发现这样处理是正确的。</p>
<p>但是新的问题又来了，如何在求点双的过程中求出环上所有边的边权。网上很少有这种用点双来实现的做法，笔者这里给出较为简单的一种方式。容易发现，仙人掌上每一个点，最多只有一条路径以该点为起点，能够到达搜索树上的祖先，而这个祖先就是割点。于是我们在求 $low_x$ 的过程中记录下使 $low_x$ 更新的边 $(x,y,z)$ 的权值，找出点双的过程中即可求出我们想要的信息。</p>
<p>这里给出一种实现方式。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>点双连通分量<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>,M=<span class="number">2e4</span>+<span class="number">10</span>,K=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> dfncnt,top,dfn[N],low[N],sta[N],to[N];</span><br><span class="line"><span class="type">int</span> s[N],stot[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">vector&lt;Edge&gt;e[N],g[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N],dis[N],f[N][<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> A,B;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_e</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].<span class="built_in">push_back</span>((Edge)&#123;v,w&#125;);</span><br><span class="line">    e[v].<span class="built_in">push_back</span>((Edge)&#123;u,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_g</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g[u].<span class="built_in">push_back</span>((Edge)&#123;v,w&#125;);</span><br><span class="line">    g[v].<span class="built_in">push_back</span>((Edge)&#123;u,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add_g</span>(x,++cnt,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> i,u=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=top;i&amp;&amp;u!=y;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        u=sta[i];</span><br><span class="line">        sum+=to[u];</span><br><span class="line">        s[u]=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    sum+=z;</span><br><span class="line">    </span><br><span class="line">    stot[x]=sum;</span><br><span class="line">    <span class="keyword">for</span>(u=<span class="number">0</span>;u!=y;top--)</span><br><span class="line">    &#123;</span><br><span class="line">        u=sta[top];</span><br><span class="line">        stot[u]=sum;</span><br><span class="line">        <span class="built_in">add_g</span>(u,cnt,<span class="built_in">min</span>(s[u],sum-s[u]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfncnt;</span><br><span class="line">    sta[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=u.v,z=u.w;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&lt;=low[x])low[x]=low[y],to[x]=z;<span class="comment">//注意这个 if 语句中的 &lt;= 号！留给读者思考</span></span><br><span class="line">            <span class="comment">// low[x]=min(low[x],low[y]);</span></span><br><span class="line">            <span class="keyword">if</span>(dfn[x]==low[y])<span class="built_in">build</span>(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[y]&lt;low[x])low[x]=dfn[y],to[x]=z;</span><br><span class="line">        <span class="comment">// low[x]=min(low[x],dfn[y]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=u.v,z=u.w;</span><br><span class="line">        <span class="keyword">if</span>(y==f[x][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>,dis[y]=dis[x]+z;</span><br><span class="line">        f[y][<span class="number">0</span>]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">            f[y][i]=f[f[y][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)<span class="keyword">if</span>(d[f[x][i]]&gt;=d[y])x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)<span class="keyword">if</span>(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];</span><br><span class="line">    A=x,B=y;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add_e</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="type">int</span> lca=<span class="built_in">LCA</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(lca&lt;=n)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[x]+dis[y]<span class="number">-2</span>*dis[lca]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[x]+dis[y]-dis[A]-dis[B]+<span class="built_in">min</span>(<span class="built_in">abs</span>(s[A]-s[B]),stot[A]-<span class="built_in">abs</span>(s[A]-s[B])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>特别地，对于仙人掌，我们可以采用类似求边双连通分量的方式来建仙人掌的圆方树。因为当我们从 $x$ 走到一个 $y$ 不以 $x$ 为搜索树上的父亲，也不是在 $x$ 之前访问节点。那么搜索树上 $x\to y$ 的路径和 $(y,x)$ 就一同构成了一个环。这样做的话，在处理边权问题时就会方便一些。具体实现也可以看看代码。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>边双连通分量<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>,M=<span class="number">2e4</span>+<span class="number">10</span>,K=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> dfncnt,cnt,dfn[N],low[N],fa[N],fw[N];</span><br><span class="line"><span class="type">int</span> stot[N],s[N];</span><br><span class="line">vector&lt;Edge&gt;e[N],g[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N],dis[N],f[N][<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> A,B;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_e</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].<span class="built_in">push_back</span>((Edge)&#123;v,w&#125;);</span><br><span class="line">    e[v].<span class="built_in">push_back</span>((Edge)&#123;u,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_g</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g[u].<span class="built_in">push_back</span>((Edge)&#123;v,w&#125;);</span><br><span class="line">    g[v].<span class="built_in">push_back</span>((Edge)&#123;u,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=y;i!=x;i=fa[i])</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]=sum;</span><br><span class="line">        sum+=fw[i];</span><br><span class="line">    &#125;</span><br><span class="line">    stot[x]=s[x]=sum;</span><br><span class="line">    <span class="built_in">add_g</span>(x,++cnt,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=y;i!=x;i=fa[i])</span><br><span class="line">    &#123;</span><br><span class="line">        stot[i]=sum;</span><br><span class="line">        <span class="built_in">add_g</span>(i,cnt,<span class="built_in">min</span>(s[i],sum-s[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfncnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=u.v,z=u.w;</span><br><span class="line">        <span class="keyword">if</span>(fa[x]==y)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[y]=x,fw[y]=z;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]&lt;low[y])<span class="built_in">add_g</span>(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:e[x])</span><br><span class="line">        <span class="keyword">if</span>(dfn[u.v]&gt;dfn[x]&amp;&amp;fa[u.v]!=x)</span><br><span class="line">            <span class="built_in">build</span>(x,u.v,u.w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=u.v,z=u.w;</span><br><span class="line">        <span class="keyword">if</span>(y==f[x][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>,dis[y]=dis[x]+z;</span><br><span class="line">        f[y][<span class="number">0</span>]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">            f[y][i]=f[f[y][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)<span class="keyword">if</span>(d[f[x][i]]&gt;=d[y])x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)<span class="keyword">if</span>(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];</span><br><span class="line">    A=x,B=y;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add_e</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!dfn[i])<span class="built_in">Tarjan</span>(i);</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="type">int</span> lca=<span class="built_in">LCA</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(lca&lt;=n)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[x]+dis[y]<span class="number">-2</span>*dis[lca]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[x]+dis[y]-dis[A]-dis[B]+<span class="built_in">min</span>(<span class="built_in">abs</span>(s[A]-s[B]),stot[A]-<span class="built_in">abs</span>(s[A]-s[B])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="2-P4630-APIO2018-铁人两项"><a href="#2-P4630-APIO2018-铁人两项" class="headerlink" title="2.P4630 [APIO2018] 铁人两项"></a>2.<a href="https://www.luogu.com.cn/problem/P4630">P4630 [APIO2018] 铁人两项</a></h4><p>经典圆方树练习题，考虑建出圆方树。考虑初末点 $s,f$，容易发现应当求圆方树上路径 $(s,f)$ 经过的所有点双的大小之和。考虑将方点的权值赋为点双的大小，树上 DP 求出。但是这样做显然是会重复的，因为路径上的每个圆点（除 $s,f$）作为原图上的割点会存在于两个点双之中。并且中转点 $c$ 不能为 $s,f$。于是我们将每个圆点点权赋为 $-1$，问题得到很好的解决。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dfncnt,top,tot,dfn[N],low[N],sta[N];</span><br><span class="line"><span class="type">int</span> cnt,val[N&lt;&lt;<span class="number">1</span>],si[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">ll ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N],g[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_e</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;e[u].<span class="built_in">push_back</span>(v);e[v].<span class="built_in">push_back</span>(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_g</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;g[u].<span class="built_in">push_back</span>(v),g[v].<span class="built_in">push_back</span>(u);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add_g</span>(x,++cnt);val[cnt]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u!=y;top--)<span class="built_in">add_g</span>(u=sta[top],cnt),val[cnt]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfncnt;</span><br><span class="line">    sta[++top]=x,tot++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]==low[y])<span class="built_in">build</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=x&lt;=n;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        sum+=<span class="number">1ll</span>*si[x]*si[y];</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">    &#125;</span><br><span class="line">    sum+=<span class="number">1ll</span>*si[x]*(tot-si[x]);</span><br><span class="line">    ans+=<span class="number">2</span>*sum*val[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Tarjan</span>(x);</span><br><span class="line">    <span class="built_in">dfs</span>(x,<span class="number">0</span>);</span><br><span class="line">    top=tot=<span class="number">0</span>;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add_e</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)val[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!dfn[i])<span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="3-P4606-SDOI2018-战略游戏"><a href="#3-P4606-SDOI2018-战略游戏" class="headerlink" title="3.P4606 [SDOI2018]战略游戏"></a>3.<a href="https://www.luogu.com.cn/problem/P4606">P4606 [SDOI2018]战略游戏</a></h4><p>建出圆方树，相当于求点集 $S$ 中所有点最小公共祖先 $lca$ 与 $S$ 中所有点的形成的连通块的原点个数。这就是很经典的问题了，我们考虑将 $S$ 中的点按照圆方树上的 $dfn$ 序排序，那么路径 $(S’_1,S’_2),(S’_2,S’_3),\cdots,(S’_{|S|},S’_1)$ 则可以覆盖连通块上所有边两次。特判一下 $lca$ 是圆点还是方点即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,M=<span class="number">4e5</span>+<span class="number">10</span>,K=<span class="number">18</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m,q;</span><br><span class="line"><span class="type">int</span> dfncnt,top,dfn[N&lt;&lt;<span class="number">1</span>],low[N],sta[N];</span><br><span class="line"><span class="type">int</span> d[N&lt;&lt;<span class="number">1</span>],dis[N&lt;&lt;<span class="number">1</span>],fa[N&lt;&lt;<span class="number">1</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N],g[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_e</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;e[u].<span class="built_in">push_back</span>(v),e[v].<span class="built_in">push_back</span>(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_g</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;g[u].<span class="built_in">push_back</span>(v),g[v].<span class="built_in">push_back</span>(u);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add_g</span>(x,++cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u!=y;top--)u=sta[top],<span class="built_in">add_g</span>(u,cnt);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfncnt;</span><br><span class="line">    sta[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]==low[y])<span class="built_in">build</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=++dfncnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>,dis[y]=dis[x]+(y&lt;=n),fa[y][<span class="number">0</span>]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=K;j++)fa[y][j]=fa[fa[y][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)</span><br><span class="line">        <span class="keyword">if</span>(d[fa[x][i]]&gt;=d[y])</span><br><span class="line">            x=fa[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])</span><br><span class="line">            x=fa[x][i],y=fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)</span></span>&#123;<span class="keyword">return</span> dfn[x]&lt;dfn[y];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add_e</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    d[<span class="number">1</span>]=dis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dfncnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s;</span><br><span class="line">        <span class="built_in">read</span>(s);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            vec.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(vec[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">-2</span>*s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> lca=<span class="built_in">LCA</span>(vec[i],vec[i+<span class="number">1</span>]);</span><br><span class="line">            ans+=dis[vec[i]]+dis[vec[i+<span class="number">1</span>]]<span class="number">-2</span>*dis[lca];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">LCA</span>(vec[s<span class="number">-1</span>],vec[s])&lt;=n)ans+=<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfncnt=top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)low[i]=<span class="number">0</span>,e[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)dfn[i]=d[i]=dis[i]=<span class="number">0</span>,g[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="4-CF487E-Tourists"><a href="#4-CF487E-Tourists" class="headerlink" title="4.CF487E Tourists"></a>4.<a href="https://codeforces.com/problemset/problem/487/E">CF487E Tourists</a></h4><p>经典题。考虑建出圆方树，将方点的权值设为该点双连通分量中所有圆点权值最小值，然后进行树链剖分。但是这样修改原点时会影响到很多方点。考虑经典 trick，只维护方点所有儿子节点的权值最小值，用 <code>multiset</code> 维护即可，寻问时再算上父节点的值。时间复杂度 $\mathcal O(n\log n+q\log^2 n )$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> dfncnt,top,cnt,dfn[N],low[N],sta[N];</span><br><span class="line"><span class="type">int</span> si[N],d[N],fa[N],son[N],num[N],t[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N],g[N];</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt;sonv[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span></span><br><span class="line">&#123;</span><br><span class="line">    Node tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;tr[x].val=<span class="built_in">min</span>(tr[x&lt;&lt;<span class="number">1</span>].val,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x].l=l,tr[x].r=r;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> tr[x].val=a[num[l]],<span class="built_in">void</span>();</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].l==tr[x].r)<span class="keyword">return</span> tr[x].val=k,<span class="built_in">void</span>();</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,pos,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos,k);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)<span class="keyword">return</span> tr[x].val;</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>,res=INF;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>,l,r));</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Seg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_e</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;e[u].<span class="built_in">push_back</span>(v),e[v].<span class="built_in">push_back</span>(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_g</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;g[u].<span class="built_in">push_back</span>(v),g[v].<span class="built_in">push_back</span>(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add_g</span>(x,++cnt);a[cnt]=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u!=y;top--)<span class="built_in">add_g</span>(u=sta[top],cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfncnt;</span><br><span class="line">    sta[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]==low[y])<span class="built_in">build</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=<span class="number">1</span>,d[x]=d[fa[x]]+<span class="number">1</span>;</span><br><span class="line">    sonv[x].<span class="built_in">insert</span>(a[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x])<span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;</span><br><span class="line">        sonv[x].<span class="built_in">insert</span>(a[y]);</span><br><span class="line">        <span class="built_in">dfs1</span>(y);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        <span class="keyword">if</span>(si[son[x]]&lt;si[y])son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n)a[x]=*sonv[x].<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num[dfn[x]=++dfncnt]=x;</span><br><span class="line">    t[x]=p;</span><br><span class="line">    <span class="keyword">if</span>(son[x])<span class="built_in">dfs2</span>(son[x],p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:g[x])<span class="keyword">if</span>(y!=fa[x]&amp;&amp;y!=son[x])<span class="built_in">dfs2</span>(y,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Seg.<span class="built_in">modify</span>(<span class="number">1</span>,dfn[x],k);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> a[x]=k,<span class="built_in">void</span>();</span><br><span class="line">    sonv[fa[x]].<span class="built_in">erase</span>(sonv[fa[x]].<span class="built_in">find</span>(a[x]));</span><br><span class="line">    sonv[fa[x]].<span class="built_in">insert</span>(k);</span><br><span class="line">    a[x]=k,a[fa[x]]=*sonv[fa[x]].<span class="built_in">begin</span>();</span><br><span class="line">    Seg.<span class="built_in">modify</span>(<span class="number">1</span>,dfn[fa[x]],a[fa[x]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=INF;</span><br><span class="line">    <span class="keyword">while</span>(t[x]!=t[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[t[x]]&lt;d[t[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        res=<span class="built_in">min</span>(res,Seg.<span class="built_in">query</span>(<span class="number">1</span>,dfn[t[x]],dfn[x]));</span><br><span class="line">        x=fa[t[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&gt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    res=<span class="built_in">min</span>(res,Seg.<span class="built_in">query</span>(<span class="number">1</span>,dfn[x],dfn[y]));</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n)res=<span class="built_in">min</span>(res,a[fa[x]]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add_e</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="built_in">Tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    dfncnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>),<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    Seg.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)<span class="built_in">modify</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>笔记</tag>
        <tag>生成树</tag>
        <tag>最短路</tag>
        <tag>差分约束</tag>
        <tag>圆方树</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式汇总</title>
    <url>/2023/05/27/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>一些模板与式子。</p>
<span id="more"></span>
<h2 id="1-多项式乘法"><a href="#1-多项式乘法" class="headerlink" title="1.多项式乘法"></a>1.多项式乘法</h2><p>梦开始的地方。</p>
<h3 id="1-1-FFT-快速傅里叶变换"><a href="#1-1-FFT-快速傅里叶变换" class="headerlink" title="1.1. FFT 快速傅里叶变换"></a>1.1. FFT 快速傅里叶变换</h3><details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="type">const</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x+t.x,y+t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x-t.x,y-t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> Complex <span class="keyword">operator</span>*(<span class="type">const</span> Complex &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x*t.x-y*t.y,x*t.y+y*t.x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N],b[N];</span><br><span class="line"><span class="type">int</span> tot,bit,rev[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FFT</span><span class="params">(Complex *a,<span class="type">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        <span class="keyword">if</span>(rev[i]&lt;i)<span class="built_in">swap</span>(a[rev[i]],a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Complex w1=&#123;<span class="built_in">cos</span>(PI/mid),<span class="built_in">sin</span>(inv*PI/mid)&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid*<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Complex cur=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++,cur=cur*w1)</span><br><span class="line">            &#123;</span><br><span class="line">                Complex x=a[i+j],y=cur*a[i+j+mid];</span><br><span class="line">                a[i+j]=x+y,a[i+j+mid]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">read</span>(x);</span><br><span class="line">        a[i].x=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">read</span>(x);</span><br><span class="line">        b[i].x=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;n+m+<span class="number">1</span>)bit++;</span><br><span class="line">    tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;bit<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(a,<span class="number">1</span>),<span class="built_in">FFT</span>(b,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)a[i]=a[i]*b[i];</span><br><span class="line">    <span class="built_in">FFT</span>(a,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">int</span>(a[i].x/tot+<span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-2-NTT-快速数论变换"><a href="#1-2-NTT-快速数论变换" class="headerlink" title="1.2. NTT 快速数论变换"></a>1.2. NTT 快速数论变换</h3><details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e6</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>,G=<span class="number">3</span>,Gi=<span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> bit,tot,rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">		x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		<span class="keyword">if</span>(rev[i]&lt;i)<span class="built_in">swap</span>(a[rev[i]],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> g=<span class="built_in">qpow</span>(inv==<span class="number">1</span>?G:Gi,(mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,cur=<span class="number">1</span>;j&lt;mid;j++,cur=<span class="number">1ll</span>*cur*g%mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x=a[i+j],y=<span class="number">1ll</span>*cur*a[i+j+mid]%mod;</span><br><span class="line">				a[i+j]=<span class="built_in">adj</span>(x+y),a[i+j+mid]=<span class="built_in">adj</span>(x-y+mod);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="built_in">read</span>(b[i]);</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;n+m+<span class="number">1</span>)bit++;</span><br><span class="line">	tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;bit<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">1</span>),<span class="built_in">NTT</span>(b,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		a[i]=<span class="number">1ll</span>*a[i]*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> inv=<span class="built_in">qpow</span>(tot,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n+m+<span class="number">1</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="number">1ll</span>*a[i]*inv%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="2-多项式乘法逆"><a href="#2-多项式乘法逆" class="headerlink" title="2.多项式乘法逆"></a>2.多项式乘法逆</h2><p>给定 $f(x)$，求 $f^{-1}(x)$。</p>
<h3 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h3><p>首先知道：</p>
<script type="math/tex; mode=display">
\begin{align}
[x_0]f^{-1}(x)&=([x_0]f(x))^{-1}\notag
\end{align}</script><p>考虑倍增。假设已经求出 $f(x)$ 在 $\pmod {x^{\lceil \frac{n}{2}\rceil}}$ 意义下逆元 $f_0^{-1}(x)$。推一下：</p>
<script type="math/tex; mode=display">
\begin{align}
f(x)f_0^{-1}(x)&\equiv 1 \pmod {x^{\lceil \frac{n}{2}\rceil}}\notag \\
(f(x)f_0^{-1}(x)-1)^2&\equiv 0 \pmod {x^n}\notag \\
f(x)^2f_0^{-2}(x)-2f(x)f_0^{-1}(x)+1&\equiv 0 \pmod {x^n}\notag \\
\end{align}</script><p>同时除以 $f(x)$ 得到：</p>
<script type="math/tex; mode=display">
\begin{align}
f(x)f_0^{-2}(x)-2f_0^{-1}(x)+f^{-1}(x)&\equiv 0 \pmod {x^n}\notag \\
\end{align}</script><p>整理一下，最终得到：</p>
<script type="math/tex; mode=display">
\begin{align}
f^{-1}(x)&\equiv f_0^{-1}(x)(2-f(x)f_0^{-1}(x)) \pmod {x^n}\notag \\
\end{align}</script><p>递归计算即可，时间复杂度 $\mathcal O(n\log n)$。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N=<span class="number">4e6</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>,G=<span class="number">3</span>,Gi=<span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="type">int</span> bit,tot,rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bit=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;(len&lt;&lt;<span class="number">1</span>))bit++;</span><br><span class="line">	tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;bit<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">		x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		<span class="keyword">if</span>(rev[i]&lt;i)<span class="built_in">swap</span>(a[rev[i]],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> g=<span class="built_in">qpow</span>(inv==<span class="number">1</span>?G:Gi,(mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,cur=<span class="number">1</span>;j&lt;mid;j++,cur=<span class="number">1ll</span>*cur*g%mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x=a[i+j],y=<span class="number">1ll</span>*cur*a[i+j+mid]%mod;</span><br><span class="line">				a[i+j]=<span class="built_in">adj</span>(x+y),a[i+j+mid]=<span class="built_in">adj</span>(x-y+mod);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poly_inv</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		b[<span class="number">0</span>]=<span class="built_in">qpow</span>(a[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">poly_inv</span>(a,b,(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">init</span>(len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;i&lt;tot;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		c[i]=(i&lt;len?a[i]:<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">1</span>),<span class="built_in">NTT</span>(c,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		b[i]=<span class="number">1ll</span>*<span class="built_in">adj</span>(<span class="number">2</span><span class="number">-1ll</span>*b[i]*c[i]%mod+mod)*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> inv=<span class="built_in">qpow</span>(tot,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		b[i]=<span class="built_in">adj</span>(<span class="number">1ll</span>*b[i]*inv%mod+mod);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;tot;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="built_in">poly_inv</span>(a,b,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="3-多项式开根"><a href="#3-多项式开根" class="headerlink" title="3.多项式开根"></a>3.多项式开根</h2><p>给定 $g(x)$，求 $f(x)$ 满足：</p>
<script type="math/tex; mode=display">
\begin{align}
f(x)^2\equiv g(x)\pmod x^n
\end{align}</script><h3 id="倍增法-1"><a href="#倍增法-1" class="headerlink" title="倍增法"></a>倍增法</h3><p>首先知道：</p>
<script type="math/tex; mode=display">
\begin{align}
[x_0]f(x)&=\sqrt{[x_0]g(x)}\notag
\end{align}</script><p>考虑倍增。假设已经求出 $g(x)$ 在 $\pmod {x^{\lceil \frac{n}{2}\rceil}}$ 意义的平方根 $f_0(x)$。推一下：</p>
<script type="math/tex; mode=display">
\begin{align}
f_0(x)^2&\equiv g(x) &\pmod {x^{\lceil \frac{n}{2}\rceil}} \notag\\
f_0(x)^2-g(x)&\equiv 0 &\pmod {x^{\lceil \frac{n}{2}\rceil}} \notag\\
(f_0(x)^2-g(x))^2&\equiv 0 &\pmod {x^n} \notag\\
(f_0(x)^2+g(x))^2&\equiv 4 f_0(x)^2g(x) &\pmod {x^n} \notag\\
\frac{(f_0(x)^2+g(x))^2}{4 f_0(x)^2} &\equiv f(x)^2 &\pmod {x^n} \notag\\
\frac{f_0(x)^2+g(x)}{2 f_0(x)} &\equiv f(x) &\pmod {x^n} \notag\\
\end{align}</script><p>最终得到：</p>
<script type="math/tex; mode=display">
\begin{align}
2^{-1}f_0(x)+2^{-1}f_0^{-1}(x)g(x) &\equiv f(x) &\pmod {x^n} \notag\\
\end{align}</script><p>需要一次多项式求逆，时间复杂度 $\mathcal O(n\log n)$。</p>
<h3 id="多项式快速幂"><a href="#多项式快速幂" class="headerlink" title="多项式快速幂"></a>多项式快速幂</h3><h2 id="4-多项式除法"><a href="#4-多项式除法" class="headerlink" title="4.多项式除法"></a>4.多项式除法</h2><p>给定一个 $n$ 次多项式 $F(x)$ 和一个 $m$ 次多项式  $G(x)$ ，请求出多项式 $Q(x)$, $R(x)$，满足以下条件：</p>
<ul>
<li>$Q(x)$ 次数为 $n-m$，$R(x)$ 次数小于 $m$</li>
<li>$F(x) = Q(x) * G(x) + R(x)$</li>
</ul>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>我们发现假如没有 $R(x)$，那么我们只需要对 $G(x)$ 做一次多项式求逆，再与 $F(x)$ 相乘即可。于是尝试去掉 $R(x)$ 的影响。</p>
<p>考虑一种变换，我们将 $F(x)$ 视作 $n$ 次多项式（实际次数小于等于 $n$），$F_R(x)=x^n F(\frac{1}{x})$，即 $[x_i]F_R(x)=[x_{n-i}]F(x)$。</p>
<p>开始推导：</p>
<script type="math/tex; mode=display">
\begin{align}
F(x) &= Q(x) * G(x) + R(x)\notag\\
F(\frac{1}{x}) &= Q(\frac{1}{x}) * G(\frac{1}{x}) + R(\frac{1}{x})\notag\\
x^n F(\frac{1}{x}) &= x^{n-m} Q(\frac{1}{x}) * x^m G(\frac{1}{x}) + x^{n-m+1} x^{m-1} R(\frac{1}{x})\notag\\
F_R(x) &= Q_R(x) * G_R(x) + x^{n-m+1} R_R(x)\notag\\
\end{align}</script><p>注意 $Q_R(x)$ 的次数为 $n-m$，我们考虑对整个式子对 $x^{n-m+1}$ 取模并不会影响 $Q_R(x)$，并且可以消去 $R_R(x)$。</p>
<script type="math/tex; mode=display">
\begin{align}
F_R(x) &\equiv Q_R(x) * G_R(x) &\pmod {x^{n-m+1}}\notag\\
Q_R(x) &\equiv F_R(x) * G_R^{-1}(x) &\pmod {x^{n-m+1}}\notag\\
\end{align}</script><p>于是可以得到 $Q(x)$，继而可以得到 $R(x)$。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>容斥原理</title>
    <url>/2023/02/26/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>容斥是门学问。</p>
<span id="more"></span>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>集合 $U$ 中的元素有 $n$ 种不同的属性，而第 $i$ 种属性称为 $P_i$，拥有属性 $P_i$ 的元素构成的集合为 $S_i$，那么：</p>
<script type="math/tex; mode=display">
\begin{align}
\bigcup_{i=1}^n S_i=& \sum_i |S_i|-\sum_{i<j} |S_i\bigcap S_j|+\sum_{i<j<k}|S_i\bigcap S_j\bigcap S_k|-\dots\\
&+(-1)^{m-1}\sum_{a_i<a_{i+1}}\bigcap_{i=1}^m S_{a_i}+\dots+(-1)^{n-1}|S_1\cap S_2\cap \dots S_n|
\end{align}</script><p>即：</p>
<script type="math/tex; mode=display">
\begin{align}
\bigcup_{i=1}^n S_i=\sum_{m=1}^{n}(-1)^{m-1}\sum_{a_i<a_{i+1}}\bigcap_{i=1}^m S_{a_i}
\end{align}</script><p>对于证明，我们需要证明每个元素恰好出现一次，把所有出现该元素的集合拿出来，来算其出现次数。设其出现的集合个数为 $m$：</p>
<script type="math/tex; mode=display">
\begin{align}
cnt&=\binom{m}{1}-\binom{m}{2}+\binom{m}{3}-\dots +(-1)^{m-1}\binom{m}{m}\\
&=\binom{m}{0}-\sum_{i=0}^{m}\binom {m}{i}\\
&=1-(1+(-1))^m=1
\end{align}</script><p>另外，集合的并可以用全集减去补集的并得到，即：</p>
<script type="math/tex; mode=display">
\begin{align}
\bigcap_{i=1}^{n}S_i=|U|-\bigcup_{i=1}^{n} \overline{S_i}
\end{align}</script><p>对右边容斥即可。</p>
<h3 id="2-容斥原理一般化"><a href="#2-容斥原理一般化" class="headerlink" title="2.容斥原理一般化"></a>2.容斥原理一般化</h3><p>容斥原理是解决计数问题的利器，对于两个集合的函数 $f(S),g(S)$，若：</p>
<script type="math/tex; mode=display">
\begin{align}
f(S)=\sum_{T\subseteq S}g(T)
\end{align}</script><p>那么有：</p>
<script type="math/tex; mode=display">
\begin{align}
g(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|} f(T)
\end{align}</script><p>同样的对于</p>
<script type="math/tex; mode=display">
\begin{align}
f(T)=\sum_{T\subseteq S}g(S)
\end{align}</script><p>那么有：</p>
<script type="math/tex; mode=display">
\begin{align}
g(T)=\sum_{T\subseteq S}(-1)^{|S|-|T|} f(S)
\end{align}</script><p>我们发现上述的 $f(S),g(S)$，可以对应为 “至多/至少” 与 “恰好”。</p>
<h3 id="3-min-max-容斥"><a href="#3-min-max-容斥" class="headerlink" title="3.min-max 容斥"></a>3.min-max 容斥</h3><p>对于集合 $S,T$ 且 $T\subseteq S$，那么有：</p>
<script type="math/tex; mode=display">
\begin{align}
\max_{i\in S}a_i=\sum_{T\subseteq S}(-1)^{|T|+1}\min_{i\in S}a_i\\
\min_{i\in S}a_i=\sum_{T\subseteq S}(-1)^{|T|+1}\max_{i\in S}a_i
\end{align}</script><p>更加重要的是，这个式子在期望意义下也是成立的，即：</p>
<script type="math/tex; mode=display">
\begin{align}
E(\max_{i\in S}a_i)=\sum_{T\subseteq S}(-1)^{|T|+1}E(\min_{i\in S}a_i)\\
E(\min_{i\in S}a_i)=\sum_{T\subseteq S}(-1)^{|T|+1}E(\max_{i\in S}a_i)
\end{align}</script><p>这就比较好了，因为对于 $(13)$ 式子中，大多数情况下 $\displaystyle E(\min_{a_i\in S}a_i)$ 是相对好求的。</p>
<p>还有更强的：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{kth}\max_{ i\in S}a_i=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}\min_{i\in T} a_i\\
\text{kth}\min_{ i\in S}a_i=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}\max_{i\in T} a_i
\end{align}</script><p>同样对于期望意义下也是成立的：</p>
<script type="math/tex; mode=display">
\begin{align}
E(\text{kth}\max_{ i\in S}a_i)=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}E(\min_{i\in T} a_i)\\
E(\text{kth}\min_{ i\in S}a_i)=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}E(\max_{i\in T} a_i)
\end{align}</script><p>长得很像二项式反演！其实确实可以从二项式反演的角度证明以上等式。</p>
<h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><h4 id="1-AGC005D-K-Perm-Counting"><a href="#1-AGC005D-K-Perm-Counting" class="headerlink" title="1.AGC005D ~K Perm Counting"></a>1.<a href="https://atcoder.jp/contests/agc005/tasks/agc005_d">AGC005D ~K Perm Counting</a></h4><p>是个错位排列的扩展。我们尝试用类似的做法解决。设 $f(n)$ 表示钦定 $n$ 个元素满足 $|p_i-i|= k$ 的方案数，相当于求恰好有 $0 $ 个元素满足 $|p_i-i|= k$，利用式子 $(11)$ ，容斥得到答案为：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n (-1)^i (n-i)!f(i)</script><p>$f(n)$ 怎么求？钦定 $n$ 个元素满足 $p_i=i\pm k$，显然只有 $\bmod 2k$ 的同余类之间才会产生冲突。于是把每个同余类单独拿出来，需要在 $n$ 个点中选 $m$ 个点。将排列转化为二分图上的匹配。我们根据上面的限制对于每个同余类建出来的图是形如一条链的，问题就变为 $n$ 条匹配选 $m$ 条有多少种方案。相当于要求不能有匹配相邻。我们只要选择一条匹配则其后面的一条一定不能选，通过组合数得到方案数为 $\displaystyle \binom{n-m+1}{m}$。再使用背包进行合并不同同余类即可。这样暴力做是 $\mathcal O(n^2)$ 的，足以通过。但其实这个过程我们完全可以用生成函数来做，直接求其卷积即可，时间复杂度就为 $\mathcal O(n\log n)$。</p>
<p>此处为暴力 $\mathcal O(n^2)$ 代码。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,mod=<span class="number">924844033</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> fac[N],ifac[N];</span><br><span class="line"><span class="type">int</span> f[N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n||m&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;~i;i--)ifac[i]=<span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="built_in">prework</span>(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=<span class="built_in">min</span>(n,k&lt;&lt;<span class="number">1</span>);t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m=(t&gt;k)+((n-t)/k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;~i;i--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,m);j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> res=<span class="built_in">C</span>(m-j+<span class="number">1</span>,j);</span><br><span class="line">                f[i]=<span class="built_in">adj</span>(f[i]+<span class="number">1ll</span>*f[i-j]*res%mod);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+(i&amp;<span class="number">1</span>?mod<span class="number">-1ll</span>*f[i]*fac[n-i]%mod:<span class="number">1ll</span>*f[i]*fac[n-i]%mod));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>容斥</tag>
        <tag>笔记</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>无</title>
    <url>/2022/08/18/%E6%97%A0/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d4ae7f5d494f03af1a8664b66f4cef6335c3b2241f9df3b23d2f810984d156d3">2e38a67a3587ae81f8e8aaf04b5440843fe32d479caec342b0f00ee7e0b2dba2d49b078f4eb1df66ae05138d21963060de67353b08284844a8a2b4975bccd9ff27fe545e7686465f7906381b0d39293462ce664585782717af13ceb2175cd994b8d678ca9e99d51e5b1a6e691fde46d76137449b34d998e97bc0a3cfa397d890b88370501b3dc867629151d338653cf41da13679f466d7be21de4248b094660bab24453b07d7a616a4d094e6d7af065fe4b380e4c8cd603ca3b4fdad08627e1cf6e362fe917dc1b9be2f70faae51aa1efd59b4692cc48484065f430b0875c3ef5371d5b0d35b0be7ca4e3754d861ad0aab9324dc93b61e051c47dc59387985b9060c8fb8892cb88db463bb97a6c474523a6fe9522bdf6644210d6e8456f656f4bd91692ddcd2afa521a6a3ac01e197fc64d5418c4702596300669b2cbdb0c1f57894ae1f2150097626c037376f68b91a50a434c62a12406753e083bc3512794eb1a120497374b08e7f21456a7077d6a303ba2b6b017797111ed94d2a041ae2ddb7d40af1ffdd3110aad1d19523737ea22dcecbfa0fc6f19bb18ef363026f21eb82529593ba945cf9b9feba5a7f42f31f4648dd95c0cc5b7090e87190510730861eab0a0a0fe475932b54f684ec970746f37cdeacdccd2e6116e8f93a14d59cda91577ce40ddbabc37d401d5f8ff85ab5888070a8d675e347f58998fc47d654e5c1f656e6e04b90751f78658800bce127f26b3931992a5de4510c2ae868ec3bca5d06976a2fe3d9fb05a2634e38138b58775b7897803beb737b2986c98172ca48b27952cbfe649b9741271716523cba6767566e3aea020566e3e0a9655fe8e3727e9b1d757f89cd8a35671eef2555a649567474d75da9af74acd06b258120226b12f9f391cc3b1094f03a8d981620e394aec3ac4006fde6b3b7f1a54dbf662233a44eefb63c2bfdec37ee20866b20349d5666d18dbfbb31a3a81f025a83d5377ba676a5bd99a6bbe4d91c039f3772c92bc7cbe841b3ab1c9569eaf2a497305ffe906fd644275c4cae905b8d43e3611f75189a38e54c7e028e79576ad5244a20f7869aa29eb370eeebc7117b2b79dd8a741eed51ce1d3353ccb3bd745546da875236c14012410b2265053f0f762eb76c955514a7695cbde9e01287f85641da16f326f4f48e892c9f08234592b8c5980fb747f0845f4e03ad6237a17cb971aadb0c16f326204b781eabf5c243789740bc8593ce3a0238d9d47cf480685b7cfcf8dd819433adad4e0906b50447f28923f58edfd9e27ae8ea048a95283122b0f4e63308e4dd9dfa51e17ab3e3a57fbd5c2c9399e873360ee3091abad46bed9071cff72385e03abdb550d45fe6d3f8644f329466f75421658a2bfe21d174dc6727aa88cf56ed51743d34a0ad612a84fdc70445d2a6cc50f0e0deadd14512407ba41773a5591975d744bf9615f5c3a6953560e666bd07481b874bbe434886cb61278d87cfc013baf8a771c39db2d38dba33ffeb2c126d826ad001e6f074ff193e66215d4d6800e426d0865e7222bc8b4e2cf1f67ff4f950992bbd6de44667e6c96905d2668bff96893b8678ee7153385422a0794c89dd16a67d43cfc796565cd04add59ae28b448cd376eba092e2a7faafcb318681daa38781dfa425649939211ec77fac7b6c25c767df702fdd2b717122bde5bfa4bd28768885d37e34d1fdea418cbe53713479e9c115204ced44614cb9cfe497107a8f1b2bfa9ff2e74855624e0e045f502502284d5988a2a2f12f10b7d7605bdd9a4b64b8c2aac550698e0898aca72aa8ed6f7c8df320dc055044d4906e6fabcdb78078ea59e77f510d7b93e93aa3eab520ff94e4bf65e4659a58329fad7b7f5b1c2768be01fe0b8ef58a03317bdc00f94fd63997cb622fed37ab25c9a81352e74065b9ebcc907d89a1b03815ff237e7ef82d6eb876b4638fa92ee645ab2d01be4b3f0be11053965879b0af17bee2aaba1c0677af7ff7622cee794611c2d8eda650c3f909925d03d6e74d8177c5285e6f92ba90eb325c9fa026e2a876c1383321e712a9c04fd9d035b2a2edd75fe0823e1493cdab7bc12fa0d1ff3742714d667d36548662637028696cc077594a30a1a0959fc2dcb3a545d3b64ac20dee95651a1135e3101fc8715a64ab11878dcb8146aedeb8c990dd89bcb15d5b385faa68c9304d298d9d661b53834e457c2eb78bc50459876dba6c2a8a76e062ed27d7c16800f47a75433dc1037e3a71b5b9133fb51dba0bf01ce6b01ff3d3a4d9bdf3053f60b3b1aac612a3f5fc7fd7ccc795206d1732238872d8280b0e67bee0d43d7b19a8198811a3a7aecaf3bfdc82ffb7c94579a24ab6917e59053b7ba377844ef045e7b9194ef98f32242fa2b5b6e9f81a79c633882009523efb24f2bc7c482dbe14889b309172cae84ef7abf81623049b09c74d1ae10f45c192aee068035c7a6bb75e9e45ec962858992dd84190679567ca6eda17b94e63baea0926a316ade729e1cf2377da89cd111840f559ffb0489e4744481d404223cdea1c12634e08d6f39568a455cc2651bba9615850b55fce292a83c02b684a237aaf87b6f50109cfc1271602d508cedffbcda26474497f0954bb5b1155f14447d54d0dbf9223503144e740fe3c982b53d807acc3e883b46b44b0c40505132abda25f0aeef959ec7289ff0c8db007ca48e3803835ad311e8a3180bf276f552679365adcd91fabbf82e118e1db464f815aec4aa2fc49d046557a9eeed4d4973320a79d0882b304767265afcbeb49dbd1b26183312be706b7bd3cd76e820bc6ac486cfd2c6c914d741b8efb28aa211fab7960947f289a16e1ca2c005d87c17739d433840f796320f4626fe671130e49959fdea7d825c96305f973795d35fafbc34b6326e22ca7409459f1d3650cb4f3c01fde71c1e5e7eb5f19a5b922854cc9564d0e38cb3d6e25fe6132882f2567f8a537e7fda1d19857a9a9bbebf0fe161f4cacd8d7ba702806ee756dc6e847d0187853dd1af8b35421372f31c2f90578a6db01b312fa9ed27ad92acb3600dd26d77cd402a5b16e9dc8918c8d27ab22fafff7d297aef63e33f6c73dd1d74ea8af09294da10472c456c079c3fda47d652850d5a57e145aa6014b3ded3d8f4d2b2d10d0a290956e17efb94ae4e74c3b4855e20edd7d8d64cc7e64c0eec458646d4a83e1a37edf26c4e0b72adfb843892c4dc2e6f188c04191a1f7fc56fc6ec457fbccf64276b1770544080ff700659fecfc20ad60b3d0e501dddac200340160a134e15a73a04a2475904b55ea1cf8bcf2563ca4d1e477ff9a232ac9b62986ca4a565f1eb3a61928559b484aa6adcf3a87b4f4051c4e840bec8d79cc896d069997d45de4f9881e155757daed0976bcfcd04dcee1720b6ee947601a78f0c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">无</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>无</tag>
      </tags>
  </entry>
  <entry>
    <title>斯特林数</title>
    <url>/2023/05/25/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/</url>
    <content><![CDATA[<p>斯特林数学习笔记。</p>
<span id="more"></span>
<h2 id="1-第二类斯特林数"><a href="#1-第二类斯特林数" class="headerlink" title="1.第二类斯特林数"></a>1.第二类斯特林数</h2><p>虽然被称为第二类，但是应用比第一类更为广泛重要。</p>
<p><strong>第二类斯特林数</strong>（斯特林子集数）$\displaystyle {n \brace k}$，也可记作 $S(n,k)$，表示将 $n$ 个两两不同数，划分为 $k$ 个互不区分的非空集合的方案数。</p>
<h3 id="1-1-递推式"><a href="#1-1-递推式" class="headerlink" title="1.1 递推式"></a>1.1 递推式</h3><script type="math/tex; mode=display">
{n \brace k}={n-1 \brace k-1}+k{n-1 \brace k}</script><p>边界为 $\displaystyle {n \brace 0}=[n=0]$。</p>
<p>考虑组合意义，设当前元素为 $n$，将 $n$ 放进一个新建的集合的方案数为 $\displaystyle {n-1 \brace k-1}$，或者将其放进任意一个已有的集合的方案数为 $\displaystyle k{n-1 \brace k}$，二者相加得到。</p>
<h3 id="1-2-通项公式"><a href="#1-2-通项公式" class="headerlink" title="1.2 通项公式"></a>1.2 通项公式</h3><p>考虑先固定 $n$。发现“非空”的限制条件不好处理。考虑用容斥去掉这一条件。设计 $f(i)$ 表示将 $n$ 个两两不同数，划分为 $i$ 个<strong>互相区分</strong>的<strong>非空集合</strong>， $g(i)$ 表示将 $n$ 个两两不同数，划分为 $i$ 个<strong>互相区分</strong>的<strong>集合</strong>。根据定义容易得到：</p>
<script type="math/tex; mode=display">
\begin{align}
g(i)&=i^n\notag\\
g(i)&=\sum_{j=0}^n \binom{i}{j} f(j)\notag\\ 
\end{align}</script><p>运用二项式反演，得到：</p>
<script type="math/tex; mode=display">
\begin{align}
f(i)&=\sum_{j=0}^n (-1)^{i-j}\binom{i}{j}g(j)\notag\\
f(i)&=\sum_{j=0}^n \frac{(-1)^{i-j} j^n i!}{j!(i-j)!}\notag\\
\end{align}</script><p>最终得到：</p>
<script type="math/tex; mode=display">
{n \brace k}=\frac{f(k)}{k!}=\sum_{i=0}^n \frac{(-1)^{k-i} i^n}{i!(k-i)!}</script><h3 id="1-3-同一行第二类斯特林数的计算"><a href="#1-3-同一行第二类斯特林数的计算" class="headerlink" title="1.3 同一行第二类斯特林数的计算"></a>1.3 同一行第二类斯特林数的计算</h3><p>求出 $\displaystyle {n \brace i}$，其中 $i=0,1,\cdots,n$。</p>
<p>很容易根据通项公式辨识出卷积的形式：$\displaystyle {n \brace k}=\sum_{i=0}^n \frac{i^n}{i!}\frac{(-1)^{k-i}}{(k-i)!}$，直接卷积计算即可。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e6</span>+<span class="number">10</span>,mod=<span class="number">167772161</span>,G=<span class="number">3</span>,Gi=(mod+<span class="number">1</span>)/G;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="type">int</span> bit,tot,rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bit=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;len)bit++;</span><br><span class="line">	tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;bit<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">		x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)<span class="keyword">if</span>(rev[i]&lt;i)<span class="built_in">swap</span>(a[rev[i]],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> g=<span class="built_in">qpow</span>(inv==<span class="number">1</span>?G:Gi,(mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,cur=<span class="number">1</span>;j&lt;mid;j++,cur=<span class="number">1ll</span>*cur*g%mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x=a[i+j],y=<span class="number">1ll</span>*cur*a[i+j+mid]%mod;</span><br><span class="line">				a[i+j]=<span class="built_in">adj</span>(x+y),a[i+j+mid]=<span class="built_in">adj</span>(x-y+mod);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(inv==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> inv=<span class="built_in">qpow</span>(tot,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)a[i]=<span class="built_in">adj</span>(<span class="number">1ll</span>*a[i]*inv%mod+mod);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,prod=<span class="number">1</span>;i&lt;=n;i++,prod=<span class="number">1ll</span>*prod*i%mod)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> inv=<span class="built_in">qpow</span>(prod);</span><br><span class="line">		a[i]=<span class="number">1ll</span>*<span class="built_in">qpow</span>(i,n)*inv%mod;</span><br><span class="line">		b[i]=((i&amp;<span class="number">1</span>)?mod-inv:inv);</span><br><span class="line">	&#125;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">init</span>(n&lt;&lt;<span class="number">1</span>); </span><br><span class="line">    <span class="built_in">NTT</span>(a,<span class="number">1</span>),<span class="built_in">NTT</span>(b,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)a[i]=<span class="number">1ll</span>*a[i]*b[i]%mod;</span><br><span class="line">    <span class="built_in">NTT</span>(a,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-4-同一行第二类斯特林数的计算"><a href="#1-4-同一行第二类斯特林数的计算" class="headerlink" title="1.4 同一行第二类斯特林数的计算"></a>1.4 同一行第二类斯特林数的计算</h3><h2 id="2-第一类斯特林数"><a href="#2-第一类斯特林数" class="headerlink" title="2.第一类斯特林数"></a>2.第一类斯特林数</h2><p><strong>第一类斯特林数</strong>（斯特林轮换数）$\displaystyle {n \brack k}$，也可记作 $s(n,k)$，表示将 $n$ 个两两不同数，划分为 $k$ 个互不区分的非空轮换的方案数。</p>
<h3 id="1-1-递推式-1"><a href="#1-1-递推式-1" class="headerlink" title="1.1 递推式"></a>1.1 递推式</h3><script type="math/tex; mode=display">
{n \brack k}={n-1 \brack k-1}+(n-1){n-1 \brack k}</script><p>边界为 $\displaystyle {n \brack 0}=[n=0]$。</p>
<p>其组合意义与<strong>第二类斯特林数</strong>类似，不再赘述。</p>
<h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h2><p>记上升幂 $x^{\overline n}=\prod_{k=0}^{n-1}(x+k)=\frac{(x+n-1)!}{(x-1)!}$，下降幂 $x^{\underline n} =\prod_{k=0}^{n-1}(x-k)=\frac{x!}{(x-n)!}$。</p>
<p>我们发现他跟组合数相乘有很好的性质：</p>
<script type="math/tex; mode=display">
\begin{align}
\binom{n}{k}\times k^{\underline m}&=\binom{n-m}{k-m}\times n^{\underline m}\notag\\
\binom{n}{k}\times (n+1)^{\overline m}&=\binom{n+m}{k+m}\times (k+1)^{\overline m}\notag\\
\end{align}</script><p>我们很多时候可以利用这一点来处理带组合数的问题。</p>
<h3 id="3-1-普通幂与上升幂的相互转换"><a href="#3-1-普通幂与上升幂的相互转换" class="headerlink" title="3.1 普通幂与上升幂的相互转换"></a>3.1 普通幂与上升幂的相互转换</h3><script type="math/tex; mode=display">
\begin{align}
x^{\overline n}&=\sum_k {n\brack k} x^k\\
x^n&=\sum_k (-1)^{n-k} {n\brace k} x^{\overline k}\\
\end{align}</script><h3 id="3-2-普通幂与下降幂升幂的相互转换"><a href="#3-2-普通幂与下降幂升幂的相互转换" class="headerlink" title="3.2 普通幂与下降幂升幂的相互转换"></a>3.2 普通幂与下降幂升幂的相互转换</h3><script type="math/tex; mode=display">
\begin{align}
x^n&=\sum_k {n\brace k} x^{\underline k}\\
x^{\underline n}&=\sum_k (-1)^{n-k} {n\brack k} x^k\\
\end{align}</script><p>至于证明，$(1),(3)$ 式可以通过斯特林数的递推关系得到。$(2),(4)$ 式根据 $(1),(3)$ 式的结果，利用式子 $x^{\underline n}=(-1)^n (-x)^{\overline n}$ 容易得到。</p>
<p>利用这几条性质，我们可以容易实现普通幂多项式对下降幂多项式或者上升幂多项式的转化。</p>
<h3 id="3-3-点值转下降幂表示"><a href="#3-3-点值转下降幂表示" class="headerlink" title="3.3 点值转下降幂表示"></a>3.3 点值转下降幂表示</h3><p>给定 $n$ 次多项式 $F(x)$ 在 $[0,n]$ 的点值，求出它的下降幂表示。</p>
<p>根据定义得到：</p>
<script type="math/tex; mode=display">
F(x)=\sum_{i=0}^n b_i x^{\underline i}=\sum_{i=0}^n b_i \frac{x!}{(x-i)!}</script><p>将 $F(x)$ 转为 $\text{EGF}$，得到：</p>
<script type="math/tex; mode=display">
\hat{F}(x)=\sum_{i=0}^n b_i \frac{1}{(x-i)!}=b*e^x</script><p>于是得到 $b=\hat{F}(x)*e^{-x}$。卷积求出即可。详见 </p>
<h3 id="3-4-例题"><a href="#3-4-例题" class="headerlink" title="3.4 例题"></a>3.4 例题</h3><h4 id="1-P6620-省选联考-2020-A-卷-组合数问题"><a href="#1-P6620-省选联考-2020-A-卷-组合数问题" class="headerlink" title="1.P6620 [省选联考 2020 A 卷] 组合数问题"></a>1.<a href="https://www.luogu.com.cn/problem/P6620">P6620 [省选联考 2020 A 卷] 组合数问题</a></h4><p>有组合数？注意到 $n$ 很大，$m$ 比较小，我们尝试将带 $n$ 的枚举项消掉。先将普通幂多项式对下降幂多项式，设 $b_i$ 为 $f(x)$ 下降幂多项式形式的系数，即 $\displaystyle f(k)=\sum_{i=0}^m a_i k^i=\sum_{i=0}^m b_i k^{\underline i}$。</p>
<p>接下来就是推一下式子：</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{k=0}^n \sum_{i=0}^m b_i\times k^{\underline i}\times \binom{n}{k} \times x^k \notag\\
\sum_{k=0}^n \sum_{i=0}^m b_i\times n^{\underline i}\times \binom{n-i}{k-i} \times x^k \notag\\
\sum_{i=0}^m b_i\times n^{\underline i}\times x^i \sum_{k=0}^n \binom{n-i}{k-i} \times x^{k-i} \notag\\
\sum_{i=0}^m b_i\times n^{\underline i}\times x^i \times (x+1)^{n-i}\notag\\
\end{align}</script><p>直接计算即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,x,mod,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,x,mod,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)<span class="built_in">read</span>(a[i]),a[i]%=mod;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    b[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i][j]=<span class="built_in">adj</span>(s[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1ll</span>*j*s[i<span class="number">-1</span>][j]%mod);</span><br><span class="line">            b[j]=<span class="built_in">adj</span>(b[j]+<span class="number">1ll</span>*a[i]*s[i][j]%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    x%=mod;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,now=<span class="number">1</span>;i&lt;=m;now=<span class="number">1ll</span>*now*(n-i)%mod*x%mod,i++)</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*b[i]*now%mod*<span class="built_in">qpow</span>(x+<span class="number">1</span>,n-i)%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="2-P6667-清华集训2016-如何优雅地求和"><a href="#2-P6667-清华集训2016-如何优雅地求和" class="headerlink" title="2.P6667 [清华集训2016] 如何优雅地求和"></a>2.<a href="https://www.luogu.com.cn/problem/P6667">P6667 [清华集训2016] 如何优雅地求和</a></h4><p>和上一道题几乎一模一样。其中 $\displaystyle f(k)=\sum_{i=0}^m a_i k^i=\sum_{i=0}^m b_i k^{\underline i}$，推一下即可得到：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^m b_i\times n^{\underline i}\times x^i</script><p>只不过 $m\le 2\times 10^4$。需要将点值转下降幂表示求出 $b$。时间复杂度为 $\mathcal O(m\log m)$。</p>
<p>但是对此我们更简单的做法。我们设 $c_i=b_i\times i!$，容易得到：</p>
<script type="math/tex; mode=display">
f(k)=\sum_{i=0}^k c_i\cdot \frac{k^{\underline i}}{i!}=\sum_{i=0}^k \binom{k}{i} c_i</script><p>于是直接利用二项式反演即可得到：</p>
<script type="math/tex; mode=display">
c_k=\sum_{i=0}^k(-1)^{k-i}\binom{k}{i}f(i)</script><p>卷积得到即可 $\mathcal O(n\log n)$ 得到 $c$。这样可以避免点值转下降幂表示求出 $b$。两种方法本质上是一样的。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数学</tag>
        <tag>斯特林数</tag>
        <tag>下降幂</tag>
      </tags>
  </entry>
  <entry>
    <title>沉默</title>
    <url>/2022/11/15/%E6%B2%89%E9%BB%98/</url>
    <content><![CDATA[<p> ……</p>
<span id="more"></span>
<p>总有人选择沉默，似乎对于任何事都是这样，无论好的坏的。有人认为他们故作深沉，但他们的姿态不是事不关己，也不是高高在上——而是像树木一般，无言中挺立着。</p>
<p>沉默也许来源于内心的孤独。沉默是因为所流露的感情却也无人在意。既然无人倾听，那就没什么必要用话讲出来了。一个人的路上深一脚浅一脚地走，也只能感觉到自己的情感在泛滥，只好拼尽全力去保护玻璃般的心。随之语言功能也就逐渐退化，独自读一些写一些半懂不通的文字，仿佛徜徉于自己内心的世界的朦胧感，无法自拔。最后只是如此日复一日，江河日下罢了。这就是从前的感觉，像是得了病，是失去了能量的车轮，没有了向上的动力。</p>
<p>但也随着经历的是非越来越多——我想也多半是因为人总是要成长的。人们说：“沉默是成年人的默契。”此话只对了一半。从前的我们也很喜欢较真，一定要争个胜负，也不知道是为了得到什么——或许就是所谓的 <em>优越感</em>，却也害怕着被揭穿，好保住自己可怜的自尊心与<em>优越感</em>。不过谁谁谁做的什么什么事情，其实都心知肚明，只是也不愿多言。这种或是理解，或是不愿与其同流合污但也却无力改变，只暗下决心——像埋下了一颗种子，要用自己的方式完成自己的使命。更多的是少说话而多做事。自然还有一种则是纵容与包庇，这就直接成了令人厌恶的冷眼旁观者，于是这种更是废物了，并不归于这一类。沉默之中，也像这样观察着周围的一切。如此，在沉默中自身也逐渐变化着，褪去青涩就剩下粗糙的枝干，也不知道是应该高兴还是难过。只剩下沉默，直到应当的时机，再爆出口。</p>
<p>开始将目光移向自身，生活中的事物也沉淀下来。沉默中能够摒弃一些浮躁与戾气，逐渐深入自己，感觉到自我生命的本真，并明白自己想要成为什么，不想要成为什么。一切只是关乎你对自己生命价值的满足与充实的快乐。才能够宁静而致远。生命的意义是个永远求不出解的问题，但你能够知道这个问题有解，也会告诉自己继续要不停走下去。自己也在朦胧的内心世界开始清晰起来，也就不会再为了过去而后悔，为了未来而彷徨。</p>
<p>于是只是像树木一般，无言中挺立着。在冷气之中，只是感觉到充实与自由。</p>
<blockquote>
<p>人一旦悟透了就会变得沉默，不是没有与人相处的能力，而是没有了逢人作戏的兴趣。——鲁迅</p>
</blockquote>
]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>流逝</title>
    <url>/2023/05/03/%E6%B5%81%E9%80%9D/</url>
    <content><![CDATA[<p>5 月 3 日闲话。</p>
<span id="more"></span>
<p>偶然看见博客上一篇篇文章的日期，不由得惊觉已经过去这么久了。似乎还是不久之前呢，但是这么久还是一事无成。这么久了，自己真的成为了一名有水平的选手了吗？恍惚中还是懊恼。</p>
<p>需要静一静。</p>
<p>昨天刚立下的目标，顺间就全忘了。</p>
<p>甚至已经是前天了？</p>
<p>绝对不能再这样颓废下去了！！！</p>
]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>生成函数</title>
    <url>/2023/01/12/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>很有用。</p>
<span id="more"></span>
<h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0.写在前面"></a>0.写在前面</h2><p>无论是 OGF 还是 EGF，往往都具有很好的数学性质。而很多问题之所以可以用GF解决，因为我们可以将组合问题转化为研究GF的数学性质，再利用多项式科技解决。</p>
<p>所以说到底应该如何理解 GF？</p>
<h2 id="1-普通生成函数-OGF"><a href="#1-普通生成函数-OGF" class="headerlink" title="1.普通生成函数 OGF"></a>1.普通生成函数 OGF</h2><p>从 DP 的角度看，形式幂级数之间的相乘与不同状态间的转移等价，其中 $x^n$ 表示状态，系数 $a_n$ 表示该状态的答案。</p>
<h3 id="1-1-封闭形式"><a href="#1-1-封闭形式" class="headerlink" title="1.1 封闭形式"></a>1.1 封闭形式</h3><p>记几个式子，$F(x)$ 为序列 $a$ 的生成函数所对应的封闭形式：</p>
<script type="math/tex; mode=display">
\begin{align}
&a_n=\binom{m}{n}\Rightarrow F(x)=\sum_{n\ge0} \binom{m}{n} x^n=(1+x)^m\\
&a_n=\binom{m+n}{n} \Rightarrow F(x)=\sum_{n\ge0} \binom{m+n}{n}x^n=\frac{1}{(1-x)^{m+1}}\notag\\

\end{align}</script><p>还有一些经典式子：</p>
<script type="math/tex; mode=display">
\ln \frac{1}{1-x^k}=\sum_{i>0}\frac{1}{i}x^{ik}</script><h3 id="1-2-卷积"><a href="#1-2-卷积" class="headerlink" title="1.2 卷积"></a>1.2 卷积</h3><script type="math/tex; mode=display">
\begin{align}
F(x)&=\sum_{i\ge 0} a_nx^i\notag\\
G(x)&=\sum_{i\ge 0} b_nx^i\notag\\
F(x)*G(x)&=\sum_{n\ge 0}x^n\sum_{i\ge 0}a_i b_{n-i}\notag\\
\end{align}</script><p>直接卷积得到的新的生成函数，而这个生成函数系数的系数除了卷积得到的系数外，没有其他系数。从排列组合的角度理解，说明不同元素之间相对顺序的改变不会影响方案总数，故这样求出来是<strong>无标号</strong>的。</p>
<h2 id="2-指数生成函数"><a href="#2-指数生成函数" class="headerlink" title="2.指数生成函数"></a>2.指数生成函数</h2><p>或许还是可以从 DP 的角度理解，不同点是系数 $\frac{1}{i!}$，这可以用来代表 DP 转移中乘上的系数。</p>
<h3 id="2-1-封闭形式"><a href="#2-1-封闭形式" class="headerlink" title="2.1 封闭形式"></a>2.1 封闭形式</h3><h3 id="2-2-卷积"><a href="#2-2-卷积" class="headerlink" title="2.2 卷积"></a>2.2 卷积</h3><p>考虑两个EGF $\hat{F}(x)$ 和 $\hat{G}(x)$ 的卷积：</p>
<script type="math/tex; mode=display">
\begin{align}
\hat{F}(x)&=\sum_{i\ge 0} a_n\frac{x^i}{i!} \notag\\
\hat{G}(x)&=\sum_{i\ge 0} b_n\frac{x^i}{i!} \notag\\
\hat{F}(x)*\hat{G}(x)&=\sum_{n\ge 0}x^n\sum_{i\ge 0}a_i b_{n-i} \frac{1}{i!(n-i)!}\notag\\
&=\sum_{n\ge 0}\frac{x^n}{n!}\sum_{i\ge 0}\binom{n}{i}a_i b_{n-i}
\end{align}</script><p>我们得到一个新的指数生成函数，这个指数生成函数的系数还多上了 $\binom{n}i{}$。从排列组合的角度理解，说明不同元素之间相对顺序的改变会产生新的方案，或者说这样求出来的方案数是<strong>带标号</strong>的。</p>
<h3 id="2-3-指数函数-exp"><a href="#2-3-指数函数-exp" class="headerlink" title="2.3 指数函数 exp"></a>2.3 指数函数 exp</h3><p>设 $\hat{F}(x)$ 为 $f_i$ 的 EGF，考虑 EGF $\hat{F}^k(x)$ 的意义，即 $k$ 个 $\hat{F}(x)$ 卷积得到：</p>
<script type="math/tex; mode=display">
\hat{F}^k(x)=\sum_{n\ge 0}\frac{x^n}{n!}n!\sum_{\sum_i^k a_i=n}\prod_{j}^k\frac{f_{a_j}}{a_j!}</script><p>从集合的角度理解就是将 $n$ 个有标号元素划分到 $k&gt;0$ 个有标号集合中。$n=0$ 时系数为多项式常数项的乘积，之后的多项式 $\exp$ 的常数项需要满足常数项为 $0$。  </p>
<p>设 $F_k(n)$ 为 $n$ 个有标号元素划分为 $k$ 非空无序集合（这里 $n,k$ 的意义与上面相反，非空因为 $\exp$ 要求常数项为 $0$），$f_n$ 为满足原有 $n$ 个元素组成的特定结构的数量（具体由求解问题给定，且只与集合个数 $n$ 相关）。根据定义得到：</p>
<script type="math/tex; mode=display">
\begin{align}
F_k(n)=\frac{n!}{k!}\sum_{\sum_i^k a_i=n}\prod_{j}^k\frac{f_{a_j}}{a_j!}\notag\\
\end{align}</script><p>设 $F_k(n)$ 的 EGF 为 $G(x)$，那么得到：</p>
<script type="math/tex; mode=display">
\begin{align}
G_k(x)&=\sum_{n\ge 0}\frac{x^n}{n!}F_k(n)\notag\\
G_k(x)&=\frac{1}{k!}\sum_{n\ge 0}x^n\sum_{\sum_i^k a_i=n}\prod_{j}^k\frac{f_{a_j}}{a_j!}\notag\\
G_k(x)&=\frac{1}{k!}\hat{F}^k(x)
\end{align}</script><p>我们得到 $G_k$，尝试对 $G$ 求和得到 $G$：</p>
<script type="math/tex; mode=display">
G(x)=\sum_{k\ge 0} G_k(x)=\sum_{k\ge 0}\frac{1}{k!}\hat{F}^k(x)=\exp \hat{F}(x)</script><p>$\hat{F}(x)$ 是 $f_n$ 的指数生成函数，$f_n$ 为满足原有 $n$ 个元素组成的特定结构的数量。于是我们得到指数函数 $\exp$ 即 $G(x)=\exp \hat{F}(x)$ 的组合意义：表示将 $n$ 个元素划分为任意个不为空的集合的方案数。这就是<strong>指数公式定理</strong>。形式化的描述，即：</p>
<p>如果存在两个 EGF $F(x),G(x)$，其中 $F(x)$ 为 $f_n$ 的 EGF，$G(X)=\exp F(x)$，那么 $G(x)$ 是：</p>
<script type="math/tex; mode=display">
g_n=\sum_{\pi={S_1,S_2,\cdots,S_k}}\prod_{i=1}^k f_{|S_i|}</script><p>的 EGF，$\pi$ 是 $[n]$ 的一个划分。</p>
<h3 id="2-4-例题"><a href="#2-4-例题" class="headerlink" title="2.4 例题"></a>2.4 例题</h3><h4 id="1-P4841-集训队作业2013-城市规划"><a href="#1-P4841-集训队作业2013-城市规划" class="headerlink" title="1.P4841 [集训队作业2013]城市规划"></a>1.<a href="https://www.luogu.com.cn/problem/P4841">P4841 [集训队作业2013]城市规划</a></h4><p>设 $f_n$ 表示 $n$ 个点的有标号无向<strong>连通</strong>图方案数，$g_n$ 表示 $n$ 个点的有标号无向图方案数，$F(x),G(x)$ 分别为二者的 EGF。首先容易得到：$g_n=2^{\binom{n}{2}}$。</p>
<p>根据<strong>指数公式定理</strong>，我们容易得到：</p>
<script type="math/tex; mode=display">
\exp F(x)=G(x)</script><p>于是我们只需要对 $G(x)$ 取 $\ln$ 即可得到 $F(x)=\ln G(x)$。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>痛定思痛</title>
    <url>/2023/05/14/%E7%97%9B%E5%AE%9A%E6%80%9D%E7%97%9B/</url>
    <content><![CDATA[<p>我的时日也不久了。</p>
<span id="more"></span>
<p>何其憾？何其乐？何其短？</p>
<p>多乎哉？不多矣！！！</p>
]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>脑子里并没有另一个人的记忆</title>
    <url>/2023/01/15/%E8%84%91%E5%AD%90%E9%87%8C%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E8%AE%B0%E5%BF%86/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="18ffc29d707d3591fdf4c70f44b28d641a17f342fe9de0db2344df352626ee7f">ffc2a1a8d5dd2c8af5bcfcf7b828bee0cb524c044d024bc4843593b6a590981848eaae75129507fd7a1b3574b6c6c609c3ba37bbb90bd8dc46ead3468cc68a5ad8e99ced4f8e797217fdbf9ec8f60e730524708200cb811af10d56077d1fabd8ba4651e156fe4e179546ccafe37686fa151c2d54d68606b16715b1c27217ebf4fca4a762c5793bd96dbe88c80717eca13ae1df66429006e68c23303daf2548d557e56a6d60a9ff4cce568e1771db98bd677def74789a178eb9195b427743863e86a64ef866de7b63b4b63be6c4cfe3ff3e023865932cc8e2ee5d2212b5320ef526831af3723a73e036d58b9dcc9ece2f0be31a989814c362f5796f85af51d7339c5c61933d65639aa839431368b9b631113beb746c6d41acaec6f324d7264a47132438bf4959cf80348cdd958fab995828d06423a58acccc66f895bcc678322a0c67c7213208341b3a5cfa085ab1f2b0fd0f280f6b1e11e63100ac63664a19355a390e48b90ec747567a0b03d14dbf196ddc18b4c769a563afcb4c5e030c8c71a1bfd2c98d14e8229c4e7b686d9531320a047c48fdc13544808e3acf046d05fd3b78ceafd3f220d46c736866df9f9b3f8aace2eebe7dd78c43c3048cac205a1607d5dfea04e5144f789e552ecd605198e3a943f15f60c0eaf158f08a44e6c93e927a8e3c3515cada3b93984c7a6b005d872cb33098cf5cac20386d59ae215443bd730ca24e9176b472270635e105bc095a0cf767c73fe6c596b86d3431b410ac006e30d53b4b064d3fcb0e48655f5fc9d8c17609859b3780f065340e7741173f1d9d5451ac306ba4ba43aa687d278ec3c9f3427460fa965b5ed28ce7a3f5a7c74b9aea66f6faa08e7ebd84a028dc73af47c98268cf7985820270efc469760cccacad9b74c6b665f263b0b9cc77163b6e42dba24d68e789867763ddaf53a05df685b0c355c63260cdb97961e7d72532cb436b75a2179185f07106452c2422526c760eb516908f49a6dca8c6f7ad0e599f304520fc245472ac652fcfbca2866c9fbb3e3ee9f56b49b715c79ad3f7ae8e89c97bf7dbc0f9aaed86179b1e6af4abde3a2852dcc897e6787a8f04f88a5e1dd3a25972b8ad211e37ae24d087a3bab769622e1e8337c03329e08504046db2eccd2568d53c3c4fc13a65531ddb476d85b7ff25dd0266f555518f4c089b70b27d6bcbc1fbda5599506d61f69b2b40d43013ca626a3f75767ae98d5773d5804e89de12644a3325c140cc5e33b16e1bec67b76c6501f2b8354e80ae77777526c6bb6f32782fdef4dab57094bb2ab1bab12119a8a8e5373978f01c2d048accfcc58c334d3f0888d368e08e741941a9b76973e3ed0c3e771cdd7ed027a1d52d66ae8fad43fa5796ef5758505fabbb40f297023d1d9c786db9229c103e056f47a9f0a8ba70ef71770e8cd7be2fa07f1c4e35834cac4c5a41a885c089c85cb8214c12721a641e75cb0606dc08d5bab954978740b0f4da15a6a7c4e605a92dc8cae4cec04e9f762dd90c608f8298348b6c06805febaf51eed3aa1a557412f59e6aad936b1d9159257775079a624bc20edb6cc20e35ac38ea7de1f335adbd74c823b1c79295</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">I am.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>记梦</title>
    <url>/2023/06/12/%E8%AE%B0%E6%A2%A6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="adbc6290cf61e741fca124d2f05ce0602d9ba1a3ad0e3e95d248343a4cf7236c">1b05e05313998e5f4de994245a1b63dc3fa1111bfa407d42f7d6819ed87864b770335d25511c58f55134098d9dd5e4e07d9fcb413fbc4b9c04e7d152af1f92e50bbccf94c9e3980c962a326cceb563c736e72521e756294329843654305a7d49a5fb5f5cce31206e2715141170981de5550f480626e26f049c193860c8aa419c05d5a6c86959a7dbeb97a4b34cc6f6bfccf752616a2673f35629ee4a7dd66cff9d6e2ed0845ab24b8aaaa68e67f91cb155a2aab769739792c258c24b71f0f212648b4e09604f2d5edd3311087cbbe35506efbf561a1ac2864451503f1ed0b996378cae5c83281091762ffe4a97f3da26101ae68f95e6ead45b82c2de709ce053e006d79671c7e53fc4863094cbdc5b51a08eef4f4d65439ebca77321c22eedcef85f5528f281699d493bc5350693f0b3cc9bb26f197256292cf93b271c5a6d334d6b522dd0848ab14491ee5b8e06512e0f10bceb39c1ab042a5bb2c756e517ecad4fbfc6d565ca35f259aefeeb920e7987bb1423b584e882460c09060f03fb35ec38ed161bd2127980db58053e832b0feaee5aeccec9349dbdeb11bf8f99b8a1d4a7801b75722b868419af70695f6dfb8efdfed4f444e28f4bc5a42b6bd121de8d847a4dc4052a2294b73670e402bfe57ce0c2cc80921b09b0918cfa2058bd835230e834becb736e1cf845034ffbe0633aa5b98a3a84e69842c37be79904de16cf1960ceb1e82309abbdec58bb987c5ba3e99a390a0ea40b8a3427f5b3a91aa78b003a4caa86902c87ecbcbb134e6f4479bcf90e5cbc13ef85be1a5ad889ed3d8f7506d6a84222e096707647744192b8c805de5822cbcfc731ec1b0cbc30ec6172916567c2f65cbb7881f65af85af3c2ab5da4e49e0c298322041689657943b76bb3c4d9eb4ac43fe3d15b5f1784affb6601c0b8173413c524713183d6c83d98862ed7ad602434c240c23abbb17c23f616bdf15e8079194ac3758a083c9b8521ae80fddfa7440b4104f5cc2709018685a5769137733735438f0722ae14cddcecbc0c5698d4ebf868af0e912773b95ae7fe7778d48286234754ecf190a318f8028b1117d40eb473b333a748fdd53f776244fa6da707e5be3cca0e195f908a1e88ded6ae46b92c00a42b51378d975ceb4663d0763a81d168d869dc8e08184d906dfb70ba3832d4100fa5d49a90b1eca93eb9614862725639afae23b2a85cbcf17ad6ab93e36e52b89157fbf43a98459f01e8b118f76cd1d96df5e6b347c32cf5ed07eca05f9ec7e9e2f09456ff8da76a02f2b4d0d36f9fa3c4e2f837d2adbbb446398762f0e4fb2ae2ee1ce7a214938087e188e85916326b7a60fc86963308fe91358c24ab5b1b7c669d070df4611632dcb238ace6d528111d5dfd110b2f4250d3e1767ee445204bb0b7906962bbfe13599534f548febe28a0c4e8ff1537d7cb8189ba3b2b36bf71a1e77601af6d4ab3f9dca6400cbfd3d56dd0eee78237e98d9f0b56dc6e41c56b170db0ff3506528073602357ca15752c06fb43e634453a94a2b776536a9e720f67460a735bd39c8cec3a0b393f3ba27301e1c7d52d40fde22f994aba80e919dbc1cae8370ee7c7ffe003e615f66b8a0e89ae62fc356e78741c2ae804d500db36e3996ea2701a77e804677151f8639d93c803b1db4c3aa20d11abfafc122ba7cc1f23d230064a85710d5a6d4edf7f3d859297cfa286f95606bfaf199635a0677ee69a8ca3a2b960473986e5ff225844274dd96d45abd183abd4e0ef58e9afae821f7e300e9ffb527072b668988aafc693435dcb0da69b954753ec56713d7573a61a7d15e0918385bf67d39acea14e2368f6af0f7cace282fc5875801fcdf582f67d423d0373a24d1ba17547b4011125c8e1e212a4abdc812b0c6f28a27233a3e5964598b7ca3f1c95bb15400cbe37fda22cde1d11add5cd2fb0b8683a9c4d6edc98cd03db48f37d821f4a776eb8bdd2ee08b9761c6f53271ed4c833bf4e2bdad675b3029c8639c40f669d886430146a178989c9a6e7245cb8921421f0ed2d45df5b70b9961b00fa16ebcabf8a75dfcaf99347ed2769b2cf9bd7542e5de6bf12d8cecc2e67a7f72ee9bd97b1e67eb38fad524d38093b3b2e546e6ceec8ec0059c6a4fc48f334a94123ec9074644a9c4869901a868e4b337f52c0088ae003f154f371e739ade27ed8a079731f87e2c3d7f56ac5c54cf5549b6190b0d490aaa5912d6e365aa58ee64cf7e264fce09badc4aa32de136676c41d739d26c7c2f0c749e4c6b6c924f7120304d0fbd3469e1fcf6003080a799a59a347e44951b8a9c8191d4503685e13c792c2c4d145f28ddef821e47f055388b96a514d9b187c4100e42b9a63c34dee320bd683f9c22a39e4096e65ea15fc1d97f51b533fbadf53618d0cb31a00cafa430abb32f670e5cda86a22c5669f0607c1d7d81b1b2f5d4969db758fa8eb1d5d0931a02e7c38ba9ac2ca9f98c8c3b6c7fd0dc4e96ed12fa9849841d205a74edcd6a02a65c20786bfe6fde75d1501346c9363f9b4b20644f557a24b2aab29cb57f56825fdf7bac1235a916a7f53190a87b6565ced5dfb98af98d4a38f1e424b996b744a6dc4ac252ecad333c990fe253cf7a716b34af86fbc09a02e249b9d365c91cfffef04dc18abbc42f75b5e95320c9e1ed113353bbc006bcefcdb3e36ff2d55623a6500dc0a5d352ea51d56f705fbbbb815b46f7d2bed66691ee1782a43c9d09ec4f4545d73da66242bbdf08f8bc9dbecc04f399eb628366a3eadfb059faf3b54f14197381834e92a3bb4c48474e3274fbdf22ecab82a557ebbfb0e18e171443f7b0847988d607f477ae8d0a5fdfbbc73684484163779a4bbe2c3526206eea735060d9a3eaeb4878cca43fcaedc494d47d8de846827ebacafb59d3fa98e846922b965d83c227b6e713bef05d82ea0b948ef11d60f7af710211fbc85371656faee368ad25fd103ea2004aba2c970e9268c803a94d19d158b3841b867d4ea6c2701574492ca3b714530d057466c94b204147141a82f805c2695e8cf895014030d9f0d663baec4ba52639bb32d2ce069d9c703df049113a8f1cdd50d2d012963d1ae0d64134fd9c24ba0fdf862d90f6ef043e487e57260502e051dd432bc3ae5ddd7e45b7a503e5fba1156c288a8ad1a5227d9bbf6ac5d17119d1395bb2d9353e3a8738a45c2e11955296a2af1ac5219dbe01e7bb8278dc35accd6b960bfa9dde1ab0c285fd9e5acf6b45c5f7dec1edc6fda1d764f0084a0d88d08ab224291cd17c0380e804375dbbab7f526dca772c69e352b7dc0f711ec8f33fc3b3bacae9be5c4e3ab2431073cab6246d1a21c5d24e50e8b57e41a7d48b42528cad117e67d55bb6b6fe234c651a0e977d20475d882c637914c3441b0c8cd2493dbf32986378c83c00ec572fea9389c8e0e3826fafd422923e90ebb08d84a14707c810737373e82f7fb2dce79214c2651d4b4e7208c2d31f7b16225cc4b9cfb61ef434b710c1e126ddd84916deb0053b27797d4379dc3e82584a8a677f5628861b8a21d0bbaef9de3128ddee6561486a72ba753e7c33a3bedfe863a951bde979b880f89508450acf7d562461a262a4b1602b52a5100d4707bdbec9c3de68b3af115a745b89fc8c3a740adc279c061d55300de6a3fae2603c2fa716c0c8224bbd7fcada0a21b831f5dccd64f4d406e9f40974efceec7d41ccdf67909d7fb9a46bc32cb0813028dd42b852db317158dbc23444ac304e6257869602d59d39e7a04204ebc17ce4ede9a3a8c7bd7e84c3ea6f9bfe938e2cedaa5a8f53b2ef917ad7451c6d0d84f500ef38b13d37e5546233553379cbfd81516ce85cc326234cf4d93555a55be134eadabc45e9816db953d0e93d95f11f1cbf7e4b008239a188d1dd539f692c5cffb9be34377d9b1b951e26e60ccb42fd570d416b1ec1cd65f441358689505bd859d579fcb0626305987aa6b6bcb462aed555bcfb5cede52d39e2e6d974385521732078bba352f6f8a8283f1c65427d622477ed5413aefb4144cf792d3dffc905d825a6617cbbc1d56d7bf296cbfef9190c3d7d6672412e328c8e8907fbd8a9115b2452a016d923ecebdcc8675c473068e613ad85bf6d211697a083dc0f0cbf185ac179b899593a436ff8d305e48d660d5c60c6e3c920f1b923194392f92910d6052f8616dc1e9ea9be08c7594bff6859d1eee9c9cd32fcae9198ad3ca1e82356ab0b0147393f0cfb0a930ee6de7a9949b280300653f9b157854540b4e86086dea11d2d7e0f2ccdcbc7202783b95646820ab4da1ef77</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Say goodbye.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>辩驳</title>
    <url>/2023/04/22/%E8%BE%A9%E9%A9%B3/</url>
    <content><![CDATA[<p>4 月 22 日闲话。</p>
<span id="more"></span>
<p>脑子很乱。逐渐发现写闲话似乎是十分必要的了。现在情况是议论文处于完全不会写的状态，甚至文字也逐渐变得冗杂凌乱，信息熵极高。可是文字越来越多，时间越来越少，我该怎么办？？？不得不说的是考试的议论文真像是八股。既然阅卷人爱听，也只好说点浮夸美妙的词汇了。问题就在于，我连八股文的排比对偶都搞不懂，什么破题承题权当是一窍不通。我并不觉得好，我不愿写也并不写得出来。出来，于是连评论评论者得资格也丧失了。</p>
<p>也似乎都改不掉无病呻吟的毛病，还是说无病呻吟也是一种毛病？即使有病也不必呻吟，何必用锦绣之饰遮遮掩掩？在这一层层的胶布下的病灶也被修饰的成锦上添花的模样，不知在何处，只好装做出健全的模样，掩饰着真实的痛感。而又为什么不撕开绷带来，仔仔细细地瞧呢？有人就说了：“你居心何在？”或许溃烂的创面让病人自己看了也觉得恶心。索性直接宣称为“特色出口”，希望不会受到人们的怀疑罢了。</p>
<p>改日再写。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>随机100题</title>
    <url>/2022/06/16/%E9%9A%8F%E6%9C%BA100%E9%A2%98/</url>
    <content><![CDATA[<p> 随机的100道题作为练习 ，争取在NOIP前做完。</p>
<span id="more"></span>
<p>update: NOIP前应该是做不完了，还是太菜了。</p>
<p>update: NOIP爆炸了，可能是因为没把这东西做完吧。。。</p>
<p>update: 摆了，练习题目都做不完，还是有空再来吧。。。</p>
<h4 id="1-P4881-hby与tkw的基情"><a href="#1-P4881-hby与tkw的基情" class="headerlink" title="1.P4881 hby与tkw的基情"></a>1.<a href="https://www.luogu.com.cn/problem/P4881">P4881 hby与tkw的基情</a></h4><p>设 $m=\frac{(n+1)}{2}$​，容易得到要求的是 $Ans=\sum_{i=1}^{m}(2i-1)\cdot 26^i $​ </p>
<p>再用错位相减随便推一下得到：  </p>
<p>$26Ans=\sum_{i=1}^{m}(2i-1)\cdot 26^{i+1} $​  </p>
<p>$25Ans=-26+(2m-1)\cdot 26^{m+1}+2\cdot \sum_{i=2}^{m}26^i $​ </p>
<p>最后运用等比数列求和公式就可以得到：</p>
<p>$Ans=\frac{-26+(2m-1)\cdot26^{m+1}+2\cdot \frac{26^{n+1}-26^2}{25} }{25}$</p>
<p>最后直接套式子，除法用逆元即可，时间复杂度 $\mathcal O(T\log n)$。    </p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,inv;</span><br><span class="line"><span class="function">ll <span class="title">power</span><span class="params">(ll a,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inv=<span class="built_in">power</span>(<span class="number">25</span>,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(n);</span><br><span class="line">        <span class="type">int</span> m=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        ll res=<span class="built_in">power</span>(<span class="number">26</span>,m+<span class="number">1</span>);</span><br><span class="line">        ll ans=((<span class="number">2</span>*m<span class="number">-1</span>)*res%mod<span class="number">-26</span><span class="number">-2</span>*((res<span class="number">-26</span>*<span class="number">26</span>+mod)%mod*inv%mod)%mod+mod)%mod*inv%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="2-P5148-大循环"><a href="#2-P5148-大循环" class="headerlink" title="2.P5148 大循环"></a>2.<a href="https://www.luogu.com.cn/problem/P5148">P5148 大循环</a></h4><p>很明显得到 $Ans=C_{n}^{k}\cdot f(q)$ 。<br>而求 $f(q)$ 也很简单的用一个秦九韶算法就完了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line">ll n,m,k,q;</span><br><span class="line">ll a[N],pre[N];</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=a[m]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i;i--)</span><br><span class="line">        res=(res*q%mod+a[i<span class="number">-1</span>])%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (mod-mod/x)*<span class="built_in">inv</span>(mod%x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> pre[n]*<span class="built_in">inv</span>(pre[m])%mod*<span class="built_in">inv</span>(pre[n-m])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k,q);</span><br><span class="line">    q%=mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">f</span>(q)*<span class="built_in">C</span>(n,k)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="3-CF1601C-Optimal-Insertion"><a href="#3-CF1601C-Optimal-Insertion" class="headerlink" title="3.CF1601C Optimal Insertion"></a>3.<a href="https://www.luogu.com.cn/problem/CF1601C">CF1601C Optimal Insertion</a></h4><p>不错的一道分治，也不算很难。</p>
<p>运用调整法很容易证明，将 $b$ 按照升序插入才可能得到最优解，于是我们先将 $b$ 排序。 </p>
<p>考虑求出一个 $pos_i$ 为将 $b_i$ 插入到 $a_{pos_i}$ 前面（特别地 $pos_i=n+1$ 表示将 $b_i$ 插入到 $a$ 的最后面 ）。  </p>
<p>有上面的结论可以得到，$b$ 中的元素各自的<strong>产生的逆序对数</strong>是<strong>互不影响</strong>的，但他们的位置又互相受到限制，都是因为 $b$ 是以升序插入的，于是我们可以知道：当若有 $l&lt;mid&lt;r$ ，那么 $b_{mid}$ 在 $[pos_l,pos_r]$中的最优解即为在全局 $[1,n]$ 中的最优解（微扰法可以证明，此处就不再赘述）。</p>
<p>其实这个贡献有关系式 $w(i,j)+w(i-1,j+1)=w(i,j+1)+w(i-1,j)$，这就是决策单调性的经典式子了。</p>
<p>有了这个新结论，我们利用决策单调性这一点进行分治，用 $solve(p,q,l,r)$，表示将 $b_l,b_{l+1},…,b_r$ 插入到 $a$ 的 $[p,q]$ 之间，每次递归只需要用 $\mathcal O(p-q)$ 求出 $pos_{mid}$。</p>
<p>随后根据求出的 $pos$ 将 $b$ 插入 $a$ 中再求逆序对即可。时间复杂度 $\mathcal O((n+m)\log(n+m))$。</p>
<p>实际上还有另外一种解法，就是先将 $a$ 离散化并计算逆序对，再建立一颗线段树，表示每个位置维护插入到位置 $i$ 新增加的逆序对数。新增加的逆序对数由两部分组成，前面比 $b_i$ 大的 $+$ 后面比 $b_i$ 小的。我们接着考虑当 $b_i$ 变为 $b_{i+1}$ 时对线段树的影响，同时 $a$ 也需要小到大考虑，得到：当 $a_x&lt;b_i$ 时，应当使 $[1,x]+1$；而当 $a_y\le b_i$ 时，应当使 $[y+1,n+1]-1$，同时动态维护答案即可。时间复杂度 $\mathcal O(n\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> pos[N];</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> sum1[N],sum2[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	sum1[p<span class="number">-1</span>]=sum2[q<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=q;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum1[i]=a[i]&gt;b[mid];</span><br><span class="line">		sum2[i]=a[i]&lt;b[mid];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">		sum1[i]+=sum1[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=q<span class="number">-1</span>;i&gt;=p;i--)</span><br><span class="line">		sum2[i]+=sum2[i+<span class="number">1</span>];</span><br><span class="line">	pos[mid]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=q;i++)</span><br><span class="line">		<span class="keyword">if</span>(!pos[mid]||sum1[i<span class="number">-1</span>]+sum2[i]&lt;sum1[pos[mid]<span class="number">-1</span>]+sum2[pos[mid]])</span><br><span class="line">			pos[mid]=i;</span><br><span class="line">	<span class="built_in">solve</span>(p,pos[mid],l,mid<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">solve</span>(pos[mid],q,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) </span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge</span>(a,l,mid);</span><br><span class="line">    <span class="built_in">merge</span>(a,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>,k=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">        &#123;</span><br><span class="line">        	h[k]=a[i];</span><br><span class="line">			k++;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">            h[k]=a[j];</span><br><span class="line">			k++;</span><br><span class="line">			j++;</span><br><span class="line">            ans+=mid-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">        h[k]=a[i],k++,i++;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">        h[k]=a[j],k++,j++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        a[i]=h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(n,m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">read</span>(a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			<span class="built_in">read</span>(b[i]);</span><br><span class="line">		<span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m);</span><br><span class="line">		<span class="built_in">solve</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">		<span class="type">int</span> p=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;=m&amp;&amp;pos[j]==i)</span><br><span class="line">				c[++p]=b[j++];</span><br><span class="line">            c[++p]=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">merge</span>(c,<span class="number">1</span>,n+m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="4-P4516-JSOI2018-潜入行动"><a href="#4-P4516-JSOI2018-潜入行动" class="headerlink" title="4.P4516 [JSOI2018] 潜入行动"></a>4.<a href="https://www.luogu.com.cn/problem/P4516">P4516 [JSOI2018] 潜入行动</a></h4><p>树形背包裸题，状态和转移方程稍复杂，还需要滚动数组优化一下。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,K=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> si[N];</span><br><span class="line"><span class="type">int</span> f[N][K][<span class="number">2</span>][<span class="number">2</span>],g[K][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    f[x][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=f[x][<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(fa==y)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(y,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(si[x],m);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[j][<span class="number">0</span>][<span class="number">0</span>]=f[x][j][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            g[j][<span class="number">0</span>][<span class="number">1</span>]=f[x][j][<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">            g[j][<span class="number">1</span>][<span class="number">0</span>]=f[x][j][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            g[j][<span class="number">1</span>][<span class="number">1</span>]=f[x][j][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            f[x][j][<span class="number">0</span>][<span class="number">0</span>]=f[x][j][<span class="number">0</span>][<span class="number">1</span>]=f[x][j][<span class="number">1</span>][<span class="number">0</span>]=f[x][j][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(si[x],m);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=si[y]&amp;&amp;j+k&lt;=m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[x][j+k][<span class="number">0</span>][<span class="number">0</span>]=(f[x][j+k][<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1ll</span>*g[j][<span class="number">0</span>][<span class="number">0</span>]*f[y][k][<span class="number">0</span>][<span class="number">1</span>]%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">0</span>][<span class="number">1</span>]=(f[x][j+k][<span class="number">0</span>][<span class="number">1</span>]+<span class="number">1ll</span>*g[j][<span class="number">0</span>][<span class="number">1</span>]*(f[y][k][<span class="number">0</span>][<span class="number">1</span>]+f[y][k][<span class="number">1</span>][<span class="number">1</span>])%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">0</span>][<span class="number">1</span>]=(f[x][j+k][<span class="number">0</span>][<span class="number">1</span>]+<span class="number">1ll</span>*g[j][<span class="number">0</span>][<span class="number">0</span>]*f[y][k][<span class="number">1</span>][<span class="number">1</span>]%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">1</span>][<span class="number">0</span>]=(f[x][j+k][<span class="number">1</span>][<span class="number">0</span>]+<span class="number">1ll</span>*g[j][<span class="number">1</span>][<span class="number">0</span>]*(f[y][k][<span class="number">0</span>][<span class="number">0</span>]+f[y][k][<span class="number">0</span>][<span class="number">1</span>])%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">1</span>][<span class="number">1</span>]=(f[x][j+k][<span class="number">1</span>][<span class="number">1</span>]+<span class="number">1ll</span>*g[j][<span class="number">1</span>][<span class="number">0</span>]*(f[y][k][<span class="number">1</span>][<span class="number">0</span>]+f[y][k][<span class="number">1</span>][<span class="number">1</span>])%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">1</span>][<span class="number">1</span>]=(f[x][j+k][<span class="number">1</span>][<span class="number">1</span>]+<span class="number">1ll</span>*g[j][<span class="number">1</span>][<span class="number">1</span>]*(<span class="number">1ll</span>*f[y][k][<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1ll</span>*f[y][k][<span class="number">0</span>][<span class="number">1</span>]+<span class="number">1ll</span>*f[y][k][<span class="number">1</span>][<span class="number">0</span>]+<span class="number">1ll</span>*f[y][k][<span class="number">1</span>][<span class="number">1</span>])%mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(f[<span class="number">1</span>][m][<span class="number">0</span>][<span class="number">1</span>]+f[<span class="number">1</span>][m][<span class="number">1</span>][<span class="number">1</span>])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="5-CF1630D-Flipping-Range"><a href="#5-CF1630D-Flipping-Range" class="headerlink" title="5.CF1630D Flipping Range"></a>5.<a href="https://www.luogu.com.cn/problem/CF1630D">CF1630D Flipping Range</a></h4><p>题意简述：给你一个长度为 n 的数组 $A$ 和长度为 $m$ 的数组 $B$，你每次可以选择 $B$ 中的一个数 $b_i$，然后将 $A$ 中一段长度为 $b_i$ 的区间取反，求可能的 $\max{\sum_{i=1}^{n}a_i}$。</p>
<p>首先要转化问题，注意 $B$ 中的一个数 $b_i$ 可以重复选择，那么我们每一次都可以取反长度为 $|b_i-b_j|$ 的区间，容易由<strong>更相减损术</strong>转化为我们每次都选取一段长度为 $\gcd_{i=1}^{m}b_i$ 的区间。</p>
<p>那么问题就很简单了，用 $DP$ 将模 $\gcd_{i=1}^{m}b_i$ 的余数和其奇偶性记录进状态就可以很好转移了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m,a[N],b[N];</span><br><span class="line">ll f[N][<span class="number">2</span>],ans1,ans2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x==<span class="number">0</span>?y:<span class="built_in">gcd</span>(y%x,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(n,m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">read</span>(a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			<span class="built_in">read</span>(b[i]);</span><br><span class="line">		<span class="type">int</span> g=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			g=<span class="built_in">gcd</span>(g,b[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)</span><br><span class="line">			f[i][<span class="number">0</span>]=<span class="number">0</span>,f[i][<span class="number">1</span>]=-INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ll res1=f[i%g][<span class="number">0</span>],res2=f[i%g][<span class="number">1</span>];</span><br><span class="line">			f[i%g][<span class="number">0</span>]=<span class="built_in">max</span>(res1+a[i],res2-a[i]);</span><br><span class="line">			f[i%g][<span class="number">1</span>]=<span class="built_in">max</span>(res1-a[i],res2+a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		ans1=ans2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)</span><br><span class="line">			ans1+=f[i][<span class="number">0</span>],ans2+=f[i][<span class="number">1</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">max</span>(ans1,ans2));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="6-P2150-NOI2015-寿司晚宴"><a href="#6-P2150-NOI2015-寿司晚宴" class="headerlink" title="6.P2150 [NOI2015] 寿司晚宴"></a>6.<a href="https://www.luogu.com.cn/problem/P2150">P2150 [NOI2015] 寿司晚宴</a></h4><p>容易想到以所选数的质因数的集合为状态进行 DP，设 $f_{s_1,s_2}$ 为小 G 和小 W 所选数的质因数的集合分别为 $s_1,s_2$ 的方案数。但 $\le 500$ 的质因数太多了，无法全部记录。</p>
<p>注意一个关键点，$\le 500$ 的数最多有一个 $p\ge 23$ 的质因数，我们可以按照质因数 $p$ 对所有数进行分类，那么我们只需要考虑 $p$ 对同类数之间的限制即可。</p>
<p>考虑 $f1_{s_1,s_2},f2_{s_1,s_2}$，分别为小 G 和 小 W 选 $p$ 的方案数，而 $f’_{s_1,s_2}=f1_{s_1,s_2}+f2_{s_1,s_2}-f_{s_1,s_2}$。</p>
<p>于是我们只需要记录前面 $8$ 个质数即可。DP 过程中枚举 $s_2$ 时枚举 $s_1$ 补集的子集即可，时间复杂度为 $\mathcal O(3^8n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,S=(<span class="number">1</span>&lt;&lt;<span class="number">8</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Num</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s,d;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Num &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d&lt;t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line"><span class="type">int</span> cnt,prime[N],vis[N];</span><br><span class="line"><span class="type">int</span> f[N][N],f1[N][N],f2[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            prime[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j]))<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>&amp;&amp;x&gt;=prime[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(x%prime[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            a[now].s|=<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(x&amp;&amp;!(x%prime[i]))x/=prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[now].d=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,p);</span><br><span class="line">    <span class="built_in">prework</span>(N<span class="number">-10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">get</span>(i);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">2</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].d==<span class="number">1</span>||a[i].d!=a[i<span class="number">-1</span>].d)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(f1,f,<span class="built_in">sizeof</span>(f));</span><br><span class="line">            <span class="built_in">memcpy</span>(f2,f,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s1=S;~s1;s1--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c=S^s1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> s2=c;s2;s2=(s2<span class="number">-1</span>)&amp;c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(a[i].s&amp;s2))f1[s1|a[i].s][s2]=(f1[s1|a[i].s][s2]+f1[s1][s2])%p;</span><br><span class="line">                <span class="keyword">if</span>(!(a[i].s&amp;s1))f2[s1][s2|a[i].s]=(f2[s1][s2|a[i].s]+f2[s1][s2])%p;</span><br><span class="line">            &#125;</span><br><span class="line">            f1[s1|a[i].s][<span class="number">0</span>]=(f1[s1|a[i].s][<span class="number">0</span>]+f1[s1][<span class="number">0</span>])%p;</span><br><span class="line">            <span class="keyword">if</span>(!(a[i].s&amp;s1))f2[s1][a[i].s]=(f2[s1][a[i].s]+f2[s1][<span class="number">0</span>])%p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i].d==<span class="number">1</span>||a[i].d!=a[i+<span class="number">1</span>].d)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> s1=<span class="number">0</span>;s1&lt;=S;s1++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> c=S^s1;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> s2=c;s2;s2=(s2<span class="number">-1</span>)&amp;c)</span><br><span class="line">                    f[s1][s2]=((f1[s1][s2]+f2[s1][s2])%p-f[s1][s2]+p)%p;</span><br><span class="line">                f[s1][<span class="number">0</span>]=((f1[s1][<span class="number">0</span>]+f2[s1][<span class="number">0</span>])%p-f[s1][<span class="number">0</span>]+p)%p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s1=<span class="number">0</span>;s1&lt;=S;s1++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c=S^s1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s2=c;s2;s2=(s2<span class="number">-1</span>)&amp;c)</span><br><span class="line">            ans=(ans+f[s1][s2])%p;</span><br><span class="line">        ans=(ans+f[s1][<span class="number">0</span>])%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>​    </p>
<h4 id="7-CF777E-Hanoi-Factory"><a href="#7-CF777E-Hanoi-Factory" class="headerlink" title="7.CF777E Hanoi Factory"></a>7.<a href="https://www.luogu.com.cn/problem/CF777E">CF777E Hanoi Factory</a></h4><p>比较简单的题目，首先以<strong>外径</strong>为关键字进行排序，保证遍历时外径是有序的。再维护一个栈，直接模拟题意，当栈顶元素的内径 $\ge$ 当前元素的外径，将栈顶元素弹去。同时维护答案即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ring</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    ll h;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(ring x,ring y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x.b!=y.b)<span class="keyword">return</span> x.b&gt;y.b;</span><br><span class="line">        <span class="keyword">return</span> x.a&gt;y.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;k[N],sta[N];</span><br><span class="line"><span class="type">int</span> n,top;</span><br><span class="line">ll f[N],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(k[i].a,k[i].b,k[i].h);</span><br><span class="line">    <span class="built_in">sort</span>(k+<span class="number">1</span>,k+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;k[i].b&lt;=sta[top].a)top--;</span><br><span class="line">        sta[++top]=k[i];</span><br><span class="line">        sta[top].h+=sta[top<span class="number">-1</span>].h;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,sta[top].h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="8-CF475D-CGCDSSQ"><a href="#8-CF475D-CGCDSSQ" class="headerlink" title="8.CF475D CGCDSSQ"></a>8.<a href="https://www.luogu.com.cn/problem/CF475D">CF475D CGCDSSQ</a></h4><p>在线算法不容易实现，我们直接考虑对全局暴力求出所有公约数，用一个 $\text{map}$ 存储答案。只需要考虑优化。</p>
<p>比较简单地有：若 $l\le r&lt;n$，则有 $ \gcd_{i=l}^{r}\le \gcd_{i=l}^{r+1}$。这就意味当左端点固定时，随着右端点递增，$\gcd$ 单调递减。并且 $\gcd$ 种类数是 $\mathcal O(\log V)$ 的</p>
<p>这样就很简单了，我们只需要枚举左端点，对右端点进行二分或者倍增就可以了。ST 表查询 $\gcd$ 的时间是 $\mathcal O(\log V)$，其中 $V$ 为值域。</p>
<p>时间复杂度 $\mathcal O(n\log n\log^2 V+q\log n)$：</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> Log[N],st[N][<span class="number">25</span>];</span><br><span class="line">map&lt;<span class="type">int</span>,ll&gt;ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x?<span class="built_in">gcd</span>(y%x,x):y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        st[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=Log[n];j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">            st[i][j]=<span class="built_in">gcd</span>(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=Log[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len,<span class="type">int</span> g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=x+len,r=n,res=x;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    	<span class="type">int</span> now=<span class="built_in">query</span>(x,mid);</span><br><span class="line">    	<span class="keyword">if</span>(now==g)res=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res-x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=x,r=x;</span><br><span class="line">    <span class="keyword">while</span>(r&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> g=<span class="built_in">query</span>(x,l);</span><br><span class="line">        r=x+<span class="built_in">find</span>(x,l-x,g);</span><br><span class="line">        ans[g]+=r-l;</span><br><span class="line">        l=r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        Log[i]=Log[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="9-P3411-序列变换"><a href="#9-P3411-序列变换" class="headerlink" title="9.P3411 序列变换"></a>9.<a href="https://www.luogu.com.cn/problem/P3411">P3411 序列变换</a></h4><p>学会转化问题，与其考虑变，我们不如将目光放到哪些不变上。手动模拟，我们发现一个长度为 $n$ 的序列无论如何只需要最多 $n-1$ 次操作，我们考虑最优情况哪些数不会被操作。</p>
<p>这下就更简单了，我们只需要找到一条<strong>带重复元素的最长无缝上升子序列</strong>，设其长度为 $len$，因为穿插在这个子序列中的数总是能够被按一定顺序移到两端去从而变得有序。答案就是 $n-len$ 。</p>
<p>然而至今笔者未在网上找到靠谱的<strong>带重复元素的最长无缝上升子序列</strong>解法，现有有两组hack：</p>
<p><code>input1:
4
3 1 2 3
output1:
1</code><br><code>input2:
6
4 2 3 4 1 5
output2:
3</code></p>
<p>希望读者有新的思考，随时可以联系笔者。</p>
<details class="failure"><summary><i class="fa fa-times fa-fw"></i>Code1 100pts<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">int</span> a[N],b[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),b[i]=a[i];</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+len,a[i])-b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[a[i]]=(f[a[i]]?f[a[i]]:f[a[i]<span class="number">-1</span>])+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<details class="failure"><summary><i class="fa fa-times fa-fw"></i>Code2 90pts<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">int</span> a[N],b[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),b[i]=a[i];</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+len,a[i])-b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[a[i]]=<span class="built_in">max</span>(f[a[i]],f[a[i]<span class="number">-1</span>])+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="10-P1730-最小密度路径"><a href="#10-P1730-最小密度路径" class="headerlink" title="10.P1730 最小密度路径"></a>10.<a href="https://www.luogu.com.cn/problem/P1730">P1730 最小密度路径</a></h4><p>注意到关键：<strong>有向无环图</strong>。这意味一条路径最多只会经过 $n-1$ 次。再者 $1\le n\le 50$，我们考虑直接跑一遍 Floyd，并且将走过的边数记录进状态就可以实现类似于<strong>背包</strong>的转移。稍想便知，我们并不需要枚举边的决策点，有状态转移方程：</p>
<p>$f_{t,i,j}=\min f_{t-1,i,j}+f_{1,k,j}$</p>
<p>最直接遍历一遍 $f$ 数组计算出所有答案即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50</span>+<span class="number">10</span>,M=<span class="number">1e3</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> f[N][N][N];</span><br><span class="line"><span class="type">double</span> ans[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            ans[i][j]=<span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        f[<span class="number">1</span>][u][v]=<span class="built_in">min</span>(f[<span class="number">1</span>][u][v],w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">2</span>;t&lt;=n;t++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(k!=i&amp;&amp;k!=j&amp;&amp;i!=j)</span><br><span class="line">                        f[t][i][j]=<span class="built_in">min</span>(f[t][i][j],f[t<span class="number">-1</span>][i][k]+f[<span class="number">1</span>][k][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n;t++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(f[t][i][j]&lt;INF)</span><br><span class="line">                    ans[i][j]=<span class="built_in">min</span>(ans[i][j],f[t][i][j]*<span class="number">1.0</span>/t);</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(ans[x][y]&lt;INF)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,ans[x][y]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;OMG!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="11-P1485-火枪打怪"><a href="#11-P1485-火枪打怪" class="headerlink" title="11.P1485 火枪打怪"></a>11.<a href="https://www.luogu.com.cn/problem/P1485">P1485 火枪打怪</a></h4><p>很明显的二分，直接选择二分 $p$，重点在于如何写 $check(p)$ 函数。</p>
<p>首先考虑暴力，这样 $check(p)$ 时间复杂度是 $O(n^2)$ 的，尝试推一下性质。</p>
<p>很容易得到：</p>
<p>$\sum p-(i-j)^2=\sum p-\sum i^2+2\sum i\cdot j-\sum j^2=sum\cdot p-sum_{i^2}+2\cdot sum_i\cdot j-sum\cdot j$ </p>
<p>我们只需要维护，$sum,sum_i,sum_{i^2}$ 就可以直接计算出前面对当前的影响。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll a[N],c[N],h[N];</span><br><span class="line">ll l,r=<span class="number">1e12</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>,len=<span class="built_in">sqrt</span>(p),s=<span class="number">0</span>,si=<span class="number">0</span>,si2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        c[i]=a[i],h[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i]-=s*p-si2+<span class="number">2</span>*si*i-s*i*i;</span><br><span class="line">        <span class="keyword">if</span>(c[i]&gt;=<span class="number">0</span>)</span><br><span class="line">            h[i]=c[i]/p+<span class="number">1</span>,cnt+=h[i];</span><br><span class="line">        s+=h[i];</span><br><span class="line">        si+=h[i]*i;</span><br><span class="line">        si2+=h[i]*i*i;</span><br><span class="line">        <span class="keyword">if</span>(i-len&gt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s-=h[i-len];</span><br><span class="line">            si-=h[i-len]*(i-len);</span><br><span class="line">            si2-=h[i-len]*(i-len)*(i-len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;k)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[n-i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="12-CF1000G-Two-Paths"><a href="#12-CF1000G-Two-Paths" class="headerlink" title="12.CF1000G Two-Paths "></a>12.<a href="https://www.luogu.com.cn/problem/CF1000G">CF1000G Two-Paths </a></h4><p>有难度的倍增题目，比较有趣。</p>
<p>首先用DP预处理出数组 $pr_x$ 为遍历节点 $x$ 的子树获得的最大权值。先考虑从节点向根走，尝试求出 $f_{x,i}$ 为从点 $x$ 出发走到它的第 $2^i$ 辈祖先。只不过不能想当然地进行转移，考虑一下容斥，得到：</p>
<p>$f_{x,i}=f_{x,i-1}+f_{fa_{x,i-1},i-1}-pr_{fa_{x,i-1}}$</p>
<p>同时需要注意 $f_{x,0}$ 的值，需要判断 $x$ 的父亲节点是否选取了 $x$ 作为答案。</p>
<p>我们接着就可以使用倍增向上跳并累加答案 $f_{x,i}-pr_x$。但需要注意的是，我们最后只是会跳到 $LCA$ 处，实际上从 $LCA$ 还可以往上跳继续寻找答案。为了累加这个答案，我们可以再用一个 $g_x$ 表示从 $x$ 向上走能够获得的最大权值，从 $x$ 的父节点就可以很好地转移。最后统计答案时加上 $g_{LCA}$ 就行了。记得最后加上原来端点的 $pr_x$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>,M=<span class="number">6e5</span>+<span class="number">10</span>,K=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q,rt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">ll pr[N],g[N];</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">30</span>],d[N];</span><br><span class="line">ll f[N][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr[x]+=a[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ver[i]==fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(ver[i],x);</span><br><span class="line">        pr[x]+=<span class="built_in">max</span>(<span class="number">0ll</span>,pr[ver[i]]<span class="number">-2</span>*e[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		f[x][i]=f[x][i<span class="number">-1</span>]+f[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>]-pr[fa[x][i<span class="number">-1</span>]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(d[ver[i]])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        d[ver[i]]=d[x]+<span class="number">1</span>;</span><br><span class="line">        fa[ver[i]][<span class="number">0</span>]=x;</span><br><span class="line">		f[ver[i]][<span class="number">0</span>]=pr[ver[i]]+pr[x]-e[i]-(pr[ver[i]]<span class="number">-2</span>*e[i]&gt;<span class="number">0</span>?pr[ver[i]]<span class="number">-2</span>*e[i]:<span class="number">0</span>);</span><br><span class="line">		g[ver[i]]=<span class="built_in">max</span>(<span class="number">0ll</span>,g[x]+f[ver[i]][<span class="number">0</span>]-e[i]-pr[ver[i]]);</span><br><span class="line">		<span class="built_in">dfs</span>(ver[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="type">int</span> u=x,v=y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(d[fa[x][i]]&gt;=d[y])</span><br><span class="line">        &#123;</span><br><span class="line">            res+=f[x][i]-pr[x];</span><br><span class="line">            x=fa[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y)</span><br><span class="line">        <span class="keyword">return</span> res+pr[u]+g[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            res+=f[x][i]-pr[x]+f[y][i]-pr[y];</span><br><span class="line">            x=fa[x][i],y=fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> lca=fa[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> res+f[x][<span class="number">0</span>]-pr[x]+f[y][<span class="number">0</span>]-pr[y]-pr[lca]+pr[u]+pr[v]+g[lca];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(rt,<span class="number">0</span>);</span><br><span class="line">    d[rt]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="13-AT4837-ABC150E-Change-a-Little-Bit"><a href="#13-AT4837-ABC150E-Change-a-Little-Bit" class="headerlink" title="13.AT4837 [ABC150E] Change a Little Bit"></a>13.<a href="https://www.luogu.com.cn/problem/AT4837">AT4837 [ABC150E] Change a Little Bit</a></h4><p>推式子为主。</p>
<p>首先很明显应该贪心，先将 $C_i$ 进行排序。并很容易得出答案为：</p>
<p>$2^n\cdot (\sum_{i=1}^{n}2^{i-1}\cdot C_i\cdot \sum_{j=0}^{n-i}\begin{pmatrix} n-i\ j\end{pmatrix}\cdot(j+1))$</p>
<p>对后面这一坨尝试进行变换：$\sum_{j=0}^{n-i} \begin{pmatrix} n-i \ j \end{pmatrix} \cdot(j+1) = \sum_{j=0}^{n-i}\begin{pmatrix} n-i \ j \end{pmatrix} \cdot j+2^{n-i}$</p>
<p>运用<strong>吸收恒等式</strong>：$\begin{pmatrix} i  \ j \end{pmatrix}\cdot j = \begin{pmatrix} i-1 \ j-1 \end{pmatrix} \cdot i$，对第一项进行变换：</p>
<p>$\sum_{j=0}^{n-i} \begin{pmatrix} n-i \ j\end{pmatrix} \cdot j =  \sum_{j=0}^{n-i} \begin{pmatrix} n-i-1 \ j-1 \end{pmatrix} \cdot (n-i) = (n-i) \cdot2^{n-i-1}$</p>
<p>所以得到最终式子：</p>
<p>$2^n\cdot (\sum_{i=1}^{n}2^{i-1} \cdot C_i \cdot ((n-i) \cdot 2^{n-i-1}+2^{n-i}))$</p>
<p>直接计算即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans,c[N],p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+n);</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=(p[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=(ans+p[i<span class="number">-1</span>]*c[i]%mod*((n-i)*p[n-i<span class="number">-1</span>]%mod+p[n-i]))%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans*p[n]%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="14-P4804-CCC-2016-生命中的圆"><a href="#14-P4804-CCC-2016-生命中的圆" class="headerlink" title="14.P4804 [CCC 2016]生命中的圆"></a>14.<a href="https://www.luogu.com.cn/problem/P4804">P4804 [CCC 2016]生命中的圆</a></h4><p>容易得到：$f_{i,j}=f_{i-1,x-1}⊕f_{i-1,j+1}$。</p>
<p>然后<del>稍加思索</del>，便得到：$f_{i,j}=f_{i-2^k,x-2^k}⊕f_{i-2^k,j+2^k}$。</p>
<p>然后就直接将 $T$ 按照二进制拆开计算就可以了，时间复杂度 $\mathcal O(n\log T)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,K=<span class="number">60</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll t;</span><br><span class="line"><span class="type">int</span> p,f[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;f[p][i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=K;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t&amp;(<span class="number">1ll</span>&lt;&lt;k))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=(<span class="number">1ll</span>&lt;&lt;k)%n,l=(n-r)%n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[p^<span class="number">1</span>][i]=f[p][l]^f[p][r];</span><br><span class="line">                <span class="keyword">if</span>(++l&gt;=n)l-=n;</span><br><span class="line">                <span class="keyword">if</span>(++r&gt;=n)r-=n;</span><br><span class="line">            &#125;</span><br><span class="line">            p^=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[p][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="15-P3097-USACO13DEC-Optimal-Milking-G"><a href="#15-P3097-USACO13DEC-Optimal-Milking-G" class="headerlink" title="15.P3097 [USACO13DEC]Optimal Milking G"></a>15.<a href="https://www.luogu.com.cn/problem/P3097">P3097 [USACO13DEC]Optimal Milking G</a></h4><p>单点修改求最大独立集。尝试使用线段树来维护，左右端点各自取或不取所得到的区间最大值就可以了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll v[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll a[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].v[<span class="number">0</span>][<span class="number">0</span>]=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    tr[x].v[<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    tr[x].v[<span class="number">0</span>][<span class="number">1</span>]=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>],<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>],tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">    tr[x].v[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>],<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>],tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].v[<span class="number">1</span>][<span class="number">1</span>]=a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l==tr[x].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].v[<span class="number">1</span>][<span class="number">1</span>]=k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,pos,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        ans+=<span class="built_in">max</span>(<span class="built_in">max</span>(tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],tr[<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]),<span class="built_in">max</span>(tr[<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>],tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="16-P6845-CEOI2019-Dynamic-Diameter"><a href="#16-P6845-CEOI2019-Dynamic-Diameter" class="headerlink" title="16.P6845 [CEOI2019] Dynamic Diameter"></a>16.<a href="https://www.luogu.com.cn/problem/P6845">P6845 [CEOI2019] Dynamic Diameter</a></h4><p>单边修改求树上直径。很厉害的一道题，一开始根本没有思路，看题解也想了一会儿才弄懂。</p>
<p>先考虑把树上问题向区间问题转换。还记得我们如何将 LCA 问题进行转化的吗？对，这道题我们就是需要尝试用<strong>欧拉序</strong>进行转换。我们需要求的：$\max_{l,r\in [1,N]} {dep_l+dep_r-2*dep_{lca(l,r)}}$ </p>
<p>就变为了：$\max_{1\le l \le r \le 2N-1}{dep_l+dep_r- 2\times\min_{l\le mid\le r}{dep_{mid}}$。</p>
<p>考虑怎么维护这个东西，考虑分多个值：</p>
<p>1.区间深度最大值（作为 $dep_l$ 或 $dep_r$）。</p>
<p>2.区间深度最小值（作为 $dep_{lca}$）。</p>
<p>3.左端点与 LCA 合并的最大值，和右端点与 LCA 合并的最大值。</p>
<p>4.区间内直径最大值。</p>
<p>而修改操作就是欧拉序上的一段区间修改，这道题就完美解决了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q,rt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],ne[M];</span><br><span class="line"><span class="type">int</span> cnt,num[N&lt;&lt;<span class="number">1</span>],in[N],out[N],pos[N];</span><br><span class="line">ll w,e[M],val[N],d[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll maxd,mind,lm,mr,lmr;</span><br><span class="line">    ll tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num[in[x]=++cnt]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ver[i]==fa)<span class="keyword">continue</span>;</span><br><span class="line">        d[ver[i]]=d[x]+e[i];</span><br><span class="line">        pos[i+<span class="number">1</span>&gt;&gt;<span class="number">1</span>]=ver[i];</span><br><span class="line">        <span class="built_in">dfs</span>(ver[i],x);</span><br><span class="line">        num[++cnt]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    out[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].maxd=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].maxd,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].maxd);</span><br><span class="line">    tr[x].mind=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].mind,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mind);</span><br><span class="line">    tr[x].lm=<span class="built_in">max</span>(<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].lm,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lm),tr[x&lt;&lt;<span class="number">1</span>].maxd+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mind);</span><br><span class="line">    tr[x].mr=<span class="built_in">max</span>(<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].mr,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mr),tr[x&lt;&lt;<span class="number">1</span>].mind+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].maxd);</span><br><span class="line">    tr[x].lmr=<span class="built_in">max</span>(<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].lmr,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lmr),<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].lm+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].maxd,tr[x&lt;&lt;<span class="number">1</span>].maxd+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].maxd+=k;</span><br><span class="line">    tr[x].mind-=<span class="number">2</span>*k;</span><br><span class="line">    tr[x].lm-=k;</span><br><span class="line">    tr[x].mr-=k;</span><br><span class="line">    tr[x].tag+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].maxd=d[num[l]];</span><br><span class="line">        tr[x].mind=<span class="number">-2</span>*d[num[l]];</span><br><span class="line">        tr[x].lm=tr[x].mr=-d[num[l]];</span><br><span class="line">        tr[x].lmr=<span class="number">0</span>;</span><br><span class="line">        tr[x].tag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].tag)</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q,w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v,val[i]);</span><br><span class="line">        <span class="built_in">add</span>(u,v,val[i]);</span><br><span class="line">        <span class="built_in">add</span>(v,u,val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        ll k;</span><br><span class="line">        <span class="built_in">read</span>(x,k);</span><br><span class="line">        x=(x+ans%(n<span class="number">-1</span>))%(n<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">        k=(k+ans%w)%w;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,in[pos[x]],out[pos[x]],k-val[x]);</span><br><span class="line">        val[x]=k;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans=tr[<span class="number">1</span>].lmr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="17-AT4835-ABC141F-Xor-Sum-3"><a href="#17-AT4835-ABC141F-Xor-Sum-3" class="headerlink" title="17.AT4835 [ABC141F] Xor Sum 3"></a>17.<a href="https://www.luogu.com.cn/problem/AT4835">AT4835 [ABC141F] Xor Sum 3</a></h4><p>按照每一位来考虑，设 $sum$ 为其所有数的异或和，其中 $sum_i$ 表示其二进制下的第 $i$ 位，考虑其奇偶性，有：</p>
<p>1.$sum_i$ 为 $1$，则分为两组的异或和的贡献一定为 $2^i$。</p>
<p>2.$sum_i$ 为 $0$ ，则分为两组的异或和第 $i$ 位一定相同。</p>
<p>第一种情况可以直接累加上答案，于是我们只需要考虑第二种情况就可以了。由第二条性质可以得到：仅考虑 $sum_i=0$ 的情况下,分为两组的异或和一定是相等的，于是我们直接用<strong>线性基</strong>算之后将答案乘二即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll sum,ans,res,a[N],p[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(x&gt;&gt;i&amp;<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p[i])</span><br><span class="line">        &#123;</span><br><span class="line">            p[i]=x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x^=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),sum^=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=<span class="number">1ll</span>&lt;&lt;i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(a[j]&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                    a[j]^=<span class="number">1ll</span>&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        res=<span class="built_in">max</span>(res,res^p[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans+<span class="number">2ll</span>*res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="18-CF460C-Present"><a href="#18-CF460C-Present" class="headerlink" title="18.CF460C Present"></a>18.<a href="https://www.luogu.com.cn/problem/CF460C">CF460C Present</a></h4><p>最小值最大，很明显考虑二分。$check(i)$ 用线段树修改查询就可以了。</p>
<p>看题解后，发现还是做复杂了，可以直接差分，做到 $\mathcal O(n)$  $check(i)$ 。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll val,tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,w;</span><br><span class="line">ll a[N];</span><br><span class="line">ll l=INF,r;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x&lt;&lt;<span class="number">1</span>].tag+=tr[x].tag;</span><br><span class="line">    tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tag+=tr[x].tag;</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].val=a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].tag+=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].tag)<span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l==tr[x].r)</span><br><span class="line">        <span class="keyword">return</span> tr[x].val+tr[x].tag;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].tag)</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>,pos);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(n&lt;&lt;<span class="number">2</span>);i++)</span><br><span class="line">        tr[i].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res=<span class="built_in">query</span>(<span class="number">1</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(res&lt;x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,i,i+w<span class="number">-1</span>,x-res);</span><br><span class="line">            cnt+=x-res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),l=<span class="built_in">min</span>(l,a[i]),r+=a[i];</span><br><span class="line">    r=(r+<span class="number">1ll</span>*m*w)/n;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    ll ans=l;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">            l=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="19-CF282E-Sausage-Maximization"><a href="#19-CF282E-Sausage-Maximization" class="headerlink" title="19.CF282E Sausage Maximization"></a>19.<a href="https://www.luogu.com.cn/problem/CF282E">CF282E Sausage Maximization</a></h4><p>直接将所有后缀异或和插入进 <strong>01Trie</strong>，再查询每个前缀异或和所能得到最大值就可以了。</p>
<p>还有 <strong>01Trie</strong> 记得将空间开大。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,cnt,t[N&lt;&lt;<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line">ll a[N],ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">63</span>;~i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=(x&gt;&gt;i&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!t[p][num])</span><br><span class="line">            t[p][num]=++cnt;</span><br><span class="line">        p=t[p][num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">63</span>;~i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=(x&gt;&gt;i&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(t[p][num^<span class="number">1</span>])</span><br><span class="line">            sum+=<span class="number">1ll</span>&lt;&lt;i,p=t[p][num^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> p=t[p][num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        res^=a[i];</span><br><span class="line">        <span class="built_in">insert</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res^=a[i];</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="20-P4068-SDOI2016-数字配对"><a href="#20-P4068-SDOI2016-数字配对" class="headerlink" title="20.P4068 [SDOI2016]数字配对"></a>20.<a href="https://www.luogu.com.cn/problem/P4068">P4068 [SDOI2016]数字配对</a></h4><p>因为每次我们需要贪心地考虑选择获得价值<strong>最大</strong>的数字进行 配对，考虑使用<strong>费用流</strong>，我们来看看怎么建模。</p>
<p>一定要想到将其转化为<strong>二分图</strong>，它是我们最好解决的了。我们对每个数进行质因数分解，将 $i$ 其分解成 $cnt_i$ 个质因数。再考虑将这些点其按照 $cnt_i$ 的<strong>奇偶性</strong>分为<strong>左部</strong>和<strong>右部</strong>的点，再将能够配对的点连起来，剩下的建图就很显然了。</p>
<p>注意这里我们需要写的是<strong>最大费用最大流</strong>。但又有一些不一样，我们只有在<strong>费用</strong>大于0的情况下才能继续继续增广，改一下就好了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">4e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,s,t,maxflow;</span><br><span class="line"><span class="type">int</span> a[N],b[N],cnt[N];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> incf[N],pre[N],vis[N];</span><br><span class="line">ll maxcost,c[N],cost[M],d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    cost[tot]=c;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add_edge</span>(u,v,w,c);</span><br><span class="line">    <span class="built_in">add_edge</span>(v,u,<span class="number">0</span>,-c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t;i++)</span><br><span class="line">        d[i]=<span class="number">-1e18</span>,vis[i]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    incf[s]=INF;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!e[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y]&lt;d[x]+cost[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[y]=d[x]+cost[i];</span><br><span class="line">                incf[y]=<span class="built_in">min</span>(incf[x],e[i]);</span><br><span class="line">                pre[y]=i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y])</span><br><span class="line">                    vis[y]=<span class="number">1</span>,q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[t]&gt;<span class="number">-1e18</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll now=d[t]*incf[t];</span><br><span class="line">    <span class="keyword">if</span>(maxcost+now&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        maxflow+=maxcost/(-d[t]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxcost+=now;</span><br><span class="line">    maxflow+=incf[t];</span><br><span class="line">    <span class="type">int</span> x=t;</span><br><span class="line">    <span class="keyword">while</span>(x!=s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i=pre[x];</span><br><span class="line">        e[i]-=incf[t];</span><br><span class="line">        e[i^<span class="number">1</span>]+=incf[t];</span><br><span class="line">        x=ver[i^<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!(x%i))</span><br><span class="line">            x/=i,res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    s=n+<span class="number">1</span>,t=s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),cnt[i]=<span class="built_in">divide</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(b[i]);</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]&amp;<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">add</span>(s,i,b[i],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(i,t,b[i],<span class="number">0</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((a[i]%a[j]==<span class="number">0</span>&amp;&amp;cnt[i]==cnt[j]+<span class="number">1</span>)||(a[j]%a[i]==<span class="number">0</span>&amp;&amp;cnt[j]==cnt[i]+<span class="number">1</span>))</span><br><span class="line">                    <span class="built_in">add</span>(i,j,INF,<span class="number">1ll</span>*c[i]*c[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA</span>()&amp;&amp;<span class="built_in">update</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="21-CF442C-Artem-and-Array"><a href="#21-CF442C-Artem-and-Array" class="headerlink" title="21.CF442C Artem and Array"></a>21.<a href="https://www.luogu.com.cn/problem/CF442C">CF442C Artem and Array</a></h4><p>第一眼是一个<strong>区间DP</strong>，但是数据范围很明显不能让我们通过，我们没法DP直接考虑<strong>贪心</strong>。</p>
<p>很明显，若 $a_i&lt;a_{i-1}$ 且 $a_i&lt;a_{i+1}$ ，我们一定会将 $a_i$ 删去。</p>
<p>我们直接将其放入一个<strong>单调栈</strong>中进行维护并统计，最后得到的序列一定是<strong>单峰</strong>的。然后我们直接在剩下的 $m$ 个数中取最小的 $m-2$ 个就可以得到答案（因为最大的两个数不可能被取到）。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> top,sta[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(top&gt;=<span class="number">2</span>&amp;&amp;sta[top]&lt;=sta[top<span class="number">-1</span>]&amp;&amp;sta[top]&lt;=x)</span><br><span class="line">            ans+=<span class="built_in">min</span>(sta[top<span class="number">-1</span>],x),top--;</span><br><span class="line">        sta[++top]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sta+<span class="number">1</span>,sta+<span class="number">1</span>+top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top<span class="number">-2</span>;i++)</span><br><span class="line">        ans+=sta[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="22-AT4434-ARC103D-Distance-Sums"><a href="#22-AT4434-ARC103D-Distance-Sums" class="headerlink" title="22.AT4434 [ARC103D] Distance Sums"></a>22.<a href="https://www.luogu.com.cn/problem/AT4434">AT4434 [ARC103D] Distance Sums</a></h4><p>比较清新的构造题（？）。</p>
<p>我们尝试从每个点的 $D_i$ 之间的关系入手。很明显 $D_i$ 值最大的节点必定为<strong>叶子</strong>，$D_i$ 值最小的节点必定为<strong>树的重心</strong>（<del>可似乎没什么用</del>），还记得之前的<strong>换根DP</strong>吗？若 $v$ 为 $u$ 的子节点，我们很明显有：$D_v=D_u-2\times size_v+n$。变换一下得到 $D_u=D_v+2\times size_v-n$。我们把两者结合一下，尝试用<strong>叶子节点</strong>逐渐构造其祖先。我们先将其排序，从 $D_i$ 值最大的开始处理，大致分为这几步：</p>
<p>1、计算用当前节点计算父节点的 $D$ 值。 2、父节点的 $D$ 值在给定的 $D_i$ 中进行二分查找。找到了则新加一条边计入答案，并且计算父节点的 $size_u$；若未找到直接输出 $-1$ 。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    ll d;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node x,<span class="type">const</span> Node y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.d&lt;y.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n,si[N];</span><br><span class="line"><span class="type">int</span> cnt,u[N],v[N];</span><br><span class="line">ll dis;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i].d),a[i].id=i,si[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll d=a[i].d-n+(si[i]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> k=<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,(Node)&#123;<span class="number">0</span>,d&#125;)-a;</span><br><span class="line">        <span class="keyword">if</span>(a[k].d!=d)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        u[i]=a[i].id;</span><br><span class="line">        v[i]=a[k].id;</span><br><span class="line">        si[k]+=si[i];</span><br><span class="line">        dis+=si[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis!=a[<span class="number">1</span>].d)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,u[i],v[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="23-AT3621-ARC084B-Small-Multiple"><a href="#23-AT3621-ARC084B-Small-Multiple" class="headerlink" title="23.AT3621 [ARC084B] Small Multiple"></a>23.<a href="https://www.luogu.com.cn/problem/AT3621">AT3621 [ARC084B] Small Multiple</a></h4><p>直接枚举 $k$ 的正整数倍并不是明智之举，我们并不能找到较好的条件或方式来优化。我们考虑直接对其进行搜索，再判断其是否为 $k$ 的倍数。</p>
<p>在搜索过程中，很明显每次只有两种分支：$\times 10$ 或 $+1$。而其花费分别为 $0$ 和 $1$。很自然想到了双端队列 BFS。并且我们在搜索过程中直接对数进行取模就行。时间复杂度 $\mathcal O(k)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num,val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">bitset&lt;N&gt;vis;</span><br><span class="line">deque&lt;Node&gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push_back</span>((Node)&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>().num,y=q.<span class="built_in">front</span>().val;</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,y);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!vis[x*<span class="number">10</span>%k])</span><br><span class="line">            q.<span class="built_in">push_front</span>((Node)&#123;x*<span class="number">10</span>%k,y&#125;);</span><br><span class="line">        <span class="keyword">if</span>(!vis[(x+<span class="number">1</span>)%k])</span><br><span class="line">            q.<span class="built_in">push_back</span>((Node)&#123;(x+<span class="number">1</span>)%k,y+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(k);</span><br><span class="line">    <span class="built_in">BFS</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="24-AT5361-ABC158E-Divisible-Substring"><a href="#24-AT5361-ABC158E-Divisible-Substring" class="headerlink" title="24.AT5361 [ABC158E] Divisible Substring"></a>24.<a href="https://www.luogu.com.cn/problem/AT5361">AT5361 [ABC158E] Divisible Substring</a></h4><p>很明显应当从低位向高位考虑。每次从后面枚举，得到它后缀 $\mod p$ 的余数，很明显用该后缀减去之前所枚举的所有满足 $\mod p$ 的余数与其相等的后缀，所得到的字串一定被 $p$ 整除。这就很好办了，直接拿一个数组 $f_i$ 来存 $\mod p$ 的余数为 $i$ 的后缀数量，并且在枚举后缀时累加答案即可。</p>
<p>注意特判 $p=2,5$ 时的情况。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,M=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> sum,t=<span class="number">1</span>,a[N],f[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,a+i);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">2</span>||p==<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            ans+=a[i]%p?<span class="number">0</span>:i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;  </span><br><span class="line">        sum=(sum+t*a[i])%p;</span><br><span class="line">        ans+=f[sum];</span><br><span class="line">        f[sum]++;</span><br><span class="line">        t=t*<span class="number">10</span>%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="25-AT5242-ABC163E-Active-Infants"><a href="#25-AT5242-ABC163E-Active-Infants" class="headerlink" title="25.AT5242 [ABC163E] Active Infants"></a>25.<a href="https://www.luogu.com.cn/problem/AT5242">AT5242 [ABC163E] Active Infants</a></h4><p>开始本来以为是贪心，但发现并不能总是得到最优解。</p>
<p>有端联想，我们似乎可以直接上<strong>费用流</strong>，建图很显然，直接上<strong>最大费用最大流</strong>跑就可以了，确实可以过，但是效率并不高。</p>
<p>我们逐渐想到<strong>区间DP</strong>，但是直接搞的话 $\mathcal O(n^3)$ 的。我们每次只能考虑从端点转移。</p>
<p>于是我们尝试将<strong>区间DP</strong>与<strong>贪心</strong>结合，直觉告诉我们对于 $a_i$ 较大的，应当将它尽可能排在一段区间的两端，而非中间，这样产生的贡献才大。<del>然后乱搞</del>，现将数组按照 $a_i$ 为第一关键字排序，并记录其初始位置 $pos_i$。对于区间 $[l,r]$ 我们只需要将前 $r-l+1$ 个数填进去，这样来满足贪心即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val,pos;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> val&lt;t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i].val),a[i].pos=i;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        f[i][i]=<span class="number">1ll</span>*<span class="built_in">abs</span>(a[<span class="number">1</span>].pos-i)*a[<span class="number">1</span>].val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+i<span class="number">-1</span>&lt;=n;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=l+i<span class="number">-1</span>;</span><br><span class="line">            f[l][r]=<span class="built_in">max</span>(f[l+<span class="number">1</span>][r]+<span class="number">1ll</span>*<span class="built_in">abs</span>(a[i].pos-l)*a[i].val,f[l][r<span class="number">-1</span>]+<span class="number">1ll</span>*<span class="built_in">abs</span>(a[i].pos-r)*a[i].val);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="26-CF360B-Levko-and-Array"><a href="#26-CF360B-Levko-and-Array" class="headerlink" title="26.CF360B Levko and Array"></a>26.<a href="https://www.luogu.com.cn/problem/CF360B">CF360B Levko and Array</a></h4><p>使最大值最小，直接二分答案。我们需要研究 $check$ 函数应该如何写，设二分答案为 $lim$。</p>
<p>容易看出来是个 DP。可是直接 DP 明显很难做到 $\mathcal O(n^2)$。这就很难搞了。我们必须转换思路进行 DP。</p>
<p>经典正难则反，我们直接考虑计算 $[1,i]$ 中最多有多少个可以不变。可是似乎还是不太好转移。又该怎么办？只有当满足 $mid\times (i-j)\ge |a_i-a_j|$ 时，才可能有 $a_j$  不改变，通过改变 $(j,i]$ 得到合法方案。最后判断其中是否存在某个 $i$ 使得 $n-dp_i\le k$ 即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll a[N];</span><br><span class="line">ll l,r,f[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lim*(i-j)&gt;=<span class="built_in">abs</span>(a[i]-a[j]))</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[i]+k&gt;=n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        r=<span class="built_in">max</span>(r,<span class="built_in">abs</span>(a[i]-a[i+<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">            r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="27-CF573B-Bear-and-Blocks"><a href="#27-CF573B-Bear-and-Blocks" class="headerlink" title="27.CF573B Bear and Blocks"></a>27.<a href="https://www.luogu.com.cn/problem/CF573B">CF573B Bear and Blocks</a></h4><p>简单题，分别从左和从右模拟一次就可以了</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">int</span> h[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(h[i]);</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        f[i]=<span class="built_in">min</span>(f[i<span class="number">-1</span>]+<span class="number">1</span>,h[i]);</span><br><span class="line">    f[n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i;i--)</span><br><span class="line">        f[i]=<span class="built_in">min</span>(f[i+<span class="number">1</span>]+<span class="number">1</span>,f[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="28-AT2368-AGC013B-Hamiltonish-Path"><a href="#28-AT2368-AGC013B-Hamiltonish-Path" class="headerlink" title="28.AT2368 [AGC013B] Hamiltonish Path"></a>28.<a href="https://www.luogu.com.cn/problem/AT2368">AT2368 [AGC013B] Hamiltonish Path</a></h4><p>又是简单题，两遍 dfs 即可</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M&lt;&lt;<span class="number">1</span>],ne[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="type">int</span> cnt1,cnt2,ans1[N],ans2[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[ver[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[ver[i]]=<span class="number">1</span>;</span><br><span class="line">            ans1[++cnt1]=ver[i];</span><br><span class="line">            <span class="built_in">dfs1</span>(ver[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[ver[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[ver[i]]=<span class="number">1</span>;</span><br><span class="line">            ans2[++cnt2]=ver[i];</span><br><span class="line">            <span class="built_in">dfs2</span>(ver[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt1+cnt2+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cnt1;i;i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans1[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt2;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans2[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="29-AT923-IOI饅頭（IOI-Manju）"><a href="#29-AT923-IOI饅頭（IOI-Manju）" class="headerlink" title="29.AT923 IOI饅頭（IOI Manju）"></a>29.<a href="https://www.luogu.com.cn/problem/AT923">AT923 IOI饅頭（IOI Manju）</a></h4><p>还是简单题（大雾）。排序后直接 01背包 就可以了，然后注意细节。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,M=<span class="number">1e4</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> c[N],e[N];</span><br><span class="line">ll p[M],f[M],ans;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(m,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">read</span>(p[i]);</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">        p[i]+=p[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i],e[i]),c[i]=<span class="built_in">min</span>(c[i],m);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=c[i];j--)</span><br><span class="line">            f[j]=<span class="built_in">min</span>(f[j],f[j-c[i]]+e[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            f[j]=<span class="built_in">min</span>(f[j],f[j+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ll res=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,p[i]-f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="30-CF242E-XOR-on-Segment"><a href="#30-CF242E-XOR-on-Segment" class="headerlink" title="30.CF242E XOR on Segment"></a>30.<a href="https://www.luogu.com.cn/problem/CF242E">CF242E XOR on Segment</a></h4><p>小清新数据结构题，<del>比较水</del>。看到位运算很容易想到按位拆开来算，毕竟时限本来就很宽松（<del>以至于暴力用循环展开都可以卡过去</del>）。对于线段树中每个节点维护一个数组 $sum_i$，表示在此区间中有多少个数第 $i$ 位为 $1$。查询和修改大力维护就可以了。时间复杂度 $\mathcal O(m\log n\log V)$，其中 $V$ 为值域。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,K=<span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> sum[<span class="number">32</span>],tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K;i++)</span><br><span class="line">        tr[x].sum[i]=tr[x&lt;&lt;<span class="number">1</span>].sum[i]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].tag^=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K;i++)</span><br><span class="line">        <span class="keyword">if</span>(k&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">            tr[x].sum[i]=(tr[x].r-tr[x].l+<span class="number">1</span>-tr[x].sum[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[x].tag)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K;i++)</span><br><span class="line">            tr[x].sum[i]=(a[l]&gt;&gt;i&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K;i++)</span><br><span class="line">            res+=<span class="number">1ll</span>*tr[x].sum[i]&lt;&lt;i;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)res+=<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)res+=<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,l,r;</span><br><span class="line">        <span class="built_in">read</span>(op,l,r);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,l,r));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="31-CF444A-DZY-Loves-Physics"><a href="#31-CF444A-DZY-Loves-Physics" class="headerlink" title="31.CF444A DZY Loves Physics"></a>31.<a href="https://www.luogu.com.cn/problem/CF444A">CF444A DZY Loves Physics</a></h4><p>第一眼觉得很神秘。但是我们容易发现最优方案似乎只有一条边。因为加入选取一条密度最大的边后，选取其它边只会是密度变小。</p>
<p><del>然后就过了？</del></p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">double</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,(a[u]+a[v])*<span class="number">1.0</span>/w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="32-AT3559-Squeezing-Slimes"><a href="#32-AT3559-Squeezing-Slimes" class="headerlink" title="32.AT3559 Squeezing Slimes"></a>32.<a href="https://www.luogu.com.cn/problem/AT3559">AT3559 Squeezing Slimes</a></h4><p>考虑假如每次将一个数拆成两半，最少会进行 $\lceil\log_2 n\rceil$ 次。一个贪心的想法是一次尽可能选尽量多的数进行操作。我们只用考虑一段单峰区间的最大操作次数就行了。每次只需要记录上一个数的操作次数就行了。</p>
<p>但是这样似乎很容易被 Hack：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3 3 3</span><br><span class="line">out:2</span><br><span class="line">ans:3</span><br><span class="line">3 3 3 -&gt; 1 2 2 1 3 -&gt; 1 1 1 1 1 1 3 -&gt; 1 1 1 1 1 1 1 2 -&gt;</span><br><span class="line">1 1 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure>
<p>原因很显然，可能存在并不能将多个数一起操作的情况。但是没有关系，这种情况只可能存在于需要上取整的情况。对于此种情况，如果前面的操作次数比它小，我们就将其看做已经对其执行了一次操作，使它变成了较小的另一半。这样继续贪心就没有问题了。</p>
<p>这样看来似乎有一点奇怪，但仔细想想这确实是没有问题的。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,res,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,d;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        d=<span class="built_in">log2</span>(x);</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;d)&lt;x&amp;&amp;d&gt;=res)</span><br><span class="line">            d++;</span><br><span class="line">        <span class="keyword">if</span>(d&gt;res)ans+=d-res;</span><br><span class="line">        res=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="33-CF14D-Two-Paths"><a href="#33-CF14D-Two-Paths" class="headerlink" title="33.CF14D Two Paths"></a>33.<a href="https://www.luogu.com.cn/problem/CF14D">CF14D Two Paths</a></h4><p>水题，暴力断开一条边，然后对剩下的两棵树分别求直径。最后求最大值就可以。时间复杂度 $\mathcal O(n^2)$。</p>
<p>难道就这样吗？</p>
<p>不如看看加强版 <a href="https://www.luogu.com.cn/problem/SP6717">SP6717 TWOPATHS - Two Paths</a>（<del>但还是虚高题</del>）。</p>
<p>我们考虑 $\mathcal O(n)$ 的做法。</p>
<p>update on 2022.11.13。原题解被 @zhanghenglei 所 Hack。现在已将解法修正，如果仍有问题，欢迎指出qwq。</p>
<p>不难想到用 $f_x,g_x$ 分别表示以 $x$ 为根的子树内和子树外最长链的长度。答案就是 $\max{f_x\times g_x}$。$f_x$ 很容易求，考虑 $g_x$ 怎么求。</p>
<p>$g_x$ 可以从父亲节点转移过来，这启发我们可以类似于换根 DP 的方法来求 $g_x$。</p>
<p>考虑怎么构成一条子树外的链。无非是从父节点往上延伸，或者从父节点往下延伸的链。再将他们最长的两段在父节点拼起来成为一个答案。</p>
<p>但是我们选取的两段链不能在 $x$ 的子树中。这就意味着我们需要先求出，从父节点往下延伸的链的最大值、亚大值和次大值，以及对应的子节点。转移时判断一下所选的链有没有在 $x$ 的子树中就行。</p>
<p>从该节点 $x$ 往上延伸的最长链也可以通过最大值和亚大值通过换根 DP 来求出，也比较简单。</p>
<p>但是这样解是有漏洞的，$g_x$ 求出来只是恰好经过其父节点的最长链，而不是整棵树中除去该子树的最长链，就像这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/93kgatph.png" alt=""></p>
<p><code>output : 30</code> \<br><code>answer : 36</code></p>
<p>所以我们需要再多记一个 $h_x$ 表示该节点的父节点的子树之外的最长链，转移与上面类似。</p>
<p>具体可看看代码，有一些注释。有点繁琐，但还是比较好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[N][<span class="number">3</span>],l[N],t[N][<span class="number">3</span>],f[N],g[N],h[N];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">2</span>]=d[x][<span class="number">1</span>],t[x][<span class="number">2</span>]=t[x][<span class="number">1</span>];</span><br><span class="line">            d[x][<span class="number">1</span>]=d[x][<span class="number">0</span>],t[x][<span class="number">1</span>]=t[x][<span class="number">0</span>];</span><br><span class="line">            d[x][<span class="number">0</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">0</span>]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">2</span>]=d[x][<span class="number">1</span>],t[x][<span class="number">2</span>]=t[x][<span class="number">1</span>];</span><br><span class="line">            d[x][<span class="number">1</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">1</span>]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">2</span>])</span><br><span class="line">            d[x][<span class="number">2</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">2</span>]=y;</span><br><span class="line">        <span class="comment">//处理出从该节点往下延伸的链的最大值、亚大值和次大值</span></span><br><span class="line">        <span class="comment">//以及其所对应的儿子</span></span><br><span class="line">        f[x]=<span class="built_in">max</span>(f[x],f[y]);<span class="comment">//从子节点转移</span></span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=<span class="built_in">max</span>(f[x],d[x][<span class="number">0</span>]+d[x][<span class="number">1</span>]);<span class="comment">//从自己转移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,<span class="number">1ll</span>*f[x]*<span class="built_in">max</span>(g[x],h[x]));<span class="comment">//统计答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        l[y]=l[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[x][<span class="number">0</span>]&amp;&amp;t[x][<span class="number">0</span>]!=y)</span><br><span class="line">            l[y]=<span class="built_in">max</span>(l[x],d[x][<span class="number">0</span>])+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[x][<span class="number">1</span>])</span><br><span class="line">            l[y]=<span class="built_in">max</span>(l[x],d[x][<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//转移从该节点向上延伸的最长链</span></span><br><span class="line">        <span class="type">int</span> res[<span class="number">4</span>];</span><br><span class="line">        res[<span class="number">0</span>]=t[x][<span class="number">0</span>]!=y?d[x][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>]=t[x][<span class="number">1</span>]!=y?d[x][<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">2</span>]=t[x][<span class="number">2</span>]!=y?d[x][<span class="number">2</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">3</span>]=l[x];</span><br><span class="line">        <span class="built_in">sort</span>(res,res+<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//从四条链中选取合法的最长的两条</span></span><br><span class="line">        g[y]=<span class="built_in">max</span>(g[x],res[<span class="number">2</span>]+res[<span class="number">3</span>]);</span><br><span class="line">        h[y]=h[x];</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x);</span><br><span class="line">        res[<span class="number">0</span>]=t[y][<span class="number">0</span>]!=y?d[y][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>]=t[y][<span class="number">1</span>]!=y?d[y][<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">2</span>]=t[y][<span class="number">2</span>]!=y?d[y][<span class="number">2</span>]:<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(res,res+<span class="number">3</span>);</span><br><span class="line">        h[x]=<span class="built_in">max</span>(h[x],res[<span class="number">1</span>]+res[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//转移该节点的父节点的子树之外的最长链</span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="34-P5078-Tweetuzki-爱军训"><a href="#34-P5078-Tweetuzki-爱军训" class="headerlink" title="34.P5078 Tweetuzki 爱军训"></a>34.<a href="https://www.luogu.com.cn/problem/P5078">P5078 Tweetuzki 爱军训</a></h4><p>考虑贪心。我们依次考虑，将每个点放在左端或者右端。</p>
<p>而是对于每个点，我们考虑拆贡献。设放在前面的点 $[1,l]$ 的和为 $sum_1$，放在后面的点 $ [r,n]$ 的和为 $sum_2$，所有点和为 $sum$，那么：</p>
<p>1.放在前面的点，对其后面的点贡献为 $sum-sum_1$。</p>
<p>2.放在后面的点，对其后面的点贡献为 $sum_2$。而他前面还有 $r-l+1$ 个点未计算贡献，而这部分贡献为 $a_i\times (r-l+1)$。</p>
<p>注意，我们直接统计贡献是会有重复的。但是这样贪心的话，我们能保证对于之后的决策都会是更优的。真正的的贡献直接统计就好了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> l,r,ans[N];</span><br><span class="line">ll sum1,sum2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),sum1+=a[i];</span><br><span class="line">    l=<span class="number">1</span>,r=n;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum1&gt;=<span class="number">1ll</span>*a[i]*(r-l+<span class="number">1</span>)+sum2)</span><br><span class="line">            res+=<span class="number">1ll</span>*a[i]*l,ans[l++]=a[i],sum1-=a[i];</span><br><span class="line">        <span class="keyword">else</span> res+=<span class="number">1ll</span>*a[i]*r,ans[r--]=a[i],sum2+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="35-CF1305F-Kuroni-and-the-Punishment"><a href="#35-CF1305F-Kuroni-and-the-Punishment" class="headerlink" title="35.CF1305F Kuroni and the Punishment"></a>35.<a href="https://www.luogu.com.cn/problem/CF1305F">CF1305F Kuroni and the Punishment</a></h4><p>神秘题。随机化题目都没怎么做过，所以根本不会。。。</p>
<p>考虑两个结论：</p>
<p>1.操作次数 $&lt; n$。</p>
<p>2.操作超过两次的数 $\le \frac{n}{2}$。</p>
<p>那么随机化做法就来了，我们每次随机选取一个数 $x$，并将 $x-1,x,x+1$ 都分解质因数，放入一个 set 里。我们一共选取 50 次，这样最多有约 600 个质数。</p>
<p>然后我们暴力枚举每个质因数 $p$，计算 $\gcd=p$ 时的操作次数是多少。取最小值就可以了。</p>
<p>我们每次都有至少 $\frac{1}{2}$ 的概率选中操作次数小于等于一次的数。所以错误的概率只为 $\frac{1}{2^{50}}$。</p>
<p>注意每个数不能为 $0$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line">ll a[N];</span><br><span class="line">set&lt;ll&gt;prime;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">divide</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(x%i))</span><br><span class="line">        &#123;</span><br><span class="line">            prime.<span class="built_in">insert</span>(i);</span><br><span class="line">            <span class="keyword">while</span>(!(x%i))x/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>)prime.<span class="built_in">insert</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos=<span class="built_in">rand</span>()*<span class="built_in">rand</span>()%n+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">divide</span>(a[pos]<span class="number">-1</span>),<span class="built_in">divide</span>(a[pos]),<span class="built_in">divide</span>(a[pos]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    set&lt;ll&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it=prime.<span class="built_in">begin</span>();it!=prime.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;*it)</span><br><span class="line">                res+=<span class="built_in">min</span>(a[i]%*it,(*it-a[i]%*it));</span><br><span class="line">            <span class="keyword">else</span> res+=*it-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="36-AT3911-Forest"><a href="#36-AT3911-Forest" class="headerlink" title="36.AT3911 Forest"></a>36.<a href="https://www.luogu.com.cn/problem/AT3911">AT3911 Forest</a></h4><p>假如有 $cnt$ 个连通块，那么我们需要连 $cnt-1$ 条边，那么就要选取 $2\times cnt-2$ 个点。现在每个连通块里选一个最小的，再贪心地在所以里面再选 $cnt-2$ 个最小的即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> a[N],fa[N],v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),fa[i]=i,v[i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        fa[<span class="built_in">find</span>(v+<span class="number">1</span>)]=<span class="built_in">find</span>(u+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        v[<span class="built_in">find</span>(i)]=<span class="built_in">min</span>(v[<span class="built_in">find</span>(i)],a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==v[<span class="built_in">find</span>(i)])</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=a[i];</span><br><span class="line">            cnt++;</span><br><span class="line">            v[<span class="built_in">find</span>(i)]=INF;</span><br><span class="line">            a[i]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt<span class="number">-2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==INF)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="37-CF351A-Jeff-and-Rounding"><a href="#37-CF351A-Jeff-and-Rounding" class="headerlink" title="37.CF351A Jeff and Rounding"></a>37.<a href="https://www.luogu.com.cn/problem/CF351A">CF351A Jeff and Rounding</a></h4><p>如果没有整数的话，答案就是一定的。我们只需要枚举将多少个整数上取整即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N],sum,ans=INF;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i]);</span><br><span class="line">        a[i]=a[i]-<span class="built_in">int</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=eps)cnt++;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">max</span>(cnt-n,<span class="number">0</span>);i&lt;=<span class="built_in">min</span>(cnt,n);i++)</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(sum-n+i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="38-CF448C-Painting-Fence"><a href="#38-CF448C-Painting-Fence" class="headerlink" title="38.CF448C Painting Fence"></a>38.<a href="https://www.luogu.com.cn/problem/CF448C">CF448C Painting Fence</a></h4><p>分治求解即可。每次考虑将区间内高度最小的横着刷，将其分成多个小区间再求解。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> <span class="built_in">min</span>(<span class="number">1</span>,a[l]-h);</span><br><span class="line">    <span class="type">int</span> minx=INF,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        minx=<span class="built_in">min</span>(minx,a[i]);</span><br><span class="line">    <span class="type">int</span> pre=l,res=minx-h;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==minx)</span><br><span class="line">            res+=<span class="built_in">solve</span>(pre,i<span class="number">-1</span>,minx),pre=i+<span class="number">1</span>;</span><br><span class="line">    res+=<span class="built_in">solve</span>(pre,r,minx);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(<span class="number">1</span>,n,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>虽然这样已经做可以通过此题，但这并不影响我们对更优解的思考。我们发现时间都浪费在找最小值上，我们可以用笛卡尔树来做（本题的形式就是笛卡尔树的经典模型）。这样很容易做到 $\mathcal O(n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> top,sta[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">solve</span>(l,pos<span class="number">-1</span>,tr[pos].l,tr[pos].val)+</span><br><span class="line">            <span class="built_in">solve</span>(pos+<span class="number">1</span>,r,tr[pos].r,tr[pos].val)+tr[pos].val-h;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(tr[i].val);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=top;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;tr[sta[p]].val&gt;tr[i].val)</span><br><span class="line">            p--;</span><br><span class="line">        <span class="keyword">if</span>(p)tr[sta[p]].r=i;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;top)tr[i].l=sta[p+<span class="number">1</span>];</span><br><span class="line">        sta[++p]=i;</span><br><span class="line">        top=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(<span class="number">1</span>,n,sta[<span class="number">1</span>],<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="39-Manga-Market"><a href="#39-Manga-Market" class="headerlink" title="39.Manga Market"></a>39.<a href="https://www.luogu.com.cn/problem/AT_hitachi2020_d">Manga Market</a></h4><p>先考虑贪心，考虑微扰法，假设有 $i$ 与 $j$，他们的花费分别为 $(a_i+1)\times (a_j\times t+b_j+t+1)+b_i$ 与 $(a_j+1)\times (a_i\times t+b_i+t+1)+b_j$，两式相减即可得到 $a_i\times b_j +a_i- a_j\times b_i -a_j$，于是我们按照 $\frac{a_i}{b_i+1}&lt;\frac{a_j}{b_j+1}$ 的顺序排序即可。</p>
<p>确定顺序后考虑 DP，$f_{i,j}$ 为考虑前 $i$ 个点选取 $j$ 个点，很容易有转移方程 $f_{i,j}=\min {f_{i-1,j},(f_{i-1,j-1}+1)*(a_i+1)+b_i}$。</p>
<p>这样状态已经是 $\mathcal O(n^2)$ 的。但是我们注意当 $a_i\ge 1$ 时，时间是按照指数级别增长，那么我们最多就只能选取 $\log t$ 个点，状态就变为 $\mathcal O(n\log t)$ 了。过程中还可以使用滚动数组优化。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,K=<span class="number">40</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">    ll k,b;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n,t,ans,tot;</span><br><span class="line">ll c[N],f[N][K];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Line x,Line y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y.k*(x.b+<span class="number">1</span>)&lt;x.k*(y.b+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i].k,a[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a[i].k==<span class="number">0</span>)</span><br><span class="line">            c[++tot]=a[i].b,a[i].k=INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            f[i][j]=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            f[i][j]=<span class="built_in">min</span>(f[i][j<span class="number">-1</span>],(f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>)*(a[j].k+<span class="number">1</span>)+a[j].b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">        c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> j=tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n&amp;&amp;f[i][n]&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;f[i][n]+c[j]&gt;t)j--;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,i+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="40-AGC033C-Removing-Coins"><a href="#40-AGC033C-Removing-Coins" class="headerlink" title="40.[AGC033C] Removing Coins"></a>40.<a href="https://www.luogu.com.cn/problem/AT_agc033_c">[AGC033C] Removing Coins</a></h4><p>考虑每一次操作的本质就是断开该节点以外的所有叶子。于是考虑树的直径 $len$，简单博弈就可以得到当 $len \equiv 2\mod3$ 时才是 <code>Second</code>。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> len,d[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        len=<span class="built_in">max</span>(len,d[x]+d[y]+<span class="number">1</span>);</span><br><span class="line">        d[x]=<span class="built_in">max</span>(d[x],d[y]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    len++;</span><br><span class="line">    <span class="built_in">puts</span>(len%<span class="number">3</span>!=<span class="number">2</span>?<span class="string">&quot;First&quot;</span>:<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="41-Polycarp-and-Div-3"><a href="#41-Polycarp-and-Div-3" class="headerlink" title="41.Polycarp and Div 3"></a>41.<a href="https://www.luogu.com.cn/problem/CF1005D">Polycarp and Div 3</a></h4><p>简单题，前缀和然后 DP 就完了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">int</span> a[N],sum[N],f[N],pre[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;a[++n])!=EOF)</span><br><span class="line">        sum[n]=sum[n<span class="number">-1</span>]+a[n];</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>],f[pre[sum[i]%<span class="number">3</span>]]+(pre[sum[i]%<span class="number">3</span>]||sum[i]%<span class="number">3</span>==<span class="number">0</span>));</span><br><span class="line">        pre[sum[i]%<span class="number">3</span>]=i;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="42-P6835-Cnoi2020-线形生物"><a href="#42-P6835-Cnoi2020-线形生物" class="headerlink" title="42.P6835 [Cnoi2020]线形生物"></a>42.<a href="https://www.luogu.com.cn/problem/P6835">P6835 [Cnoi2020]线形生物</a></h4><p>考虑 $f_x$ 为从点 $x$ 走到 $x+1$ 的期望步数。$\deg_x$ 为 $x$ 的出度那么有：</p>
<p>$f_x=1+\frac{\sum_y \sum_{i=y}^{x} f_i}{\deg_x}$ </p>
<p>使用对 $f$ 做前缀和得到：</p>
<p>$f_x=\frac{\deg_x+(\deg_x-1)\times sum_x-\sum sum_{y-1}}{\deg_x}$</p>
<p>将 $sum_x$ 替换为 $sum_{x-1}+f_x$ 得：</p>
<p>$f_x=\deg_x+(\deg_x-1)\times sum_{x-1}-\sum sum_{y-1}$</p>
<p>线性递推即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,id;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],ne[M];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line">ll f[N],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(id,n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        deg[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">            f[x]=(f[x]+sum[ver[i]<span class="number">-1</span>])%mod;</span><br><span class="line">        f[x]=((deg[x]+<span class="number">1</span>+deg[x]*sum[x<span class="number">-1</span>]%mod-f[x])%mod+mod)%mod;</span><br><span class="line">        sum[x]=(sum[x<span class="number">-1</span>]+f[x])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="43-Pudding-Monsters"><a href="#43-Pudding-Monsters" class="headerlink" title="43.Pudding Monsters"></a>43.<a href="https://www.luogu.com.cn/problem/CF526F">Pudding Monsters</a></h4><p>将问题转化为一维，等价于求 $max-min=r-l$  的区间个数。</p>
<p>考虑枚举左端点 $l$，求出满足答案的右端点 $r$，并且用线段树维护 $max-min-r+l$ 的最小值及其个数。每次移动左端点 $l$ 时，用单调栈维护最小值和最大值，消除前面的影响即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> val,cnt,tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> top1,top2,sta1[N],sta2[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val=<span class="built_in">min</span>(tr[x&lt;&lt;<span class="number">1</span>].val,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val);</span><br><span class="line">    tr[x].cnt=(tr[x&lt;&lt;<span class="number">1</span>].val==tr[x].val)*tr[x&lt;&lt;<span class="number">1</span>].cnt</span><br><span class="line">            +(tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val==tr[x].val)*tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val+=k;</span><br><span class="line">    tr[x].tag+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[x].tag)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].val=l,tr[x].cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        a[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top1&amp;&amp;a[i]&lt;a[sta1[top1]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,sta1[top1<span class="number">-1</span>]+<span class="number">1</span>,sta1[top1],-(a[i]-a[sta1[top1]]));</span><br><span class="line">            top1--;</span><br><span class="line">        &#125;</span><br><span class="line">        sta1[++top1]=i;</span><br><span class="line">        <span class="keyword">while</span>(top2&amp;&amp;a[i]&gt;a[sta2[top2]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,sta2[top2<span class="number">-1</span>]+<span class="number">1</span>,sta2[top2],a[i]-a[sta2[top2]]);</span><br><span class="line">            top2--;</span><br><span class="line">        &#125;</span><br><span class="line">        sta2[++top2]=i;</span><br><span class="line">        ans+=tr[<span class="number">1</span>].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="44-P3609-USACO17JAN-Hoof-Paper-Scissor-G"><a href="#44-P3609-USACO17JAN-Hoof-Paper-Scissor-G" class="headerlink" title="44.P3609 [USACO17JAN]Hoof, Paper, Scissor G"></a>44.<a href="https://www.luogu.com.cn/problem/P3609">P3609 [USACO17JAN]Hoof, Paper, Scissor G</a></h4><p>直接DP。$f_{i,j,k}$ 表示到第 $i$ 轮变换 $j$ 次变成手势 $k$ 时最多赢的次数。时间复杂度 $\mathcal O(nk)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][M][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((x==<span class="number">0</span>&amp;&amp;y==<span class="number">1</span>)||(x==<span class="number">1</span>&amp;&amp;y==<span class="number">2</span>)||(x==<span class="number">2</span>&amp;&amp;y==<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch);</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>]==<span class="string">&#x27;H&#x27;</span>)a[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>)a[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> a[i]=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>][i]=<span class="built_in">h</span>(i,a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;<span class="number">3</span>;l++)</span><br><span class="line">                    f[i][j][k]=<span class="built_in">max</span>(f[i][j][k],<span class="built_in">max</span>(f[i<span class="number">-1</span>][j][k],(j-(k!=l)&gt;=<span class="number">0</span>)?f[i<span class="number">-1</span>][j-(k!=l)][l]:<span class="number">0</span>)+<span class="built_in">h</span>(k,a[i]));</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,f[n][i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="44-X-or-mas-Tree"><a href="#44-X-or-mas-Tree" class="headerlink" title="44.X(or)-mas Tree"></a>44.<a href="https://www.luogu.com.cn/problem/CF1615D">X(or)-mas Tree</a></h4><p>小清新构造题。</p>
<p>注意观察，其实我们只需要将边权按照 popcount 的奇偶全部转为 $0,1$ 即可。我们再通过边的限制维护两个点集，表示两个点集中的元素互相之间边权异或和为 $1$，而点集内部的点之间的边权异或和为 $0$。这个可以直接用扩展域并查集维护即可。</p>
<p>需要注意的是最后输出方案时也需要把新加的边权加进限制里面。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> u[N],v[N],w[N];</span><br><span class="line"><span class="type">int</span> fa[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x==fa[x])?x:fa[x]=<span class="built_in">get</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="built_in">get</span>(x),y=<span class="built_in">get</span>(y);</span><br><span class="line">	fa[y]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++)</span><br><span class="line">		fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(u[i],v[i],w[i]);</span><br><span class="line">		<span class="keyword">if</span>(!~w[i])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> x=__builtin_popcount(w[i])&amp;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(x)<span class="built_in">merge</span>(u[i]+n,v[i]),<span class="built_in">merge</span>(u[i],v[i]+n);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">merge</span>(u[i],v[i]),<span class="built_in">merge</span>(u[i]+n,v[i]+n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">read</span>(u,v,w);</span><br><span class="line">		<span class="keyword">if</span>(w)<span class="built_in">merge</span>(u+n,v),<span class="built_in">merge</span>(u,v+n);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">merge</span>(u,v),<span class="built_in">merge</span>(u+n,v+n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">get</span>(i)==<span class="built_in">get</span>(i+n))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!~w[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">get</span>(u[i])!=<span class="built_in">get</span>(v[i]))w[i]=<span class="number">1</span>,<span class="built_in">merge</span>(u[i]+n,v[i]),<span class="built_in">merge</span>(u[i],v[i]+n);</span><br><span class="line">			<span class="keyword">else</span> w[i]=<span class="number">0</span>,<span class="built_in">merge</span>(u[i],v[i]),<span class="built_in">merge</span>(u[i]+n,v[i]+n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,u[i],v[i],w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="45-ABC131F-Must-Be-Rectangular"><a href="#45-ABC131F-Must-Be-Rectangular" class="headerlink" title="45.[ABC131F] Must Be Rectangular!"></a>45.<a href="https://www.luogu.com.cn/problem/AT_abc131_f">[ABC131F] Must Be Rectangular!</a></h4><p>感觉自己的人类智慧又不够用了。</p>
<p>通过简单动手画图，如果将每个点向所有和它同行或同列的点连边，我们发现只要形成连通块，那么可以按照这个连通块的最大长与宽把这个长方形填满。维护连通性？我们可以用并查集。</p>
<p>我们有一种比较巧妙的方法来维护。我们将一个点的坐标拆成 $x$ 和 $y$ 单独的两个点，并且将每个点的第 $x$ 行与第 $y$ 列合并。最后统计根节点的长与宽就行了，代码很简洁。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="type">int</span> fa[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[N&lt;&lt;<span class="number">1</span>],g[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">get</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="built_in">get</span>(x),y=<span class="built_in">get</span>(y);</span><br><span class="line">	fa[y]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m&lt;&lt;<span class="number">1</span>;i++)</span><br><span class="line">		fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">read</span>(x,y);</span><br><span class="line">		<span class="built_in">merge</span>(x,y+m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)f[<span class="built_in">get</span>(i)]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)g[<span class="built_in">get</span>(i+m)]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m&lt;&lt;<span class="number">1</span>;i++)</span><br><span class="line">		ans+=<span class="number">1ll</span>*f[i]*g[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans-n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="46-GCD等于XOR-GCD-XOR"><a href="#46-GCD等于XOR-GCD-XOR" class="headerlink" title="46.GCD等于XOR GCD XOR"></a>46.<a href="https://www.luogu.com.cn/problem/UVA12716">GCD等于XOR GCD XOR</a></h4><p>有点意思的结论题。</p>
<p>直接给结论，设 $a&gt;b$，则 $a-b=a\oplus b$。</p>
<p>简单证明：</p>
<p>先考虑一个结论 $a-b\le a\oplus b$，</p>
<p>又因为 $\gcd(a,b)\ge a-b$。</p>
<p>就有了上面的结论。</p>
<p>剩下的直接枚举就行了，时间复杂度 $\mathcal O(n\ln n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*i;j&lt;=n;j+=i)</span><br><span class="line">			<span class="keyword">if</span>(((j-i)^j)==i)</span><br><span class="line">				sum[j]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">prework</span>(N<span class="number">-10</span>);</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		<span class="built_in">read</span>(x);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case %d: %lld\n&quot;</span>,t,sum[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="47-CF258D-Little-Elephant-and-Broken-Sorting"><a href="#47-CF258D-Little-Elephant-and-Broken-Sorting" class="headerlink" title="47.CF258D Little Elephant and Broken Sorting"></a>47.<a href="https://www.luogu.com.cn/problem/CF258D">CF258D Little Elephant and Broken Sorting</a></h4><p>有意思的一道题。</p>
<p>直接 DP，但是似乎不好设计出好转移的状态。这里就比较关键，直接设 $f_{i,j}$ 表示位置 $i$ 与 位置 $j$ 上的数满足偏序关系的期望。这样就对于每一个交换操作我们可以 $\mathcal O(n)$ 求出其贡献，而预处理和统计答案的时间为 $\mathcal O(n^2)$。总时间复杂度为 $\mathcal O(n^2+qn)$。</p>
<p>代码十分好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">double</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j)<span class="keyword">continue</span>;</span><br><span class="line">            f[i][j]=(a[i]&lt;a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==x||i==y)<span class="keyword">continue</span>;</span><br><span class="line">            f[x][i]=f[y][i]=f[x][i]*<span class="number">0.5</span>+f[y][i]*<span class="number">0.5</span>;</span><br><span class="line">            f[i][x]=f[i][y]=f[i][x]*<span class="number">0.5</span>+f[i][y]*<span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[x][y]=f[y][x]=f[x][y]*<span class="number">0.5</span>+f[y][x]*<span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            ans+=f[j][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="48-CF662C-Binary-Table"><a href="#48-CF662C-Binary-Table" class="headerlink" title="48.CF662C Binary Table"></a>48.<a href="https://www.luogu.com.cn/problem/CF662C">CF662C Binary Table</a></h4><p>这次是真的要认真开始做了。</p>
<p>比较容易想复杂，但还是挺巧妙的经典题。</p>
<p>因为有 $n\le 20$，考虑对每一列进行状压，设第 $i$ 行的初始状态为 $g[i]$。接着考虑对行操作，也只有 $2^n$ 种。对行的操作为 $x$ 时，答案 $\displaystyle f[x]=\sum_{i=1}^m \min(\text{popcount} (g[i]\oplus x),\text{popcount}(\neg g[i]\oplus x))$。暴力计算是 $\mathcal O(m2^n)$。考虑将 $m$ 去掉，所有行的状态总数最多为 $2^n$，记 $\displaystyle a[x]=\sum_{i=1}^{m}[g[i]=x]$。关键的来了，这个转移成立满足的条件是 $g[i]\oplus x=y$ 或 $\neg g[i]\oplus x=y$，贡献与 $y$ 相关，要求的是对 $x$ 的贡献，于是将 $y$ 移至等式右侧，$x$ 移至等式右侧吗，得到 $g[i]\oplus y=x$ 或 $g[i]\oplus \neg y=x$。于是进一步得到下面的式子：</p>
<script type="math/tex; mode=display">
f[x]=\sum_{i\oplus j=x}a[i]*b[j]</script><p>其中 $b[i]$ 代表 $\min(\text{popcount} (i),\text{popcount}(\neg x))$。转化为 FWT 板子，时间复杂度为 $\mathcal O(n 2^n)$。</p>
<p>注意 FWT 过程中需要开<code>long long</code>。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> popcnt __builtin_popcount</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">21</span>,M=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[M];</span><br><span class="line">ll a[<span class="number">1</span>&lt;&lt;N],b[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT</span><span class="params">(<span class="type">int</span> n,ll *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ll x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=x+y,a[i+j+mid]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IFWT</span><span class="params">(<span class="type">int</span> x,ll *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ll x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=x+y&gt;&gt;<span class="number">1</span>,a[i+j+mid]=x-y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;x);</span><br><span class="line">            g[j]|=x&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)a[g[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)b[i]=<span class="built_in">popcnt</span>(i),b[i]=<span class="built_in">min</span>(b[i],n-b[i]);</span><br><span class="line">    <span class="built_in">FWT</span>(n,a),<span class="built_in">FWT</span>(n,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)a[i]*=b[i];</span><br><span class="line">    <span class="built_in">IFWT</span>(n,a);</span><br><span class="line">    ll ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)ans=<span class="built_in">min</span>(ans,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>集合幂级数</title>
    <url>/2023/02/19/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/</url>
    <content><![CDATA[<p>快速莫比乌斯变换 FMT 与 快速沃尔什变换 FWT。</p>
<span id="more"></span>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>一个长度为 $2^n$ 的序列 $f(i)$，有一个生成函数 $F(x)=\sum_{i=0}^{2^n-1}f(i) x^i$，那么，这个生成函数叫做集合幂级数。</p>
<p>这和集合有什么关系呢？将集合 ${0,1,\cdots,n-1 }$ 的一个子集状态压缩后就对应着原序列的一个下标 $i$。</p>
<p>其卷积形式大多为 $c(i)=\sum_{j\oplus k=i}a(j)*b(k)$，这里的 $\oplus$ 指代某种运算，其大多是位运算。</p>
<p>直接暴力求卷积是 $\mathcal O(4^n)$ 的，考虑更优的做法。</p>
<h3 id="2-快速莫比乌斯变换-FMT"><a href="#2-快速莫比乌斯变换-FMT" class="headerlink" title="2.快速莫比乌斯变换 FMT"></a>2.快速莫比乌斯变换 FMT</h3><p>用来求高维前缀和。高维前缀和就是对 $n$ 维数组求前缀和，不过每一维只有 $0,1$ 两个下标。本质上就是子集和 $b(i)=\sum_{j|i=i} a(j)$。暴力枚举子集来求的时间复杂度是 $\mathcal O(3^n)$ 的。</p>
<p>是实际上我们可以对每一维单独来做遍前缀和，容易发现这样做是正确的。于是是时间复杂度 为 $\mathcal O(n2^n)$。</p>
<p>其实这样做法也可以从子集和或者另外的角度来理解。而高维后缀和同理。</p>
<details class="code" open><summary><i class="fab fa-code fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1</span>&lt;&lt;n;j++)</span><br><span class="line">        <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">            a[j]+=a[j^(<span class="number">1</span>&lt;&lt;i)];</span><br></pre></td></tr></table></figure>

</details>
<h3 id="3-快速沃尔什变换-FWT"><a href="#3-快速沃尔什变换-FWT" class="headerlink" title="3.快速沃尔什变换 FWT"></a>3.快速沃尔什变换 FWT</h3><p>用于求异或卷积，在下面说。</p>
<h3 id="4-卷积"><a href="#4-卷积" class="headerlink" title="4.卷积"></a>4.卷积</h3><p>为了让卷积 $c(i)=\sum_{j\oplus k=i}a(i)*b(i)$ 更快计算，我们需要用 FMT/FWT 将 $a,b$ 进行变换，再 $\mathcal O(n)$ 求出变换后的 $c$，再对其进行逆变换就可以求出原本的 $c$。</p>
<h4 id="1-或卷积"><a href="#1-或卷积" class="headerlink" title="1.或卷积"></a>1.或卷积</h4><p>求卷积 $c_i=\sum_{j|k=i} a_j*b_k$。</p>
<p>考虑构造出变换 $FMT(c)_x=FMT(a)_x*FMT(b)_x$。</p>
<p>证明如下：</p>
<script type="math/tex; mode=display">
\begin{align}
FMT(a)_x*FMT(b)_x&=\sum_{i|x=x} a(i)*\sum_{i|x=x}b(i)\\
&=\sum_{i|x=x}\sum_{j|x=x} a(i)*b(j)\\
&=\sum_{i|x=x}c(i)\\
&=FMT(c)_x
\end{align}</script><p>于是先对 $a,b$ 做一次高维前缀和，相乘后做一次逆变换即得到了 $c$。</p>
<h4 id="2-与卷积"><a href="#2-与卷积" class="headerlink" title="2.与卷积"></a>2.与卷积</h4><p>和或卷积类似，将高维前缀和变为高维后缀和即可。</p>
<h4 id="3-异或卷积"><a href="#3-异或卷积" class="headerlink" title="3.异或卷积"></a>3.异或卷积</h4><p>求卷积 $c_i=\sum_{j\oplus k=i} a_j*b_k$。</p>
<p>我们设对序列 $a$ 变换为 $FWT(a)_x=\sum_{i=0}^{n-1} g(x,i)a_i$。</p>
<p>我们要想使 </p>
<script type="math/tex; mode=display">
FWT(c)_x=FWT(a)_x*FWT(b)_x</script><p>尝试变换一下：</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=0}^{n-1} g(x,i)c_i=\sum_{i=0}^{n-1} g(x,i)a_i *\sum_{i=0}^{n-1} g(x,i)b_i
\\
\sum_{i=0}^{n-1} g(x,i)\sum_{j\oplus k=i} a_j*b_k=\sum_{i=0}^{n-1} g(x,i)a_i \sum_{i=0}^{n-1} *g(x,i)b_i
\\
\sum_{i=0}^{n-1}\sum_{j\oplus k=i} g(x,i) a_j*b_k=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1} g(x,i)g(x,j)a_i*b_j
\\
\sum_{i=0}^{n-1}\sum_{j=0}^{n-1} g(x,i\oplus j)a_i*b_j=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1} g(x,i)g(x,j)a_i*b_j
\end{align}</script><p>于是得到：</p>
<script type="math/tex; mode=display">
g(x,i\oplus j)=g(x,i)g(x,j)</script><p>我们需要构造的式子需要满足上面这个等式，并且能够快速得到 $FWT(a)$。前人的智慧告诉我们应当为 $g(x,i)=(-1)^{|i\odot x|}$，因为有 $(i\oplus j)\odot x=(i\odot x)\oplus (j\odot x)$。所以 FWT 的式子就是：</p>
<script type="math/tex; mode=display">
FWT(a)_x=(-1)^{|i\odot x|}a_i</script><p>至于如何快速求出 $FWT(a)$，考虑一个类似于蝶形运算的过程，具体可见代码，这里不再赘述。这样总的时间复杂度为 $\mathcal O(n2^n)$。</p>
<details class="code" open><summary><i class="fab fa-code fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=x+y,a[i+j+mid]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IFWT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=x+y&gt;&gt;<span class="number">1</span>,a[i+j+mid]=x-y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>发现此过程和 NTT 非常相似。</p>
<h4 id="4-子集卷积"><a href="#4-子集卷积" class="headerlink" title="4.子集卷积"></a>4.子集卷积</h4><p>求 $c_i=\sum_{j\odot k=0,j|k=i} a_j*b_k$。</p>
<p>注意到 $j,k$ 对 $j|k$ 有贡献，当且仅当 $\mid j\mid +\mid k\mid =\mid j|k\mid $。这启发我们按照集合的大小来进行分类。</p>
<p>将原序列扩展到二维为 $A_{x,i}=a_i[|i|=x]$，于是有：</p>
<script type="math/tex; mode=display">
\begin{align}
C_{|x|,x}=\sum_{i|j=x,|i|+|j|=|x|} A_{|i|,i}*B_{|j|,j}\\
FMT(C_{|x|})=\sum_{|i|}(FMT(A_{|i|})*FMT(B_{|x|-|i|}))
\end{align}</script><p>这里我们同时对两边做 FMT，这显然是成立的。我们先处理出 $FMT (A_{|i|}),FMT(B_{|i|})$，求出 $FMT(C_{|x|})$ 后做 $IFMT$ 即可。时间复杂度为 $\mathcal O(n^22^n)$。</p>
 <details class="code" open><summary><i class="fab fa-code fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">FMT</span>(n,a[i]),<span class="built_in">FMT</span>(n,b[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n-i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;tot;x++)</span><br><span class="line">            c[i+j][x]=<span class="built_in">adj</span>(c[i+j][x]+<span class="number">1ll</span>*a[i][x]*b[j][x]%mod);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">IFMT</span>(n,c[i]);</span><br></pre></td></tr></table></figure>

</details>
<h3 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h3><h4 id="1-CF914G-Sum-the-Fibonacci"><a href="#1-CF914G-Sum-the-Fibonacci" class="headerlink" title="1.CF914G Sum the Fibonacci"></a>1.<a href="https://codeforces.com/problemset/problem/914/G">CF914G Sum the Fibonacci</a></h4><p>模板题。</p>
 <details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> popcnt __builtin_popcount</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">17</span>,M=<span class="number">1</span>&lt;&lt;N,mod=<span class="number">1e9</span>+<span class="number">7</span>,inv=mod+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,tot;</span><br><span class="line"><span class="type">int</span> f[M],A[M];</span><br><span class="line"><span class="type">int</span> a[N+<span class="number">1</span>][M],b[N+<span class="number">1</span>][M],c[M],d[M],e[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FMT</span><span class="params">(<span class="type">int</span> op,<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">if</span>(!op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j]=<span class="built_in">adj</span>(a[j]+a[j^(<span class="number">1</span>&lt;&lt;i)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j^(<span class="number">1</span>&lt;&lt;i)]=<span class="built_in">adj</span>(a[j]+a[j^(<span class="number">1</span>&lt;&lt;i)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IFMT</span><span class="params">(<span class="type">int</span> op,<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">if</span>(!op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=tot<span class="number">-1</span>;~j;j--)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j]=<span class="built_in">adj</span>(a[j]-a[j^(<span class="number">1</span>&lt;&lt;i)]+mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=tot<span class="number">-1</span>;~j;j--)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j^(<span class="number">1</span>&lt;&lt;i)]=<span class="built_in">adj</span>(a[j^(<span class="number">1</span>&lt;&lt;i)]-a[j]+mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=<span class="built_in">adj</span>(x+y),a[i+j+mid]=<span class="built_in">adj</span>(x-y+mod);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IFWT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=<span class="number">1ll</span>*<span class="built_in">adj</span>(x+y)*inv%mod,a[i+j+mid]=<span class="number">1ll</span>*<span class="built_in">adj</span>(x-y+mod)*inv%mod;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        A[x]++,tot=<span class="built_in">max</span>(tot,x);</span><br><span class="line">    &#125;</span><br><span class="line">    tot++;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;n)&lt;tot)n++;</span><br><span class="line">    tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>,f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;tot;i++)</span><br><span class="line">        f[i]=<span class="built_in">adj</span>(f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//subset</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        a[<span class="built_in">popcnt</span>(i)][i]=A[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="built_in">FMT</span>(<span class="number">0</span>,n,a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n-i;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;tot;x++)</span><br><span class="line">                b[i+j][x]=<span class="built_in">adj</span>(b[i+j][x]+<span class="number">1ll</span>*a[i][x]*a[j][x]%mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">IFMT</span>(<span class="number">0</span>,n,b[i]);</span><br><span class="line">    <span class="comment">//xor</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c,A,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">FWT</span>(n,c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        c[i]=<span class="number">1ll</span>*c[i]*c[i]%mod;</span><br><span class="line">    <span class="built_in">IFWT</span>(n,c);</span><br><span class="line">    <span class="comment">//and</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        d[i]=<span class="number">1ll</span>*b[<span class="built_in">popcnt</span>(i)][i]*f[i]%mod;</span><br><span class="line">    <span class="built_in">memcpy</span>(e,A,<span class="built_in">sizeof</span>(e));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        c[i]=<span class="number">1ll</span>*c[i]*f[i]%mod,e[i]=<span class="number">1ll</span>*e[i]*f[i]%mod;</span><br><span class="line">    <span class="built_in">FMT</span>(<span class="number">1</span>,n,c),<span class="built_in">FMT</span>(<span class="number">1</span>,n,d),<span class="built_in">FMT</span>(<span class="number">1</span>,n,e);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        c[i]=<span class="number">1ll</span>*c[i]*d[i]%mod*e[i]%mod;</span><br><span class="line">    <span class="built_in">IFMT</span>(<span class="number">1</span>,n,c);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+c[<span class="number">1</span>&lt;&lt;i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>集合幂级数</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>我需要冷水</title>
    <url>/2023/06/29/%E6%88%91%E9%9C%80%E8%A6%81%E5%86%B7%E6%B0%B4/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="172bb354694b3e88e7f1b7565a1c38288bb7bb329a186bec6124b753bbaf9e08">d1b2e94ab475e6a08da918bb547c6123a22f9797e66e695c52583b08237d6411a644efaae7497cafaaf09b70c6e76dfe0fae8da522c1d1f3ddaf67183f2c661367be78636004cbba327e1962ef35804e7e57e72bb517ccfd4d47f155d87ade7fe59004fc22752500b828d7e7fc7f2ae482a98ed0e510fc3b2ca052b9dd5779616a1acaec67339a96657f19920de8a5e6b0aae06fddcc8baa5a70077cffdc8f7decc5242f711cdec5c9c5319c59811137d22c9c8406302f60d1ef8f3b62009affb0d6415d3b0dac653fe78e889b8ab18731c52267bc58ee22a92f296dad6f073e7753ce58893e3d2aef3fce025b55a5410a48a13bb17dd63431043acc1aec6e0396b90161e6b01a6f2927db0b5fcb3793d24d6692fc66b3fbe02a310520f541de4336dd16f9aa92245f6beb81d068fa28aa75dec46579ee9abd0feeeabd731e1937f4dc6cafb1c3a3f112305f3409cbe836929e16ce1c5ecfba42ce71588ece49e59c13a0c900d7d861eb3c8e6411952ce0cb433f40b1d9fabb3016a527c37b36d44b9922c78841c4c0887fabca28f0076cd029392e36518b8e96405737a43c011114a27645a79e47647ae013ef6250d055eeb222cece93716f9c2be321910ea6d2281e12d464834f9a4e0dc9ef5e89589d659d8103379f23f2db806df0800e98c81cc2779a59eca8a48bcac39d639a2959e6dd8f0c9b21db24b43c05e53f8ba4b07fa38cec5020ca02cb4b61bde1488e06219453055e5ceeecaa3b63c7129076cabbabf1c5bcaaeabc79085c5b516aec4de6ea5d803a26f9d844d1a461ef61fca5f14e8d095b3f23d5e2423e881715eb86935cafaadffe492dad0a796d3af2e7ab53a9070b60e624fc6cd046d0a60083273c4b5b23dc55cc092b2f3df9c44665317eb06ee83ee5ef62c4ffdf7536897ca85d81e33367e8310780b745f818da28563063eba90769c3147b2bdce7298d94d9606a9da4a7c7519c42b54cc14238cc46ef73baf7d5da9c053c9a8ad1cf7b04aa8677af215899f12a3293fd9bc1f4a344b32a805e104de002daf5c8c44c24f9ee9f43531649d2d8c1b86615f45a5695</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">我需要冷水</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>[ARC150D] Removing Gacha</title>
    <url>/2023/07/01/ARC150D-Removing-Gacha/</url>
    <content><![CDATA[<p>小清新题。</p>
<span id="more"></span>
<p>设 $x$ 到根的距离为 $d_x$，期望次数为 $f_x$ 。从 $x$ 到根的链中所有点都已染色时，此时的期望次数为 $\frac{1}{d_x}$，其余情况，只要这条链上有未染色的点，就可以对 $x$ 进行操作，并且每次都是从剩下可行点相等概率选择一个，这种情况下与将从 $x$ 到根的链中所有点全部染色的的期望相同，而这恰好可以理解为 $f_x$ 另一个定义。所有得到：$\displaystyle f_x=f_{fa}+\frac{1}{d_x}=\sum_{i=1}^{d_x}\frac{1}{i}$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> d[N],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sum[i]=<span class="built_in">adj</span>(sum[i<span class="number">-1</span>]+<span class="built_in">qpow</span>(i));</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,fa;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(fa);</span><br><span class="line">        d[i]=d[fa]+<span class="number">1</span>;</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+sum[d[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF Nasty Donchik</title>
    <url>/2023/07/11/CF-Nasty-Donchik/</url>
    <content><![CDATA[<p>数据结构好题。</p>
<span id="more"></span>    
<p><a href="https://codeforces.com/group/Uo1lq8ZyWf/contest/265564/problem/C">题目链接</a></p>
<p>如何快速判断数集相等？考虑处理出每个位置的数在前面和后面第一次出现的位置 $pre_i,ne_i$。对于三元组 $(i,j,k)$ 合法的充要条件是： $\displaystyle \min_{t=j+1}^k pre_t\ge i,\max_{t=i}^j ne_t\le k$。考虑固定 $j,k$，第一个条件限制的是 $i$ 的上界，第二个条件限制的是 $i$ 的下界，二者之间的 $i$ 都是满足条件的。我们考虑从左到右枚举 $k$，维护前面所有 $j$，对应的 $i$ 的上界与下界，以及它们之和，最后相减即可得到答案。</p>
<p>我们需要每个位置 $j$ 的数是否在后面 $(j,k]$ 中出现过，这样的位置我们称之为“合法”，我们只对合法位置计算答案。第一个条件是容易的，区间取 min 即可。考虑第二个条件，相当于求 $j$ 向前最大的合法连续段（这样的段才满足 $\max_{t=i}^j ne_t\le k$）。加入位置 $k$ 会使位置 $pre_k$ 的点变为合法，用向前连续段的答案更新向后连续段的答案即可，线段树二分和区间赋值操作完成，也可以直接区间取 min。</p>
<p>jls 线段树维护一下即可，时间复杂度 $\mathcal O(n\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> pre[N],suf[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum;</span><br><span class="line">    <span class="type">int</span> si,pre,suf,fir,se,cnt,tag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span></span><br><span class="line">&#123;</span><br><span class="line">    Node tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x].sum=tr[x&lt;&lt;<span class="number">1</span>].sum+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">        tr[x].si=tr[x&lt;&lt;<span class="number">1</span>].si&amp;tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].si;</span><br><span class="line">        tr[x].pre=tr[x&lt;&lt;<span class="number">1</span>].pre;</span><br><span class="line">        <span class="keyword">if</span>(tr[x&lt;&lt;<span class="number">1</span>].si)tr[x].pre+=tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].pre;</span><br><span class="line">        tr[x].suf=tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].suf;</span><br><span class="line">        <span class="keyword">if</span>(tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].si)tr[x].suf+=tr[x&lt;&lt;<span class="number">1</span>].suf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tr[x&lt;&lt;<span class="number">1</span>].fir==tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].fir)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[x].fir=tr[x&lt;&lt;<span class="number">1</span>].fir;</span><br><span class="line">            tr[x].cnt=tr[x&lt;&lt;<span class="number">1</span>].cnt+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt;</span><br><span class="line">            tr[x].se=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].se,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].se);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[x&lt;&lt;<span class="number">1</span>].fir&gt;tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].fir)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[x].fir=tr[x&lt;&lt;<span class="number">1</span>].fir;</span><br><span class="line">            tr[x].cnt=tr[x&lt;&lt;<span class="number">1</span>].cnt;</span><br><span class="line">            tr[x].se=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].se,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].fir);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tr[x].fir=tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].fir;</span><br><span class="line">            tr[x].cnt=tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt;</span><br><span class="line">            tr[x].se=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].fir,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].se);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].fir&lt;=k)<span class="keyword">return</span> ;</span><br><span class="line">        tr[x].sum+=<span class="number">1ll</span>*(k-tr[x].fir)*tr[x].cnt;</span><br><span class="line">        tr[x].fir=tr[x].tag=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!~tr[x].tag)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag);</span><br><span class="line">        <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag);</span><br><span class="line">        tr[x].tag=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x].l=l,tr[x].r=r,tr[x].tag=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span>  tr[x].sum=tr[x].si=tr[x].pre=tr[x].suf=<span class="number">0</span>,tr[x].fir=l,tr[x].se=<span class="number">-1</span>,tr[x].cnt=<span class="number">1</span>,<span class="built_in">void</span>();</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify_min</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].fir&lt;=k)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=tr[x].l&amp;&amp;r&gt;=tr[x].r&amp;&amp;tr[x].se&lt;k)<span class="keyword">return</span> <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify_min</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify_min</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].l==tr[x].r)<span class="keyword">return</span> tr[x].pre=tr[x].suf=tr[x].si=<span class="number">1</span>,tr[x].sum=tr[x].fir,<span class="built_in">void</span>();</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,pos);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;x&lt;&lt;&quot; : &quot;&lt;&lt;tr[x].l&lt;&lt;&quot; &quot;&lt;&lt;tr[x].r&lt;&lt;&quot; &quot;&lt;&lt;mid&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;tr[x&lt;&lt;1].suf&lt;&lt;&quot; &quot;&lt;&lt;tr[x&lt;&lt;1|1].pre&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=tr[x].l&amp;&amp;r&gt;=tr[x].r)<span class="keyword">return</span> tr[x].sum;</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)res+=<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)res+=<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_pre</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].l==tr[x].r)<span class="keyword">return</span> pos;</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;x&lt;&lt;&quot; : &quot;&lt;&lt;tr[x].l&lt;&lt;&quot; &quot;&lt;&lt;tr[x].r&lt;&lt;&quot; &quot;&lt;&lt;mid&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;tr[x&lt;&lt;1].suf&lt;&lt;&quot; &quot;&lt;&lt;tr[x&lt;&lt;1|1].pre&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid)<span class="keyword">return</span> <span class="built_in">get_pre</span>(x&lt;&lt;<span class="number">1</span>,pos);</span><br><span class="line">        <span class="keyword">if</span>(mid+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].pre&gt;=pos)<span class="keyword">return</span> mid-tr[x&lt;&lt;<span class="number">1</span>].suf;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_pre</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_ne</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].l==tr[x].r)<span class="keyword">return</span> pos;</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;x&lt;&lt;&quot; : &quot;&lt;&lt;tr[x].l&lt;&lt;&quot; &quot;&lt;&lt;tr[x].r&lt;&lt;&quot; &quot;&lt;&lt;mid&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;tr[x&lt;&lt;1].suf&lt;&lt;&quot; &quot;&lt;&lt;tr[x&lt;&lt;1|1].pre&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">        <span class="keyword">if</span>(pos&gt;mid)<span class="keyword">return</span> <span class="built_in">get_ne</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos);</span><br><span class="line">        <span class="keyword">if</span>(mid-tr[x&lt;&lt;<span class="number">1</span>].suf+<span class="number">1</span>&lt;=pos)<span class="keyword">return</span> mid+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].pre+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_ne</span>(x&lt;&lt;<span class="number">1</span>,pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t1,t2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]),pre[i]=p[a[i]],p[a[i]]=i;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,a[i]);</span></span><br><span class="line">    <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,pre[i]);</span></span><br><span class="line">    <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">    t1.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,n+<span class="number">1</span>);</span><br><span class="line">    t2.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,n+<span class="number">1</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(pre[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;&quot;get : &quot;&lt;&lt;i&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">            <span class="type">int</span> x=t1.<span class="built_in">get_pre</span>(<span class="number">1</span>,pre[i]<span class="number">-1</span>);</span><br><span class="line">            <span class="type">int</span> y=t1.<span class="built_in">get_ne</span>(<span class="number">1</span>,pre[i]+<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line">            t1.<span class="built_in">modify_min</span>(<span class="number">1</span>,pre[i],y,x);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot; : &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;&quot;end_get : \n&quot;;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// cout&lt;&lt;&quot;modify: &quot;&lt;&lt;pre[i]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">            t1.<span class="built_in">modify</span>(<span class="number">1</span>,pre[i]);</span><br><span class="line">            t2.<span class="built_in">modify</span>(<span class="number">1</span>,pre[i]);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;&quot;end_modify : \n&quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        t1.<span class="built_in">modify_min</span>(<span class="number">1</span>,<span class="number">1</span>,i<span class="number">-1</span>,pre[i]);</span><br><span class="line">        t2.<span class="built_in">modify_min</span>(<span class="number">1</span>,<span class="number">1</span>,i<span class="number">-1</span>,pre[i]);</span><br><span class="line">        ans+=t2.tr[<span class="number">1</span>].sum-t1.tr[<span class="number">1</span>].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC164</title>
    <url>/2023/07/10/ARC164/</url>
    <content><![CDATA[<p>第一场 ARC，全靠 mydcwfy 带飞。</p>
<span id="more"></span>
<p>据 mydcwfy 说是 sb 场。。。</p>
<h3 id="A-Ternary-Decomposition"><a href="#A-Ternary-Decomposition" class="headerlink" title="A - Ternary Decomposition"></a>A - Ternary Decomposition</h3><p>考虑最小的分解个数，就是按照三进制每位分解。判断 $n,k$ 奇偶性即可。</p>
<h3 id="B-Switching-Travel"><a href="#B-Switching-Travel" class="headerlink" title="B - Switching Travel"></a>B - Switching Travel</h3><p>同色点间的边作为答案路径的最后一条边，异色点间路径作为其余的边。将异色点之间的边连起来，同色点间的边判一下是否在同一连通块。</p>
<h3 id="C-Reversible-Card-Game"><a href="#C-Reversible-Card-Game" class="headerlink" title="C - Reversible Card Game"></a>C - Reversible Card Game</h3><p>简单博弈。Alice 每次必定翻 $a_i-b_i$ 最大的牌。Bob 每次必定取走 $a_i-b_i$ 次大的牌。但是所有 $a_i&gt;b_i$ 的牌翻完时，Alice 必须翻 $a_i<b_i$ 的牌了，此时 Bob 直接取这张即可。不过我们需要判断一下有奇数张 $a_i>b_i$ 的牌的情况，这种情况下 Bob 必定会取一张不优的牌，减去 $\min_i |a_i-b_i|$ 即可。</p>
<h3 id="D-1D-Coulomb"><a href="#D-1D-Coulomb" class="headerlink" title="D - 1D Coulomb"></a>D - 1D Coulomb</h3><p>题面花里胡哨。实际上是个括号匹配的问题。直接 DP 即可。DP 的过程中不仅需要记录答案，还有到达该状态的方案数（转移时需要乘上）。</p>
<p>最sb的是题目给的是 $\frac{n}{2}$，但是我没看到，然后调了老久。。。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>CF566C Logistical Questions</title>
    <url>/2023/06/30/CF566C-Logistical-Questions/</url>
    <content><![CDATA[<p>大清新妙妙题。</p>
<span id="more"></span>
<p>设 $d(x,y)$ 为其在原树上的距离，$dis(x,y)=d(x,y)^{\frac{3}{2}}$。首先我们考虑链上情况，对于 $[a,b]$ 这条路径，随着 $i$ 的移动，容易发现 $dis(x,i)$ 是一个下凸函数，有且仅有一个极值点。我们可以三分求。更进一步，我们发现树上不过是将很多条链拼起来，所以也是若干个下凸函数相加，得到依旧是关于 $x$ 的下凸函数。</p>
<p>于是我们考虑在树上一步一步逼近取到极值的 $x$。一个朴素的想法是，求出当前位置的所有子节点的答案，然后向最小的子节点走。但这样显然是 $\mathcal O(n^2)$，和暴力一个复杂度。不难想到我们可以使用点分治的方式来代替，也就是每次找到子树的重心再按照上面进行。不幸的是，这样还是会被卡成 $\mathcal O(n^2)$ 的。</p>
<p>考虑瓶颈在哪里，因为我们只要计算一个点的贡献就需要遍历整棵树，这样当度数很多时会寄。但是下凸函数的性质我们并没有用好，于是就有了妙妙的做法——对函数<strong>求导</strong>。对 $dis(x,i)$ 求导，得到 $dis(x,i)’=1.5\cdot d(x,i)^{\frac{1}{2}}$。求出该子节点为根的子树中所有项导函数之和 $dv_i$。那么 $x$ 在向某一个 $son$ 移动时，其余所有点的导数加一，该点导数减一。所以导函数变为 $(\sum_{i} p_i)-2\times p_{son}$，我们只需要找到 $son$ 的导函数 $f(son)’\le 0$ 的点即可（因为有且仅有一个极值点，这样的 $son $ 也是唯一的）。而每次求各个子树的复杂度为 $\mathcal O(n)$。于是总的时间复杂度为 $\mathcal O(n\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> INF=<span class="number">1e30</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,anspos,rt;</span><br><span class="line"><span class="type">int</span> v[N],nowtot;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],e[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> si[N],maxp[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">double</span> ans=INF,sum,dv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_rt</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[x])<span class="keyword">return</span> ;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    maxp[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa||vis[y])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">get_rt</span>(y,x);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        maxp[x]=<span class="built_in">max</span>(maxp[x],si[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    maxp[x]=<span class="built_in">max</span>(maxp[x],nowtot-si[x]);</span><br><span class="line">    <span class="keyword">if</span>(maxp[x]&lt;maxp[rt])rt=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa,<span class="type">double</span> &amp;dv,<span class="type">int</span> nowd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum+=<span class="built_in">pow</span>(nowd,<span class="number">1.5</span>)*v[x],dv+=<span class="number">1.5</span>*<span class="built_in">sqrt</span>(nowd)*v[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">calc</span>(y,x,dv,nowd+e[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[x])<span class="keyword">return</span> ;</span><br><span class="line">    rt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">get_rt</span>(x,<span class="number">0</span>);</span><br><span class="line">    x=rt;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> sumd=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        dv[y]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">calc</span>(y,x,dv[y],e[i]);</span><br><span class="line">        sumd+=dv[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;ans)anspos=x,ans=sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(sumd<span class="number">-2</span>*dv[y]&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nowtot=si[y];</span><br><span class="line">            <span class="built_in">dfs</span>(y);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(v[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    nowtot=n;</span><br><span class="line">    maxp[<span class="number">0</span>]=n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %lf&quot;</span>,anspos,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P4198 楼房重建</title>
    <url>/2023/07/09/P4198-%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<p>小 trick。</p>
<span id="more"></span>
<p>转化为斜率。相当于维护一段区间的前缀最大值个数。尝试线段树维护，问题在于如何合并子儿子的信息，即 <code>pushup</code>。对于每个节点维护区间的最大值，以及答案。最大值一定会在这段区间的答案序列之中。我们每一次直接递归合并答案。我们先直接加上左儿子本身的答案，再递归求解右儿子接上的答案。如果当前递归到某个节点，左儿子的最大值小于当前左儿子的最大值，直接递归右儿子。否则，递归左儿子，再加上该节点在右儿子上的答案。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">double</span> val; </span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">double</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].val&lt;=k)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l==tr[x].r)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[x&lt;&lt;<span class="number">1</span>].val&lt;=k)<span class="keyword">return</span> <span class="built_in">get</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(x&lt;&lt;<span class="number">1</span>,k)+tr[x].len-tr[x&lt;&lt;<span class="number">1</span>].len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].val,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val);</span><br><span class="line">    tr[x].len=tr[x&lt;&lt;<span class="number">1</span>].len+<span class="built_in">get</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x&lt;&lt;<span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bulid</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bulid</span>(x&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">bulid</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos,<span class="type">double</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l==tr[x].r)<span class="keyword">return</span> tr[x].val=k,tr[x].len=<span class="number">1</span>,<span class="built_in">void</span>();</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,pos,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">bulid</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,x,<span class="number">1.0</span>*y/x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="number">1</span>].len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P8994 [北大集训 2021] 经典游戏</title>
    <url>/2023/07/07/P8994-%E5%8C%97%E5%A4%A7%E9%9B%86%E8%AE%AD-2021-%E7%BB%8F%E5%85%B8%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>考试题目。</p>
<span id="more"></span>
<p>考虑用 $SG$ 函数解决问题，那么 $SG(x)=\oplus_{y\in \text{subtree(x)},y\neq x} SG(y)$，叶节点 $SG(x)=0$。容易发现 $SG(x)=d_x$，其中 $d_x$ 为 $x$ 为根的子树的最深深度。我们只处理 $a_i\equiv 1 \pmod 2$ 的 $SG(x)$ 值。那么先手必胜的充要条件即 $\oplus_{a_x\equiv \pmod 21} SG(x)&gt;d_y$。</p>
<p>考虑我们需要进行的操作，换根，$a_x \oplus 1$，以及求满足 $dis(y’,y)\le 1$ 的 $y’$。s</p>
<p>不妨设点 $1$ 为初始根。考虑换根操作，$dep_x$ 只与 $fa_x$ 有关。于是 $SG$ 值发生改变的只有以 $1$ 为根 $1\to x$ 链上节点，这一部分不会因为 $a_x\oplus 1$ 而改变。我们可以简单树形 DP 得到。我们还需要异或上以 $x$ 为根 $x\to 1$ 的。</p>
<p>考虑 $a_x\oplus 1$。而 $x$ 对点 $x’$ 产生影响的条件是 $x\in \text{subtree}(x’)$ ，并且子树 $x$ 为子树 $x’$ 中最深的子树，即为 $x$ 的长儿子。于是我们直接长链剖分，那么修改是长链上开头的连续一段，树状数组维护。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Trie</tag>
        <tag>树状数组</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>QOJ#2065. Cyclic Distance</title>
    <url>/2023/07/12/QOJ-2065-Cyclic-Distance/</url>
    <content><![CDATA[<p>DP 趣题，运用到函数的凸性。以及 mydcwfy 提供了的贪心解法。</p>
<span id="more"></span>
<p>考虑选点后每条边的贡献。容易发现对于子树 $i$ 中选择 $j$ 个点，存在一种顺序使得父亲边被贡献 $2\times \min(j,k-j)$ 次，调整法容易证明。于是我们不需要考虑顺序， 考虑子树中点集即可。设计 $f(i,j)$ 表示子树 $i$ 中选取 $j$ 个点，容易得到 $\mathcal O(nk)$ 的朴素树上背包的解法。</p>
<p>考虑研究 $f(i,j)$ 的性质，不妨猜测 $f(i,x)$ 具有凸性。当前点是否选中相当于平移加取 $\max$，而背包的转移是 $(\max,+)$ 卷积，相当于求凸包的闵可夫斯基和，得到的还是一个凸包。所以 $f(i,x)$ 具有凸性质。</p>
<p>于是我们考虑用维护 $f(i,x)$ 的差分数组，求闵可夫斯基和就直接进行启发式合并。因为贡献是 $\min(j,k-j)$ 的样子，我们需要根据 $j$ 按照 $\frac{k}{2}$ 分类，甚至需要讨论 $k\equiv 1\pmod 2$ 的情况，中间可能需要多维护一个值。而这部分的贡献是区间修改，直接在平衡树上打 $\text{tag}$ 就行。</p>
<p>但是实际上我们直接用堆就可以维护了。我们将函数分为两段 $j\le \lfloor \frac{k}{2}\rfloor,j&gt; \lceil \frac{k}{2}\rceil$，这两段用堆来维护。再一个变量表示 $j=\lceil \frac{k}{2}\rceil$ 的答案。根据凸性质，$f(i,x)$ 差分数组单减，每次我们取出堆顶元素进行更新。同样加上贡献对于两个堆打上 $\text{tag}$ 即可。</p>
<p>两种写法时间复杂度均为 $\mathcal O(n\log^2 n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T,n,k;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],e[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Heap</span></span><br><span class="line">&#123;</span><br><span class="line">    priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;h1,h2;</span><br><span class="line">    ll v,tag1,tag2;</span><br><span class="line">    <span class="built_in">Heap</span>() : <span class="built_in">v</span>(<span class="number">-1</span>),<span class="built_in">tag1</span>(<span class="number">0</span>),<span class="built_in">tag2</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> h1.<span class="built_in">size</span>()+h2.<span class="built_in">size</span>()+(v!=<span class="number">-1</span>);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1.<span class="built_in">size</span>()&lt;k/<span class="number">2</span>)<span class="keyword">return</span> h1.<span class="built_in">push</span>(val-tag1);</span><br><span class="line">        <span class="keyword">if</span>(val&gt;h1.<span class="built_in">top</span>()+tag1)</span><br><span class="line">        &#123;</span><br><span class="line">            ll ne=h1.<span class="built_in">top</span>()+tag1;</span><br><span class="line">            <span class="keyword">return</span> h1.<span class="built_in">pop</span>(),h1.<span class="built_in">push</span>(val-tag1),<span class="built_in">add</span>(ne);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((k&amp;<span class="number">1</span>)&amp;&amp;v==<span class="number">-1</span>)<span class="keyword">return</span> v=val,<span class="built_in">void</span>();</span><br><span class="line">        <span class="keyword">if</span>((k&amp;<span class="number">1</span>)&amp;&amp;val&gt;v)</span><br><span class="line">        &#123;</span><br><span class="line">            ll ne=v;</span><br><span class="line">            <span class="keyword">return</span> v=val,<span class="built_in">add</span>(ne);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(h2.<span class="built_in">size</span>()&lt;k/<span class="number">2</span>)<span class="keyword">return</span> h2.<span class="built_in">push</span>(val-tag2);</span><br><span class="line">        <span class="keyword">if</span>(val&gt;h2.<span class="built_in">top</span>()+tag2)h2.<span class="built_in">pop</span>(),h2.<span class="built_in">push</span>(val-tag2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(Heap &amp;x,Heap &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.<span class="built_in">size</span>()&lt;y.<span class="built_in">size</span>())<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">while</span>(!y.h1.<span class="built_in">empty</span>())x.<span class="built_in">add</span>(y.h1.<span class="built_in">top</span>()+y.tag1),y.h1.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span>(!y.h2.<span class="built_in">empty</span>())x.<span class="built_in">add</span>(y.h2.<span class="built_in">top</span>()+y.tag2),y.h2.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(~y.v)x.<span class="built_in">add</span>(y.v),y.v=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x].<span class="built_in">add</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        f[y].tag1+=e[i]&lt;&lt;<span class="number">1</span>,f[y].tag2-=e[i]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">merge</span>(f[x],f[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,w;i&lt;n;i++)<span class="built_in">read</span>(u,v,w),<span class="built_in">add</span>(u,v,w),<span class="built_in">add</span>(v,u,w);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!f[<span class="number">1</span>].h1.<span class="built_in">empty</span>())ans+=f[<span class="number">1</span>].h1.<span class="built_in">top</span>(),f[<span class="number">1</span>].h1.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span>(!f[<span class="number">1</span>].h2.<span class="built_in">empty</span>())ans+=f[<span class="number">1</span>].h2.<span class="built_in">top</span>(),f[<span class="number">1</span>].h2.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>((k&amp;<span class="number">1</span>)&amp;&amp;(~f[<span class="number">1</span>].v))ans+=f[<span class="number">1</span>].v,f[<span class="number">1</span>].v=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="comment">// T=1;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>还有 mydcwfy 的贪心解法，此处简述。我们每次贪心选取贡献最大的点。具体来讲，未选的点都被视为在根节点，并且维护在该点到根节点上链的贡献之和。过程中需要维护点到根节点的各条边上的贡献系数是 $1$ 还是 $-1$。具体以 $\lfloor \frac{k}{2}\rfloor$ 作为分界，该边被贡献 $\le \lfloor \frac{k}{2}\rfloor$ 次，那么贡献还是 $1$，超过就将其变为 $-1$。这个可以用树链剖分维护。正确性可以调整法证明，但是给人感觉就是很对。</p>
<p>总的时间复杂度为 $\mathcal O(n\log^2 n)$。贴一份巨佬 mydcwfy 的代码qwq。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> LL INF = <span class="number">1e17</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N &lt;&lt; <span class="number">1</span>], ne[N &lt;&lt; <span class="number">1</span>], w[N &lt;&lt; <span class="number">1</span>], idx;</span><br><span class="line"><span class="type">int</span> n, k, added, delst, fw[N], fa[N];</span><br><span class="line"><span class="type">int</span> dfn[N], sz[N], nw[N], top[N], dep[N], son[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sgt1</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> l, r, id;</span><br><span class="line">        LL lt, mx;</span><br><span class="line">    &#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[x &lt;&lt; <span class="number">1</span>].mx &gt; tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx)</span><br><span class="line">            tr[x].mx = tr[x &lt;&lt; <span class="number">1</span>].mx, tr[x].id = tr[x &lt;&lt; <span class="number">1</span>].id;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tr[x].mx = tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx, tr[x].id = tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x] = &#123;l, r, l, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, LL c)</span> </span>&#123; tr[x].mx += c, tr[x].lt += c; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tr[x].lt) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, tr[x].lt), <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[x].lt);</span><br><span class="line">        tr[x].lt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, LL c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r) <span class="keyword">return</span> <span class="built_in">update</span>(x, c);</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span>, l, r, c), <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, c);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; seg1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sgt2</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> l, r, mx, mn, lt;</span><br><span class="line">    &#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        tr[x].mx = std::<span class="built_in">max</span>(tr[x &lt;&lt; <span class="number">1</span>].mx, tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx);</span><br><span class="line">        tr[x].mn = std::<span class="built_in">min</span>(tr[x &lt;&lt; <span class="number">1</span>].mn, tr[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span> </span>&#123; tr[x].lt += c, tr[x].mx += c, tr[x].mn += c; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tr[x].lt) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span>, tr[x].lt), <span class="built_in">update</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[x].lt);</span><br><span class="line">        tr[x].lt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l &gt; r || tr[x].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l &gt;= l &amp;&amp; tr[x].r &lt;= r &amp;&amp; (tr[x].mn &gt;= delst || tr[x].mx + c &lt;= added))</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">update</span>(x, c);</span><br><span class="line">        <span class="keyword">if</span> (tr[x].l == tr[x].r) &#123;</span><br><span class="line">            <span class="type">int</span> to = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr[x].mn &lt;= added) to --;</span><br><span class="line">            <span class="keyword">if</span> (tr[x].mn + c &lt;= added) to ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tr[x].mn + c &gt;= delst) to --;</span><br><span class="line">            <span class="built_in">update</span>(x, c);</span><br><span class="line">            seg1.<span class="built_in">modify</span>(<span class="number">1</span>, tr[x].l, tr[x].l + sz[nw[tr[x].l]] - <span class="number">1</span>, to * fw[nw[tr[x].l]]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span>, l, r, c), <span class="built_in">modify</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, c);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; seg2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">chkmax</span><span class="params">(T &amp;x, T y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ? x = y, <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz[x] = <span class="number">1</span>, ::fa[x] = fa, dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x], v; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((v = e[i]) == fa) <span class="keyword">continue</span>;</span><br><span class="line">        fw[v] = w[i], <span class="built_in">dfs1</span>(v, x);</span><br><span class="line">        <span class="keyword">if</span> (sz[v] &gt; sz[son[x]]) son[x] = v;</span><br><span class="line">        sz[x] += sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> tp = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x] = tp, nw[dfn[x] = ++ *dfn] = x;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], tp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x], v; ~i; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> ((v = e[i]) != fa[x] &amp;&amp; v != son[x]) <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x) seg2.<span class="built_in">modify</span>(<span class="number">1</span>, dfn[top[x]], dfn[x], <span class="number">1</span>), x = fa[top[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) h[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>), <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    added = k / <span class="number">2</span> - <span class="number">1</span>, delst = (k + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    seg1.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n), seg2.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        seg1.<span class="built_in">modify</span>(<span class="number">1</span>, dfn[i], dfn[i] + sz[i] - <span class="number">1</span>, fw[i]);</span><br><span class="line">    <span class="comment">/*for (int i = 1; i &lt;= n; ++ i) printf(&quot;%d &quot;, sz[i]);</span></span><br><span class="line"><span class="comment">    puts(&quot;&quot;);*/</span></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k --) &#123;</span><br><span class="line">        <span class="type">int</span> cur = nw[seg1.tr[<span class="number">1</span>].id];</span><br><span class="line">        res += seg1.tr[<span class="number">1</span>].mx;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; seg1.tr[1].id &lt;&lt; &#x27; &#x27; &lt;&lt; seg1.tr[1].mx &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">        seg1.<span class="built_in">modify</span>(<span class="number">1</span>, dfn[cur], dfn[cur], -INF), <span class="built_in">update</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; res * <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>堆</tag>
        <tag>平衡树</tag>
        <tag>启发式合并</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC040E] Prefix Suffix Addition</title>
    <url>/2023/07/20/AGC040E-Prefix-Suffix-Addition/</url>
    <content><![CDATA[<p>DP 优化：将分界点作为状态。</p>
<span id="more"></span>
<p>先考虑只有操作一的情况，那么我们每次能够消除一个差分为负的位置，答案为 $\sum_i [x_i&gt;x_{i+1}]$。操作二与操作以类似并且对称，于是还是从这一方面入手。设操作一位置 $i$ 加上了 $y_i$，那么答案为：</p>
<script type="math/tex; mode=display">
\sum_{i}[y_{i-1}>y_i]+[x_{i-1}-y_{i-1}<x_i-y_i]</script><p>相当于求出一个序列 $y$，使得最小化上式值。于是我们考虑朴素 DP，设 $f(i,j)$ 表示填到 $i$，第 $i$ 位填 $j$ 的最小值。 暴力转移即可得到 $\mathcal O(nV)$ 的做法。观察该 DP 的性质，得到：</p>
<p>性质 $1$ : $f(i,x)$ 单调不减。因为随着 $y_i$ 增大，转移代价不增。</p>
<p>性质 $2$：$\displaystyle \max_x f(i,x)-\min_x f(i,x)\le 2$。考虑找到 $\displaystyle \min_x f(i-1,x)$，向 $i$ 转移代价不大于 $2$。</p>
<p>那么每一层不同的答案不超过 $3$，并且单调递增。于是我们只需要记录状态的分界点的答案与位置即可。时间复杂度 $\mathcal O(n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,x,y,f,p0,p1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)p1=<span class="built_in">max</span>(p1,p0+x-y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p1=<span class="built_in">max</span>(p0,p1+x-y),p0+=x-y;</span><br><span class="line">            <span class="keyword">if</span>(p0&lt;<span class="number">0</span>)f++,p0=p1,p1=x;</span><br><span class="line">        &#125;</span><br><span class="line">        p0=<span class="built_in">min</span>(p0,y=x),p1=<span class="built_in">min</span>(p1,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f+(p0&lt;x));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC024E] Sequence Growing Hard</title>
    <url>/2023/07/24/AGC024E-Sequence-Growing-Hard/</url>
    <content><![CDATA[<p>巧妙地转换为数树的问题，但也可以从序列角度理解。</p>
<span id="more"></span>
<p>视作每次加入一个数，要求序列字典序单调递增。考虑合法的充要条件，我们先在末尾插入一个 $0$ 将插在末尾转化为下面的情况，设插入的数为 $x$，容易发现需满足二者之一：1.$v$ 为 $x$ 的下一个数，满足 $x&lt;v$；2.$v$ 为 $x$ 之后不与 $x$ 相等的第一个数，满足 $x&lt;v$。但二者只需条件 1 即可，因为满足条件 2 的序列必然与某一个满足条件 1 的序列重复（将 $x$ 插在与 $x$ 相等的段的末尾即可得到一个满足条件 1 的序列），这样就直接去重了。</p>
<p>考虑转化，每次操作从 $x$ 向 $v$ 连边，那么我们可以得到一颗树，二者构成双射。其中父亲权值大于儿子权值。设 $f(v,s)$ 为当根节点权值为 $v$，子树大小为 $s$ 时的方案数。转移每次考虑在左边插入一个子树，得到：</p>
<script type="math/tex; mode=display">
f(v,s)=\sum_{i=1}^{s-1} f(v,s-i)\times\binom{s-2}{i-1} \sum_{p>v} f(p,i)</script><p>如何从序列角度理解？相当于按照真正的操作顺序从后往前，钦定序列的末尾，转移相当于每次加入一个之前的操作。</p>
<p>时间复杂度 $\mathcal O(n^2m)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,mod;</span><br><span class="line"><span class="type">int</span> C[N][N],f[N][N],sum[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;mod);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            C[i][j]=<span class="built_in">adj</span>(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;~i;i--)sum[i][<span class="number">1</span>]=sum[i+<span class="number">1</span>][<span class="number">1</span>]+(f[i][<span class="number">1</span>]=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;~i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;sum[i][j]=<span class="built_in">adj</span>(sum[i+<span class="number">1</span>][j]+f[i][j]),j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=j<span class="number">-1</span>;k++)</span><br><span class="line">                f[i][j]=<span class="built_in">adj</span>(f[i][j]+<span class="number">1ll</span>*f[i][j-k]*C[j<span class="number">-2</span>][k<span class="number">-1</span>]%mod*sum[i+<span class="number">1</span>][k]%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">0</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1368H2 Breadboard Capacity (hard version)</title>
    <url>/2023/07/19/CF1368H2-Breadboard-Capacity-hard-version/</url>
    <content><![CDATA[<p>有趣的 DP 题，用到模拟网络流的技巧。</p>
<span id="more"></span>
<p>首先考虑简单版 <a href="https://codeforces.com/contest/1368/problem/H1">CF1368H1 Breadboard Capacity (easy version)</a>。容易发现是个网络流模型：对于边缘，将源点 $S$ 连向所有蓝色点，所有红色点连向汇点 $T$；对于其它点，直接按照四联通连边。那么最大流就是答案。$n,m\le 10^5$，暴力做是不行的，我们不妨转化为求最小割。那么在这种类棋盘状的图上，我们容易想到转化为对偶图来求解。显然我们只用考虑一个方向的答案即可，另一个方向是类似的。下面我们考虑竖直方向的答案。</p>
<p>不过最小割形成的路径显然可以不止一条。我们可以发现，通过一定调整，除了在边界上，其余部分的割形如一条直线。。而边上的贡献是一定会被算的。对割开的的连通块中所有点染成黑色或白色，每一行的颜色是一样的。那么对于每一行进行 DP，不同颜色行之间的转移就需要加上一段割形成的路径，其余贡献只与两边的颜色有关，那么简单 DP 即可求出。时间复杂度 $\mathcal O(n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Easy version<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">char</span> L[N],R[N],U[N],D[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m,<span class="type">char</span> *L,<span class="type">char</span> *R,<span class="type">char</span> *U,<span class="type">char</span> *D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)f[<span class="number">0</span>][<span class="number">0</span>]+=(U[i]==<span class="string">&#x27;R&#x27;</span>),f[<span class="number">0</span>][<span class="number">1</span>]+=(U[i]==<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=<span class="built_in">min</span>(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>]+m)+(L[i]==<span class="string">&#x27;R&#x27;</span>)+(R[i]==<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">        f[i][<span class="number">1</span>]=<span class="built_in">min</span>(f[i<span class="number">-1</span>][<span class="number">1</span>],f[i<span class="number">-1</span>][<span class="number">0</span>]+m)+(L[i]==<span class="string">&#x27;B&#x27;</span>)+(R[i]==<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)f[n][<span class="number">0</span>]+=(D[i]==<span class="string">&#x27;R&#x27;</span>),f[n][<span class="number">1</span>]+=(D[i]==<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(f[n][<span class="number">0</span>],f[n][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %s %s %s %s&quot;</span>,&amp;n,&amp;m,&amp;q,L+<span class="number">1</span>,R+<span class="number">1</span>,U+<span class="number">1</span>,D+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">min</span>(<span class="built_in">solve</span>(n,m,L,R,U,D),<span class="built_in">solve</span>(m,n,U,D,L,R)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>接着考虑进阶版 <a href="https://codeforces.com/contest/1368/problem/H2">CF1368H2 Breadboard Capacity (easy version)</a>。多了修改操作。这个转移显然可以使用矩阵简单表示。那么问题是需要支持区间颜色翻转操作，并且只有一边的。但是我们转移与两边颜色都有关系。所以我们需要额外处理，翻转了某一边的答案，修改时直接交换即可。时间复杂度 $\mathcal O(n\log n+q\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Hard version<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">char</span> sL[N],sR[N],sU[N],sD[N];</span><br><span class="line"><span class="type">int</span> L[N],R[N],U[N],D[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ckmin</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x=(x&lt;y)?x:y;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>(): a&#123;&#123;INF,INF&#125;,&#123;INF,INF&#125;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; <span class="keyword">operator</span> [](<span class="type">int</span> x)&#123;<span class="keyword">return</span> a[x];&#125;</span><br><span class="line">    <span class="type">const</span> Matrix <span class="keyword">operator</span>*(Matrix &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix res;</span><br><span class="line">        <span class="built_in">ckmin</span>(res[<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">min</span>(a[<span class="number">0</span>][<span class="number">0</span>]+t[<span class="number">0</span>][<span class="number">0</span>],a[<span class="number">0</span>][<span class="number">1</span>]+t[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">ckmin</span>(res[<span class="number">0</span>][<span class="number">1</span>],<span class="built_in">min</span>(a[<span class="number">0</span>][<span class="number">0</span>]+t[<span class="number">0</span>][<span class="number">1</span>],a[<span class="number">0</span>][<span class="number">1</span>]+t[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">        <span class="built_in">ckmin</span>(res[<span class="number">1</span>][<span class="number">0</span>],<span class="built_in">min</span>(a[<span class="number">1</span>][<span class="number">0</span>]+t[<span class="number">0</span>][<span class="number">0</span>],a[<span class="number">1</span>][<span class="number">1</span>]+t[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">ckmin</span>(res[<span class="number">1</span>][<span class="number">1</span>],<span class="built_in">min</span>(a[<span class="number">1</span>][<span class="number">0</span>]+t[<span class="number">0</span>][<span class="number">1</span>],a[<span class="number">1</span>][<span class="number">1</span>]+t[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[<span class="number">1</span>][<span class="number">0</span>]=(a[<span class="number">0</span>][<span class="number">0</span>]=x)+y,a[<span class="number">0</span>][<span class="number">1</span>]=(a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">2</span>-x)+y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        Matrix v[<span class="number">4</span>];</span><br><span class="line">        <span class="type">int</span> c1,c2;</span><br><span class="line">        <span class="type">bool</span> tag1,tag2;</span><br><span class="line">    &#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)tr[x].v[i]=tr[x&lt;&lt;<span class="number">1</span>].v[i]*tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[i];</span><br><span class="line">        tr[x].c1=tr[x&lt;&lt;<span class="number">1</span>].c1+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].c1;</span><br><span class="line">        tr[x].c2=tr[x&lt;&lt;<span class="number">1</span>].c2+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].c2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(tr[x].v[<span class="number">0</span>],tr[x].v[<span class="number">1</span>]),<span class="built_in">swap</span>(tr[x].v[<span class="number">2</span>],tr[x].v[<span class="number">3</span>]);</span><br><span class="line">        tr[x].c1=tr[x].r-tr[x].l+<span class="number">1</span>-tr[x].c1;</span><br><span class="line">        tr[x].tag1^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(tr[x].v[<span class="number">0</span>],tr[x].v[<span class="number">2</span>]),<span class="built_in">swap</span>(tr[x].v[<span class="number">1</span>],tr[x].v[<span class="number">3</span>]);</span><br><span class="line">        tr[x].c2=tr[x].r-tr[x].l+<span class="number">1</span>-tr[x].c2;</span><br><span class="line">        tr[x].tag2^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].tag1)<span class="built_in">update1</span>(x&lt;&lt;<span class="number">1</span>),<span class="built_in">update1</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>),tr[x].tag1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].tag2)<span class="built_in">update2</span>(x&lt;&lt;<span class="number">1</span>),<span class="built_in">update2</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>),tr[x].tag2=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x].l=l,tr[x].r=r,tr[x].tag1=tr[x].tag2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[x].c1=a[l],tr[x].c2=b[l];</span><br><span class="line">            tr[x].v[<span class="number">0</span>].<span class="built_in">get</span>(a[l]+b[l],m),tr[x].v[<span class="number">1</span>].<span class="built_in">get</span>(!a[l]+b[l],m),</span><br><span class="line">            tr[x].v[<span class="number">2</span>].<span class="built_in">get</span>(a[l]+!b[l],m),tr[x].v[<span class="number">3</span>].<span class="built_in">get</span>(!a[l]+!b[l],m);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid,a,b,m),<span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,a,b,m);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flip1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=tr[x].l&amp;&amp;tr[x].r&lt;=r)<span class="keyword">return</span> <span class="built_in">update1</span>(x);</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">flip1</span>(x&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">flip1</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flip2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=tr[x].l&amp;&amp;tr[x].r&lt;=r)<span class="keyword">return</span> <span class="built_in">update2</span>(x);</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">flip2</span>(x&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">flip2</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=INF;</span><br><span class="line">    <span class="built_in">ckmin</span>(res,t[<span class="number">0</span>].tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]+t[<span class="number">1</span>].tr[<span class="number">1</span>].c1+t[<span class="number">1</span>].tr[<span class="number">1</span>].c2);</span><br><span class="line">    <span class="built_in">ckmin</span>(res,t[<span class="number">0</span>].tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]+t[<span class="number">1</span>].tr[<span class="number">1</span>].c1+(m-t[<span class="number">1</span>].tr[<span class="number">1</span>].c2));</span><br><span class="line">    <span class="built_in">ckmin</span>(res,t[<span class="number">0</span>].tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]+(m-t[<span class="number">1</span>].tr[<span class="number">1</span>].c1)+t[<span class="number">1</span>].tr[<span class="number">1</span>].c2);</span><br><span class="line">    <span class="built_in">ckmin</span>(res,t[<span class="number">0</span>].tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]+(m-t[<span class="number">1</span>].tr[<span class="number">1</span>].c1)+(m-t[<span class="number">1</span>].tr[<span class="number">1</span>].c2));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ckmin</span>(res,t[<span class="number">1</span>].tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]+t[<span class="number">0</span>].tr[<span class="number">1</span>].c1+t[<span class="number">0</span>].tr[<span class="number">1</span>].c2);</span><br><span class="line">    <span class="built_in">ckmin</span>(res,t[<span class="number">1</span>].tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]+t[<span class="number">0</span>].tr[<span class="number">1</span>].c1+(n-t[<span class="number">0</span>].tr[<span class="number">1</span>].c2));</span><br><span class="line">    <span class="built_in">ckmin</span>(res,t[<span class="number">1</span>].tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]+(n-t[<span class="number">0</span>].tr[<span class="number">1</span>].c1)+t[<span class="number">0</span>].tr[<span class="number">1</span>].c2);</span><br><span class="line">    <span class="built_in">ckmin</span>(res,t[<span class="number">1</span>].tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]+(n-t[<span class="number">0</span>].tr[<span class="number">1</span>].c1)+(n-t[<span class="number">0</span>].tr[<span class="number">1</span>].c2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %s %s %s&quot;</span>,sL+<span class="number">1</span>,sR+<span class="number">1</span>,sU+<span class="number">1</span>,sD+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)L[i]=(sL[i]==<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)R[i]=(sR[i]==<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)U[i]=(sU[i]==<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)D[i]=(sD[i]==<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">    t[<span class="number">0</span>].<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n,L,R,m),t[<span class="number">1</span>].<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m,U,D,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">calc</span>());</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;L&#x27;</span>)t[<span class="number">0</span>].<span class="built_in">flip1</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>)t[<span class="number">0</span>].<span class="built_in">flip2</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;U&#x27;</span>)t[<span class="number">1</span>].<span class="built_in">flip1</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        <span class="keyword">else</span> t[<span class="number">1</span>].<span class="built_in">flip2</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">calc</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>线段树</tag>
        <tag>网络流</tag>
        <tag>动态DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1458D Flip and Reverse</title>
    <url>/2023/07/18/CF1458D-Flip-and-Reverse/</url>
    <content><![CDATA[<p>巧妙的转化为欧拉路径。</p>
<span id="more"></span>
<p>将 <code>0</code> 视作 $-1$，将 <code>1</code> 视作 $+1$，转化为前缀和 $s_i$。操作 $[l,r]$ 的条件为 $s_{l-1}=s_r$。尝试研究操作的本质，容易发现就是对于 $[l-1,r]$ 的的前缀和的 <code>reverse</code> 操作。</p>
<p>对于前缀和 $s_i$ 对应的点建 $s_i\to s_{i+1}$ 这条边，而原字符串相当于一条欧拉路径。操作就相当于找到一个环，将上面的边反向。但实际上边集是不会变的，因为只有相邻的 $s_i$ 之间才会连边，所以环一定是若干个二元环拼起来的。更进一步的，我们发现，所有的可能的字符串，对应的图都是一样的，而图也对应所有可能的字符串。因为对于两条不同的欧拉路径，中间不同部分我们一定可以通过操作将其变为相同。所以问题转化为求字典序最小的欧拉路径。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> e[N&lt;&lt;<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> x=N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            e[x][s[i]-<span class="string">&#x27;0&#x27;</span>]++,x+=(s[i]==<span class="string">&#x27;0&#x27;</span>?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">        x=N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e[x][<span class="number">0</span>]&amp;&amp;e[x<span class="number">-1</span>][<span class="number">1</span>])e[x][<span class="number">0</span>]--,x--,<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(e[x][<span class="number">1</span>])e[x][<span class="number">1</span>]--,x++,<span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> e[x][<span class="number">0</span>]--,x--,<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title>CF319E Ping-Pong</title>
    <url>/2023/07/23/CF319E-Ping-Pong/</url>
    <content><![CDATA[<p>线段树应用。</p>
<span id="more"></span>
<p>不相交的区间不能互相到达，包含的区间只能从小区间向大区间走，相交但不包含的区间都可以走。我们考虑用并查集把所有的相交但不包含的区间合并起来，视为同一个连通块，合并后对应着一个等效区间 $[\min_{i\in S} l_i,\max_{i\in S} r_i]$。那么判定条件就是，是否为同一个连通块，或者等效区间是否存在包含关系（那么该连通块中必然存在一个区间包含当前区间）。</p>
<p>那么我们相当于每次需要找到所有与当前区间有交的区间。需要注意到题面给出的“所有区间长度单调递增”。我们利用线段树，把当前区间的端点与经过的区间合并，这样合并的区间必然与当前区间相交，再打上该节点的 <code>tag</code> 作为代表。再把区间中除了端点所有位置打上 <code>tag</code> 即可。</p>
<p>注意体面中给的条件是小于号而非小于等于号，可能需要一些细节。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Interval</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">const</span> Interval <span class="keyword">operator</span>+(<span class="type">const</span> Interval &amp;t)<span class="type">const</span>&#123;<span class="keyword">return</span> (Interval)&#123;<span class="built_in">min</span>(l,t.l),<span class="built_in">max</span>(r,t.r)&#125;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,tot;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="type">int</span> op[N],x[N],y[N];</span><br><span class="line"><span class="type">int</span> c[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">Interval a[N],val[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> ;</span><br><span class="line">    val[x]=val[x]+val[y],fa[y]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;tag;</span><br><span class="line">    &#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;tr[x].tag.<span class="built_in">push_back</span>(k);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x].l=l,tr[x].r=r;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[x].tag.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:tr[x].tag)<span class="built_in">merge</span>(i,k);</span><br><span class="line">            tr[x].tag.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="built_in">update</span>(x,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].l==tr[x].r)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">get</span>(x&lt;&lt;<span class="number">1</span>,pos,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">get</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tag</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=tr[x].l&amp;&amp;r&gt;=tr[x].r)<span class="keyword">return</span> <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">tag</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">tag</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(op[i],x[i],y[i]);</span><br><span class="line">        <span class="keyword">if</span>(op[i]==<span class="number">1</span>)c[++m]=x[i],c[++m]=y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+m);</span><br><span class="line">    m=<span class="built_in">unique</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+m)-c<span class="number">-1</span>;</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(op[i]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x[i]=<span class="built_in">lower_bound</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+m,x[i])-c;</span><br><span class="line">            y[i]=<span class="built_in">lower_bound</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+m,y[i])-c;</span><br><span class="line">            tot++;</span><br><span class="line">            fa[tot]=tot;</span><br><span class="line">            val[tot]=a[tot]=&#123;x[i],y[i]&#125;;</span><br><span class="line">            t.<span class="built_in">get</span>(<span class="number">1</span>,x[i],tot),t.<span class="built_in">get</span>(<span class="number">1</span>,y[i],tot);</span><br><span class="line">            <span class="keyword">if</span>(x[i]+<span class="number">1</span>&lt;=y[i]<span class="number">-1</span>)t.<span class="built_in">tag</span>(<span class="number">1</span>,x[i]+<span class="number">1</span>,y[i]<span class="number">-1</span>,tot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u=<span class="built_in">find</span>(x[i]),v=<span class="built_in">find</span>(y[i]);</span><br><span class="line">            <span class="keyword">if</span>(u==v||(a[u].l&gt;val[v].l&amp;&amp;a[u].r&lt;=val[v].r)||(a[u].l&gt;=val[v].l&amp;&amp;a[u].r&lt;val[v].r))<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P6109 [Ynoi2009] rprmq1</title>
    <url>/2023/07/17/P6109-Ynoi2009-rprmq1/</url>
    <content><![CDATA[<p>线段树 + 猫树分治</p>
<span id="more"></span>
<p>修改均在询问之前，相当于没有时间轴，于是是离线下来。但是二维我们还是不好做，考虑将 $x$ 这一维看作时间轴，只考虑 $y$ 这一维的答案。我们考虑类似扫描线的过程，将修改操作拆成 $(l_x,l_y,r_y,x),(r_x+1,l_y,r_y,-x)$。那么询问就变成了 $[l_x,r_x]$ 这段时间内最值的查询。但是仍然不好处理，因为最值查询不满足可减性。</p>
<p>但是其满足快速合并的性质，容易想到对 $x$ 这一维进行猫树分治，过程中用历史最值线段树维护。</p>
<p>每次将跨过中点的询问按照中点分开，向两边扩展，在本层处理并合并答案；否则下放到分治的下一层处理。</p>
<p>而对于修改操作，假设当前求 $[l,mid]$ 的答案，我们对于另一半 $[mid+1,r]$ 的修改全部加入（但是不更新历史最值），再进行扫描线加入 $[l,mid]$ 的修改，并且处理询问。需要注意的是要先处理右端点的修改，否则历史最值可能会出错。</p>
<p>每个修改操作在每一层都会被执行一次，而每个查询只会被执行一次，所以时间复杂度为 $\mathcal O(m\log^2 n+q\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>,M=<span class="number">5e4</span>+<span class="number">10</span>,Q=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e18</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> pos;</span><br><span class="line">ll ans[Q];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Modify</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t,l,r,x;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Modify &amp;e)<span class="type">const</span>&#123;<span class="keyword">if</span>(t!=e.t)<span class="keyword">return</span> t&lt;e.t;<span class="keyword">return</span> x&lt;e.x;&#125; </span><br><span class="line">&#125;a[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id,tl,tr,l,r;</span><br><span class="line">&#125;b[Q];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll v,vh;</span><br><span class="line">    ll a,ah;</span><br><span class="line">    <span class="type">bool</span> s;</span><br><span class="line">    ll tag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span></span><br><span class="line">&#123;</span><br><span class="line">    Node tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x].v=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v);</span><br><span class="line">        tr[x].vh=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].vh,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].vh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x].l=l,tr[x].r=r;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k,ll kh)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x].vh=<span class="built_in">max</span>(tr[x].vh,tr[x].v+kh),tr[x].v+=k;</span><br><span class="line">        tr[x].ah=<span class="built_in">max</span>(tr[x].ah,tr[x].a+kh),tr[x].a+=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x].vh=(tr[x].v+=k);</span><br><span class="line">        tr[x].tag+=tr[x].a+k,tr[x].s=<span class="number">1</span>;</span><br><span class="line">        tr[x].a=tr[x].ah=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].s)<span class="built_in">set</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag),<span class="built_in">set</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag),tr[x].s=<span class="number">0</span>,tr[x].tag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].a||tr[x].ah)<span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].a,tr[x].ah),<span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].a,tr[x].ah),tr[x].a=tr[x].ah=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,ll k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=tr[x].l&amp;&amp;r&gt;=tr[x].r)<span class="keyword">return</span> <span class="built_in">update</span>(x,k,k);</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query_h</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=tr[x].l&amp;&amp;tr[x].r&lt;=r)<span class="keyword">return</span> tr[x].vh;</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ll res=-INF;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)res=<span class="built_in">max</span>(res,<span class="built_in">query_h</span>(x&lt;&lt;<span class="number">1</span>,l,r));</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)res=<span class="built_in">max</span>(res,<span class="built_in">query_h</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ckmax</span><span class="params">(ll &amp;x,ll y)</span></span>&#123;x=(x&gt;y)?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pos+<span class="number">1</span>&lt;=m&amp;&amp;a[pos+<span class="number">1</span>].t&lt;=x)pos++,t.<span class="built_in">modify</span>(<span class="number">1</span>,a[pos].l,a[pos].r,a[pos].x);</span><br><span class="line">    <span class="keyword">while</span>(pos&amp;&amp;a[pos].t&gt;x)t.<span class="built_in">modify</span>(<span class="number">1</span>,a[pos].l,a[pos].r,-a[pos].x),pos--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> lb,<span class="type">int</span> rb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,x=lb,y=rb;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lb;i&lt;=rb;i++)<span class="keyword">if</span>(b[i].tr&lt;mid)<span class="built_in">swap</span>(b[i],b[x++]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=rb;i&gt;=lb;i--)<span class="keyword">if</span>(b[i].tl&gt;mid)<span class="built_in">swap</span>(b[i],b[y--]);</span><br><span class="line">    <span class="built_in">solve</span>(l,mid<span class="number">-1</span>,lb,x<span class="number">-1</span>),<span class="built_in">solve</span>(mid+<span class="number">1</span>,r,y+<span class="number">1</span>,rb);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=y;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[b[i].tl].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(b[i].tr&gt;mid)p[b[i].tr].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">move</span>(mid),t.<span class="built_in">set</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&gt;=l;<span class="built_in">move</span>(--i))</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j:p[i])</span><br><span class="line">            <span class="built_in">ckmax</span>(ans[b[j].id],t.<span class="built_in">query_h</span>(<span class="number">1</span>,b[j].l,b[j].r));</span><br><span class="line">    <span class="built_in">move</span>(mid+<span class="number">1</span>),t.<span class="built_in">set</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=r;<span class="built_in">move</span>(++i))</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j:p[i])</span><br><span class="line">            <span class="built_in">ckmax</span>(ans[b[j].id],t.<span class="built_in">query_h</span>(<span class="number">1</span>,b[j].l,b[j].r));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)p[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tl,tr,l,r,x;</span><br><span class="line">        <span class="built_in">read</span>(tl,l,tr,r,x);</span><br><span class="line">        a[i]=&#123;tl,l,r,x&#125;,a[i+m]=&#123;tr+<span class="number">1</span>,l,r,-x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    m&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tl,tr,l,r;</span><br><span class="line">        <span class="built_in">read</span>(tl,l,tr,r);</span><br><span class="line">        b[i]=&#123;i,tl,tr,l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,n,<span class="number">1</span>,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>猫树分治</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3215. 「PA 2019」Muzyka pop</title>
    <url>/2023/07/23/LOJ-3215-%E3%80%8CPA-2019%E3%80%8DMuzyka-pop/</url>
    <content><![CDATA[<p>数位 DP 与 区间 DP 的结合</p>
<span id="more"></span>
<p>$\text{popcount}(x)$ 的贡献是很好拆开的，我们显然可以按照每一位进行 DP。但是还需要满足升序。我们尝试从低位向高位填，每一段的后面一段在当前位上加上 $1$，容易满足升序的限制。更进一步的，我们发现这个过程形如一个区间 DP，每次将当前位为 $0$ 的 $[l,mid]$ 与当前位为 $1$ 的 $[mid+1,r]$ 合并起来，贡献就是 $\sum_{i=1}^r a_i-\sum_{i=1}^{mid} a_i$。但还需要满足值域的限制，我们参照已往数位 DP 时的做法，设新的一维表示前面还未填的 $k-i$ 位是否将 $m$ 卡满。所以设计状态 $f(i,l,r,0/1)$ 意义如上，直接转移即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200</span>+<span class="number">10</span>,K=<span class="number">61</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll m;</span><br><span class="line">ll a[N];</span><br><span class="line">ll f[K+<span class="number">5</span>][N][N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ckmax</span><span class="params">(ll &amp;x,ll y)</span></span>&#123;x=x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]),a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)f[<span class="number">0</span>][i][i][<span class="number">0</span>]=f[<span class="number">0</span>][i][i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K;i++)<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n+<span class="number">1</span>;l++)f[i][l][l<span class="number">-1</span>][<span class="number">0</span>]=f[i][l][l<span class="number">-1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n;l++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r=l;r&lt;=n;r++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">                    <span class="keyword">if</span>(!(m&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>)&amp;&amp;t)f[i][l][r][t]=f[i<span class="number">-1</span>][l][r][t];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> k=l<span class="number">-1</span>;k&lt;=r;k++)<span class="built_in">ckmax</span>(f[i][l][r][t],f[i<span class="number">-1</span>][l][k][<span class="number">0</span>]+f[i<span class="number">-1</span>][k+<span class="number">1</span>][r][t]+a[r]-a[k]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[K][<span class="number">1</span>][n][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC001E] BBQ Hard</title>
    <url>/2023/07/25/AGC001E-BBQ-Hard/</url>
    <content><![CDATA[<p>组合意义简单题。</p>
<span id="more"></span>
<p>注意这个组合数的形式，我们显然可以转化为从 $(0,0$ 走到 $(n,m)$ 的方案数。$n$ 范围较大，但 $a_i,b_i$ 值域范围较小，我们考虑继续沿用这个思路。相当于求所有 $(-a_i,-b_i)$ 走到 $(a_j,b_j)$ 的方案数。我们可以 $\mathcal O(V^2)$ DP 求出，再用 $\mathcal O(n)$ 统计。注意需要减去 $i=j$ 的答案。</p>
 <details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,M=<span class="number">2e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> fac[N],ifac[N];</span><br><span class="line"><span class="type">int</span> f[M&lt;&lt;<span class="number">1</span>][M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)ifac[i<span class="number">-1</span>]=<span class="number">1ll</span>*ifac[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i],b[i]),f[M-a[i]][M-b[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M&lt;&lt;<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;M&lt;&lt;<span class="number">1</span>;j++)</span><br><span class="line">            f[i][j]=<span class="built_in">adj</span>(f[i][j]+<span class="built_in">adj</span>(f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>]));</span><br><span class="line">    <span class="built_in">init</span>(M&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ans=<span class="built_in">adj</span>(<span class="built_in">adj</span>(ans+f[M+a[i]][M+b[i]])+mod-<span class="built_in">C</span>(a[i]+b[i]&lt;&lt;<span class="number">1</span>,a[i]&lt;&lt;<span class="number">1</span>));  </span><br><span class="line">    ans=<span class="number">1ll</span>*ans*<span class="built_in">qpow</span>(<span class="number">2</span>)%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>组合意义</tag>
      </tags>
  </entry>
  <entry>
    <title>运气游戏</title>
    <url>/2023/07/26/%E8%BF%90%E6%B0%94%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="17a0a34b3d3bd762503c7974ed2bc73f7c6e658d791dac52573b2c955a591c4f">2fcc1830d6613e3737de56192d1002f2c6f8fcf1e7ed6e367fc43c08f550152b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Who is the lucky dog?</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3399. 「2020-2021 集训队作业」Communication Network</title>
    <url>/2023/07/26/LOJ-3399-%E3%80%8C2020-2021-%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A%E3%80%8DCommunication-Network/</url>
    <content><![CDATA[<p>组合意义妙妙题，也可以用容斥暴力处理。</p>
<span id="more"></span>
<p>太厉害了！！！</p>
<h3 id="暴力容斥"><a href="#暴力容斥" class="headerlink" title="暴力容斥"></a>暴力容斥</h3><p>设 $\displaystyle f(S)=|S|\cdot 2^{|S|}$，答案为 $\displaystyle \sum_{T_2}f(T_1\cap T_2)$。并集的限制似乎必须要枚举，我们考虑子集容斥得到：</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{T_2}\sum_{S\subseteq (T_1\cap T_2)}\sum_{T\subseteq S}(-1)^{|S|-|T|} |T|\cdot 2^{|T|}\notag\\
\end{align}</script><p>这里使用组合意义，我们直接枚举并集，贡献就是包含边集 $S$ 的生成树个数，设为 $g(S)$。进一步得到下面的式子，并进行推导：</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{S\subseteq T_1}g(S)\sum_{T\subseteq S}(-1)^{|S|-|T|} |T|\cdot 2^{|T|}\notag\\
=&\sum_{S\subseteq T_1}(-1)^{|S|}g(S)\sum_{T\subseteq S}(-1)^{|T|} |T|\cdot 2^{|T|}\notag\\
=&\sum_{S\subseteq T_1}(-1)^{|S|}g(S)\sum_{i=0}^{|S|}\binom{|S|}{i}(-2)^{i}\cdot i\notag\\
=&\sum_{S\subseteq T_1}(-1)^{|S|}g(S)\cdot |S|\sum_{i=1}^{|S|}\binom{|S|-1}{i-1}(-2)^{i}\notag\\
=&\sum_{S\subseteq T_1}(-1)^{|S|}g(S)\cdot (-2|S|)\sum_{i=0}^{|S|}\binom{|S|-1}{i}(-2)^{i}\notag\\
=&\sum_{S\subseteq T_1}(-1)^{|S|}g(S)\cdot (-2|S|)\cdot (-1)^{|S|-1}\notag\\
=&2\sum_{S\subseteq T_1}|S|\cdot g(S)\notag\\
\end{align}</script><p>根据 Prufer 序列经典结论：$\displaystyle g(S)=n^{k-2}\prod_{i=1}^{k} a_i$，其中 $k$ 为连通块个数，$a_i$ 为连通块大小。这有比较显然的组合意义，$k-2$ 等于删去的边减一，可以看成每条删去的边使答案乘 $n$，最后再将答案除以 $n$。那么 $\prod_{i=1}^{k} a_i$ 在每个连通块中选一个点的方案数。我们直接 DP 就好了。</p>
<h3 id="组合意义"><a href="#组合意义" class="headerlink" title="组合意义"></a>组合意义</h3><p>我们直接对 $n\cdot 2^n$ 使用组合意义，$n$ 相当于选一条边，$2^n$ 相当于选择一条公共边乘 $2$，但是这涉及到找出所有公共边的问题（直接处理的方式就是上面的容斥）。重新考虑其组合意桜流し义，可以看成 $2^n=(1+1)^n$，相当于选取一个公共边的子集。两部分合起来相当于钦定一条公共边，再钦定一些公共边。 我们会得到与上面一样的式子。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>容斥</tag>
        <tag>组合意义</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1278F Cards</title>
    <url>/2023/08/13/CF1278F-Cards/</url>
    <content><![CDATA[<p>利用组合意义 DP。或者利用斯特林数推式子可以做到更优。</p>
<span id="more"></span>
<p>注意到 $x^k$ 不好处理，我们容易想到进行转化。</p>
<h3 id="组合意义DP"><a href="#组合意义DP" class="headerlink" title="组合意义DP"></a>组合意义DP</h3><p>换一种思考方式，考虑 $x^k$ 的组合意义，即从第 $i$ 次王牌翻出王牌的方案所构成的集合中选 $k$ 次的方案数。 这只与不同的 $i$ 相关。我们可以通过 DP 求出 $s(x,y)$ 表示选了 $x$ 个，有 $y$ 种不同的 $i$ 的方案数，最后乘上 $\frac{1}{m^y}$ 的系数统计答案即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            s[i][j]=<span class="built_in">adj</span>(<span class="number">1ll</span>*j*s[i<span class="number">-1</span>][j]%mod+<span class="number">1ll</span>*s[i<span class="number">-1</span>][j<span class="number">-1</span>]*(n-j+<span class="number">1</span>)%mod);</span><br><span class="line">    m=<span class="built_in">qpow</span>(m);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,res=m;i&lt;=k;i++,res=<span class="number">1ll</span>*res*m%mod)</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*res*s[k][i]%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h3><p>注意到 $x^k$ 的形式，利用经典套路，即斯特林数数转下降幂的技巧进行处理。设 $p=\frac{1}{m},q=1-p$，将朴素的式子列出来，并进行推导：</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{i=0}^n \binom{n}{i}p^i q^{n-i}i^k\\
=&\sum_{i=0}^n \binom{n}{i}p^i q^{n-i}\sum_{j=0}^k {k \brace j}i^{\underline j}\notag\\
=&\sum_{j=0}^k {k \brace j}\sum_{i=0}^n \binom{n}{i}p^i q^{n-i}i^{\underline j}\notag\\
=&\sum_{j=0}^k{k \brace j} \cdot j!\sum_{i=0}^n \binom{i}{j}\binom{n}{i}p^i q^{n-i}\notag\\
=&\sum_{j=0}^k{k \brace j} \cdot n^{\underline j}\sum_{i=j}^n \binom{n-j}{i-j}p^i q^{n-i}\notag\\
=&\sum_{j=0}^k{k \brace j} \cdot n^{\underline j}\sum_{i=0}^{n-j} \binom{n-j}{i}p^{i+j} q^{n-j-i}\notag\\
=&\sum_{j=0}^k{k \brace j} \cdot n^{\underline j} p^j\sum_{i=0}^{n-j}\binom{n-j}{i}p^{i} q^{n-j-i}\notag\\
=&\sum_{j=0}^k{k \brace j} \cdot n^{\underline j} p^j\notag\\
\end{align}</script><p>暴力做是 $\mathcal O(k^2)$ 的。同一行斯特林数可以通过其通项公式 $\displaystyle {n \brace k}=\sum_{i=0}^n \frac{i^n}{i!}\frac{(-1)^{k-i}}{(k-i)!}$ 卷积计算，时间复杂度 $\mathcal O(k\log k)$。</p>
<p>考虑更优的做法，我们直接将通项公式带入其中， 再推一下：</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{j=0}^k{k \brace j} \cdot n^{\underline j} p^j\notag\\
=&\sum_{j=0}^k n^{\underline j} p^j\sum_{i=0}^k (-1)^{j-i} \frac{i^k}{i!(j-i)!}\notag\\
=&\sum_{j=0}^k j!\binom{n}{j} p^j\sum_{i=0}^k (-1)^{j-i}i^k \frac{1}{j!}\binom{j}{i}\notag\\
=&\sum_{j=0}^k p^j\sum_{i=0}^k (-1)^{j-i}i^k\binom{n}{j} \binom{j}{i}\notag\\
=&\sum_{j=0}^k p^j\sum_{i=0}^k (-1)^{j-i}i^k\binom{n-i}{j-i} \binom{n}{i}\notag\\
=&\sum_{i=0}^k i^k \binom{n}{i} \sum_{j=i}^k p^j(-1)^{j-i}\binom{n-i}{j-i}\notag\\
=&\sum_{i=0}^k i^k p^i \binom{n}{i} \sum_{j=0}^{k-i} (-p)^j \binom{n-i}{j}\notag\\

\end{align}</script><p>考虑求出 $\displaystyle \sum_{j=0}^{k-i} (-p)^j \binom{n-i}{j}$ 只与 $i$ 有关，考虑求出其通项公式。。设 $\displaystyle f(i)=\displaystyle \sum_{j=0}^{k-i} (-p)^j \binom{n-i}{j}$。暴力拆开组合数也可以，这里是构造出组合数递推的形式，即 $\displaystyle \binom{n-i}{j}=\binom{n-i-1}{j-1}+\binom{n-i-1}{j-1}$。那么 $\displaystyle f(i+1)=\sum_{j=0}^{k-i-1} (-p)^j \binom{n-i-1}{j}$，对其进行一些推导：</p>
<script type="math/tex; mode=display">
\begin{align}
-p\cdot f(i+1)&=-p\cdot \sum_{j=0}^{k-i-1} (-p)^j\binom{n-i-1}{j}\notag\\
&=\sum_{j=1}^{k-i} (-p)^{j}\binom{n-i-1}{j-1}\notag\\
&=\sum_{j=1}^{k-i-1} (-p)^{j}\binom{n-i-1}{j-1}+(-p)^{k-i}\binom{n-i-1}{k-i-1} \\

f(i+1)&=\sum_{j=0}^{k-i-1} (-p)^j\binom{n-i-1}{j}
\end{align}</script><p>$(2)$ 式与 $(3)$ 式相加得到：</p>
<script type="math/tex; mode=display">
\begin{align}
(1-p)\cdot f(i+1)
&=\sum_{j=1}^{k-i-1} (-p)^j(\binom{n-i-1}{j-1}+\binom{n-i-1}{j})+1+(-p)^{k-i}\binom{n-i-1}{k-i-1} \notag\\
&=\sum_{j=0}^{k-i-1} (-p)^j\binom{n-i}{j}+(-p)^{k-i}\binom{n-i-1}{k-i-1} \notag\\
&=\sum_{j=0}^{k-i} (-p)^j\binom{n-i}{j}-(-p)^{k-i}\binom{n-i}{k-i}+(-p)^{k-i}\binom{n-i-1}{k-i-1} \notag\\
&=f(i)-(-p)^{k-i}(\binom{n-i}{k-i}-\binom{n-i-1}{k-i-1}) \notag\\
&=f(i)-(-p)^{k-i}\binom{n-i-1}{k-i} \notag\\
\end{align}</script><p>所以得到最终的递推式：</p>
<script type="math/tex; mode=display">
f(i)=(1-p)\cdot f(i+1)+(-p)^{k-i}\binom{n-i-1}{k-i}</script><p>其边界为 $f(k)=1$。对于 $n\le k$ 的情况直接用 $(1)$ 式暴力计算即可。 总的时间复杂度可以做到 $\mathcal O(k)$。</p>
<p>注意需要特判 $m=1$ 的情况下，此时 $q=0$ 不存在逆元。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> cnt,prime[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> p,q,invp,invq;</span><br><span class="line"><span class="type">int</span> inv[N],pw[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pw[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[++cnt]=i;</span><br><span class="line">            pw[i]=<span class="built_in">qpow</span>(i,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;<span class="number">1ll</span>*i*prime[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            pw[i*prime[j]]=<span class="number">1ll</span>*pw[i]*pw[prime[j]]%mod;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j]))<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">qpow</span>(q,n),ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res=<span class="number">1ll</span>*res*(n-i+<span class="number">1</span>)%mod*inv[i]%mod*p%mod*invq%mod;</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*res*pw[i]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    f[k]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">-1</span>;i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        res=<span class="number">1ll</span>*res*(n-i<span class="number">-1</span>)%mod*inv[k-i]%mod*(mod-p)%mod;</span><br><span class="line">        f[i]=<span class="built_in">adj</span>(<span class="number">1ll</span>*(mod+<span class="number">1</span>-p)*f[i+<span class="number">1</span>]%mod+res);</span><br><span class="line">    &#125;</span><br><span class="line">    res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res=<span class="number">1ll</span>*res*(n-i+<span class="number">1</span>)%mod*inv[i]%mod*p%mod;</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*res*pw[i]%mod*f[i]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p=<span class="built_in">qpow</span>(invp);</span><br><span class="line">    q=mod+<span class="number">1</span>-p;</span><br><span class="line">    invq=<span class="built_in">qpow</span>(q);</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)inv[i]=<span class="number">1ll</span>*(mod-(mod/i))*inv[mod%i]%mod;</span><br><span class="line">    <span class="built_in">sieve</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;invp,&amp;k);</span><br><span class="line">    <span class="keyword">if</span>(invp==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">qpow</span>(n,k)),<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">prework</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=k)<span class="built_in">solve1</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title>P1654 OSU!</title>
    <url>/2023/08/11/P1654-OSU/</url>
    <content><![CDATA[<p>利用斯特林数转下降幂的技巧，再求期望。</p>
<span id="more"></span>
<p>单纯求 $x^3$ 的期望比较简单，两次差分即可。考虑加强一下，求 $x^m$ 的期望。用二项式定理拆开求每一项可以做到 $\mathcal O(nm^2)$。</p>
<p>还能做到更优吗？我们发现直接求 $x^m$ 的期望是非常困难的。考虑拆开，但不是用二项式定理，而是利用斯特林数转下降幂的技巧：</p>
<script type="math/tex; mode=display">
x^m=\sum_k^m {m\brace k} x^{\underline k}</script><p>对于每个 $k$ 求 $x^{\underline k}$ 的期望最后乘上系数得到答案。时间复杂度 $\mathcal O(m^2+nm)$。</p>
<p>实际上，还有一种办法避免求逆元，将 $x^{\underline  k}$ 转化为 $k!\binom{x}{k}$，即求 $\binom{x}{k}$ 的期望。过程中可以根据 $\binom{x}{k}=\binom {x-1}{k-1}+\binom{x-1}{k}$ 直接递推即可（二者本质上是一样的）。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">double</span> p,a[N],b[N];</span><br><span class="line"><span class="type">int</span> fac[M],s[N][M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    m=<span class="number">3</span>;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)fac[i]=fac[i<span class="number">-1</span>]*i;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            s[i][j]=s[i<span class="number">-1</span>][j<span class="number">-1</span>]+j*s[i<span class="number">-1</span>][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++,b[<span class="number">1</span>]+=(a[<span class="number">1</span>]=p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;<span class="number">1</span>;j--)a[j]+=a[j<span class="number">-1</span>],a[j]*=p,b[j]+=a[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)ans+=b[i]*fac[i]*s[m][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>期望</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1830E Bully Sort</title>
    <url>/2023/08/15/CF1830E-Bully-Sort/</url>
    <content><![CDATA[<p>经典的排序与逆序对之间的转化，以及一些性质的观察。</p>
<span id="more"></span>
<p>先不管修改，考虑每次操作时需要满足的条件。假设我们某一次要交换位置为 $i,j~(i&lt;j)$ 的两个数，那么位置 $[p_i+1,n]$ 必然已经排好序（否则会先选择 $[p_i+1,n]$ 中的数进行操作），并且满足 $p_j\le i$（否则数 $[1,i]$ 中的数必然存在一个在位置 $i$ 之后）。</p>
<p>那么问题就变得简单了，位置 $[i,j]$ 之间的数均满足 $p_j&lt;x&lt;p_i$。设 $d=j-i$，那么逆序对会减少 $2d-1$，$\sum_i |p_i-i|$ 会减少 $2d$。</p>
<p>所以答案就是 $\sum_i |p_i-i|-\sum_{i&lt;j}[p_j&lt;p_i]$，前半部分容易维护，后半部分是动态逆序对，用三维偏序解决。</p>
<p>时间复杂度 $\mathcal O((n+q)\log^2n)$。</p>
<p>感觉我写的很鬼畜，随便看看就行了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,M=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">int</span> a[N],t[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Op</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t,p,x,y;</span><br><span class="line">&#125;q[N+(M&lt;&lt;<span class="number">2</span>)],w[N+(M&lt;&lt;<span class="number">2</span>)];</span><br><span class="line">ll res[M],ans[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))t[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x))res+=t[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">solve</span>(l,mid),<span class="built_in">solve</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;\nl,r : &quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;mid&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>,k=l;</span><br><span class="line">    <span class="keyword">auto</span> lm=[&amp;]()&#123;<span class="built_in">add</span>(q[i].x,q[i].y),w[k++]=q[i++];&#125;;</span><br><span class="line">    <span class="keyword">auto</span> mr=[&amp;]()&#123;ans[q[j].t]+=(<span class="built_in">ask</span>(n)-<span class="built_in">ask</span>(q[j].x))*q[j].y,w[k++]=q[j++];&#125;;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i].p&lt;=q[j].p)<span class="built_in">lm</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">mr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)<span class="built_in">lm</span>();</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)<span class="built_in">mr</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=mid;i++)<span class="built_in">add</span>(q[i].x,-q[i].y);</span><br><span class="line">    </span><br><span class="line">    i=mid,j=r;</span><br><span class="line">    <span class="keyword">auto</span> ml=[&amp;]()&#123;<span class="built_in">add</span>(q[i].x,q[i].y),i--;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> rm=[&amp;]()&#123;ans[q[j].t]+=<span class="built_in">ask</span>(q[j].x<span class="number">-1</span>)*q[j].y,j--;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=l&amp;&amp;j&gt;=mid+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i].p&gt;=q[j].p)<span class="built_in">ml</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">rm</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=l)<span class="built_in">ml</span>();</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=mid+<span class="number">1</span>)<span class="built_in">rm</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=mid;i++)<span class="built_in">add</span>(q[i].x,-q[i].y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)q[i]=w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]),q[++tot]=&#123;<span class="number">0</span>,i,a[i],<span class="number">1</span>&#125;,res[<span class="number">0</span>]+=<span class="built_in">abs</span>(a[i]-i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        res[i]=res[i<span class="number">-1</span>];</span><br><span class="line">        res[i]-=<span class="built_in">abs</span>(a[x]-x)+<span class="built_in">abs</span>(a[y]-y);</span><br><span class="line">        q[++tot]=&#123;i,x,a[x],<span class="number">-1</span>&#125;,q[++tot]=&#123;i,y,a[y],<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="built_in">swap</span>(a[x],a[y]);</span><br><span class="line">        res[i]+=<span class="built_in">abs</span>(a[x]-x)+<span class="built_in">abs</span>(a[y]-y);</span><br><span class="line">        q[++tot]=&#123;i,x,a[x],<span class="number">1</span>&#125;,q[++tot]=&#123;i,y,a[y],<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>,tot);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;ans[0]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i]+=ans[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res[i]-ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3980. 「NOI2023」桂花树</title>
    <url>/2023/08/21/LOJ-3980-%E3%80%8CNOI2023%E3%80%8D%E6%A1%82%E8%8A%B1%E6%A0%91/</url>
    <content><![CDATA[<p>好的 DP 题，但是感觉手玩几下就出来了。</p>
<span id="more"></span>
<p>先只考虑第一个限制。手玩一下得到，原树的结构是不变。需要考虑，在原树上的一条边插入一个新节点，或者在一个节点下方加一个新节点。</p>
<p>考虑 $k=0$ 的情况，从小到大考虑，那么与上面一样只有两种操作。每次插入有 $2n-1$ 种选择，插入后变为 $n+1$ 的情况。以此类推得到答案 $\displaystyle\prod_{i=n}^{n+m-1}(2i-1)$。期望得分 $\text{35 pts}$（实测有 $\text{50 pts}$）。</p>
<p>考虑 $k\le 10$ 的情况。第二个限制相当于对于 $[1,i]$ 的所有节点所构成的虚树属于 $[1,i+k]$。依然从小到大考虑，不同于 $k=0$ 的两种操作，我们可以进行这样一种操作：在一条边上插入一个新节点 $x$，在 $x$ 节点下方插入一个新节点 $y$，满足 $y&lt;x\le y+k$。而对于当前状态，我们先填上 $y$，再状压记录空白节点 $x$ 的上限 $y+k$，之后填上 $x$。</p>
<p>于是设计状态 $f(i,S)$ 表示填到 $i$，未填的节点的上限状态为 $S$ 的方案数。那么有几种转移，其中 $size=n+\text{popcount}(S)$：</p>
<ol>
<li>在一条边插入一个新节点 $i$，系数为 $size-1$。</li>
<li>在一个节点下方加一个新节点 $i$，系数为 $size$。</li>
<li>在一条边插入一个空白节点，将 $i$ 加在空白节点下方。</li>
<li>在一个空白节点上填上 $i$。</li>
</ol>
<p>时间复杂度 $\mathcal O(Tmk2^k)$。答案与原树的形态无关。</p>
<p>感觉挺平凡的，但是又比较巧妙。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>,M=<span class="number">1</span>&lt;&lt;N,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> type,T,n,m,k,tot;</span><br><span class="line"><span class="type">int</span> f[M],g[M];</span><br><span class="line"><span class="type">int</span> cnt[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x+=y,x=x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,fa;i&lt;=n;i++)<span class="built_in">read</span>(fa);</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;n+m;i++)res=<span class="number">1ll</span>*res*(<span class="number">2</span>*i<span class="number">-1</span>)%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    tot=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line">    <span class="type">int</span> high=tot&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;n+m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=high;j&lt;tot;j++)g[(j^high)&lt;&lt;<span class="number">1</span>]=f[j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;high;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=j;t;)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> now=<span class="built_in">lowbit</span>(t);</span><br><span class="line">                <span class="built_in">upd</span>(g[(j^now)&lt;&lt;<span class="number">1</span>],f[j]);</span><br><span class="line">                t^=now;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> si=i+cnt[j];</span><br><span class="line">            <span class="built_in">upd</span>(g[j&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],<span class="number">1ll</span>*(si<span class="number">-1</span>)*f[j]%mod);</span><br><span class="line">            <span class="built_in">upd</span>(g[j&lt;&lt;<span class="number">1</span>],<span class="number">1ll</span>*(<span class="number">2</span>*si<span class="number">-1</span>)*f[j]%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(f,g,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;tree.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;tree.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(type,T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(M&gt;&gt;<span class="number">1</span>);i++)cnt[i&lt;&lt;<span class="number">1</span>]=cnt[i],cnt[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=cnt[i]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Say goodbye,my love.</title>
    <url>/2023/08/15/Say-goodbye-my-love/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="44137d1283954086562e7357a38e93f83437398607d74767afb17b640b5a3ea9">1b05e05313998e5f4de994245a1b63dc4754021f58e4c5b8ab6b31f2b16d53917bc74bdcc431348fbf88723c7b22dec042fa691f5ccf98561757ccd119d00ba9a8fa5b9b257f1d4e417067e1e1a7eaab</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Say goodbye.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3983. 「NOI2023」字符串</title>
    <url>/2023/08/23/LOJ-3983-%E3%80%8CNOI2023%E3%80%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>感觉有些套路。。。</p>
<span id="more"></span>
<p>转化限制，转为好统计的后缀或者是前缀。设 $S_i=s[i,n],P_i=R(s[1,i])$，那么对于 $i,l$，需要满足原限制的必要条件是 $S_i&lt;P_{i+2l-1}$。考虑去掉多余的情况，即满足 $s[i,i+l-1]=R(s[i+l,i+2l-1])$ 即 $s[i,i+2l-1]$ 是回文串，并且满足 $S_{i-1}&lt;P_{i+2l}$。于是把问题分为两部分分别计数。将询问离线考虑。</p>
<p>对于第一部分，我们对 $s+c_1+R(s)+c_2$ 建后缀数组，$c_1,c_2$ 为分隔符，均小于字符集种最小字符且满足 $c_1&gt;c_2$。问题变为二维数点，扫描线即可解决。</p>
<p>对于第二部i分，使用 Manacher 求出所有回文串。设其回文中心为 $i$，回文半径为 $r$。对于 $S_{i-r-1}&lt;P_{i+r}$ 只需要判断 $s[i-r-1]&lt;s[i+r]$。问题依然是二位数点，加入的点形如一条斜率为 $-1$ 的斜线 $(i-l,i+l+1)$ 其中 $0&lt;l\le r$，查询 $(i,i+2r-1)$ 下方的点个数。对坐标进行简单变换，$(x,y)\to (\frac{y+x+1}{2},\frac{y-x+1}{2})$，二者分别变为 $(i+1,l+1)$，其中 $0&lt;l\le r$，与 $(i+r,r)$。问题变为二维数点，扫描线即可解决</p>
<p>总的时间复杂度为 $\mathcal O((n+q)\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,C=<span class="number">128</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> type,T,n,m,k;</span><br><span class="line"><span class="type">char</span> s[N],t[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,c[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;<span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))c[x]+=k;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="type">int</span> res=<span class="number">0</span>;<span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x))res+=c[x];<span class="keyword">return</span> res;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">ask</span>(r)-<span class="built_in">ask</span>(l<span class="number">-1</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> SA</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">int</span> pos,sa[N],rk[N],oldrk[N&lt;&lt;<span class="number">1</span>],id[N],key1[N],cnt[N];</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span>&#123;<span class="keyword">return</span> oldrk[x]==oldrk[y]&amp;&amp;oldrk[x+w]==oldrk[y+w];&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> len,<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n=len;</span><br><span class="line">        m=C;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(rk,<span class="number">0</span>,<span class="built_in">sizeof</span>(rk));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[rk[i]=s[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)sa[cnt[rk[i]]--]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;;w&lt;&lt;=<span class="number">1</span>,m=pos)</span><br><span class="line">        &#123;</span><br><span class="line">            pos=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;n-w;i--)id[++pos]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(sa[i]&gt;w)id[++pos]=sa[i]-w;</span><br><span class="line">            <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cnt[key1[i]=rk[id[i]]]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)sa[cnt[key1[i]]--]=id[i];</span><br><span class="line">            <span class="built_in">memcpy</span>(oldrk+<span class="number">1</span>,rk+<span class="number">1</span>,n*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            pos=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)rk[sa[i]]=<span class="built_in">cmp</span>(sa[i],sa[i<span class="number">-1</span>],w)?pos:++pos;</span><br><span class="line">            <span class="keyword">if</span>(pos==n)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> Manacher</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len,p[N];</span><br><span class="line">    <span class="type">char</span> s[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">char</span> *c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=<span class="built_in">strlen</span>(c+<span class="number">1</span>);</span><br><span class="line">        s[<span class="number">0</span>]=<span class="string">&#x27;~&#x27;</span>,s[len=<span class="number">1</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)s[++len]=c[i],s[++len]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        s[++len]=<span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">0</span>,mr=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=mid*<span class="number">2</span>-i;</span><br><span class="line">            p[i]=i&gt;mr?<span class="number">1</span>:<span class="built_in">min</span>(p[j],mr-i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// if(i&lt;=mr)p[i]=min(p[j],mr-i+1);</span></span><br><span class="line">            <span class="keyword">while</span>(s[i-p[i]]==s[i+p[i]])p[i]++;</span><br><span class="line">            <span class="keyword">if</span>(i+p[i]&gt;mr)mr=i+p[i]<span class="number">-1</span>,mid=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Part1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Query</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id,l,r;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;Query&gt;q[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> i,<span class="type">int</span> r)</span></span>&#123;q[SA::rk[i]].<span class="built_in">push_back</span>(&#123;id,i+<span class="number">1</span>,i+(r&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>&#125;);&#125;</span><br><span class="line">    BIT t[<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t[<span class="number">0</span>].<span class="built_in">clear</span>(),t[<span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">        t[<span class="number">0</span>].n=t[<span class="number">1</span>].n=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m;i;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pos=SA::sa[i];</span><br><span class="line">            <span class="keyword">if</span>(pos&lt;=n)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> now:q[i])</span><br><span class="line">                    ans[now.id]+=t[now.l&amp;<span class="number">1</span>].<span class="built_in">query</span>(now.l,now.r);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pos&gt;n+<span class="number">1</span>&amp;&amp;pos&lt;m)</span><br><span class="line">            &#123;</span><br><span class="line">                pos=m-pos;</span><br><span class="line">                t[pos&amp;<span class="number">1</span>].<span class="built_in">add</span>(pos,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            q[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> Part2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Modify</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;Modify&gt;a[N],q[N];</span><br><span class="line">    BIT t;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> i,<span class="type">int</span> r)</span></span>&#123;q[i].<span class="built_in">push_back</span>(&#123;id,i+r&#125;);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t.<span class="built_in">clear</span>();</span><br><span class="line">        t.n=n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        Manacher::<span class="built_in">build</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=Manacher::p[i*<span class="number">2</span><span class="number">-1</span>]&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!r||s[i+r]&gt;=s[i-r<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            a[i-r].<span class="built_in">push_back</span>(&#123;i,<span class="number">1</span>&#125;);</span><br><span class="line">            a[i].<span class="built_in">push_back</span>(&#123;i,<span class="number">-1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> now:a[i])t.<span class="built_in">add</span>(now.x,now.y);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> now:q[i])ans[now.x]-=t.<span class="built_in">ask</span>(now.y);</span><br><span class="line">            a[i].<span class="built_in">clear</span>(),q[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)t[i]=s[i];</span><br><span class="line">    t[n+<span class="number">1</span>]=<span class="string">&#x27;2&#x27;</span>,t[<span class="number">2</span>*n+<span class="number">2</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    t[<span class="number">2</span>*n+<span class="number">3</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    s[n+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)t[n+i+<span class="number">1</span>]=s[n-i+<span class="number">1</span>];</span><br><span class="line">    m=<span class="number">2</span>*n+<span class="number">2</span>;</span><br><span class="line">    SA::<span class="built_in">build</span>(m,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,r;</span><br><span class="line">        <span class="built_in">read</span>(x,r);</span><br><span class="line">        Part1::<span class="built_in">add</span>(i,x,r);</span><br><span class="line">        Part2::<span class="built_in">add</span>(i,x,r);</span><br><span class="line">    &#125;</span><br><span class="line">    Part1::<span class="built_in">solve</span>();</span><br><span class="line">    Part2::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]),ans[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;string.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;string.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="built_in">read</span>(type,T);</span><br><span class="line">	<span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
        <tag>后缀数据结构</tag>
        <tag>Manacher</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1327F AND Segments</title>
    <url>/2023/08/30/CF1327F-AND-Segments/</url>
    <content><![CDATA[<p>简单的 DP。</p>
<span id="more"></span>
<p>根据 $\text{AND}$ 位运算的的性质，我们显然可以拆成每一位单独考虑，最后乘起来即可。转化为，有现在一条线段上已经填了若干连续的 $1$，现有若干限制 $[l_i,r_i]$ 中至少有一个 $0$，问满足限制的方案个数。</p>
<p>这种问题很容易想到容斥，但是很难做到一个比较优秀的复杂度。考虑直接 DP，设 $f(i,j)$ 表示填到第 $i$ 个位置，上一个 $0$ 是在 $j$ 位置。转移时从左到右枚举 $r_i$，但是直接做单次 DP 是 $\mathcal O(n^2)$ 的。考虑优化一下，我们发现每次转移过程中发生变化的只有 $\displaystyle f(i,i)=\sum_{x=l_{i-1}}^{i-1}f(i-1,x)=\sum_{x=0}^{i-1}f(i-1,x)$，即在 $i$ 这一位填 $0$。实际上 有值的位置是单增的，于是转移时维护左端点，以及总和即可。时间复杂度 $\mathcal O(k(n+m))$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k,m;</span><br><span class="line"><span class="type">int</span> l[N],r[N],x[N];</span><br><span class="line"><span class="type">int</span> cnt[N],f[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> bit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="built_in">sizeof</span>(q));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i]&gt;&gt;bit&amp;<span class="number">1</span>)cnt[l[i]]++,cnt[r[i]+<span class="number">1</span>]--;</span><br><span class="line">        <span class="keyword">else</span> q[r[i]+<span class="number">1</span>]=<span class="built_in">max</span>(q[r[i]+<span class="number">1</span>],l[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,sum=f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i])sum=<span class="built_in">adj</span>(sum-f[l]+mod),f[l]=<span class="number">0</span>,l++;</span><br><span class="line">        f[i]=cnt[i]?<span class="number">0</span>:sum;</span><br><span class="line">        sum=<span class="built_in">adj</span>(sum+f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">read</span>(l[i],r[i],x[i]);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)ans=<span class="number">1ll</span>*ans*<span class="built_in">solve</span>(i)%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1456E XOR-ranges</title>
    <url>/2023/08/28/CF1456E-XOR-ranges/</url>
    <content><![CDATA[<p>数位DP + 区间DP 的好题。</p>
<span id="more"></span>
<p>数位的形式很显然，我们需要同时限制上下界。考虑最优解的形式，对于当前位，我们会尽可能选相同的，这样就不会产生贡献。假如当前位置，所有数已经脱离上下界限制，那么接下来所有位肯定会全部选成相同的。那么我们只需要关心，哪一个数最后脱离限制。这样就相当于将原区间分离为两个子区间，能够递归解决。</p>
<p>根据这一点，我们很容易想到将区间 DP 与数位 DP 进行结合。我们尝试对 $l-1,r+1$ 上的数进行限制，设当前解决 $[l,r]$ 此时已全部脱离限制，我们枚举 $[l,r]$ 中最后脱离限制的数 $mid$。设计状态 $f(x,l,r,l_1,l_2,r_1,r_2)$，表示 填到第 $x$ 位，$[l,r]$ 已经全部脱离限制，$l_1$ 表示限制 $l-1$ 的是上界还是下界，$l_2$ 表示 $l-1$ 是否翻转当前位，$r_1,r_2$ 同理。具体地，有两种转移：</p>
<ol>
<li>将 $l_1,r_1$ 的限制移到上一位，并且计算当前位贡献。</li>
<li>枚举 $mid$ 在当前位脱离限制，递归为子问题解决。</li>
</ol>
<p>记忆化搜索即可，时间复杂度 $\mathcal O(n^3k)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e18</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll L[N],R[N],c[N];</span><br><span class="line">ll f[N][N][N][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ckmin</span><span class="params">(ll &amp;x,ll y)</span></span>&#123;x=x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">bool</span> l1,<span class="type">bool</span> l2,<span class="type">bool</span> r1,<span class="type">bool</span> r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=k)<span class="keyword">return</span> l&gt;r?<span class="number">0</span>:INF;</span><br><span class="line">    ll &amp;res=f[x][l][r][l1][l2][r1][r2];</span><br><span class="line">    <span class="keyword">if</span>(~res)<span class="keyword">return</span> res;</span><br><span class="line">    res=INF;</span><br><span class="line">    <span class="type">bool</span> tl=((l1?R[l<span class="number">-1</span>]:L[l<span class="number">-1</span>])&gt;&gt;x&amp;<span class="number">1</span>)^l2,tr=((r1?R[r+<span class="number">1</span>]:L[r+<span class="number">1</span>])&gt;&gt;x&amp;<span class="number">1</span>)^r2;</span><br><span class="line">    <span class="built_in">ckmin</span>(res,<span class="built_in">solve</span>(x+<span class="number">1</span>,l,r,l1,<span class="number">0</span>,r1,<span class="number">0</span>)+(l!=<span class="number">1</span>&amp;&amp;r!=n&amp;&amp;(tl^tr)?c[x]:<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=l;mid&lt;=r;mid++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!x)<span class="built_in">ckmin</span>(res,<span class="built_in">solve</span>(x,l,mid<span class="number">-1</span>,l1,l2,t,<span class="number">0</span>)+<span class="built_in">solve</span>(x,mid+<span class="number">1</span>,r,t,<span class="number">0</span>,r1,r2));</span><br><span class="line">            ll lim=t?R[mid]:L[mid];</span><br><span class="line">            <span class="keyword">if</span>(L[mid]&lt;=((lim^(<span class="number">1ll</span>&lt;&lt;x))&amp;(~((<span class="number">1ll</span>&lt;&lt;x)<span class="number">-1</span>)))&amp;&amp;((lim^(<span class="number">1ll</span>&lt;&lt;x))|((<span class="number">1ll</span>&lt;&lt;x)<span class="number">-1</span>))&lt;=R[mid])</span><br><span class="line">                <span class="built_in">ckmin</span>(res,<span class="built_in">solve</span>(x,l,mid<span class="number">-1</span>,l1,l2,t,<span class="number">1</span>)+<span class="built_in">solve</span>(x,mid+<span class="number">1</span>,r,t,<span class="number">1</span>,r1,r2));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(L[i],R[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)<span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(<span class="number">0</span>,<span class="number">1</span>,n,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1408H Rainbow Triples</title>
    <url>/2023/08/28/CF1408H-Rainbow-Triples/</url>
    <content><![CDATA[<p>模拟网络流的技巧，用线段树来维护。</p>
<span id="more"></span>
<p>每个点最多用一次，想到将限制转化为网络流模型。设 $cnt$ 为 $0$ 的总数，那么答案上界为 $\lfloor\frac{cnt}{2}\rfloor$。我们将所有点以 $\lfloor\frac{cnt}{2}\rfloor$ 为界分为 $L,R$ 两个点集。每个颜色只能用一次，我们从源点向每个颜色连边，再从每个每个颜色向可行位置对应的 $l/r$ 连边，最大流即为答案。</p>
<p>考虑类似 <a href="https://codeforces.com/problemset/problem/1368/H2">CF1368H2 Breadboard Capacity (hard version)</a> 的做法，考虑模拟最大流，尝试求出其最小割。我们必然会割去 $L$ 的一段前缀与 $R$ 的后缀 的连向汇点的边，以及源点连向部分颜色的边。</p>
<p>直接模拟割边的过程，考虑枚举 $L$ 的前缀，用线段树维护 $R$ 的答案。设当前枚举到前缀 $i$，考虑几种情况即可：</p>
<ol>
<li>颜色 $c$ 未在 $L$ 中出现，但在 $R$ 中出现，需要在 $R$ 中最后出现前的位置割掉。</li>
<li>只考虑在 $L$，颜色 $c$ 于位置 $i$ 最后出现，需要在 $R$ 中最后出现前的位置割掉。</li>
<li>颜色 $c$ 在 $L$ 中出现，但未在 $R$ 中出现，需要 $R$ 中所有位置都不需要割掉。</li>
</ol>
<p>直接线段树维护即可，时间复杂度 $\mathcal O(n\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> v,tag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span></span><br><span class="line">&#123;</span><br><span class="line">    Node tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;tr[x].v=<span class="built_in">min</span>(tr[x&lt;&lt;<span class="number">1</span>].v,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;tr[x].v+=k,tr[x].tag+=k;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[x].tag)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag),<span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag);</span><br><span class="line">        tr[x].tag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x].l=l,tr[x].r=r,tr[x].v=k+l,tr[x].tag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid,k),<span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=tr[x].l&amp;&amp;tr[x].r&lt;=r)<span class="keyword">return</span> <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line"><span class="type">int</span> a[N],pre[N];</span><br><span class="line"><span class="type">int</span> pl[N],pr[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;L,R;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+(a[i]==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lim=(pre[n]&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;pos&lt;=n;pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!a[pos])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre[pos]&gt;lim)<span class="keyword">break</span>;</span><br><span class="line">        L.<span class="built_in">push_back</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=pos;i--)<span class="keyword">if</span>(a[i])R.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:L)pl[a[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:R)pr[a[i]]=i;</span><br><span class="line">    <span class="type">int</span> totc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)totc+=(pl[i]||pr[i]);</span><br><span class="line">    <span class="type">int</span> m=pre[n]-lim;</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,m,totc);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!pl[i]&amp;&amp;pr[i])</span><br><span class="line">            t.<span class="built_in">modify</span>(<span class="number">1</span>,pre[n]-pre[pr[i]<span class="number">-1</span>],m,<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">min</span>(t.tr[<span class="number">1</span>].v,lim);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pl[a[i]]!=i)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(pr[a[i]])t.<span class="built_in">modify</span>(<span class="number">1</span>,pre[n]-pre[pr[a[i]]<span class="number">-1</span>],m,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> t.<span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">0</span>,m,<span class="number">-1</span>);</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,pre[i]+t.tr[<span class="number">1</span>].v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pl[i]=pr[i]=pre[i]=<span class="number">0</span>;</span><br><span class="line">    L.<span class="built_in">clear</span>(),R.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1770F Koxia and Sequence</title>
    <url>/2023/08/31/CF1770F-Koxia-and-Sequence/</url>
    <content><![CDATA[<p>妙妙题。</p>
<span id="more"></span>
<p>首先第一步，因为对于任意 $a_i=t$ 的情况数量是相等的，所以 $n$ 为偶数的情况的答案是 $0$，$n$ 为奇数我们只需要求 $a_1$ 的异或和即可。</p>
<p>考虑先满足 $+$ 的条件即 $\sum a_i=x$，再拆成每一位满足 $\operatorname{OR}$ 的限制即 $\operatorname{OR}a_i=y$。这是第一步。</p>
<p>第二步， $\operatorname{OR}a_i=y$ 的限制太死了，考虑容斥，设 $f(y)$ 为满足 $\operatorname{OR}a_i$ 为 $y$ 的子集的方案数，那么恰好满足 $\operatorname{OR}a_i$ 为 $y$ 的方案数为 $\displaystyle \sum_{y’\subseteq y}(-1)^{|y|-|y’|}f(y’)$，我们只关心奇偶性，直接写成 $\displaystyle \bigoplus_{y’\subseteq y} f(y’)$，对 $y’$ 进行限制即可。 </p>
<p>第三步，钦定当前位为 $i$，设 $a_1=a_1’-2^i$，列出答案式子：</p>
<script type="math/tex; mode=display">
\text{ans}=\bigoplus_{\sum a_i=x-2^i}[a_1'\subseteq y'-2^i][a_2\subseteq y']\cdots[a_n\subseteq y']</script><p>第四步，子集的限制我们并不好合并，考虑 $\displaystyle \binom{x}{y}=[y\subseteq x]\pmod 2$，于是将子集限制全部替换为组合数得到：</p>
<script type="math/tex; mode=display">
\text{ans}=\bigoplus_{\sum a_i=x-2^i}\binom{y'-2^i}{a_1}\binom{y'}{a_2}\cdots\binom{y'}{a_n}\pmod 2</script><p>注意到 $\sum a_i=x-2^i$ 的限制，我们可以使用范德蒙德卷积公式直接处理，进一步得到：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{ans}&=\binom{ny'-2^i}{x-2^i}\pmod 2\notag\\
&=[x-2^i\subseteq ny'-2^i]\notag\\
\end{align}</script><p>于是直接枚举计算即可，时间复杂度为 $\mathcal O(y\log y)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K=<span class="number">20</span>;</span><br><span class="line">ll n,x;</span><br><span class="line"><span class="type">int</span> y,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %d&quot;</span>,&amp;n,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span>(!(n&amp;<span class="number">1</span>))<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    ll now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=y;now+=n,i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&amp;y)!=i)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;K;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(i&gt;&gt;j&amp;<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">            ll fir=now-(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            ll sec=x-(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            <span class="keyword">if</span>(fir&gt;=<span class="number">0</span>&amp;&amp;sec&gt;=<span class="number">0</span>&amp;&amp;(sec&amp;fir)==sec)ans^=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CF677D Vanya and Treasure</title>
    <url>/2023/09/04/CF677D-Vanya-and-Treasure/</url>
    <content><![CDATA[<p>巧妙的根号分治。</p>
<span id="more"></span>
<p>考虑暴力做法，我们将所有点按照值分层，每层节点个数设为 $w_i$，层之间暴力转移。但是我们有两种不同的转移方式：</p>
<ol>
<li>暴力枚举两层之间所有点进行转移，单次时间复杂度 $\mathcal O(w_i\cdot w_{i+1})$。</li>
<li>直接在网格图上进行多源多汇 BFS，单次时间复杂度 $\mathcal O(nm)$。</li>
</ol>
<p>直接用两种做法之一很容易被卡成 $\mathcal O(n^2m^2)$。我们考虑将两种做法结合，对于每一层，若 $w_i\cdot w_{i+1}\le nm$，则采用做法一，否则采用做法二。接下来我们证明这样做的时间复杂度是对的。</p>
<p>考虑 $w_i\cdot w_{i+1}\le nm$ 的情况。我们们有 $\sum_i w_i=nm$，利用均值不等式得到 $\sum_i \sqrt{w_i\cdot w_{i+1}}\le nm$。那么 $\sum_i {w_i\cdot w_{i+1}}=\sum_i(\sqrt{w_i\cdot w_{i+1}})^2\le \sqrt{nm}\sum_i \sqrt{w_i\cdot w_{i+1}}\le nm\sqrt{nm}$。这样时间复杂度上限是 $\mathcal O(nm\sqrt{nm})$。</p>
<p>考虑 $w_i\cdot w_{i+1}&gt;nm$。那么有 $\max(w_i,w_{i+1})&gt;\sqrt{nm}$，这样的点最多有 $\mathcal O(\sqrt{nm})$ 个，时间复杂度也是 $\mathcal O(nm\sqrt{nm})$。至此我们得到这个时间复杂度正确的算法。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,p;</span><br><span class="line"><span class="type">int</span> a[N][N],f[N][N];</span><br><span class="line"><span class="type">int</span> dis[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;<span class="type">int</span> x,y;&#125;;</span><br><span class="line">vector&lt;Point&gt;w[N*N];</span><br><span class="line">queue&lt;Point&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ckmin</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x=x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">const</span> Point &amp;u,<span class="type">const</span> Point &amp;v)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(u.x-v.x)+<span class="built_in">abs</span>(u.y-v.y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Point &amp;u,<span class="type">const</span> Point &amp;v)</span></span>&#123;<span class="keyword">return</span> f[u.x][u.y]&lt;f[v.x][v.y];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">sort</span>(w[key].<span class="built_in">begin</span>(),w[key].<span class="built_in">end</span>(),cmp);</span><br><span class="line">    q.<span class="built_in">push</span>(w[key][<span class="number">0</span>]);</span><br><span class="line">    dis[w[key][<span class="number">0</span>].x][w[key][<span class="number">0</span>].y]=f[w[key][<span class="number">0</span>].x][w[key][<span class="number">0</span>].y];</span><br><span class="line">    <span class="keyword">auto</span> it=w[key].<span class="built_in">begin</span>();</span><br><span class="line">    it++;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Point now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(;it!=w[key].<span class="built_in">end</span>()&amp;&amp;f[(*it).x][(*it).y]&lt;=dis[now.x][now.y]+<span class="number">1</span>;it++)</span><br><span class="line">            dis[(*it).x][(*it).y]=f[(*it).x][(*it).y],q.<span class="built_in">push</span>(*it);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Point ne=now;</span><br><span class="line">            ne.x+=dx[i],ne.y+=dy[i];</span><br><span class="line">            <span class="keyword">if</span>(ne.x&lt;<span class="number">0</span>||ne.x&gt;n||ne.y&lt;<span class="number">0</span>||ne.y&gt;m)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[now.x][now.y]+<span class="number">1</span>&lt;dis[ne.x][ne.y])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[ne.x][ne.y]=dis[now.x][now.y]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(ne);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:w[key+<span class="number">1</span>])f[u.x][u.y]=dis[u.x][u.y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">read</span>(n,m,p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">read</span>(a[i][j]);</span><br><span class="line">            w[a[i][j]].<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="number">1</span>)f[i][j]=i+j<span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;p;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i].<span class="built_in">size</span>()*w[i+<span class="number">1</span>].<span class="built_in">size</span>()&lt;=n*m)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> u:w[i])</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v:w[i+<span class="number">1</span>])</span><br><span class="line">                    <span class="built_in">ckmin</span>(f[v.x][v.y],f[u.x][u.y]+<span class="built_in">dist</span>(u,v));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">BFS</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:w[p])<span class="built_in">ckmin</span>(ans,f[u.x][u.y]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>平衡规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#6077. 「2017 山东一轮集训 Day7」逆序对</title>
    <url>/2023/09/05/LOJ-6077-%E3%80%8C2017-%E5%B1%B1%E4%B8%9C%E4%B8%80%E8%BD%AE%E9%9B%86%E8%AE%AD-Day7%E3%80%8D%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p>生成函数 + DP ，或者容斥，一道好题。</p>
<span id="more"></span>
<h3 id="生成函数-mathcal-O-k-sqrt-k"><a href="#生成函数-mathcal-O-k-sqrt-k" class="headerlink" title="生成函数 $\mathcal O(k\sqrt{k})$"></a>生成函数 $\mathcal O(k\sqrt{k})$</h3><p>首先根据题意，得到答案得生成函数：</p>
<script type="math/tex; mode=display">
F(x)=\prod_{i=1}^n(\sum_{j=0}^{i-1} x^j)=\prod_{i=1}^n\frac{(1-x^i)}{1-x}
=\frac{1}{(1-x)^n}\prod_{i=1}^n(1-x^i)</script><p>前面一部分是简单的，我们有 $\displaystyle \frac{1}{(1-x)^n}=\sum_{i\ge 0}\binom{n+i-1}{i}x^i$。于是考虑分子即可，注意到我们最多只会选出 $\mathcal O(\sqrt {k})$ 个 $-x^i$。再利用好每个 $-x^i$ 仅能选择一次这一点，我们进行 DP。设 $f(i,j)$ 表示选择了 $i$ 个，其和为 $j$ 的方案数。我们考虑两种转移：</p>
<ol>
<li>前 $i$ 个数全部 $+1$： $f(i,j)\gets f(i,j-i)$。</li>
<li>前 $i-1$ 全部 $+1$，插入一个新的 $1$：$f(i,j)\gets f(i-1,j-i)$。</li>
</ol>
<p>需要注意的是，若 $k&gt;n$ ，那么其中的数可能会大于 $n$，我们减掉这一部分的答案即可。</p>
<ol>
<li>若 $j&gt;n$，$f(i,j)\gets -f(i-1,j-n-1)$。</li>
</ol>
<p>DP 之后在乘上系数即可，时间复杂度 $\mathcal O(k\sqrt{k})$。</p>
<h3 id="容斥-mathcal-O-k-sqrt-k"><a href="#容斥-mathcal-O-k-sqrt-k" class="headerlink" title="容斥 $\mathcal O(k\sqrt{k})$"></a>容斥 $\mathcal O(k\sqrt{k})$</h3><p>有 $n$ 个数 $x_i$ 满足限制条件 $x_i\in[0,i-1]$，现在求满足 $\displaystyle \sum_{i=1}^{n} x_i=k$ 的 方案数。</p>
<p>真正限制我们的是 $x_i\in [0,i-1]$ 这一条件，我们考虑容斥去掉。钦定 $j\in S$ 中 $x_j$ 满足 $x_j\ge j$，我们将这些 $x_j$ 减去 $j$，那么所有的限制就变成了 $x_i\ge 0$，使用插板法即可直接算出答案。</p>
<p>现在我们相当于求从 $1,2,\cdots,i-1, i$ 选出若干个，使其和为 $j$。问题转化为与上面一模一样的 DP！！！这样时间复杂度也是 $\mathcal O(k\sqrt{k})$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">500</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> f[M][N];</span><br><span class="line"><span class="type">int</span> fac[N&lt;&lt;<span class="number">1</span>],ifac[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)ifac[i<span class="number">-1</span>]=<span class="number">1ll</span>*ifac[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="built_in">init</span>(n+k);</span><br><span class="line">    m=<span class="built_in">sqrt</span>(k&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=k;j++)</span><br><span class="line">            f[i][j]=<span class="built_in">adj</span>(<span class="built_in">adj</span>(f[i][j-i]+f[i<span class="number">-1</span>][j-i])+((j&gt;n)?(mod-f[i<span class="number">-1</span>][j-n<span class="number">-1</span>]):<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">            res=<span class="built_in">adj</span>(res+((j&amp;<span class="number">1</span>)?(mod-f[j][k-i]):f[j][k-i]));</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*<span class="built_in">C</span>(n+i<span class="number">-1</span>,i)*res%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>能不能再给力一点？</p>
<h3 id="生成函数-多项式-exp-mathcal-O-n-log-n"><a href="#生成函数-多项式-exp-mathcal-O-n-log-n" class="headerlink" title="生成函数 + 多项式 exp  $\mathcal O(n\log n)$"></a>生成函数 + 多项式 exp  $\mathcal O(n\log n)$</h3><p>我们还是写出其生成函数：</p>
<script type="math/tex; mode=display">
F(x)=\frac{1}{(1-x)^n}\prod_{i=1}^n(1-x^i)</script><p>前一部分还是一样，我们有 $\displaystyle \frac{1}{(1-x)^n}=\sum_{i\ge 0}\binom{n+i-1}{i}x^i$。考虑后一部分，利用 <a href="https://www.luogu.com.cn/problem/P4389">P4389 付公主的背包</a> 一样的技巧，先对其取 $\ln$ 将其转化为加法。我们有下面的式子：</p>
<script type="math/tex; mode=display">
\ln (1-x^k)=-\sum_{i>0}\frac{1}{i}x^{ik}</script><p>所以得到：</p>
<script type="math/tex; mode=display">
\ln(\prod_{i=1}^n{(1-x^i)})=-\sum_{i=1}^n \sum_{j>0}\frac{1}{j}x^{ij}</script><p>右边暴力 $\mathcal O(n\ln n)$ 枚举，再做一次多项式 $\exp $ 即可，最后乘上 $\displaystyle \frac{1}{(1-x)^n}=\sum_{i\ge 0}\binom{n+i-1}{i}x^i$ 即可。时间复杂度为 $\mathcal O(n\log n)$。需要用到任意模数 NTT。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>容斥</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>P4389 付公主的背包</title>
    <url>/2023/09/06/P4389-%E4%BB%98%E5%85%AC%E4%B8%BB%E7%9A%84%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<p>生成函数+多项式，一个经典技巧。</p>
<span id="more"></span>
<p>背包问题，考虑使用多项式解决，，容易发现我们要求：</p>
<script type="math/tex; mode=display">
F(x)=\prod_{i=1}^n (\sum_{j\ge 0}x^{v_i j})=\prod_{i=1}^n \frac{1}{1-x^{v_i}}</script><p>乘法操作并不好实现，我们考虑用 $\ln$ 运算转化为加法，我们有下面的式子：</p>
<script type="math/tex; mode=display">
\ln \frac{1}{1-x^k}=\sum_{i>0}\frac{1}{i}x^{ik}</script><p>于是我们要求的式子变成了：</p>
<script type="math/tex; mode=display">
\begin{align}
\ln F(x)&=\sum_{i=1}^n \sum_{j>0}\frac{1}{j}x^{v_ij} \notag\\
\end{align}</script><p>于是直接暴力求出右边的式子，时间复杂度为调和级数 $\mathcal O(n\ln n)$，再做一次 $\exp$，时间复杂度 $\mathcal O(n\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N=<span class="number">4e6</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>,G=<span class="number">3</span>,Gi=(mod+<span class="number">1</span>)/G;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N],d[N],e[N],f[N];</span><br><span class="line"><span class="type">int</span> bit,tot,rev[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">		x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bit=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;len)bit++;</span><br><span class="line">	tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;bit<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)<span class="keyword">if</span>(rev[i]&lt;i)<span class="built_in">swap</span>(a[rev[i]],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> g=<span class="built_in">qpow</span>(inv==<span class="number">1</span>?G:Gi,(mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,cur=<span class="number">1</span>;j&lt;mid;j++,cur=<span class="number">1ll</span>*cur*g%mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x=a[i+j],y=<span class="number">1ll</span>*cur*a[i+j+mid]%mod;</span><br><span class="line">				a[i+j]=<span class="built_in">adj</span>(x+y),a[i+j+mid]=<span class="built_in">adj</span>(x-y+mod);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(inv==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> inv=<span class="built_in">qpow</span>(tot,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)a[i]=<span class="built_in">adj</span>(<span class="number">1ll</span>*a[i]*inv%mod+mod);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poly_inv</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(len==<span class="number">1</span>)<span class="keyword">return</span> b[<span class="number">0</span>]=<span class="built_in">qpow</span>(a[<span class="number">0</span>]),<span class="built_in">void</span>();</span><br><span class="line">	<span class="built_in">poly_inv</span>(a,b,(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">init</span>(len&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)c[i]=(i&lt;len?a[i]:<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">1</span>),<span class="built_in">NTT</span>(c,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)b[i]=<span class="number">1ll</span>*<span class="built_in">adj</span>(<span class="number">2</span><span class="number">-1ll</span>*b[i]*c[i]%mod+mod)*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">-1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;tot;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">derivative</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)b[i<span class="number">-1</span>]=<span class="number">1ll</span>*i*a[i]%mod;</span><br><span class="line">	b[len<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">integrate</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i;i--)b[i]=<span class="number">1ll</span>*<span class="built_in">qpow</span>(i)*a[i<span class="number">-1</span>]%mod;</span><br><span class="line">	b[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">poly_ln</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">poly_inv</span>(a,b,len);</span><br><span class="line">    <span class="built_in">derivative</span>(a,d,len);</span><br><span class="line">    <span class="built_in">init</span>(len&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(b,<span class="number">1</span>),<span class="built_in">NTT</span>(d,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)b[i]=<span class="number">1ll</span>*b[i]*d[i]%mod;</span><br><span class="line">    <span class="built_in">NTT</span>(b,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">integrate</span>(b,b,len&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">poly_exp</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(len==<span class="number">1</span>)<span class="keyword">return</span> b[<span class="number">0</span>]=(a[<span class="number">0</span>]==<span class="number">0</span>),<span class="built_in">void</span>();</span><br><span class="line">	<span class="built_in">poly_exp</span>(a,b,(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(len&lt;&lt;<span class="number">1</span>);i++)e[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">poly_ln</span>(b,e,len);</span><br><span class="line">	<span class="built_in">init</span>(len&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)f[i]=(i&lt;len?a[i]:<span class="number">0</span>);</span><br><span class="line">	f[<span class="number">0</span>]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)f[i]=<span class="built_in">adj</span>(f[i]-e[i]+mod);</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">1</span>),<span class="built_in">NTT</span>(f,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)b[i]=<span class="number">1ll</span>*b[i]*f[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;tot;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">int</span> inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        cnt[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)inv[i]=<span class="built_in">qpow</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!cnt[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;i*j&lt;=m;j++)</span><br><span class="line">            a[i*j]=<span class="built_in">adj</span>(a[i*j]+<span class="number">1ll</span>*cnt[i]*inv[j]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">poly_exp</span>(a,b,m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3566. 「NOIP2021」方差</title>
    <url>/2023/09/08/LOJ-3566-%E3%80%8CNOIP2021%E3%80%8D%E6%96%B9%E5%B7%AE/</url>
    <content><![CDATA[<p>其实感觉这题出的挺好的，来补一下。</p>
<span id="more"></span>
<p>首先题目中的操作 $a_i’=a_{i-1}+a_{i+1}-a_i$ ，就是交换相邻两个数的差分。相当于我们要对差分进行重排使方差最小。</p>
<p>化简一下答案的式子得到：</p>
<script type="math/tex; mode=display">
ans=n\cdot\sum_{i=1}^n a_i^2-(\sum_{i=1}^n a_i)^2</script><p>我们考虑将答案化成差分形式，再研究其性质：</p>
<script type="math/tex; mode=display">
\begin{align}
ans&=n\cdot\sum_{i=1}^n a_i^2-(\sum_{i=1}^n a_i)^2\notag\\
&=n\cdot \sum_{i=1}^{n-1}(\sum_{j=1}^i d_j)^2-(\sum_{i=1}^{n-1} \sum_{j=1}^i d_j)^2\notag\\
&=n\cdot \sum_{i=1}^{n-1}\sum_{j=1}^i\sum_{k=1}^i d_j\cdot d_k-(\sum_{i=1}^{n-1}(n-i)\cdot d_i)^2\notag\\
&=n\cdot \sum_{i=1}^{n-1}\sum_{j=1}^{n-1}(n-\max(i,j))\cdot d_i\cdot d_j-
\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}(n-i)\cdot (n-j)\cdot d_i\cdot d_j\notag\\
&=\sum_{i=1}^{n-1}(\sum_{j=1}^{n-1}(i+j-\max(i,j))\cdot n-i\cdot j)\cdot d_i\cdot d_j\notag\\
&=\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}(\min(i,j)\cdot n-i\cdot j)\cdot d_i\cdot d_j\notag\\
\end{align}</script><p>简单考虑邻值交换就能够得到：最优情况下，差分数组呈现单谷。</p>
<p>于是有了单谷性质，我们考虑从小到大依次考虑差分数组中的元素，考虑将它放在左侧还是右侧。考虑最开始答案的式子，我们将 $\sum_i a_i$ 记录进状态，设计 $f(i,j)$ 表示前 $i$ 个差分数组，$\sum_i a_i=j$ 的答案。设 $s_i=\sum_{j=1}^i d_i$。转移时，考虑放在首还是尾，容易得到：</p>
<script type="math/tex; mode=display">
\begin{align}
f(i-1,j)+2\cdot j\cdot  d_i+i\cdot d_i^2&\to f(i,j+i\cdot d_i)\notag\\
f(i-1,j)+s_i^2&\to f(i,j+s_i)\notag\\
\end{align}</script><p>最终答案为 $ans=\min_x {n\cdot f(n-1,x)-x^2}$。直接做时间复杂度是 $\mathcal O(n^2a)$ 的无法通过。加一个小优化，直接跳过 $d_i=0$ 的元素，这些元素不会发生任何转移。于是时间复杂度变为 $\mathcal O(na\min(n,a))$。</p>
<p>可以用滚动数组优化一下空间。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans=INF;</span><br><span class="line"><span class="type">int</span> a[N],b[N],sum[N];</span><br><span class="line"><span class="type">int</span> p,f[<span class="number">2</span>][N*<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        b[i]=a[i+<span class="number">1</span>]-a[i];</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+n);</span><br><span class="line">    <span class="type">int</span> begin=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!b[i])</span><br><span class="line">            begin++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+b[i];</span><br><span class="line">    <span class="built_in">memset</span>(f[p^<span class="number">1</span>],<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f[p^<span class="number">1</span>]));</span><br><span class="line">    f[p^<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=begin+<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f[p],<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f[p]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[n]*n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[p][j+sum[i]]=<span class="built_in">min</span>(f[p][j+sum[i]],f[p^<span class="number">1</span>][j]+sum[i]*sum[i]);</span><br><span class="line">			f[p][j+b[i]*i]=<span class="built_in">min</span>(f[p][j+b[i]*i],f[p^<span class="number">1</span>][j]+j*<span class="number">2</span>*b[i]+b[i]*b[i]*i);</span><br><span class="line">        &#125;</span><br><span class="line">        p^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a[n]*(n<span class="number">-1</span>);i++)</span><br><span class="line">		<span class="keyword">if</span>(f[p^<span class="number">1</span>][i]&lt;INF)</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,n*f[p^<span class="number">1</span>][i]-i*i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡规划</title>
    <url>/2023/09/13/%E5%B9%B3%E8%A1%A1%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>平衡规划小记。</p>
<span id="more"></span>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><blockquote>
<p>平衡规划其实也可以算是一种思想，他其实是不同算法的综合， 出题人为了增加你的码量和思维难度而产生的新的做法，但一般 良心点的出题人对于想到一个都还是会给较多的分数的。</p>
<p>——mydcwfy</p>
</blockquote>
<p>平衡规划大致分为以下四种：</p>
<p>​    1.隐含的和相同，然后可以根号或者是其他之类的分治。一般有序列出现次数和为 $\mathcal O(n)$ 和图的度数和为 $\mathcal O(m)$ 两种。 </p>
<p>​    2.题面给定 $n + m$ 或 $n\times m$，然后按照 $n,m ≤ \sqrt{n\times m}$ 或 $n, m ≤ \frac{n + m}{ 2}$ 分治。 </p>
<p>​    3.题目给定 $n$，容易计算 $\sqrt n$ 以内的答案且有规律性，用 $\sqrt n$ 个答案来合并出总答案。也有可能是利用 $\frac{n}{2}$ 合并两端。 </p>
<p>​    4.不同算法因为切入点不同，得到的时间复杂度不同，比如 $O(nB)$ 和 $O(\frac{n^2}{B} )$，合适的平衡他们，让最劣复杂度最优。</p>
<p>接下来以例题为主介绍平衡规划的思想。</p>
<h2 id="1-出现次数和一定"><a href="#1-出现次数和一定" class="headerlink" title="1.出现次数和一定"></a>1.出现次数和一定</h2><p>经典，很多时候看到与出现次数相关就可以考虑平衡规划。</p>
<h3 id="1-1-P8349-SDOI-SXOI2022-整数序列"><a href="#1-1-P8349-SDOI-SXOI2022-整数序列" class="headerlink" title="1.1 P8349 [SDOI/SXOI2022] 整数序列"></a>1.1 <a href="https://www.luogu.com.cn/problem/P8349">P8349 [SDOI/SXOI2022] 整数序列</a></h3><p>我们分为几种情况来考虑，设阈值 $B$，出现次数为 $cnt_x$ 表示 $x$ 的出现次数。当 $cnt_x\le B$ 我们称之为“小“，否则称为”大“。我们容易想到把每个数的位置拿出来做是相对容易的。</p>
<h4 id="1-小对小"><a href="#1-小对小" class="headerlink" title="1.小对小"></a>1.小对小</h4><p>我们直接暴力做，把 $x,y$ 出现的位置单独拉出来，前缀 min 统计一下即可。时间复杂度 $\mathcal O(q(cnt_x+cnt_y))=\mathcal O(qB)$。</p>
<h4 id="2-大对大"><a href="#2-大对大" class="headerlink" title="2.大对大"></a>2.大对大</h4><p>我们发现大对大的情况其实很少，种类不超过 $\frac{n}{B}$ 个。所以我们还是暴力做，用 <code>map</code> 记忆化一下即可。时间复杂度 $\displaystyle \mathcal O(\frac{n^2}{B})$。</p>
<h4 id="3-小对大"><a href="#3-小对大" class="headerlink" title="3.小对大"></a>3.小对大</h4><p>我们发现还是有很多位置是</p>
<h2 id="2-度数和一定"><a href="#2-度数和一定" class="headerlink" title="2.度数和一定"></a>2.度数和一定</h2><p>有些图论题目比较感觉复杂度假的但是又严重跑不满，和度数相关的，可以考虑用度数平衡规划。</p>
<h3 id="2-1-Dinic-求解二分图最大匹配复杂度证明"><a href="#2-1-Dinic-求解二分图最大匹配复杂度证明" class="headerlink" title="2.1 Dinic 求解二分图最大匹配复杂度证明"></a>2.1 Dinic 求解二分图最大匹配复杂度证明</h3><p>众所周知，用 Dinic 求解二分图最大匹配复杂度是 $\mathcal O(m\sqrt n)$，这是如何证明的呢？</p>
<p>先考虑一个结论，当我们使用 Dinic 进行增广时，每个当前增广路的长度一定比上一次更长。因为 Dinic 是多路增广，长度相同或者更短的增广路会在前面更新。</p>
<p>单次增广的时间复杂度是 $\mathcal O(m)$ 的。我们不妨设当前已经进行了 $B$ 轮，之后新一轮增广的增广路长度必然大于 $B$，这样不交的路径一定只有不超过 $\displaystyle \frac{n}{B}$ 条。而每条边最多进行一次增广，那么后半部分的时间复杂度为 $\displaystyle \mathcal O(\frac{nm}{B})$。</p>
<p>于是我们得到两部分的时间复杂度分别为为 $\displaystyle \mathcal O(mB),\mathcal O(\frac{nm}{B})$。平衡规划一下， $\displaystyle \mathcal O(mB)=\mathcal O(\frac{nm}{B})$，取 $B=\sqrt n$ 得到其时间复杂度为 $\mathcal O(m\sqrt n)$。</p>
<h3 id="2-2-P1989-无向图三元环计数"><a href="#2-2-P1989-无向图三元环计数" class="headerlink" title="2.2 P1989 无向图三元环计数"></a>2.2 <a href="https://www.luogu.com.cn/problem/P1989">P1989 无向图三元环计数</a></h3><p>经典题，我们暴力做有几种。枚举两条边是 $\mathcal O(m^2)$ 的；枚举一个点及其对边是 $\mathcal O(nm)$ 的；枚举 $u$ 及其可达点 $v$，与 $v$ 可达点 $w$ 是 $\mathcal O(\sum_i \deg_i^2)$ 的。</p>
<p>考虑优化第三个算法，先统计每个点的度数，我们只保留度数小的点连向度数大的点的边，然后直接使用第三个算法。我们接下来说明这样复杂度 $\mathcal O(m\sqrt m)$。</p>
<p>首先我们这样建出来的是一个 DAG。考虑每条边 $(u,v)$ 的贡献就是 $\text{out}_v$。显然复杂度是 $\sum_{i=1}^m out_{v_i}$，而对于 $\deg_v=i$，$\text{out}_v$ 显然有两个上界 $i,\frac{m}{i}$，而对 $\min(i,\frac{m}{i})$ 平衡规划，那么上界就是 $\sqrt m$。所以时间复杂度为 $\mathcal O(m\sqrt m)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> u[M],v[M];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">read</span>(u[i],v[i]),deg[u[i]]++,deg[v[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u[i]&gt;v[i])<span class="built_in">swap</span>(u[i],v[i]);</span><br><span class="line">        <span class="keyword">if</span>(deg[u[i]]&gt;deg[v[i]])<span class="built_in">swap</span>(u[i],v[i]);</span><br><span class="line">        e[u[i]].<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])vis[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> w:e[v])</span><br><span class="line">                ans+=vis[w];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])vis[v]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="3-不同算法的平衡规划"><a href="#3-不同算法的平衡规划" class="headerlink" title="3.不同算法的平衡规划"></a>3.不同算法的平衡规划</h2><h3 id="3-1-CF1207E-Remainder-Problem"><a href="#3-1-CF1207E-Remainder-Problem" class="headerlink" title="3.1 CF1207E Remainder Problem"></a>3.1 <a href="https://codeforces.com/problemset/problem/1207/F">CF1207E Remainder Problem</a></h3><p>经典例题。我们注意到“取模”这个很好的条件。设阈值为 $B$，容易设计以下连个暴力：</p>
<p>​    1.修改：直接对 $a[x]$ 修改，$\displaystyle \mathcal O(1)$；查询：枚举 $k$，直接查询 $a[kx+y]$ 的和，$\displaystyle \mathcal O(\frac{n}{B})$。</p>
<p>​    2.设数组 $cnt[i][j]$ 表示 $x\equiv j\pmod i$ 位置上 $a[x]$ 之和。修改：枚举 $i$，对 $cnt[i][x\pmod i]$ 进行修改，$\displaystyle \mathcal O(B)$；查询：答案为         $cnt[x][y]$，时间复杂度 $\mathcal O(1)$。</p>
<p>那么我们直接对两个算法进行平衡规划。$\displaystyle \mathcal O(\frac{n}{B})=\mathcal O(B)$，取 $B=\sqrt n$。得到时间复杂度为 $\displaystyle \mathcal O(n\sqrt m)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>平衡规划</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>P4827 [国家集训队] Crash 的文明世界</title>
    <url>/2023/09/16/P4827-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-Crash-%E7%9A%84%E6%96%87%E6%98%8E%E4%B8%96%E7%95%8C/</url>
    <content><![CDATA[<p>普通幂转下降幂的经典技巧。</p>
<span id="more"></span>
<p>注意到 $k\le 150$，很容易想到利用斯特林数，将普通幂转下降幂。即：</p>
<script type="math/tex; mode=display">
x^n=\sum_k {n\brace k} x^{\underline k}=\sum_k {n\brace k}\binom{x}{k} k!</script><p>我们设 $f(x,i)=\sum_k \binom{x}{k}$，我们容易根据组合数的递推关系 $\binom{x}{k}=\binom {x-1}{k-1}+\binom{x-1}{k}$，直接写出转移方程：$f(x,i)=\sum_y (f(y,i)+f(y,i-1))$。再做一次换根即可。时间复杂度 $\mathcal O(nk+k^2)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>,M=<span class="number">150</span>+<span class="number">10</span>,mod=<span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> s[M][M],fac[M];</span><br><span class="line"><span class="type">int</span> f[N][M],g[N][M],tmp[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)f[x][j]=<span class="built_in">adj</span>(f[x][j]+<span class="built_in">adj</span>(f[y][j<span class="number">-1</span>]+f[y][j]));</span><br><span class="line">        f[x][<span class="number">0</span>]=<span class="built_in">adj</span>(f[x][<span class="number">0</span>]+f[y][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">            tmp[j]=<span class="built_in">adj</span>(<span class="built_in">adj</span>(g[x][j]-f[y][j<span class="number">-1</span>]+mod)-f[y][j]+mod);</span><br><span class="line">        tmp[<span class="number">0</span>]=<span class="built_in">adj</span>(g[x][<span class="number">0</span>]-f[y][<span class="number">0</span>]+mod);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">            g[y][j]=<span class="built_in">adj</span>(f[y][j]+<span class="built_in">adj</span>(tmp[j<span class="number">-1</span>]+tmp[j]));</span><br><span class="line">        g[y][<span class="number">0</span>]=g[x][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++)<span class="built_in">read</span>(u,v),<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            s[i][j]=<span class="built_in">adj</span>(s[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1ll</span>*j*s[i<span class="number">-1</span>][j]%mod);</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(g[<span class="number">1</span>],f[<span class="number">1</span>],<span class="built_in">sizeof</span>(f[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)</span><br><span class="line">            ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*s[k][j]*fac[j]%mod*g[i][j]%mod);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title>P4597 序列 sequence</title>
    <url>/2023/09/18/P4597-%E5%BA%8F%E5%88%97-sequence/</url>
    <content><![CDATA[<p>经典的凸包优化，运用到 slope trick。感觉还是挺妙的。</p>
<span id="more"></span>
<p>考虑朴素 DP。设 $f(i,j)$ 表示第 $i$ 个数变为 $j$ 的最小花费，状态转移方程为：</p>
<script type="math/tex; mode=display">
f(i,j)=\min_{k\le j}f(i-1,k)+|a_i-j|</script><p>相当于先进行一次前缀 $\min$，再加上绝对值。将 $f(i,j)$ 视作关于 $j$ 的函数，容易发现这是一个凸函数。因为初始函数 $f(1,j)$ 是凸函数 ，而我们每次进行前缀取 $\min$ 以及加上一个凸函数，都能够保证得到的新函数保持凸性，并且其中线段斜率为整数。</p>
<p>如何维护这个凸包？我们考虑维护每一个转折点，考虑一个序列，序列中每个转折点 $x$ 表示再在位置 $x$ 斜率增加 $1$。那么我们加入一个绝对值函数 $|a_i-x|$，相当于插入两个转折点 ${a_i,a_i}$。由于前缀取 $\min$ 的存在，我们只需要保留斜率大于 $0$ 的部分即可。而对于当前最优解就是最右边的端点。这用堆很容易维护，于是我们对于 $a_i$ 进行如下操作：</p>
<ol>
<li>在堆中加入两个转折点 ${a_i,a_i}$。</li>
<li>取出此时最右边的端点，设为 $x$。因为前面加入了两个端点，$y&lt;x$ 的转折点斜率全部减 $1$，$x$ 之后的直线斜率变为 $1$。此时 $x$ 即为最优。所以答案直接加上 $x-a_i$。</li>
<li>因为 $x$ 之后的直线斜率变为 $1$，我们直接将 $x$ 扔掉即可。</li>
</ol>
<p>重复以上过程即可，时间复杂度 $\mathcal O(n\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(x&lt;q.<span class="built_in">top</span>())ans+=q.<span class="built_in">top</span>()-x,q.<span class="built_in">pop</span>(),q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>P4229 某位歌姬的故事</title>
    <url>/2023/09/20/P4229-%E6%9F%90%E4%BD%8D%E6%AD%8C%E5%A7%AC%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p>一个经典题。</p>
<span id="more"></span>
<p>首先进行离散化。我们容易发现若位置 $x$ 被 $(l_i,r_i,m_i),(l_j,r_j,m_j)$ 甚至更多限制同时覆盖。若 $m_i\neq m_j$，那么我们只需要保留 $\max(m_i,m_j)$ 的限制即可；若 $m_i=m_j$，那么我们需要单独拿出来尝试求。所以说我们按照 $m_i$ 可以分为若干不相交的连续区间，这些区间的答案都是独立的，最后乘起来就好了。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>弦图</title>
    <url>/2023/09/21/%E5%BC%A6%E5%9B%BE/</url>
    <content><![CDATA[<p>比较冷门，还是学一下。</p>
<span id="more"></span>
<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><strong>弦</strong>：连接环中不相邻两点的边。</p>
<p><strong>弦图</strong>：任意长度大于 $3$ 的环都有一个弦的图称为弦图。</p>
<h2 id="2-弦图的判定"><a href="#2-弦图的判定" class="headerlink" title="2.弦图的判定"></a>2.弦图的判定</h2><h3 id="2-1-点割集"><a href="#2-1-点割集" class="headerlink" title="2.1 点割集"></a>2.1 点割集</h3><p>对于图 $G$ 上的两点 $u,v$，定义这两点间的 <strong>点割集</strong> 为满足删除这一集合后，$u,v$ 两点之间不连通。如果关于 $u,v$ 两点间的一个点割集的任意子集都不是点割集，则称这个点割集为 <strong>极小点割集</strong>。</p>
<h3 id="2-2-单纯点"><a href="#2-2-单纯点" class="headerlink" title="2.2 单纯点"></a>2.2 单纯点</h3><p>设 $N(x)$ 表示与点 $x$ 相邻的点集。若点集 ${x}+N(x)$ 的导出子图为一个团，则称点 $x$ 为单纯点。</p>
<h3 id="2-3-完美消除序列"><a href="#2-3-完美消除序列" class="headerlink" title="2.3 完美消除序列"></a>2.3 完美消除序列</h3><p>令 $n=|V|$，完美消除序列 $v_1,v_2,\ldots ,v_n$ 为 $1,2,\ldots ,n$ 的一个排列，满足 $v_i$ 在 ${v_i,v_{i+1},\ldots ,v_n}$ 的导出子图中为单纯点。</p>
<p>一个无向图是<strong>弦图</strong>当且仅当其有一个完全消除序列。</p>
<h3 id="2-4-最大势算法-MCS"><a href="#2-4-最大势算法-MCS" class="headerlink" title="2.4 最大势算法 MCS"></a>2.4 最大势算法 MCS</h3><p>我们按照逆序即 $n$ 到 $1$ 的顺序给每个点编号，最终得到的序列就是完美消除序列。设 $label_x$ 为与 $x$ 相邻的已标号的节点。我们每次选择 $label_x$ 最大的节点进行编号。 我们用链表维护 $label_x=i$ 的节点即可。时间复杂度为 $\mathcal O(n+m)$。对于<strong>弦图</strong>使用该算法即可得到完美消除序列。</p>
<h4 id="2-4-1-证明"><a href="#2-4-1-证明" class="headerlink" title="2.4.1 证明"></a>2.4.1 证明</h4><p><strong>Lemma 1</strong>: 对于任意弦图，一定不存在一个序列 $v_0,v_1\cdots,v_k (k\le 2)$ 满足：</p>
<ol>
<li>$v_0,v_1\cdots,v_k$ 的导出子图是一条链。</li>
<li>$\alpha(v_0)&gt;\alpha(v_i)(i\in[1,k])$。</li>
<li>存在 $i\in[1,k-1]$，满足 $\alpha(v_i)&lt;\alpha(v_{i+1})&lt;\dots&lt;\alpha(v_k)$ 且 $\alpha(v_i)&lt;\alpha(v_{i-1})&lt;\dots&lt;\alpha(v_1)&lt;\alpha(v_k)&lt;\alpha(v_0)$。</li>
</ol>
<p><strong>证明</strong>:</p>
<p>因为 $\alpha(v_1)&lt;\alpha(v_k)&lt;\alpha(v_0)$，且 $(v_0,v_1)$ 间有边相连，$(v_0,v_k)$ 间不相连,所以必然存在 $x$ 满足 $\alpha(v_k)&lt;\alpha(x)$，$(v_k,x)$ 间相连，$(v_1,x)$ 不相连。</p>
<p>我们设最小的 $j\in(1,k]$ 满足 $(v_j,x)$ 相连。我们可以推出 $(v_0,x)$ 不相连，否则 $(v_0,v_1,\cdots,v_j,x,v_0)$ 构成一个长度大于等于 $4$ 且无弦的环。</p>
<p>若 $\alpha(x)&lt;\alpha(v_0)$，则 $v_0,v_1\cdots,v_j,x$ 也是一个满足性质的序列。若 $\alpha(x)&gt;\alpha(v_0)$，则 $x,v_j\cdots,v_1,v_0$ 也是一个满足性质的序列。这样我们扩大了 $\min(\alpha(x),\alpha(v_0))$，一直推下去，则必然产生矛盾。</p>
<p>设得到的序列中 $x$ 的位置为 $\alpha(x)$。我们要证明对于 $\alpha(u)&lt;\alpha(v)&lt;\alpha(w)$，若存在 $(u,v),(u,w)$ 相连，则必然存在 $(v,w)$ 相连。考虑反证， $(v,w)$ 不相连，那么 $w,u,v$ 就是一个满足 <strong>Lemma 1</strong> 的中性质的序列，我们证明这样的序列不存在，所以矛盾，$v,w$ 相连。</p>
<h4 id="2-4-2-代码"><a href="#2-4-2-代码" class="headerlink" title="2.4.2 代码"></a>2.4.2 代码</h4><details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MCS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)t.<span class="built_in">add</span>(<span class="number">0</span>,i);</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!t.head[now])now--;</span><br><span class="line">        <span class="type">int</span> x=t.head[now];</span><br><span class="line">        ans[x]=i;</span><br><span class="line">        t.<span class="built_in">del</span>(now,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=head[x];j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[j];</span><br><span class="line">            <span class="keyword">if</span>(ans[y])<span class="keyword">continue</span>;</span><br><span class="line">            t.<span class="built_in">del</span>(label[y],y);</span><br><span class="line">            label[y]++;</span><br><span class="line">            now=<span class="built_in">max</span>(now,label[y]);</span><br><span class="line">            t.<span class="built_in">add</span>(label[y],y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="2-5-判断一个序列是否是完美消除序列"><a href="#2-5-判断一个序列是否是完美消除序列" class="headerlink" title="2.5 判断一个序列是否是完美消除序列"></a>2.5 判断一个序列是否是完美消除序列</h3><p>根据完美消除序列的定义，设 $v_i$ 在 $v_i,v_{i+1},\cdots,v_n$ 中与 $v_i$ 相邻的按照原顺序为 $v_{c_1},v_{c_2},\cdots,v_{c_k}$，我们只需要判断 $v_{c_1}$ 与其它点是否有边相连即可。使用哈希表即可做到 $\mathcal O(n+m)$。下面给出一种不使用哈希表的做法。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans[<span class="number">0</span>]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(ans[y]&gt;ans[x]&amp;&amp;ans[y]&lt;ans[pos])pos=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos)vec[pos].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(ans[y]&gt;ans[x])vis[y]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:vec[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=head[y];i;i=ne[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> z=ver[i];</span><br><span class="line">                <span class="keyword">if</span>(ans[z]&gt;ans[x]&amp;&amp;vis[z]&lt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>二次剩余</title>
    <url>/2023/09/21/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/</url>
    <content><![CDATA[<p>二次剩余，模意义开根。</p>
<span id="more"></span>
<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>对于整数 $a,p$ 满足 $(a,p)=1$，若存在整数 $x$ 使得：</p>
<script type="math/tex; mode=display">
x^2\equiv a\pmod p</script><p>则称 $a$ 为模 $p$ 的二次剩余，否则为模 $p$ 的非二次剩余。我们只讨论 $p$ 为奇素数的情况。</p>
<h2 id="2-欧拉准则"><a href="#2-欧拉准则" class="headerlink" title="2.欧拉准则"></a>2.欧拉准则</h2><h3 id="2-1-内容"><a href="#2-1-内容" class="headerlink" title="2.1 内容"></a>2.1 内容</h3><p>用于快速判断 $a$ 是否为二次剩余。</p>
<script type="math/tex; mode=display">
a^{\frac{p-1}{2}}\equiv\begin{cases}
    1 \pmod p,  & (\exists x\in\mathbf{Z}),~~a\equiv x^2\pmod p,\\
    -1 \pmod p, & \text{otherwise}.\\
\end{cases}</script><h3 id="2-2-证明"><a href="#2-2-证明" class="headerlink" title="2.2 证明"></a>2.2 证明</h3><p>首先使用<strong>费马小定理</strong>，有 $a^{p-1}\equiv 1\pmod p$，故：</p>
<script type="math/tex; mode=display">
\left(a^{\frac{p-1}{2}}+1\right)\left(a^{\frac{p-1}{2}}-1\right)\equiv 0\pmod p</script><p>所以对于任意满足 $(a,p)=1$ 的 $a$ 均有 $a^{p-1}\equiv \pm 1\pmod p$。</p>
<p>我们先证明 “ $a$ 是模 $p$ 的二次剩余” 是 “ $a^{\frac{p-1}{2}}\equiv1\pmod p$” 的充要条件。</p>
<ol>
<li>充分性<br>设 $a\equiv x^2\pmod p$，则 $a^{\frac{p-1}{2}}\equiv x^{p-1} \equiv 1\pmod p$。 </li>
<li>必要性<br>因为 $p$ 为奇素数，所以必然存在原根。设 $g$ 是模 $p$ 的一个原根，且 $a\equiv  g^k\pmod p$。那么 $a^{\frac{p-1}{2}}\equiv g^{\frac{k}{2}(p-1)}\equiv 1\pmod p$，所以 $\frac{k}{2}(p-1)$ 是 $\varphi (p)=p-1$ 的倍数，所以 $k$ 是偶数，故令 $x\equiv g^{\frac{k}{2}}\pmod p$ 即可使 $a^{\frac{p-1}{2}}\equiv1\pmod p$。</li>
</ol>
<p>既然” $a$ 是模 $p$ 的二次剩余” 是 “ $a^{\frac{p-1}{2}}\equiv1\pmod p$” 的充要条件，又因为 $a^{p-1}\equiv \pm 1\pmod p$，那么对应的，” $a$ 是模 $p$ 的非二次剩余” 是 “ $a^{\frac{p-1}{2}}\equiv -1\pmod p$” 的充要条件。欧拉准则就成立了。</p>
<p>这样还有一个推论：设 $a$ 为模 $p$ 的二次剩余 ，当 $\frac{p-1}{2}$ 是奇数时，$-a$ 是模 $p$ 的二次非剩余。相反，当 $\frac{p-1}{2}$ 是偶数时，$-a$ 是模 $p$ 的二次剩余。</p>
<h2 id="3-Cipolla-算法"><a href="#3-Cipolla-算法" class="headerlink" title="3.Cipolla 算法"></a>3.Cipolla 算法</h2><h3 id="3-1-二次剩余数量"><a href="#3-1-二次剩余数量" class="headerlink" title="3.1 二次剩余数量"></a>3.1 二次剩余数量</h3><p>对于方程 $x^2\equiv a\pmod p$，设 $x_1,x_2$ 为方程两个解，那么 $x_1^2-x_2^2\equiv 0\pmod p$，所以 $x_1\equiv -x_2\pmod p$，即 $x_1,x_2$ 互为模 $p$ 意义下相反数。所以对于 $p$ 以内 $\frac{p-1}{2}$ 对模 $p$ 意义下相反数对应着 $\frac{p-1}{2}$ 个 $a$。所以模 $p$ 意义下二次剩余和非二次剩余个数均为 $\dfrac{p-1}{2}$。</p>
<h3 id="3-2-算法"><a href="#3-2-算法" class="headerlink" title="3.2 算法"></a>3.2 算法</h3><p>我们首先随便找到一个 $r$ 使得 $r^2-a$ 为二次非剩余。上面我们已经研究过非二次剩余数量为 $\dfrac{p-1}{2}$，我们随机选取期望两次即可得到一个 $r$。</p>
<p>类比实数域向复数域的推广，我们定义一个 $i^2=r^2-a$，可以将该域中所有数表示为 $a+bi$ 的形式，其中 $a,b$ 均为模 $p$ 意义下的数。其实可以证明这是一个环，这里略去。接下来推导都是在模 $p$ 意义下进行。</p>
<p>我们发现直接求 $(r+i)^{\frac{p+1}{2}}$。我们简单证明一下。</p>
<script type="math/tex; mode=display">
(r+i)^{p+1}\equiv(r+i)^p(r+i)\equiv(r^p+i^p)(r+i)\pmod p</script><p>由<strong>费马小定理</strong>得到：$r^p\equiv r\pmod p$。并且有：</p>
<script type="math/tex; mode=display">
i^p \equiv i^{p-1}\cdot i\equiv (r^2-a)^{\frac{p-1}{2}}i\equiv -i\pmod p</script><p>所以得到：</p>
<script type="math/tex; mode=display">
(r+i)^{p+1}\equiv(r^p+i^p)(r+i)\equiv (r-i)(r+i)\equiv r^2-i^2\equiv r^2-(r^2-a)\equiv a\pmod p</script><p>所以我们得到 $(r+i)^{p+1}\equiv a\pmod p$，所以得到 $(r+i)^{\frac{p+1}{2}}\equiv x\pmod p$。我们使用快速幂求即可。</p>
<p>整个算法时间复杂度为 $\mathcal O(\log p)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="keyword">namespace</span> Cipolla</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,a,p;</span><br><span class="line">    <span class="type">int</span> x0,x1;</span><br><span class="line">    <span class="function">mt19937 <span class="title">rnd</span><span class="params">(<span class="number">114514</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=p?x-p:x;&#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Complex</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="type">const</span> Complex <span class="keyword">operator</span>*(<span class="type">const</span> Complex &amp;t)<span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (Complex)&#123;<span class="built_in">adj</span>(<span class="number">1ll</span>*x*t.x%p+<span class="number">1ll</span>*y*t.y%p*<span class="built_in">adj</span>(<span class="number">1ll</span>*a*a%p-n+p)%p),</span><br><span class="line">                <span class="built_in">adj</span>(<span class="number">1ll</span>*x*t.y%p+<span class="number">1ll</span>*y*t.x%p)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%p;</span><br><span class="line">            x=<span class="number">1ll</span>*x*x%p;</span><br><span class="line">            k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">legendre</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> p)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">qpow</span>(a,(p<span class="number">-1</span>)/<span class="number">2</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(a=<span class="number">0</span>;<span class="built_in">legendre</span>(<span class="built_in">adj</span>(<span class="number">1ll</span>*a*a%p-n+p),p)==<span class="number">1</span>;a=<span class="built_in">rnd</span>()%p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Complex <span class="title">qpow</span><span class="params">(Complex x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Complex res=(Complex)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=res*x;</span><br><span class="line">            x=x*x;</span><br><span class="line">            k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n%=p;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">legendre</span>(n,p)==p<span class="number">-1</span>)<span class="keyword">return</span> x0=<span class="number">-1</span>,<span class="built_in">void</span>();</span><br><span class="line">        <span class="built_in">get_a</span>();</span><br><span class="line">        x0=<span class="built_in">qpow</span>((Complex)&#123;a,<span class="number">1</span>&#125;,(p+<span class="number">1</span>)/<span class="number">2</span>).x,x1=p-x0;</span><br><span class="line">        <span class="keyword">if</span>(x0&gt;x1)<span class="built_in">swap</span>(x0,x1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(Cipolla::n,Cipolla::p);</span><br><span class="line">        <span class="keyword">if</span>(!Cipolla::n)&#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        Cipolla::<span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">if</span>(Cipolla::x0==<span class="number">-1</span>)<span class="built_in">puts</span>(<span class="string">&quot;Hola!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,Cipolla::x0,Cipolla::x1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1710C XOR Triangle</title>
    <url>/2023/10/06/CF1710C-XOR-Triangle/</url>
    <content><![CDATA[<p>数位 DP，对性质的观察。</p>
<span id="more"></span>
<p>注意到 $n\le 2\times 10^5$ ，直接考虑数位DP，但是因为这个限制并不能化成较好形式，还是很难做。</p>
<p> 一开始得想法是钦定 $a\oplus b=x$，再根据 $x+y\ge x\oplus y$，对应的求出 $a\oplus b,b\oplus c$ 。但这样很难对 $a,b,c$ 的大小进行限制。</p>
<p>但是我们还是考虑利用 $x+y\ge x\oplus y$，这已经和我们的限制很接近了 $(a\oplus b) +(a\oplus c)&gt;(b\oplus c)$ 。更进一步地，我们考虑按位来做，我们只需要有一满足 $(a_i\oplus b_i) +(a_i\oplus c_i)&gt;(b_i\oplus c_i)$ 即可满足整个限制条件。我们只需要记录前面是否已经有一位满足即可。简单数位 DP 即可解决。时间复杂度 $\mathcal O(n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">bool</span> l1,<span class="type">bool</span> l2,<span class="type">bool</span> l3,<span class="type">bool</span> x,<span class="type">bool</span> y,<span class="type">bool</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;n)<span class="keyword">return</span> x&amp;&amp;y&amp;&amp;z;</span><br><span class="line">    <span class="type">int</span> &amp;res=f[pos][l1][l2][l3][x][y][z];</span><br><span class="line">    <span class="keyword">if</span>(~res)<span class="keyword">return</span> res;</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(l1?a[pos]:<span class="number">1</span>);i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=(l2?a[pos]:<span class="number">1</span>);j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;<span class="built_in">k</span>&lt;=(l3?a[pos]:<span class="number">1</span>);k++)</span><br><span class="line">    res=<span class="built_in">adj</span>(res+<span class="built_in">dfs</span>(pos+<span class="number">1</span>,l1&amp;&amp;(i==a[pos]),l2&amp;&amp;(j==a[pos]),l3&amp;&amp;(k==a[pos]),</span><br><span class="line">        x||((i^j)+(i^k)&gt;(j^k)),y||((j^i)+(j^k)&gt;(i^k)),z||((k^i)+(k^j)&gt;(i^j))));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数位 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3342. 「NOI2020」制作菜品</title>
    <url>/2023/10/07/LOJ-3342-%E3%80%8CNOI2020%E3%80%8D%E5%88%B6%E4%BD%9C%E8%8F%9C%E5%93%81/</url>
    <content><![CDATA[<p>构造题，但感觉并不算困难。</p>
<span id="more"></span>
<p>注意到部分分的设置，由浅入深大致分为 $m=n-1$，$m\ge n-1$，$m=n-2$ 几部分。我们按顺序进行思考。</p>
<h4 id="mathbf-m-n-1"><a href="#mathbf-m-n-1" class="headerlink" title="$\mathbf{m=n-1}$"></a>$\mathbf{m=n-1}$</h4><p>考虑将材料从大到小进行排序，为 $d_1\le d_2\le \cdots\le d_{n-1}\le d_n$。我们考虑以下两点：</p>
<p><strong>Lemma 1</strong>: $d_1&lt;k$。</p>
<p><strong>Lemma 2</strong>: $d_1+d_n\ge k$。</p>
<p>我们容易构造出一种方案：每次取出最小的 $d_i$ 和最大的 $d_j$，将 $d_i\to 0,d_j\to d_i+d_j-k$。然后转化为 $m-1,n-1$ 的情况，做到 $m=0$ 完成构造。</p>
<h4 id="mathbf-m-gt-n-1"><a href="#mathbf-m-gt-n-1" class="headerlink" title="$\mathbf{m&gt;n-1}$"></a>$\mathbf{m&gt;n-1}$</h4><p><strong>Lemma 3</strong>: $d_n\ge k$。</p>
<p>我们用 $d_n$ 单独做一道菜。这样就转化为 $m=n-1$ 的情况，使用上面的方法即可。</p>
<h4 id="mathbf-m-n-2"><a href="#mathbf-m-n-2" class="headerlink" title="$\mathbf{m=n-2}$"></a>$\mathbf{m=n-2}$</h4><p>我们尝试向 $m=n-1$ 转换。我们尝试将每种材料分成两个集合 $S,T$，设 $n_1=|S|,n_2=|T|$，满足 $\sum_{i\in S}d_i=(n_1-1)k$。相当于转化为两个 $m=n-1$ 的情况。显然问题有解当且仅当我们能够找到这样的 $S,T$。</p>
<p>于是我们相当于求 $\sum_{i\in S}(k-d_i)=k$ 的集合 $S$。这直接就是一个 01 背包问题。只用判断可行性，使用 <code>bitset</code> 优化即可做到 $\displaystyle \mathcal O(\frac{n^2k}{\omega})$。</p>
<p>代码还是比较好写的。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,M=<span class="number">2.5e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), res = -res;</span><br><span class="line">    <span class="keyword">if</span>(res &gt; <span class="number">9</span>) <span class="built_in">write</span>(res / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(res % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;<span class="built_in">putchar</span>(c);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> </span>&#123; <span class="keyword">while</span>(*s) <span class="built_in">putchar</span>(*s ++); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> ...ARC&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T res, ARC ...com)</span> </span>&#123; <span class="built_in">write</span>(res), <span class="built_in">write</span>(com...);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;t)<span class="type">const</span>&#123;<span class="keyword">return</span> x==t.x?id&lt;t.id:x&lt;t.x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> T,n,m,k;</span><br><span class="line">vector&lt;Node&gt;a;</span><br><span class="line">multiset&lt;Node&gt;s;</span><br><span class="line">bitset&lt;(M&lt;&lt;1)&gt;f[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">const</span> vector&lt;Node&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.<span class="built_in">clear</span>();              </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:a)<span class="keyword">if</span>(x.x)s.<span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="type">int</span> si=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;si;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Node x=*s.<span class="built_in">begin</span>(),y=*s.<span class="built_in">rbegin</span>();</span><br><span class="line">        s.<span class="built_in">erase</span>(x),s.<span class="built_in">erase</span>(y);</span><br><span class="line">        <span class="built_in">write</span>(x.id,<span class="string">&#x27; &#x27;</span>,x.x,<span class="string">&#x27; &#x27;</span>,y.id,<span class="string">&#x27; &#x27;</span>,k-x.x,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        y.x-=k-x.x;</span><br><span class="line">        s.<span class="built_in">insert</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        a.<span class="built_in">push_back</span>(&#123;i,x&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;=n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(x.x&gt;=k&amp;&amp;m&gt;n<span class="number">-1</span>)</span><br><span class="line">                x.x-=k,<span class="built_in">write</span>(x.id,<span class="string">&#x27; &#x27;</span>,k,<span class="string">&#x27;\n&#x27;</span>),m--;</span><br><span class="line">            <span class="keyword">if</span>(!x.x)n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">work</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)f[i].<span class="built_in">reset</span>();</span><br><span class="line">    f[<span class="number">0</span>][M]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cost=k-a[i<span class="number">-1</span>].x;</span><br><span class="line">        <span class="keyword">if</span>(cost&gt;<span class="number">0</span>)f[i]=f[i<span class="number">-1</span>]|f[i<span class="number">-1</span>]&lt;&lt;cost;</span><br><span class="line">        <span class="keyword">else</span> f[i]=f[i<span class="number">-1</span>]|f[i<span class="number">-1</span>]&gt;&gt;(-cost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f[n][M+k])<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lim=n<span class="number">-1</span>,now=k;</span><br><span class="line">    vector&lt;Node&gt;ans;</span><br><span class="line">    <span class="keyword">while</span>(now)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=lim;~i;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cost=k-a[i].x;</span><br><span class="line">            <span class="keyword">if</span>(f[i][M+now-cost])</span><br><span class="line">            &#123;</span><br><span class="line">                now-=cost;</span><br><span class="line">                lim=i<span class="number">-1</span>;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">work</span>(ans);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ans)vis[x.id]=<span class="number">1</span>;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:a)</span><br><span class="line">        <span class="keyword">if</span>(!vis[x.id])</span><br><span class="line">            ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="built_in">work</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;dish.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;dish.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC166</title>
    <url>/2023/10/09/ARC166/</url>
    <content><![CDATA[<p>。。。</p>
<span id="more"></span>
<h3 id="A-Replace-C-or-Swap-AB"><a href="#A-Replace-C-or-Swap-AB" class="headerlink" title="A - Replace C or Swap AB"></a>A - Replace C or Swap AB</h3><p>模拟判断即可。</p>
<h3 id="B-Make-Multiples"><a href="#B-Make-Multiples" class="headerlink" title="B - Make Multiples"></a>B - Make Multiples</h3><p>DP，对 $a,b,c$ 状压。枚举每个数 $A_i$ 钦定为其中某几个的倍数，类似背包。</p>
<h3 id="C-LU-RD-Marking"><a href="#C-LU-RD-Marking" class="headerlink" title="C - LU / RD Marking"></a>C - LU / RD Marking</h3><p>考虑将网格图划分出来，借一下官方题解的图：</p>
<p><img src="https://img.atcoder.jp/arc166/25192085101f6f5c7b5bd1b5d9ae1849.png" alt="img"></p>
<p>这样划分出的每条折线都是独立的。我们可以对每条折线单独 DP 再将方案数相乘。容易发现每条线的方案就是斐波那契数列 $f_i$。设 $n\le m$。那么答案就是：</p>
<script type="math/tex; mode=display">
(\prod_{i=1}^n f_{2i})^2 f_{2i+1}^{m-n}</script><p>预处理之后快速幂计算，时间复杂度 $\mathcal O(\max(n,m)+q\log(|n-m|))$。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>P8424 [JOI Open 2022] 跷跷板（Seesaw）</title>
    <url>/2023/10/19/P8424-JOI-Open-2022-%E8%B7%B7%E8%B7%B7%E6%9D%BF%EF%BC%88Seesaw%EF%BC%89/</url>
    <content><![CDATA[<p>很妙的贪心。</p>
<span id="more"></span>
<p>最开始的平均数是固定的，我们设为 $\overline a$。直接求极差很不方便，我们考虑求所有操作中使 $\overline a’$ 向两边分别偏移了多少。</p>
<p>我们考虑 $i$ 次操作之后，还剩下一个长度为 $n-i$ 的 $[l,r]$ 的序列。我们容易发现对于最优解的情况，去掉两边元素之后得到的区间 $[l_1,r_1],[l_2,r_2]$，分别满足为最大的 $\overline a_{l_1,r_1}\le \overline a$ 和最小的 $\overline a_{l_2,r_2}\ge \overline a$。 否则，将当前区间向左或向右平移，一定可以得到更优的答案。</p>
<p>直接处理出这样的 $[l_1,r_1],[l_2,r_2]$。根据上面的推论，我们每一步一定是取这两个区间之一。于是我们直接按照 $\overline a-\overline a_{l,r}$ 从大到小排序，然后枚举，直接钦定 $[l_1,r_1]$，对于 $\overline a_{l_1’,r_1’}\le \overline a_{l_1,r_1}$，我们选取所有 $[l_2’,r_2’]$ 即可。时间复杂度 $\mathcal O(n\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDD pair<span class="string">&lt;double,double&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> INF=<span class="number">1e9</span>,eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="type">double</span> ave;</span><br><span class="line">PDD a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> <span class="number">1.0</span>*(sum[r]-sum[l<span class="number">-1</span>])/(r-l+<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)<span class="built_in">read</span>(x),sum[i]=sum[i<span class="number">-1</span>]+x;</span><br><span class="line">    ave=<span class="number">1.0</span>*sum[n]/n;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l,r)&gt;ave)l--,r--;</span><br><span class="line">        a[i]=&#123;ave-<span class="built_in">get</span>(l,r),<span class="built_in">get</span>(l+<span class="number">1</span>,r+<span class="number">1</span>)-ave&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">    <span class="type">double</span> ans=INF,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i;i--)ans=<span class="built_in">min</span>(ans,a[i].first+res),res=<span class="built_in">max</span>(res,a[i].second);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P8594 「KDOI-02」一个仇的复</title>
    <url>/2023/10/14/P8594-%E3%80%8CKDOI-02%E3%80%8D%E4%B8%80%E4%B8%AA%E4%BB%87%E7%9A%84%E5%A4%8D/</url>
    <content><![CDATA[<p>组合数学练习题。</p>
<span id="more"></span>
<p>首先发现只能用 $1\times a$ 或 $2\times 1$ 的矩形进行覆盖。考虑只用 $1\times a$ 的矩形进行覆盖。两行显然是独立的，并且分别可以用隔板法解决，在长度为 $n$ 的方格图中用 $m$ 个矩形的方案数为：</p>
<script type="math/tex; mode=display">
f(n,m)=\sum_{i=1}^{m-1}\binom{n-1}{i-1}\binom{n-1}{m-1-i}=\binom{2n-2}{m-2}</script>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P3227 [HNOI2013] 切糕</title>
    <url>/2023/10/25/P3227-HNOI2013-%E5%88%87%E7%B3%95/</url>
    <content><![CDATA[<p>经典的网络流建图技巧。</p>
<span id="more"></span>
<p>考虑最小割，直接建图对于原图上的点 $(x,y,z)$，建 $((x,y,z),(x,y,z+1),cost_{x,y,z})$，再连上源点和汇点即可。但是哦我们还没有考虑 $d$ 的限制，我们要把不合法的边集割掉之后，仍然有流量。对于相邻的节点 $(x,y),(i,j)$，我们连边 $((x,y,z),(i,j,z-d),INF)$。严谨证明有些繁琐，感性理解就很对。于是直接跑最小割即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dy[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Flow</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s,t;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>,head[N],ver[M],e[M],ne[M];</span><br><span class="line">    <span class="type">int</span> d[N],now[N];</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ver[++tot]=v;</span><br><span class="line">        e[tot]=w;</span><br><span class="line">        ne[tot]=head[u];</span><br><span class="line">        head[u]=tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">add_edge</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add_edge</span>(v,u,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        d[s]=<span class="number">1</span>,now[s]=head[s];</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> y=ver[i];</span><br><span class="line">                <span class="keyword">if</span>(d[y]||!e[i])<span class="keyword">continue</span>;</span><br><span class="line">                d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">                now[y]=head[y];</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">                <span class="keyword">if</span>(y==t)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==t)<span class="keyword">return</span> flow;</span><br><span class="line">        <span class="type">int</span> res=flow;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=now[x];i&amp;&amp;res;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y]==d[x]+<span class="number">1</span>&amp;&amp;e[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k=<span class="built_in">Dinic</span>(y,<span class="built_in">min</span>(res,e[i]));</span><br><span class="line">                e[i]-=k,e[i^<span class="number">1</span>]+=k;</span><br><span class="line">                res-=k;</span><br><span class="line">            &#125;</span><br><span class="line">            now[x]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow-res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxflow=<span class="number">0</span>,flow;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">BFS</span>())<span class="keyword">while</span>(flow=<span class="built_in">Dinic</span>(s,INF))maxflow+=flow;</span><br><span class="line">        <span class="keyword">return</span> maxflow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> p,q,r,d;</span><br><span class="line"><span class="type">int</span> a[<span class="number">50</span>][<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x<span class="number">-1</span>)*q+y)*(r+<span class="number">1</span>)+z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(p,q,r,d);</span><br><span class="line">    Flow::s=<span class="built_in">num</span>(p,q,r+<span class="number">1</span>)+<span class="number">1</span>,Flow::t=Flow::s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=r;t++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=q;j++)</span><br><span class="line">                <span class="built_in">read</span>(a[t][i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=q;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            Flow::<span class="built_in">add</span>(Flow::s,<span class="built_in">num</span>(i,j,<span class="number">1</span>),INF);</span><br><span class="line">            Flow::<span class="built_in">add</span>(<span class="built_in">num</span>(i,j,r+<span class="number">1</span>),Flow::t,INF);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=r;t++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=q;j++)</span><br><span class="line">                Flow::<span class="built_in">add</span>(<span class="built_in">num</span>(i,j,t),<span class="built_in">num</span>(i,j,t+<span class="number">1</span>),a[t][i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=d+<span class="number">1</span>;t&lt;=r;t++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=q;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> op=<span class="number">0</span>;op&lt;<span class="number">4</span>;op++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> ti=i+dx[op],tj=j+dy[op];</span><br><span class="line">                    <span class="keyword">if</span>(ti&amp;&amp;tj&amp;&amp;ti&lt;=p&amp;&amp;tj&lt;=q)Flow::<span class="built_in">add</span>(<span class="built_in">num</span>(i,j,t),<span class="built_in">num</span>(ti,tj,t-d),INF);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Flow::<span class="built_in">solve</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1270F Awesome Substrings</title>
    <url>/2023/10/25/CF1270F-Awesome-Substrings/</url>
    <content><![CDATA[<p>简单的平衡规划题目。</p>
<span id="more"></span>
<p>注意到“倍数”的限制，这很平衡规划。我们设限制为 $B$。若直接枚举 $k\le B$，条件为 $k(s_r-s_l)=r-l$，条件即为 $k\cdot s_l-l=k\cdot s_r-r$，开个桶记录一下，再扫一遍即可。这个做法时间复杂度为 $\mathcal O(nB)$。这是对于 $k$ 较小的做法。</p>
<p>考虑 $k&gt;B$ 的答案，直接暴力枚举起点 $s$，将 $1$ 的点串在一起，这样对于每个 $s$ 最多会跳 $\mathcal O(\frac{n}{B})$ 次。过程中我们直接统计长度为 $k$ 的倍数的个数。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,M=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,B;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> pre[N],sum[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    B=<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">    s[<span class="number">0</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pre[i]=pre[i<span class="number">-1</span>]+(s[i]==<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=B;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="built_in">sizeof</span>(sum));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> now=i*pre[j]-j+M;</span><br><span class="line">            ans+=sum[now];</span><br><span class="line">            sum[now]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pos=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;~i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ne[i]=pos;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)pos=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l=i,r=ne[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n/B&amp;&amp;j&lt;=pre[n]-pre[i];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            l=ne[l],r=ne[r];</span><br><span class="line">            <span class="type">int</span> resl=<span class="built_in">max</span>(l-i<span class="number">-1</span>,j*B),resr=r-i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(resl&lt;resr)ans+=resr/j-resl/j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>平衡规划</tag>
      </tags>
  </entry>
  <entry>
    <title>CF914H Ember and Storm&#39;s Tree Game</title>
    <url>/2023/10/24/CF914H-Ember-and-Storms-Tree-Game/</url>
    <content><![CDATA[<p>不错的 DP 题目。</p>
<span id="more"></span>
<p>首先容易发现，满足条件的序列一定是 单调 或者 单峰或单谷 的。并且我们都能够通过 两种不同操作 使其合法。</p>
<p>进一步地我们发现，假如所有编号大的点向编号小的点连边，确定了根之后。根的若干棵子树，边只会是外向或内向。而对于必胜状态的树，有 $n(n-1)$ 中方案可以选，设可行的树的方案为 $ans$，那么最后答案为 $2n(n-1)ans$。外向树和内向树方案数显然是一样的，哦我们下面不妨以内向树进行考虑。</p>
<p>于是考虑 DP，设 $f(i,j)$ 表示有考虑有 $i$ 个点组成的子树，根节点度数为 $j$。因为子节点之间是无序的，所以直接钦定当前最新的为次小，系数为 $\binom{i-2}{k-1}$。那么转移比较显然：</p>
<script type="math/tex; mode=display">
f(i,j)=\sum_{k=1}^{i-1}\binom{i-2}{k-1}f(i-k,j-1)\sum_{t=0}^{d-1}f_{k,t}</script><p>再考虑合并答案，即将 一棵内向树 和 一棵外向树拼接起来，不过他们公用一个根节点。并且注意到，若两棵树根的入度为 $1$，不同的树拼接起来，中间可能会产生一条链，这些链上的点都可以作为根节点，且只能算一种情况。但是注意到必然会存在度数大于 $1$ 的点，我们直接在这些点作为根节点的时候统计答案就可以了。    </p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,d,mod;</span><br><span class="line">ll C[N][N],f[N][N],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)C[i][j]=(C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,d,mod);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    sum[<span class="number">0</span>]=sum[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i<span class="number">-1</span>,d);j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;i;k++)</span><br><span class="line">                f[i][j]=(f[i][j]+<span class="number">1ll</span>*C[i<span class="number">-2</span>][k<span class="number">-1</span>]*f[i-k][j<span class="number">-1</span>]%mod*sum[k])%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=d<span class="number">-1</span>;j++)sum[i]=(sum[i]+f[i][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d1=<span class="number">0</span>;d1&lt;=d;d1++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> d2=<span class="number">0</span>;d1+d2&lt;=d;d2++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(d2==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                ans=(ans+f[i+<span class="number">1</span>][d1]*f[n-i][d2])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    ans=<span class="number">2ll</span>*n*(n<span class="number">-1</span>)%mod*ans%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1137E Train Car Selection</title>
    <url>/2023/11/14/CF1137E-Train-Car-Selection/</url>
    <content><![CDATA[<p>经典的凸包维护线段。</p>
<span id="more"></span>
<p>注意到操作是全体加上 一条斜率大于等于 $1$ 的线段，查询最小值及其位置，我们容易想到在凸包上考虑。具体地，从左到右有用的点的不仅 值 满足单调递减，与前一个形成的线段的斜率 也需要单调递减。直接维护下凸包。而对于全局加线段操作维护 全局标记 $sum_k,sum_b$。时间复杂度 $\mathcal O(m)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span> ;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;ll x,y;&#125;sta[N];</span><br><span class="line"><span class="type">int</span> n,m,top;</span><br><span class="line">ll sumk,sumb;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">f</span><span class="params">(<span class="type">const</span> Point &amp;now)</span></span>&#123;<span class="keyword">return</span> sumk*now.x+now.y+sumb;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    sta[top=<span class="number">1</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,k;</span><br><span class="line">        <span class="built_in">read</span>(op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)<span class="built_in">read</span>(k),sta[top=<span class="number">1</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,n+=k,sumk=sumb=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">read</span>(k);</span><br><span class="line">            Point now=&#123;n,-sumk*n-sumb&#125;;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">f</span>(sta[top]))</span><br><span class="line">                <span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;(<span class="built_in">f</span>(now)-<span class="built_in">f</span>(sta[top]))*(sta[top<span class="number">-1</span>].x-sta[top].x)</span><br><span class="line">                &gt;=(<span class="built_in">f</span>(sta[top<span class="number">-1</span>])-<span class="built_in">f</span>(sta[top]))*(now.x-sta[top].x))top--;</span><br><span class="line">            sta[++top]=now;</span><br><span class="line">            n+=k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="built_in">read</span>(b,k);</span><br><span class="line">            sumk+=k,sumb+=b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">f</span>(sta[top])&gt;=<span class="built_in">f</span>(sta[top<span class="number">-1</span>]))top--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,sta[top].x+<span class="number">1</span>,<span class="built_in">f</span>(sta[top]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>P6944 [ICPC2018 WF] Gem Island</title>
    <url>/2023/10/28/P6944-ICPC2018-WF-Gem-Island/</url>
    <content><![CDATA[<p>不错的 DP 题目，中间用 二项式反演 或者 min-max 容斥处理。加强版做法也比较厉害。</p>
<span id="more"></span>
<p>真的很厉害这道题，感觉学到了很多组合数技巧。</p>
<h2 id="普通版-n-d-le-500-r-le-n"><a href="#普通版-n-d-le-500-r-le-n" class="headerlink" title="普通版 $(n,d\le 500,r\le n )$"></a>普通版 $(n,d\le 500,r\le n )$</h2><p>设 $c_i$ 为最后每个人拥有的宝石。第 $i$ 个人拥有的第 $j$ 个宝石由前面 $j-1$ 个宝石分裂得到，所以方案为 $(c_i-1)!$。再考虑每天钦定分裂 哪个人的宝石，方案数为 $\displaystyle \binom{d}{c_1-1,c_2-1,\cdots,c_n-1}=\dfrac{d!}{\prod_{i}(c_i-1)!}$二者相乘，得到 $d!$。说明每种情况出现的次数都是 $d!$。我们只需要对每种情况前 $r$ 大的 $c_i$ 求和即可。</p>
<p>对于这种形式，我们容易想到使用分拆数 DP 进行求解。我们设计状态  $f(i,j)$ 表示最大的 $c_x$ 有 $i$ 个，总和为 $j$ 的方案数。我们每次枚举将最大的 $i$ 个 $c_x$ 中选取 $k$ 个加一。转移为：</p>
<script type="math/tex; mode=display">
\binom{i}{k}f(i,j)\to f(k,j+k)</script><p>我们还需要计算前 $r$ 大的和，继续设计状态 $g(i,j)$ 意义与 $f(i,j)$ 类似，但是表示表示前 $r$ 大 $c_x$ 之和。转移为：</p>
<script type="math/tex; mode=display">
\binom{i}{k}(g(i,j)+\min(r,k)\cdot f(i,j))\to g(k,j+k)</script><p>最终答案为 $\displaystyle \dfrac{\sum_i g(i,d)}{\sum_i f(i,d)}$。总的时间复杂度为 $\mathcal O(nd^2)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,d,r;</span><br><span class="line"><span class="type">double</span> C[N][N],f[N][N],g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)C[i][j]=C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,d,r);</span><br><span class="line">    <span class="built_in">init</span>(n+d);</span><br><span class="line">    f[n][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;d;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=i&amp;&amp;j+k&lt;=d;k++)</span><br><span class="line">                f[k][j+k]+=f[i][j]*C[i][k],g[k][j+k]+=(g[i][j]+<span class="built_in">min</span>(r,k)*f[i][j])*C[i][k];</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ans+=g[i][d];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>,ans/C[n+d<span class="number">-1</span>][n<span class="number">-1</span>]+r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>能不能再给力一点？</p>
<h2 id="加强版-n-d-le-1-5-times-10-7-r-le-n-p-998244353"><a href="#加强版-n-d-le-1-5-times-10-7-r-le-n-p-998244353" class="headerlink" title="加强版  $(n,d\le 1.5\times 10^7,r\le n ,p=998244353)$"></a><a href="https://loj.ac/p/3405">加强版</a>  $(n,d\le 1.5\times 10^7,r\le n ,p=998244353)$</h2><p>有两个 DP 数组不方便考虑，我们尝试到值上进行考虑。将 $c_i$ 的贡献拆成 $\sum_{j=1}^d[c_i\ge j]$。我们设 $f(i,j)$ 表示恰好有 $i$ 个数大于等于 $j$ 的方案书。最终答案为 $\displaystyle \sum_{i=1}^n \sum_{j=1}^d \min(i,d) f(i,j)$。</p>
<p>注意到“恰好”的限制，容易想到容斥。直接钦定 有 $i$ 个数大于等于 $j$，设为 $g(i,j)$，利用隔板法得到 $\displaystyle g(i,j)=\binom{n}{i}\binom{d-ij+n-1}{n-1}$。于是根据 $\displaystyle g(i,j)=\sum_{k=i}^n\binom{k}{i}f(k,j)$，直接二项式反演得到：</p>
<script type="math/tex; mode=display">
f(i,j)=\sum_{k=i}^n (-1)^{k-i} \binom{k}{i}g(k,j)</script><p>对答案简单推导：</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{i=1}^n \sum_{j=1}^d \min(i,r) f(i,j)\notag\\
=&\sum_{i=1}^n \sum_{j=1}^d \min(i,r) \sum_{k=i}^n (-1)^{k-i} \binom{k}{i}g(k,j)\notag\\
=&\sum_{i=1}^n \min(i,r) \sum_{k=i}^n (-1)^{k-i} \binom{k}{i}\sum_{j=1}^d g(k,j)\notag\\
\end{align}</script><p>对于每个 $k$ 与处理出 $h(k)=\sum_{j=1}^d g(k,j)$ 即可，时间复杂度可以做到 $\mathcal O(n^2)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,d,r;</span><br><span class="line"><span class="type">int</span> fac[N&lt;&lt;<span class="number">1</span>],ifac[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x+=y;x=x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)ifac[i<span class="number">-1</span>]=<span class="number">1ll</span>*ifac[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,d,r);</span><br><span class="line">    <span class="built_in">init</span>(n+d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;i*j&lt;=d;j++)</span><br><span class="line">            <span class="built_in">upd</span>(h[i],<span class="number">1ll</span>*<span class="built_in">C</span>(n,i)*<span class="built_in">C</span>(d-i*j+n<span class="number">-1</span>,n<span class="number">-1</span>)%mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> res=<span class="number">1ll</span>*<span class="built_in">C</span>(j,i)*h[j]%mod;</span><br><span class="line">            <span class="built_in">upd</span>(sum,(j-i&amp;<span class="number">1</span>)?mod-res:res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">upd</span>(ans,<span class="number">1ll</span>*<span class="built_in">min</span>(i,r)*sum%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">adj</span>(<span class="number">1ll</span>*ans*<span class="built_in">qpow</span>(<span class="built_in">C</span>(n+d<span class="number">-1</span>,n<span class="number">-1</span>))%mod+r));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>但是仍然不够优秀。$h(k)$ 中的组合数不好拆，但是注意到 $\displaystyle z(k)=\binom{d-k+n-1}{n-1},h(k)=\sum z(jk)$ ，于是直接用 Dirichlet 后缀和就可以求出 $h(k)$。</p>
<p>接下来直接枚举 $k$：</p>
<script type="math/tex; mode=display">
\sum_{k=i}^n (-1)^{k}  h(k) \sum_{i=1}^k \min(i,r) (-1)^{i} \binom{k}{i}</script><p>我们需要快速计算：</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{i=1}^k \min(i,r) (-1)^{i} \binom{k}{i}\notag\\
=&\sum_{i=1}^k\sum_{j=1}^{\min(i,r)}(-1)^{i} \binom{k}{i}\notag\\
=&\sum_{j=1}^r\sum_{i=j}^k (-1)^{i} \binom{k}{i}\notag\\
\end{align}</script><p>看起来比较困难，但还是可以做。考虑上指标反转 $\displaystyle \binom{n}{m} = (-1)^m \binom{m-n-1}{m}$。再利用斜求和 $\displaystyle \sum_{i=1}^k\binom{i+j}{i}=\binom{k+1+j}{k}$，得到：</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{j=1}^r\sum_{i=j}^k (-1)^{i} \binom{k}{i}\notag\\
=&\sum_{j=1}^r\sum_{i=j}^k (-1)^{2i} \binom{i-k-1}{i}\notag\\
=&\sum_{j=1}^r(\binom{(k+1)-k-1}{k}-\binom{j-k-1}{j-1})\notag\\

\end{align}</script><p>因为 $k&gt;0$，所以 $\binom{0}{k}=0$。然后再用一次上指标反转，得：</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{j=1}^r-\binom{j-k-1}{j-1}\notag\\
=&\sum_{j=1}^r-(-1)^{j-1}\binom{(j-1)-(j-k-1)-1}{j-1}\notag\\
=&\sum_{j=1}^r(-1)^{j}\binom{k-1}{j-1}\notag\\
\end{align}</script><p>这是一个与上面类似得求和，不停地使用上指标反转，得：</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{j=1}^r(-1)^{j}\binom{k-1}{j-1}\notag\\
=&-\sum_{j=0}^{r-1}(-1)^{j}\binom{k-1}{j}\notag\\
=&-\sum_{j=0}^{r-1}(-1)^{2j}\binom{j-(k-1)-1}{j}\notag\\
=&-\sum_{j=0}^{r-1}(-1)^{2j}\binom{j-k}{j}\notag\\
=&-\binom{r-k}{r-1}\notag\\
=&(-1)^r\binom{k-2}{r-1}\notag\\
\end{align}</script><p>于是这一部分可以直接 $\mathcal O(1)$ 计算。总的时间复杂度为 $\mathcal O(n+d\log\log d)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<p>*</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.5e7</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,d,r;</span><br><span class="line"><span class="type">int</span> fac[N&lt;&lt;<span class="number">1</span>],ifac[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> tot,prime[N];</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x+=y;x=x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])prime[++tot]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;<span class="number">1ll</span>*i*prime[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j]))<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)ifac[i<span class="number">-1</span>]=<span class="number">1ll</span>*ifac[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,d,r);</span><br><span class="line">    <span class="built_in">init</span>(n+d);</span><br><span class="line">    <span class="built_in">sieve</span>(<span class="built_in">max</span>(n,d));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=d;i++)h[i]=<span class="built_in">C</span>(d-i+n<span class="number">-1</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=tot;i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=d/prime[i];j;j--)</span><br><span class="line">            <span class="built_in">upd</span>(h[j],h[j*prime[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        h[i]=<span class="number">1ll</span>*h[i]*<span class="built_in">C</span>(n,i)%mod;</span><br><span class="line">        <span class="type">int</span> res=<span class="built_in">C</span>(i<span class="number">-2</span>,r<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)res=mod<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> res=(r&amp;<span class="number">1</span>?mod-res:res);</span><br><span class="line">        res=i&amp;<span class="number">1</span>?mod-res:res;</span><br><span class="line">        <span class="built_in">upd</span>(ans,<span class="number">1ll</span>*h[i]*res%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">adj</span>(<span class="number">1ll</span>*ans*<span class="built_in">qpow</span>(<span class="built_in">C</span>(n+d<span class="number">-1</span>,n<span class="number">-1</span>))%mod+r));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC010E] Rearranging</title>
    <url>/2023/11/30/AGC010E-Rearranging/</url>
    <content><![CDATA[<p>有点意思的构造。</p>
<span id="more"></span>
<p>首先考虑后手操作是怎样的，我们根据将不互质的数按照 在序列中的顺序，顺序靠前的向顺序靠后的连边。然后重新排序的过程就是一个拓扑排序。要使其字典序最大，我们使用优先队列即可。</p>
<p>接着考虑先手操作，还是在不互质的数之间进行连边，我们需要将边重新定向得到一个 DAG，使其拓扑序尽可能的小。一个简单的想法是，直接从最小的节点开始 dfs，每次走之后最小的没有被遍历的点，并且对这条边定向。最终我们得到一棵生成树，如何证明这颗生成树是最优的呢？只考虑生成树上的边最优性显然。一是返祖边，由于是要构造成DAG，所以不能存在环，于是由祖先连向后代，这样不影响原来的正确性；二是横叉边，由于两棵独立的子树内部都是最优的，意味着横叉边没有被选择是因为不够优，也不影响原来的最优性性。最终时间复杂度为 $\mathcal O(n^2\log V)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,M=<span class="number">4e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">bool</span> g[N][N],vis[N];</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M&lt;&lt;<span class="number">1</span>],ne[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x?<span class="built_in">gcd</span>(y%x,x):y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">    deg[v]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=n;y++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[y]&amp;&amp;g[x][y])</span><br><span class="line">            <span class="built_in">dfs</span>(y),<span class="built_in">add</span>(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!deg[i])q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[x]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(!--deg[y])q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            g[i][j]=g[j][i]=(<span class="built_in">gcd</span>(a[i],a[j])!=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2023 游记</title>
    <url>/2023/11/30/NOIP2023%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>太菜导致的结果。</p>
<span id="more"></span>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h2><p>下午的模拟赛，T1不会，被低一级同学薄纱了，并且部分分力也没打满。赛后看题解发现 T1 反而有点意思，看来不会做雀食是水平问题了。然后晚上去吃了 卤肉饭+KFC（yzx 请客 /bx）。中途交流了今天题目的做法。回机房忘记干了些啥了。回寝室睡觉比较早。</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>比较快乐的一天。</p>
<p>上午先打了会板子，但是这次都没用到。然后就是传统的 NOIP前 机房 generals 大赛，感觉高一的同学并不十分擅长，所以我赢的比较多，但是还是很快乐。剩下的时间都在耍。</p>
<p>中午一点的时候出发了，在车上听了一会歌，然后就是耍手机了。三点半左右到了，找到酒店之后，发现我TM手机放车上了，又只好麻烦师傅送一下。本来以为下午就留在酒店休息了，但是刘老师说去球馆打羽毛球，<del>并且报销</del>。于是打了一下午球，打得太爽了！！！没想到刘老师竟然要打羽毛球，而且打得很不错。打完感觉很累，甚至脚都磨破皮了。回到酒店吃了饭还有烧烤。然后下去买了红牛和白巧克力（据说有buff加成）。回酒店之后一起看了会电视。然后就开始了重点：我们开始交流考试策略，大概就是：<strong>T1做完之后，先尽可能多拿分，先不要一直想着过某个题，追求总分最大化</strong>。也算是为之后埋下伏笔了。</p>
<p>然后回房间，我跟 Eternity 一个房间，再看了会板子到十点。然后洗漱玩完准备睡觉。十点半躺床上，但是想了挺多的。之前也想过很多，大不了回去学文化课！有些话想说但还是算了。十一点左右就睡了，睡得比较不错。</p>
<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>早上六点生物钟就醒了，躺在床上睡不着了。六点五十去下面吃了早饭，比较饱。然后就去七中门口等了一会进去了，中间遇到了初中同学 sgc 还有 zyc，感觉雀食很久没见了，可惜没有和 zyc 打招呼。我草，七中教学楼装修怎么这么好啊。而且早就听说过机房里机子是高贵的 i7-13700K，牛逼。考前先去上了个厕所。然后进了考场试了试机子，怎么坐这么近，而且没有挡板啊。影响不大。但是很烦的一点是，放键盘的槽子里确实如 sgc 所说很阴间，用起来比较不爽，并且我那个位置线比较短，拉不上来。但还是在可以接受的范围内。</p>
<p>然后就开题了，T1先读了两遍题，<del>发现自己不会</del>，感觉可能是自己太紧张了，于是浏览了一遍后面的题：T2 图论？T3构造？T4数学或者DP？之后重新看T1，心态稳一点了。发现自己题看错了，然后开始写，简单手写了个 <code>string</code>，但是发现死活过不了第三个大样例。于是又重新读题，发现直接把 “<strong>任意多次</strong>“ 看漏了，淦。所幸和原来差不多。写完大概是九点过一会。</p>
<p>于是看T2，知道是图论，但是不知道怎么建图。当时不知道为啥在分层图卡了一下，感觉并不好做。于是回想起 NOIP2022 的惨痛教训，于是我直接选择<strong>先放弃 T2，去看 T3 T4</strong>。感觉 T3 有点意思但比较可做。<strong>“为啥感觉T4很简单啊？”</strong> ，内心os。</p>
<p>于是决定先做 T3，感觉问题转化后形式很简单，很可做，先编了 $\mathcal O(qn^2)$ 的朴素 DP 做法。然后立马跳到 T4，把 T4 的 $\mathcal O(n^2)$ DP写完。此时不知道是多久，但是我看到 T3 的特殊性质，感觉分好多啊，猜到与正解做法类似，但是继续想了一会，就会了一个线性的双指针做法，70pts 到手了。其实当时感觉自己已经会了这题了，但是还有应多细节没想出来，于是放弃马上继续做 T4。这个时候心态非常不错，觉得自己应该挺稳的。    维护了，再加上 性质 B 有 64 pts。当时觉得这分已经不错了，就没多想，直接开始搓线段树了。有那么一瞬间，我真的在想：“加个离散化行不？”，但是马上否定了：“NOIP T4 哪有真这么简单啊。”于是陆陆续续写加调了好一会。做完上述事情已经十二点了，红牛已经干完了，白巧就吃了两小块。这个时候觉得自己节奏非常不错，<strong>比较稳了</strong>。觉得 T2 跟去年一样应该比较困难，于是选择搓暴力，再写点部分分得了。最后结束的时候还在调部分分，但意识到会这档分已经能把这题切了。最后离场。</p>
<p>考完就遇到 Eternity，交流了一下子。这个时候已经略感不妙了。出来之后不想吃饭，于是回酒店收拾东西并且和其他同学交流了一下，<del>但是没人过题</del>。准备回绵阳。到的时候已经四点过了。回家之后马上去测了一下，云斗上是 100+20+75+56=251，T2 第二档部分分挂了，T4性质B 也挂了，但问题不大，还可以接受。然后就和 using 玩 CS2，我问他考得怎么样，他说不出意外应该 AK 了。此时感觉大寄。然后跟 Fly 交流了下，他说：“T2不 sb 题吗？”，不会就我不会 T2 吧？但似乎真是这样。但是管不了了，先玩 CS2。</p>
<h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>回学校了， 放东西的时候教练找我谈话了。告诉我的分数很尴尬，完全不能说好，总结了一下就是：T2 20pts有点太少了。我也有点郁闷，但是确实没办法啊：考场上确实没看出来 T2 很sb啊。关键 T2 还挂了 20pts。真的很难受，但是水平确实有问题啊——我如果有 Fly 的水平的话，早就 AK 了吧。害。</p>
<h2 id="Day-2-11"><a href="#Day-2-11" class="headerlink" title="Day 2 - 11"></a>Day 2 - 11</h2><p>补 whk。</p>
<h2 id="Day-12"><a href="#Day-12" class="headerlink" title="Day 12"></a>Day 12</h2><p>水平还是太次了。问了很多人，包括但不限于两位学长。但是无一例外都劝我学下去。我也想啊，但是翻盘真的有些困难，我只能到达 Fly 水平才能翻盘吧。而且 SC 单独命题，往年一直都很阴间，感觉很多学长莫名其妙就被送退役了。只希望出题人能够负点责任，有点同情心吧。其它只能尽人事了。</p>
<p>也算是新的开始吧，Liveddd。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2023 全题解</title>
    <url>/2023/11/30/NOIP2023-%E5%85%A8%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>最失败的一集。</p>
<span id="more"></span>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>将每个字符串内部的字符按照大小排序，从小到大和从大到小，然后前后缀维护一下其它串倒序的最小串，与当前串的正序比较一下即可。</p>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>先模拟出最后每个 $x’_i$ 与原来 $x_j$ 或 $T,F,U$ 的关系，然后用扩展域并查集判断即可。</p>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>个人感觉出的最好的一题，也是最有意思的一道题。</p>
<p>考虑到底要求什么。若 $x_i<y_j$ （$x_i>y_j$ 也可以，但两种情况几乎一样，我们只讨论一种）则称 $x_i$ 与 $y_j$ 匹配，$x_i$ 与 $y_j$ 被覆盖 。问题就相当于，对于每个 $x_i,y_j$，要么被覆盖，要么覆盖所有一部分与之匹配的。问是否存在一种方案，使得所有 $x_i,y_j$  都被覆盖了。</p>
<p>非常关键的一点是注意到奇怪的特殊性质，并且给了 70pts。不难联想到与正解可能有很大的关联。</p>
<p>考虑特殊性质，容易发现我们可以用 $x_n$ 覆盖 $y$ 一段后缀，或者用 $y_m$ 覆盖     $x$ 的一段后缀。考虑这样的一个算法：从前往后不断尝试用 $y_j$ 覆盖 $x_i$，如果不匹配的话那么将 $i$ 前移直到遇到第一个匹配的为之。这样做是线性的。</p>
<p>再考虑一般情况，很容易想到，将 $x$ 按照最小值 将 $y$ 按照最大值分别分为两部分，前面一段正着做，后面一段倒着做，那么就可以直接套用特殊性质的解法。最终的时间复杂度为 $\mathcal O(nq)$。实际代码比较简洁。</p>
<h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><p>傻逼DP，首先设计出状态 $f(i,j)$ 表示到第 $i$ 天时已经连续打卡了 $j$ 天，这样做前缀 max 一下是 $\mathcal O(n^2)$ 的。尝试优化，但是发现不太方便，于是重新设计状态 $f(i,j)$ 表示 第 $j$ 天到第 $i$ 天连续打卡。这样就很容易用维护区间加，求区间 max 的线段树维护了，时间复杂度 $\mathcal O((n+m)\log n)$。最后离散化一下就可以得到 $\mathcal O(m\log m)$ 的算法。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[ABC240Ex] Sequence of Substrings</title>
    <url>/2023/12/02/ABC240Ex-Sequence-of-Substrings/</url>
    <content><![CDATA[<p>对一些性质的观察。</p>
<span id="more"></span>
<p>考虑朴素的 DP，先将 $\frac{n(n-1)}{2}$ 个字串排序，然后设 $f(i,j)$ 表示对于前缀 $i$，最后一个选择的是 $s[j,i]$，转移类似于二位偏序，可以使用树状数组优化至 $\mathcal O(n^2\log n)$。</p>
<p>注意到一个性质，若最优方案中存在相邻两个串 $s_i,s_{i+1}$ 有 $|s_{i+1}|-|s_i|&gt;1$，那么显然可以将 $s_{i+1}$ 的长度调整至 $|s_i|+1$。那么所有答案串最长长度满足 $\frac{len(len+1)}{2}\le n$，即 $len\le \sqrt{2n}$，我们只用保留这样的串就可以了。最终时间复杂度为 $\mathcal O(n\sqrt{n}\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> PII=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2.5e4</span>+<span class="number">10</span>,B=<span class="number">320</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,lim;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,tr[N*B][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;pos[N*B];</span><br><span class="line">vector&lt;PII&gt;op;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;<span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))t[x]=<span class="built_in">max</span>(t[x],k);&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="type">int</span> res=<span class="number">0</span>;<span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x))res=<span class="built_in">max</span>(res,t[x]);<span class="keyword">return</span> res;&#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">1</span>,m=<span class="built_in">min</span>(n,x+lim<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> &amp;v=tr[u][s[i]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(!v)v=++tot;</span><br><span class="line">        pos[u=v].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    op.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:pos[x])op.<span class="built_in">push_back</span>(&#123;i,t.<span class="built_in">ask</span>(i-len)+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:op)t.<span class="built_in">add</span>(x.fi,x.se);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)<span class="keyword">if</span>(tr[x][i])<span class="built_in">dfs</span>(tr[x][i],len+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">    lim=<span class="built_in">sqrt</span>(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t.<span class="built_in">ask</span>(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP之后的闲话</title>
    <url>/2023/12/01/NOIP%E4%B9%8B%E5%90%8E%E7%9A%84%E9%97%B2%E8%AF%9D/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2a91fa843c675a22cd50ed8f4385aa9538498b5ec88f7c1c5e79fb724f345dc3">1b05e05313998e5f4de994245a1b63dc959222cf9050c799457b5a81f8eacc715c04f0834e4918f68ef22601534f6f023949ef514177d78c4cfde563cf059454e0333206699128ab8beefb88734ab9b970ef4100201a76800d3ecdd6e88885408f6e8d02e58d92a59ccbda1dbde7fe3130e45d000158835c59dd2a63a9a3097c2940a08a9b811c733bd0af542e20738a5e048efb843ada60ba911de4f58c59508a69bcf9b7e6122bc8500adafc3a68dda4f5d4dc133861c5c31f7e602a703fbe2016e490304d000b6e9dd925699c2784218b04ff2f5ebea3608eb4d19533da50cb035ed6142a66d7e3eb6e51a0fac103fa22cdc2bae34e75c3c68092e2b4052fb301c0725d1d1ebb399d500b5dfc4b76aae91e8b3a4c19c158520bc0dd44a0ee5818de7a881f3e32b7b60611c268b10b684d9e1eedf8643b794ff32f959dc441359f3c0abf1f4bac5084a6ec792a9044e31a5117e7bd69741252fec1702d555c5434e09124d9ecb82eb1199c8f18150f62f0ca9cd2c961742136a419b1247ecf4b1d8907a412e59192f76762ef4e45cde0843439562f611481955b7480a0066ce8dae11abb22c91023a457a493aaeca0da0a5e475807c6ee08c241aa86efdff57cda48eb2832569563a6d8b4b81dbcb92aeb378346c75a5d2f72f1761eb00778fd4f84e0036d375d817c53fe2823e9b770302d622732f60fd47dc6e683bef7915f41213691d2a3c85907cfff8a6c8095d96032c2fb5585a7b71e27ada2b2a81ab50ac9e7d481d27c54e1fd884818fd01a4b28539733c236f49e2df65a3699d4dc4d626a9f0927f562c0ec1c44f4b7fdfac82eac3ae7882e6abe8c37970da256580c00e6627fad213b311d050462ead7e59c1fc33e8644140dabab9689240142845ae6da4c899e1b7cfe00b39388ab219f86bb48b0f4fde189441368471114539f93bc7f7a1f3b9abf1b341df12bd76feff741fb1a09a51a75950c1b4d4c13a4e0b1dd99c0d9aae4e45be52cefd31ae54d05f13b4bad11c156252cc6a392584041162a071d5afc40e46b06673548dbbd2fbd9ee714cffc53d67aec5d8f8e61979d1d7f51c6d9819943a399ea3e460ac95f1999be2e5a1faf557a61bb97718db35fba5406c96bc7f2a87ac7b55a2238230eb6ad0b3808787d5877eb5a21658dd71973f70f3f09026fe6f1294127757d29b1e54976aecc39901b2a5a057b7a0b4d6476deda24b9286371d7eb973aa118205fee39210e4b4cf37314cf4e61b3fb1cbcc45b370a68f59680630498a62bddf0b5833db608327fcd2f8da435c293f862b163837b27f243c3104d4f055a04eabf5a7df8a3342e70ee6436b680319f568949cf3e0657b79f36d8027073334be593f92feee3027986c84fb9e7090bafa556497a536afb4cca4d9df000696629997a0eaea6e78b68bfb4de25d161bb17586327df3e5bb09945d2eed54d3442b10f76b37c25eb5fe3a87e96de95b477d1b60525a12bdb8cf3ee25e6b6faa2b108a3de9efd024fd617a6b71fcf979ae748e13ec69dac78f810b4694cfc219c1c8f06f2171c92ce46e14583e828cbc8f7491a7df0453ac19c90cafb53bb985640d45e244ae6f37bd16e432fc98ae8d15813f44230cb92717bb9d227ec6d665c3c0e6264967ebee8ffce88e36e0e06c1bff1833ce8d4520b9e33ae785d64cf5480260a9e6b453ef461abb5d35ebc2235e2318e3c014d8246afa3716a1721b4f3d3b8a1ca5a46057c17cf2572022c46f3ed5299f7676dd30b9e523856bddc25179750ef040716c9861fa4971f1185e4501972f451151f092d8f1e696d98fe8e715250613a5e855586a39f047b1261ee226eff191de5b4df5ff2fac54506c782b3a8fb43f79d6b85cf006f0efff6b1e0862ae8943c8259158f4ba17397bf03f86f859166ef34c6fded285fb895c4fdb5ebc07baf93a649949ce3b490a898c891cb9840e7d4d3f33fb6df921c8df6c4de8c7dd52d513111e5a032c491a89b3d193659116fd7316745ba260c1faf6250834975300b86c5691f7818e3f3495c73e268472ee4ea3a7a898449c6bb781e6dbc7fb83105c30d347114a16c474c31d2120d00abf22db3a15542ae7a371cc116dc2bd561364a5bed264985ecdf664725fb7926108885f80eeeb64e4465ac139bb93ddbf5c5d9f0255923541305cf90fb695d150b62bc60e5500b3af7e0c3ed2588018ac6f58574766215e1efebd400dcc9165f7ce24bb6f9c7cb45c096839b3b31af59b2243e3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">混乱</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>P5292 [HNOI2019] 校园旅行</title>
    <url>/2023/12/04/P5292-HNOI2019-%E6%A0%A1%E5%9B%AD%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<p>比较不错的图论题。</p>
<span id="more"></span>
<p>考虑一个暴力算法，设 $f(i,j)$ 表示 $i,j$ 之间是否存在回文路径。那么我们同时枚举包含端点 $i,j$ 的边，再向外扩展。这样做时间复杂度为 $\mathcal O(m^2)$ 的。但如果单次只枚举一条边的话可以做到 $\mathcal O(nm)$。</p>
<p>其实一个关键条件是答案可以不为简单路径。那么我们可以反复地走一条边以达到回文。最终路径由 $01(10),00,11$ 组成。那么我们只需要满足，这样的每一段都可以在不改变奇偶行的条件下进行扩展。</p>
<p>我们需要满足两边需要扩展的同色边奇偶性相同。奇偶性相同容易考虑<strong>二分图</strong>也具有这样的性质。我们将边分为同色和异色两类。我们还是按照暴力算法进行扩展，扩展的两条边显然应当属于同一类。我们分别考虑两类边：</p>
<ol>
<li>同色：将所有同色边连起来，判断得到的是否是二分图。如果是的话，我们只用保留其生成树，这样不会产生影响，然后直接扩展；如果不是的话那么说明必定存在奇环，我们可以通过绕奇环来改变奇偶性，于是在其生成树上任意一个点加一个自环就可以了。</li>
<li>异色：显然得到的一定是二分图，只用保留其生成树，然后直接扩展。</li>
</ol>
<p>这样我们边数就变为 $\mathcal O(n)$ 的了。最终时间复杂度为 $\mathcal O(n^2+m)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> PII=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>,M=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Gragh</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tot,head[N],ver[M&lt;&lt;<span class="number">1</span>],ne[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ver[++tot]=v;</span><br><span class="line">        ne[tot]=head[u];</span><br><span class="line">        head[u]=tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e,g;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="type">int</span> flag,vis[N];</span><br><span class="line"><span class="type">bool</span> ans[N][N];</span><br><span class="line">queue&lt;PII&gt;Q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">get</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;x=<span class="built_in">get</span>(x),y=<span class="built_in">get</span>(y),fa[x]=y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x]=col;</span><br><span class="line">    <span class="type">int</span> z=<span class="number">3</span>-col;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=e.head[x];i;i=e.ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e.ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(y,z);</span><br><span class="line">            g.<span class="built_in">add</span>(x,y),g.<span class="built_in">add</span>(y,x);</span><br><span class="line">            ans[x][y]=ans[y][x]=<span class="number">1</span>;</span><br><span class="line">            Q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[y]!=z)flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;a[i]),fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="keyword">if</span>(a[u]==a[v])e.<span class="built_in">add</span>(u,v),e.<span class="built_in">add</span>(v,u);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">get</span>(u)!=<span class="built_in">get</span>(v))g.<span class="built_in">add</span>(u,v),g.<span class="built_in">add</span>(v,u),<span class="built_in">merge</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(flag)g.<span class="built_in">add</span>(i,i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ans[i][i]=<span class="number">1</span>,Q.<span class="built_in">push</span>(&#123;i,i&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=Q.<span class="built_in">front</span>().fi,y=Q.<span class="built_in">front</span>().se;</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=g.head[x];i;i=g.ne[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=g.head[y];j;j=g.ne[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> u=g.ver[i],v=g.ver[j];</span><br><span class="line">                <span class="keyword">if</span>(!ans[u][v]&amp;&amp;a[u]==a[v])ans[u][v]=ans[v][u]=<span class="number">1</span>,Q.<span class="built_in">push</span>(&#123;u,v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">puts</span>(ans[u][v]?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>P8421 [THUPC2022 决赛] rsraogps</title>
    <url>/2023/12/04/P8421-THUPC2022-%E5%86%B3%E8%B5%9B-rsraogps/</url>
    <content><![CDATA[<p>有点套路的数据结构。</p>
<span id="more"></span>
<p>观察到询问的形式，很容易想到离线然后扫描线计算 $l\le i$ 的答案 $s_i$，答案为 $s_r-s_{l-1}$。</p>
<p>注意到关键性质，设 $a_l’=\odot_{i=l}^r a_i$，那么对于每个 $a_l’$，在整个扫描线的过程中只会被修改 $\log V$ 次。$b_l’,c_l’$ 同理。所以对于这一部分直接暴力修改即可。具体的，我们维护对于 $s_i=sum+val\times t$，$sum$ 为上一次修改的前缀和，$val$ 为当前值，$t$ 为时间戳，这样就很好维护了。时间复杂度 $\mathcal O(n\log n+m)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> uint=<span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> PII=pair&lt;uint,uint&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,M=<span class="number">5e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">uint a[N],b[N],c[N];</span><br><span class="line">uint sum[N],val[N],t[N],ans[M];</span><br><span class="line">vector&lt;PII&gt;q[N];</span><br><span class="line"><span class="function">uint <span class="title">gcd</span><span class="params">(uint x,uint y)</span></span>&#123;<span class="keyword">return</span> x?<span class="built_in">gcd</span>(y%x,x):y;&#125;</span><br><span class="line"><span class="function">uint <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> sum[x]+val[x]*(y-t[x]+<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l,r;i&lt;=m;i++)<span class="built_in">read</span>(l,r),q[r].<span class="built_in">push_back</span>(&#123;l,i&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j)</span><br><span class="line">        &#123;</span><br><span class="line">            uint na=a[j]&amp;a[j+<span class="number">1</span>],nb=b[j]|b[j+<span class="number">1</span>],nc=<span class="built_in">gcd</span>(c[j],c[j+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(na==a[j]&amp;&amp;nb==b[j]&amp;&amp;nc==c[j])<span class="keyword">break</span>;</span><br><span class="line">            a[j]=na,b[j]=nb,c[j]=nc;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[i]=<span class="built_in">get</span>(i<span class="number">-1</span>,i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            sum[j]=<span class="built_in">get</span>(j,i<span class="number">-1</span>);</span><br><span class="line">            val[j]=val[j<span class="number">-1</span>]+a[j]*b[j]*c[j];</span><br><span class="line">            t[j]=i;</span><br><span class="line">        &#125;<span class="keyword">while</span>(j&lt;i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:q[i])ans[x.se]=<span class="built_in">get</span>(i,i)-<span class="built_in">get</span>(x.fi<span class="number">-1</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>P9837 汪了个汪</title>
    <url>/2023/11/30/P9837-%E6%B1%AA%E4%BA%86%E4%B8%AA%E6%B1%AA/</url>
    <content><![CDATA[<p>很智慧的构造。</p>
<span id="more"></span>
<p>相当于我们要将 $\frac{n(n-1)}{2}$ 个数对 $(x,y)$ ，以一定方式放入给出的方格内。一个简单的想法是，将 $(x,y)$ 按照 $|x-y|$ 分类，再以一种加减交错的方式排在一起。按照 $|x-y|=i$ 分类之后，似乎正好与每一列的二元组的个数对应起来了。</p>
<p>更具体一点，我们对于每一个 $x$，构造 $x,x+1,x-1,x+2,x-2,\cdots$，直到不能构造为止。这样的形式恰好满足上面所有限制。最后按照序列长度排序即可。正确性看起来真的显然，但是确实很巧妙。</p>
<p>时间复杂度 $\mathcal O(n^2)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,t;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> rk[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i][<span class="number">1</span>]=i;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+j&gt;n)<span class="keyword">break</span>;</span><br><span class="line">            a[i][++cnt]=i+j;</span><br><span class="line">            <span class="keyword">if</span>(i-j&lt;<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            a[i][++cnt]=i-j;</span><br><span class="line">        &#125;</span><br><span class="line">        rk[cnt]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++,<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>))<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[rk[i]][j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>Ad-hoc</tag>
      </tags>
  </entry>
  <entry>
    <title>无法说再见</title>
    <url>/2023/12/05/%E6%97%A0%E6%B3%95%E8%AF%B4%E5%86%8D%E8%A7%81/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c07a01b7bba8054f720f798cadadaacabd5c20061072a5648a72b9fad20be76c">dab07b9c085d8da6d057e0b0ac8276d528f598d860256cc0ca2fa9cd1fc46d3ca0ac0b05f211d8b8bbd63a1f41f12182b5223e0137f235a1739980c1929c09be9bfc889005b5e23c052e99e63d4537b5743cda8375b1f17e47f274493c9f768d3fbf4683f733a2c0cf1cfc847c595b90a444ddef81f625114f85c4733b273da4f499b7d08b4a714bddf09276ebe955dd56007088fbd5c021d521ae611cd037d35c3e1f8528f0b5966cc4f8fa858b093efa24c7dff04c90242d0492c78f8a889fe5ba0b252372bee4ca776a4e75e086f735682325ea7cc8c04787689b9a6340d92955bc09b8c4124e40cadee7913eaa4f26cebdc7584f29dafb49edaed4b70c33121f70503a000b367b77330e977b4c2140eb4960508f7b3f4d004885c1adb0c43703546838d1d670b7a2d810b60ac244e367cedaa3a31052c46011bb16e7ea2786d40064b033e50523a9711b6844ee463078d6ff66a42f278f65abdcac07a8b33baa2ced9ea547f4ef333fa2187efaf8e16e41aec56b2b20a8d6781d3ee3ff3e4918bb085383d7dc58a64873ed3b0015cfb311e4dc2c253dd9130b406ec505ee186f5594188f6e138d9671bf635bebff25eeacc39c64720c997037a86b6d3177cf2050c4fc8d942545bb8ccaefb614cab2da6a80eb24aa0fb2d3acabc0ec607c71b4d141258cd3eb46d7d406416c892cf29b6a704ef0625694d2aaf0165579f4c8ad2be8acaaa60aacd9dd535f553c816ca83fdd66ec5a2bfa240470d6637d5bef6d32ffb84ceee6fa20c28889d0871dcd3f254a7126f0a86cd0107ecdf2035b7f09235b2b99b6a4ae0fced5da9bc1b90bd456aea72212dfcb4af0f364a55301d003ce446e36b66b039b8e6137a22f75bfbaa2681ac1b900d4b8cc466c921b3a6a3f763dae98efe4e68806ae69e898af8c5fd9e7dd2929c3c8290713bfc43f841c204049aeac276a34156b3835f086bcd28507fb9e4e90d40e5dbe51e65d36e375b91a80a1bae604f097d5718a7498920fffc4446b570e70dbd037ff6cfeca6e232b75147fe8c88ddd120bdb1721a38853f06ff76f232b3ceedcccdba3cd0820d8a9a7fcad16c0a87114d3d31e73c3f289f1593a899fb2a1a61592520c6c485d33cc7c87afb50f85fa24303b40ed2c5035fc08af9670786c41e809a4963b641ce3c6805df892d700c221fdfd95e1ccc2078d65a6edc7e913cf7c13f6a96271110333eb62d04c871726c4f5178d5bbbe1a7abb57c402d96148851d651794cdf080f2b5f701af35eecf3152d1fbcfffa698dcd69c8cfaff968b908090a23f799e1f547f9de7d05c23e36e380f9a1918257d00cb4f1c1e977194042174b873c0cb9ba9af042f6c9c52e10c8d13528db98de340c9bfc15a6bbf7a462bc1efe16360650f4dba1043b2ebb8206e7adecf3709c86f046188cb274bc859a797f5440a8ca6bbe81ccfca15532759eef94836eaef49273436dd4514383dc01bc800ef3df3cd446c4cc2dac0f9322a7dc5cef68d0a52426af91c17cdcadff2fc0affd10216481da43438874cc213c8694e77d8a48b93ab65e246cb7d4cf4bac6e1180d84efcc73f0c48cb2bbdb21d6e01e1d276a9209d96dddfeb0cb5525ea71282d027fd105b8234ca2572a7b21cef1939b2ca4642b546794f46d7d1bbd3fe6106511369d9a007c0389c5f39051c26f7bdb079b9897e6fbcd9aad8332990e31f0e614d005ebf42ae00d5590a73e617cbbe439a0a65f5ab436a9a7689e617a5fa87429790d0f21105543eea6072442e9b976fca0048d18721b37c543bc8b38291cbb7b12b3e235360c3f0965ec832765e1b9c3fc9f979f61c09fef593cee898d06beb4346fe853202762089898936d324cf6ff8fb3fe3febd33518934e382eb2cdab809b2568dcedc6262ebc729fc5d2434ecbb3191e4e6245d8bb088f14c18663a5af3ecef516d8dc9f92ca4acc30bee69555d50a4f12b243d0f7c7edcdc912da659a9cf56f1f46e59ced0d5def04f51e6c39947d6d410d987ee20185511d6dad55a8ec50debc0de46c01cc2cff5caf3fba4ee4059172f3a233d42f12b424960f308136fc27eec826f5514a5ceef4373b5ab21ee6308ad497329e469b65515630eb4517ff1adfd71ebc30b596091f60d765bbfd8d8a48953b12fcfe2522749990d8f2d6d9ad581a0a6ec47729f56694461bd789103</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Can't get you out of mind.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>P8994 [北大集训 2021] 经典游戏</title>
    <url>/2023/12/07/P8994-%E5%8C%97%E5%A4%A7%E9%9B%86%E8%AE%AD-2021-%E7%BB%8F%E5%85%B8%E6%B8%B8%E6%88%8F-1/</url>
    <content><![CDATA[<p>博弈论，以及处理树上邻域的技巧。</p>
<span id="more"></span>
<p>首先容易发现一个点的 SG 函数是其子树的最大深度，不妨设为 $f_i$，并且对于每个棋子都是一个独立的游戏，那么总的 SG 函数就是所有子游戏的异或和，设 $c_i$ 表示以 $i$ 作为根时，$c_x=\oplus[a_i\equiv 1\pmod 2] f_i$。于是得到放一个棋子的充要条件 $\max_i f_i&lt;c_x$。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
</search>
