<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[ABC242Ex] Random Painting</title>
    <url>/2023/03/24/ABC242Ex-Random-Painting/</url>
    <content><![CDATA[<p>很好的 min-max 容斥。</p>
<span id="more"></span>
<p>之前 ZR 考了原题，不会。于是就去学了 min-max 容斥，现在重新来看这道题。</p>
<p>设每个位置被覆盖的时间为 $t_i$，我们要求的是：</p>
<script type="math/tex; mode=display">
E(\max_{i\in S} t_i)</script><p>直接 min-max 容斥，得到：</p>
<script type="math/tex; mode=display">
E(\max_{i\in S} t_i)=\sum_{T\subseteq S} (-1)^{|T|+1} E(\min_{i\in T} t_i)</script><p>考虑求如何求 $\displaystyle E(\min_{i\in S} t_i)$，设有 $f(S)$ 个区间能够覆盖 $S$ 中任意一个位置，容易得到 $\displaystyle E(\min_{i\in S}t_i)=\frac{m}{f(S)}$，于是考虑用 DP 求出 $\displaystyle \sum_{f(S)=i} (-1)^{|S|+1}$。</p>
<p>设计状态 $f_{i,j}$ 表示上一个加的位置为 $i$ ，有 $j$ 个区间覆盖 $S\subseteq\{1,2,\dots,i\}$。转移时枚举新加的位置 $p$，与 $[i,p)$ 有交的区间都可以覆盖当前点集 $S’$。因为集合 $S$ 中只多选了一个点，转移时直接将容斥系数乘 $-1$ 即可。时间复杂度 $\mathcal O(n^2m)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> cnt[N][N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">read</span>(l,r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;l;j++)</span><br><span class="line">            cnt[j][l]++,cnt[j][r+<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            cnt[i][j]+=cnt[i][j<span class="number">-1</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=mod<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[i][j])<span class="keyword">continue</span>;</span><br><span class="line">            res=<span class="built_in">adj</span>(res+<span class="number">1ll</span>*m*<span class="built_in">qpow</span>(j)%mod*f[i][j]%mod);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i+<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">                f[k][j+cnt[i][k]]=<span class="built_in">adj</span>(f[k][j+cnt[i][k]]-f[i][j]+mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>数据加强到 $n,m\le 3000$ 呢？原来我们统计的是能覆盖的区间。方便起见，我们考虑统计不覆盖点集中任意点的的区间 $\displaystyle \sum_{f(S)=i} (-1)^{|S|+1}$（此处的朴素转移方程也是类似的。利用原来的定义也可以，只是稍显麻烦）。</p>
<p>设多项式 $f_i(x)$，其中 $[x_j]f_i(x)$，表示只考虑 $[1,i]$，其中有 $j$ 个区间不覆盖点集中任意点的方案数。我们对于每个区间 $[l,r]$ 枚举其右端点，分别考虑。发现未加入该区间时有转移 $\displaystyle f_r(x)=(-1)\times\sum_{1\le i&lt;r} f_i(x)$，而加入一个新的区间，就会有 $1\le i\le l-1$，从 $[x_j]f_{i}$ 转移到 $[x_{j+1}]f’_i$ 上，即为 $\displaystyle f_i(x)=f’_i(x)\times x$。用线段树维护这个转移，具体可看看代码。时间复杂度 $\mathcal O(nm\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e3</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">poly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line">    poly <span class="keyword">operator</span>+(<span class="type">const</span> poly &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        poly res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">            res.a[i]=<span class="built_in">adj</span>(a[i]+t.a[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    poly sum;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].sum=tr[x&lt;&lt;<span class="number">1</span>].sum+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=k;i--)tr[x].sum.a[i]=tr[x].sum.a[i-k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)tr[x].sum.a[i]=<span class="number">0</span>;</span><br><span class="line">    tr[x].tag+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[x].tag)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag),<span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">add</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">add</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos,<span class="type">const</span> poly &amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l==tr[x].r)<span class="keyword">return</span>  tr[x].sum=k,<span class="built_in">void</span>();</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,pos,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">read</span>(l,r);</span><br><span class="line">        v[r].<span class="built_in">push_back</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,n);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">0</span>,(poly)&#123;mod<span class="number">-1</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        poly res=tr[<span class="number">1</span>].sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:v[i])<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">0</span>,j<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)res.a[j]=mod-res.a[j];</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,i,res);</span><br><span class="line">    &#125;</span><br><span class="line">    poly res=tr[<span class="number">1</span>].sum;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*res.a[i]*<span class="built_in">qpow</span>(m-i)%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1ll</span>*ans*m%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>容斥</tag>
        <tag>min-max 容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC043B] 123 Triangle</title>
    <url>/2022/09/19/AGC043B-123-Triangle/</url>
    <content><![CDATA[<p> mydcwfy 提供的题目。</p>
<span id="more"></span>
<p>很显然对于 $n&gt;1$ 的情况答案一定不为 $2$，特判即可。其他情况我们先做一次操作。</p>
<p>接着我们手动模拟，大胆猜测：若序列中有 $1$，则答案一定不为 $2$。似乎也比较显然，因为只要 $1$ 与 $2$ 在操作过程中相遇，那么 $2$ 就会被消掉，而 $1$ 并不会。对于只有 $2$ 的情况，我们可以把整个序列 $\div 2$ 就和 $0-1$ 序列的情况一样了，最后答案 $\times 2$ 即可。</p>
<p>实际上我们只需要判断答案奇偶，操作也变成了模 $2$ 意义下的。比较重要的是：$f_{k,x}=f_{k-1,x}-f_{k-1,x-1}=f_{k-1,x}+f_{k-1,x-1} \mod 2$。这很像组合数，我们进一步可以得到：$f_{n,1}=\sum_{i=1}^{n} a_i \cdot \binom{n-1}{i-1} \mod 2$。使用 Lucas 定理或者 <code>[n&amp;m==m]</code> 判断奇偶都可以。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;<span class="keyword">return</span> (n&amp;m)==m;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=<span class="built_in">abs</span>(a[i]-a[i+<span class="number">1</span>]),flag|=(a[i]==<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            a[i]&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    flag^=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans^=<span class="built_in">C</span>(n<span class="number">-1</span>,i<span class="number">-1</span>)*(a[i]&amp;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans&lt;&lt;flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1606F Tree Queries</title>
    <url>/2023/05/06/CF1606F-Tree-Queries/</url>
    <content><![CDATA[<p>记一个看似暴力但是比较巧妙的解法。</p>
<span id="more"></span>
<p>设 $f_{x,k}$ 表示当删点代价为 $k$，以 $x$ 为根的子树能得到的答案。容易列出状态转移方程 $f_{x,k}\gets \max(1,f_{y,k}-k)$。显然 $f_{y,k}&gt;k$ 的时候节点 $y$ 才可能被选择。所以当 $k$ 越大时，有用的状态更少。</p>
<p>固定 $k$ 来研究有用的状态数。我们根据状态的转移将原树划分成若干棵森林。这些森林除了叶子之外，其它都是有用的状态。考虑森林中任意一个大小为 $m$ 的树。仔细观察每从叶子往上走，每有一个有用状态答案都会减少 $k$。那么有用的状态数最多为 $\lfloor \frac{m}{k} \rfloor$，对于原树而言有用的状态数就最多为 $\lfloor \frac{n}{k} \rfloor$。那么对于所有的 $k$，有用的状态数的总和为 $\displaystyle \sum_{k=1}^n \lfloor n/k \rfloor$。这就是个调和级数，于是总的状态数为 $\mathcal O(n\ln n)$。</p>
<p>于是我们直接暴力 DP 就好了，过程中只保留有用的状态即可。时间复杂度与空间复杂度均为 $\mathcal O(n\ln n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt[N],si[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        si[x]++;</span><br><span class="line">        cnt[x]=<span class="built_in">max</span>(cnt[x],cnt[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[x]=<span class="built_in">max</span>(cnt[x],si[x]<span class="number">-1</span>);</span><br><span class="line">    f[x].<span class="built_in">resize</span>(cnt[x]+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=cnt[x];i++)f[x][i]=si[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=cnt[y];j++)</span><br><span class="line">            f[x][j]+=<span class="built_in">max</span>(<span class="number">0</span>,f[y][j]-j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;cnt[x]&amp;&amp;f[x][i]&gt;=i+<span class="number">1</span>)i++;</span><br><span class="line">    cnt[x]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,k;</span><br><span class="line">        <span class="built_in">read</span>(x,k);</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=f[x].<span class="built_in">size</span>()<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[x][k]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,si[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1616G Just Add an Edge</title>
    <url>/2023/01/26/CF1616G-Just-Add-an-Edge/</url>
    <content><![CDATA[<p>妙妙图论题。</p>
<span id="more"></span>
<p>*3500 的牛逼题。</p>
<p>如果原图已有哈密顿回路，那么一定是 $1\to 2\to \dots \to n$，这种情况下的答案为 $\binom{n}{2}$。</p>
<p>考虑更一般的情况，发现添加返祖边 $(v,u)$ 的哈密顿回路一定形如：</p>
<script type="math/tex; mode=display">
1\overset{+1}{\longrightarrow}u-1\to \dots \to v\to u\to \dots \to v+1\overset{+1}{\longrightarrow}n</script><p>这是因为在经过之后 $u-1$ 之后是不能回到 $&lt;u$ 的点的。问题转化为，找到不交的 $1\to v$ 与 $u\to n$ ，并且两条路径覆盖 $\{1,\dots, n\}$。 </p>
<p>我们新建 $0,n+1$ 两个点，并分别 $0$ 向所有点连边，所有点向 $n+1$ 连边，这样回路的起点与终点就固定了， 方便计算。</p>
<p>考虑暴力做法，考虑枚举 $u$ 然后进行 DP，设 $f_{x,0/1}$ 表示当前点分别在两条链上是否有合法方案。只考虑，前一个点与当前点所在的不同即可。得到 $\mathcal O(n^2)$ 做法。</p>
<details class="failure"><summary><i class="fa fa-times fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.5e5</span>+<span class="number">10</span>,M=<span class="number">1.5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">int</span> pre[N],suf[N];</span><br><span class="line"><span class="type">bool</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> flag[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;rev[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rev[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)rev[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="built_in">add</span>(<span class="number">0</span>,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="built_in">add</span>(i,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="keyword">if</span>(u+<span class="number">1</span>==v)flag[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    flag[<span class="number">1</span>]=flag[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">0</span>,suf[n+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)pre[i]=flag[i]?pre[i<span class="number">-1</span>]:i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;~i;i--)suf[i]=flag[i+<span class="number">1</span>]?suf[i+<span class="number">1</span>]:i;</span><br><span class="line">    <span class="keyword">if</span>(!pre[n+<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*n*(n<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=suf[<span class="number">0</span>]+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:rev[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">                    f[j][t]|=((suf[v+<span class="number">1</span>]&gt;=j<span class="number">-1</span>)&amp;f[v+<span class="number">1</span>][t^<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=pre[n+<span class="number">1</span>];j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            ans+=f[j][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(suf[<span class="number">0</span>]+<span class="number">1</span>==pre[n+<span class="number">1</span>])ans--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

</details>
<p>注意到关键性质，如果原图没有哈密顿回路的话，一定存在一个最小的 $p$，满足 $p$ 未向 $p+1$ 连边，于是 $p+1$ 将哈密顿回路分割成两部分 $[0,p+1],[p+2,n+1]$。转移的过程中不会跨过 $p+1$，所以这两个部分是相互独立的。于是我们可以分开计算，再将两段合并即可。但是注意到可能会出现 $f_{u,0}=f_{u,1}=f_{v,0}=f_{v,1}=1$ ，按照上述计算方式会被算两次，但实际上只存在一种连边方式，对于这一部分注意减掉就好了。</p>
<p>似乎比较好写但是还是要注意很多细节，所以必须要清楚 DP 数组的具体含义。具体也可以看看代码：</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.5e5</span>+<span class="number">10</span>,M=<span class="number">1.5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> p,q;</span><br><span class="line"><span class="type">int</span> pre[N],suf[N];</span><br><span class="line"><span class="type">bool</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> flag[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;rev[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rev[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)rev[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="built_in">add</span>(<span class="number">0</span>,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="built_in">add</span>(i,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);    </span><br><span class="line">        <span class="keyword">if</span>(u+<span class="number">1</span>==v)flag[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    flag[<span class="number">1</span>]=flag[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">0</span>,suf[n+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)pre[i]=flag[i]?pre[i<span class="number">-1</span>]:i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;~i;i--)suf[i]=flag[i+<span class="number">1</span>]?suf[i+<span class="number">1</span>]:i;</span><br><span class="line">    <span class="keyword">if</span>(!pre[n+<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*n*(n<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    p=suf[<span class="number">0</span>],q=pre[n+<span class="number">1</span>];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    f[p+<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:rev[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">                f[i][t]|=((suf[v+<span class="number">1</span>]&gt;=i<span class="number">-1</span>)&amp;f[v+<span class="number">1</span>][t^<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>;~i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:rev[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">                f[v+<span class="number">1</span>][t]|=((suf[v+<span class="number">1</span>]&gt;=i<span class="number">-1</span>)&amp;f[i][t^<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> lcnt,rcnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">2</span>;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        lcnt=<span class="number">0</span>,rcnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=p+<span class="number">1</span>;i++)lcnt+=f[i][t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=q;i&lt;=n+<span class="number">1</span>;i++)rcnt+=f[i][t];</span><br><span class="line">        ans+=<span class="number">1ll</span>*lcnt*rcnt;</span><br><span class="line">    &#125;</span><br><span class="line">    lcnt=<span class="number">0</span>,rcnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=p;i++)lcnt+=f[i][<span class="number">0</span>]&amp;f[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q;i&lt;=n+<span class="number">1</span>;i++)rcnt+=f[i][<span class="number">0</span>]&amp;f[i][<span class="number">1</span>];</span><br><span class="line">    ans-=<span class="number">1ll</span>*lcnt*rcnt;</span><br><span class="line">    <span class="keyword">if</span>(p+<span class="number">1</span>==q)ans--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1616H Keep XOR Low</title>
    <url>/2023/03/16/CF1616H-Keep-XOR-Low/</url>
    <content><![CDATA[<p>Trie 树上进行 01 分治。</p>
<span id="more"></span>
<p>感觉之前也考类似的题，于是记一下。</p>
<p>显然按照每一位进行考虑，将 Trie 树建出来。我们设置函数 $f(x,y,i)$ 表示前 $i-1$ 位的限制全部卡满，在 $x$ 节点与 $y$ 节点上分别选取两个子集，两个子集之间的元素满足 $x_i\oplus y_i\le k$，考虑当前位：</p>
<ol>
<li>第 $i$ 位为 $0$，那么 $x,y$ 必须选取同一侧的子树，即 $f(x_0,y_0,i-1),f(x_1,y_1,i-1)$。再加上 $x,y$ 分别在各自子树之中可以任意选的方案（因为前面的位数都会变成 $0$，对第 $i$ 位就没有限制了）。</li>
<li>第 $i$ 位为 $1$，那么 $x,y$ 选同侧的话，就不需要满足被卡满的限制，不符合我们的定义，我们是一定要卡满的，所以不需要递归下去计算，因为这种情况的贡献会在当前节点产生。而我们需要走 $x,y$ 的异侧。并且容易发现 $f(x_0,y_1),f(x_1,y_0)$ 之间是相互独立的，意思是 $x_0,x_1$ 之间与 $y_0,y_1$ 之间是没有限制的（两个都选相当于走同侧），两种情况的贡献就算在一起了，所以直接就是 $f(x_0,y_1)\times f(x_1,y_0)$。</li>
</ol>
<p>每个节点只会被计算一次，时间复杂度 $\mathcal O(n\log V)$，其中 $V$ 为值域。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.5e5</span>+<span class="number">10</span>,K=<span class="number">30</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,ch[N&lt;&lt;<span class="number">5</span>][<span class="number">2</span>],si[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">1</span>;si[u]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> v=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][v])ch[u][v]=++tot;</span><br><span class="line">        si[u=ch[u][v]]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x=<span class="number">1</span>,<span class="type">int</span> y=<span class="number">1</span>,<span class="type">int</span> i=<span class="number">30</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y)<span class="keyword">return</span> p[si[x]+si[y]];</span><br><span class="line">    <span class="keyword">if</span>(!(x^y))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!~i)<span class="keyword">return</span> p[si[x]];</span><br><span class="line">        <span class="keyword">if</span>(k&gt;&gt;i&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">solve</span>(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>],i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">adj</span>(<span class="built_in">solve</span>(ch[x][<span class="number">0</span>],ch[x][<span class="number">0</span>],i<span class="number">-1</span>)+<span class="built_in">solve</span>(ch[x][<span class="number">1</span>],ch[x][<span class="number">1</span>],i<span class="number">-1</span>)<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!~i)<span class="keyword">return</span> p[si[x]+si[y]];</span><br><span class="line">    <span class="keyword">if</span>(k&gt;&gt;i&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1ll</span>*<span class="built_in">solve</span>(ch[x][<span class="number">0</span>],ch[y][<span class="number">1</span>],i<span class="number">-1</span>)*<span class="built_in">solve</span>(ch[x][<span class="number">1</span>],ch[y][<span class="number">0</span>],i<span class="number">-1</span>)%mod;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">adj</span>(<span class="built_in">adj</span>(<span class="built_in">solve</span>(ch[x][<span class="number">0</span>],ch[y][<span class="number">0</span>],i<span class="number">-1</span>)+<span class="built_in">solve</span>(ch[x][<span class="number">1</span>],ch[y][<span class="number">1</span>],i<span class="number">-1</span>)<span class="number">-1</span>)+</span><br><span class="line">    <span class="built_in">adj</span>(<span class="number">1ll</span>*(p[si[ch[x][<span class="number">0</span>]]]<span class="number">-1</span>)*(p[si[ch[x][<span class="number">1</span>]]]<span class="number">-1</span>)%mod+<span class="number">1ll</span>*(p[si[ch[y][<span class="number">0</span>]]]<span class="number">-1</span>)*(p[si[ch[y][<span class="number">1</span>]]]<span class="number">-1</span>)%mod));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)p[i]=<span class="built_in">adj</span>(p[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>CF348D Turtles</title>
    <url>/2023/04/17/CF348D-Turtles/</url>
    <content><![CDATA[<p>经典题。</p>
<span id="more"></span>
<p>容易发现两条不相交的路径一定是 $(1,2)\to (n-1,m)$ 和 $(2,1)\to (n,m-1)$。但是这只具有充分性，似乎并没有什么帮助。</p>
<p>这个时候巧妙的来了，我们发现 $(1,2)\to (n,m-1)$ 与 $(2,1)\to (n-1,m)$ 是一定有交的。并且每一种方案恰好对应着原来 $(1,2)\to (n-1,m)$ 和 $(2,1)\to (n,m-1)$ 有交的一种方案（在每个交点改变两条路径连向就可以得到原来有交的一种方案）。于是直接减去这一部分就得到了没有交的路径方案数。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[x1][y1]=a[x1][y1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x1;i&lt;=x2;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=y1;j&lt;=y2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((i==x1&amp;&amp;j==y1)||!a[i][j])<span class="keyword">continue</span>;</span><br><span class="line">            f[i][j]=<span class="built_in">adj</span>(f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x2][y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch[N];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)a[i][j]=(ch[j]==<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">adj</span>(<span class="number">1ll</span>*<span class="built_in">calc</span>(<span class="number">1</span>,<span class="number">2</span>,n<span class="number">-1</span>,m)*<span class="built_in">calc</span>(<span class="number">2</span>,<span class="number">1</span>,n,m<span class="number">-1</span>)%mod<span class="number">-1ll</span>*<span class="built_in">calc</span>(<span class="number">1</span>,<span class="number">2</span>,n,m<span class="number">-1</span>)*<span class="built_in">calc</span>(<span class="number">2</span>,<span class="number">1</span>,n<span class="number">-1</span>,m)%mod+mod));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>容斥</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF708C Centroids</title>
    <url>/2022/10/17/CF708C-Centroids/</url>
    <content><![CDATA[<p>有一点思维的换根DP。</p>
<span id="more"></span>
<p>如果一个点不是重心，我们则考虑将它其中某一个子树断开在接到这个节点上。于是我们需要在以该节点为根的树中，找一个 $size\le {n\over2}$ 的最大子树。</p>
<p>接下来很容易想到换根 DP。注意到换根时 $f_x$ 的决策点可能就是 $y$。还应该维护预处理次大值。</p>
<p>随便放个代码。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tot,head[maxn],ver[<span class="number">2</span>*maxn],ne[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="type">int</span> si[maxn],d[maxn][<span class="number">2</span>],f[maxn],pre[maxn],maxsize[maxn];</span><br><span class="line"><span class="type">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(to,x);</span><br><span class="line">        si[x]+=si[to];</span><br><span class="line">        <span class="keyword">if</span>(si[to]&gt;si[maxsize[x]])maxsize[x]=to;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">if</span>(si[to]&lt;=n/<span class="number">2</span>)v=si[to];</span><br><span class="line">        <span class="keyword">else</span> v=d[to][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(d[x][<span class="number">0</span>]&lt;v)</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">1</span>]=d[x][<span class="number">0</span>];</span><br><span class="line">            d[x][<span class="number">0</span>]=v;</span><br><span class="line">            pre[x]=to;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[x][<span class="number">1</span>]&lt;v)d[x][<span class="number">1</span>]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(si[maxsize[x]]&gt;n/<span class="number">2</span>) ans[x]=(si[maxsize[x]]-d[maxsize[x]][<span class="number">0</span>]&lt;=n/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n-si[x]&gt;n/<span class="number">2</span>) ans[x]=(n-si[x]-f[x]&lt;=n/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=ver[i];</span><br><span class="line">		<span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">		<span class="keyword">if</span>(n-si[x]&gt;n/<span class="number">2</span>)v=f[x];</span><br><span class="line">		<span class="keyword">else</span> v=n-si[x];</span><br><span class="line">		f[to]=<span class="built_in">max</span>(f[to],v);</span><br><span class="line">		<span class="keyword">if</span>(pre[x]==to)f[to]=<span class="built_in">max</span>(f[to],d[x][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">else</span> f[to]=<span class="built_in">max</span>(f[to],d[x][<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">dfs</span>(to,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>换根DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF671D Roads in Yusland</title>
    <url>/2023/01/04/CF671D-Roads-in-Yusland/</url>
    <content><![CDATA[<p>线段树合并优化 DP。</p>
<span id="more"></span>
<p>考虑与 NOI2020D1T2 命运 类似的方法，设计状态 $f_{x,i}$ 为以 $x$ 为根的子树中的边全部被覆盖，并且被覆盖的路径向上延伸至深度为 $i$ 的节点，所需要的最小花费。状态转移方程：$f_{x,i}=f_{x,i}+ \min_{j\ge i} \{f_{y,j},f_{y,i}\}+\min_{j\ge i}{f_{x,j}}$。这个方程中两边状态都与下标 $i$ 相同 ，并且信息也是线段树好维护的，于是可以用线段树合并来优化。</p>
<p>注意一些细节。（<del>笔者因为不咋写动态开点误将</del> <code>ql,qr</code>  <del>写成</del> <code>l,r</code> <del>调了将近一天，敲个警钟</del>）。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ll INF=<span class="number">1e16</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    ll val,tag;</span><br><span class="line">&#125;tr[N*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt,rt[N],d[N];</span><br><span class="line"><span class="type">int</span> top,sta[N*<span class="number">20</span>];</span><br><span class="line">vector&lt;Edge&gt;vec[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sta[++top]=x;</span><br><span class="line">    tr[x].lc=tr[x].rc=<span class="number">0</span>;</span><br><span class="line">    tr[x].val=INF,tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top)<span class="keyword">return</span> sta[top--];</span><br><span class="line">    tr[++cnt].val=INF;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val=<span class="built_in">min</span>(tr[tr[x].lc].val,tr[tr[x].rc].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val+=k,tr[x].tag+=k;</span><br><span class="line">    tr[x].val=<span class="built_in">min</span>(tr[x].val,INF);</span><br><span class="line">    tr[x].tag=<span class="built_in">min</span>(tr[x].tag,INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[x].tag)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">update</span>(tr[x].lc,tr[x].tag);</span><br><span class="line">    <span class="built_in">update</span>(tr[x].rc,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)x=<span class="built_in">newnode</span>();</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].val=<span class="built_in">min</span>(tr[x].val,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(tr[x].lc,l,mid,pos,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||(l&gt;=ql&amp;&amp;r&lt;=qr))<span class="keyword">return</span> tr[x].val;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll res=INF;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(tr[x].lc,l,mid,ql,qr));</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(tr[x].rc,mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r,ll resx,ll resy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x&amp;&amp;!y)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!x)<span class="keyword">return</span> <span class="built_in">update</span>(y,resx),y;</span><br><span class="line">    <span class="keyword">if</span>(!y)<span class="keyword">return</span> <span class="built_in">update</span>(x,resy),x;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].val=<span class="built_in">min</span>(&#123;tr[x].val+resy,tr[y].val+resx,INF&#125;);</span><br><span class="line">        <span class="built_in">del</span>(y);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x),<span class="built_in">pushdown</span>(y);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[x].lc=<span class="built_in">merge</span>(tr[x].lc,tr[y].lc,l,mid,resx,resy);</span><br><span class="line">    tr[x].rc=<span class="built_in">merge</span>(tr[x].rc,tr[y].rc,mid+<span class="number">1</span>,r,resx,resy);</span><br><span class="line">    <span class="built_in">del</span>(y);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        flag=<span class="number">1</span>,d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(!rt[x])</span><br><span class="line">        &#123;</span><br><span class="line">            rt[x]=rt[y];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll resx=<span class="built_in">query</span>(rt[x],<span class="number">1</span>,n,<span class="number">1</span>,d[x]),resy=<span class="built_in">query</span>(rt[y],<span class="number">1</span>,n,<span class="number">1</span>,d[x]);</span><br><span class="line">        rt[x]=<span class="built_in">merge</span>(rt[x],rt[y],<span class="number">1</span>,n,resx,resy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)<span class="built_in">modify</span>(rt[x],<span class="number">1</span>,n,d[x],<span class="number">0</span>);</span><br><span class="line">    ll res=<span class="built_in">query</span>(rt[x],<span class="number">1</span>,n,<span class="number">1</span>,d[x]);</span><br><span class="line">    <span class="keyword">if</span>(res&gt;=INF)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:vec[x])</span><br><span class="line">        <span class="built_in">modify</span>(rt[x],<span class="number">1</span>,n,d[y.v],res+y.w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">read</span>(x,y,z);</span><br><span class="line">        vec[x].<span class="built_in">push_back</span>(&#123;y,z&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>,tr[<span class="number">0</span>].val=INF;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ll ans=<span class="built_in">query</span>(rt[<span class="number">1</span>],<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans&gt;=INF)?<span class="number">-1</span>:ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>整体DP</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2022 全题解</title>
    <url>/2023/03/10/CSP-S-2022-%E5%85%A8%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>隔了好久好久。。。</p>
<span id="more"></span>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>题意：给定 $n$ 个点 $m$ 条边的无向图，每个点上有权值 $v_i$，现在从点 $1$ 走到另外 $4$ 个点再返回点 $1$，要求另外点与点之间的路程需小于等于 $k+1$，求另外四个点的权值和最大值。$n\le 2500,m\le 10000$。</p>
<p>乱搞，考虑处理出每个点在 $k+1$ 步内能到达的所有点，以及这些点中的最大值，亚大值，次大值。然后枚举中间两个点即可。时间复杂度 $\mathcal O(nm+n^2)$。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>题意：给定两个长度分别为 $n,m$ 数组 $A,B$，有 $q$ 次询问 $l_1,r_1,l_2,r_2$，表示在小 L 先在数组 $A$ 的 $[l_1,r_1]$ 中选一个数 $a_x$，小 Q 再在数组 $B$ 的 $[l_2,r_2]$ 中选一个数 $b_y$，每一轮的得分为 $a_x\times b_y$ 。小 L 想使得分最大，小 Q 想使其最小。两人都是足够聪明的玩家，每次都会采用最优的策略。求得分是多少。$n,m,q\le 10^5$。</p>
<p>注意到是小 L 先选，小 Q 后选，很容易根据正负关系分类讨论，接着用 ST 表或者线段树维护即可，此处不再赘述。时间复杂度 $\mathcal O(n\log n+q\log n)$，此处视 $n,m$ 同阶。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>题意：给定 $n$ 个点 $m$ 条边的有向图，有 $q$ 次操作，操作有 $4$ 种类型：1.禁用边  $(u,v)$；2.禁用 $u$ 所有的入边；3.激活边  $(u,v)$；4.激活 $u$ 所有的入边。要求判断每次操作后的图是否为一棵基环树。</p>
<p>判断基环树即为判断每个点是否有且仅有一条出边。显然合法的入边总数应当为 $n$，即满足 $\displaystyle \sum_{i=1}^n in_i=n$。但是这样显然很大可能有多组解。于是尝试 Hash 一下。</p>
<p>尝试赋给每个点一个随机权值 $v_i$，并且使 $\displaystyle in_i=\sum_{(j,i)\in E} v_j$，现在我们只需要判断其是否满足 $\displaystyle \sum_{i=1}^{n} in_i=\sum_{i=1}^n k_i v_i=\sum_{i=1}^{n} v_i$。因为这个方程极大可能只有一组解 $k_1=1,k_2=1\dots k_n=1$。并且对于修改操作，我们只需要简单维护 $in_i$ 即可。时间复杂度 $\mathcal O(n+q)$。</p>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>题意：给定一棵 $n$ 个节点的树，每个点上有权值 $v_i$。给定常数 $k$，有 $q$ 次询问 $u,v$，对于一条路径 $p_1\to \dots \to p_w,p_1=u,p_w=v$，需要满足 $\forall dis(p_i,p_{i+1})\le k$，路径的权值为 $\displaystyle \sum_{i=1}^w v_i$，询问最小的权值为多少。$n,q\le 2\times 10^5,k\le 3$。</p>
<p>先考虑 $k=1,2$ 的情况。$k=1$ 时，直接输出 $u\to v$ 上所有点的权值和即可，倍增处理。$k=2$ 时，我们发现路径 $p_1\to \dots \to p_w$ 依然是在 $u\to v $ 上的，但并不是所有点都要取。设计 $(x,t)$ 表示到 $x$ 已经走了多少步没有选点。还是考虑倍增处理，设计倍增数组 $f_{x,k,p,q}$ 表示从 $(x,p)$ 到 $(fa_{x,k},q)$ 最小权值和，这是容易预处理以及计算的。</p>
<p>有了 $k=1,2$ 的启发，我们还是尝试倍增。我们发现完全可以沿用 $k=2$ 中倍增数组 $f_{x,k,p,q}$ 的设计。但是需要考虑的是，现在是可以走到 $u\to v$ 之外的点的。但是简单观察发现，是只可能绕过 $u\to v$ 上某个点，转而去到与之相邻的 $v_i$ 最小的点上，再回到 $u\to v$ 上。那么现在 $f_{x,k,p,q}$ 也是容易预处理的了。</p>
<p>但需要注意的是计算时，将 $u\to \text{LCA}$ 与 $\text{LCA}\to v$ 拼在一起时的两种特殊情况：1.若 $p=0,q=0$，则 $v_{\text{LCA}}$ 会被计算两次，需要减去。2.若 $p=2,q=2$，则 $v_{\text{LCA}}$ 被少算，需要加上。</p>
<p>时间复杂度 $\mathcal O(n\log n+q\log n)$。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>DP 专项训练</title>
    <url>/2022/08/26/DP-%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p>可以说是 DP 乱做。</p>
<span id="more"></span>
<p>先做几道真题。</p>
<h4 id="1-P7077-CSP-S2020-函数调用"><a href="#1-P7077-CSP-S2020-函数调用" class="headerlink" title="1.P7077 [CSP-S2020] 函数调用"></a>1.<a href="https://www.luogu.com.cn/problem/P7077">P7077 [CSP-S2020] 函数调用</a></h4><p>很明显各个函数的调用关系是一张 DAG。假如只有函数 2，我们就只需要 dfs 一遍就可以求出所有函数的 $mul_i$。我们并不好处理先进行函数 1 再进行函数 2 的情况。于是我们考虑再求出一个 $add_i$ 表示调用完所有函数后第 $i$ 个数的增量。</p>
<p>容易想到在拓扑序 DP 来求这个东西。其实想要求 $add$ 数组很简单，乘 $k$ 也看作将该函数被执行 $k$ 次，我们只需要求出每个函数被执行了多少次，这个我们用 $f_i$ 表示函数 $i$ 被执行了多少次。</p>
<p>因为我们是按照拓扑序来考虑每个函数，而非函数本来的执行顺序。所以我们需要先考虑 $f$ 的初值。$res$ 是一个动态维护的值，表示在第 $i$ 个执行的函数被执行了 $res$ 次（注意上文所说的“被执行”）。对于三种类型的函数分开讨论：1.直接加上 $res$；2.用 $res$ 乘上 $mul_{fuc_i}$（不用加上 $res$，因为我们们根本不关心函数 2 的 $f$ 值）；3.先加上 $res$ ，再用 $res$ 乘上 $mul_{fuc_i}$。</p>
<p>接着我们考虑 DP，设当前节点为 $x$。还是对于三种类型的函数分开讨论：1.直接计算 $add_{pos_x}$；2.根本不用管；3.我们尝试倒序遍历其所有出点，就像上面求初值一样来处理所有出点的 $f$ 值，只不过不需要讨论类型，还有最开始的 $res$ 的值应该为 $f_x$ 。</p>
<p>似乎就这样做完了。。。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>)<span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;<span class="built_in">putchar</span>(c);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>&#123;<span class="keyword">while</span>(*s)<span class="built_in">putchar</span>(*s++);&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x,T1 ...x1)</span></span>&#123;<span class="built_in">write</span>(x),<span class="built_in">write</span>(x1...);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N],fuc[N];</span><br><span class="line"><span class="type">int</span> type[N],pos[N],val[N];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line">ll mul[N],f[N],add[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mul[x]=(type[x]==<span class="number">2</span>)?val[x]:<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> si=e[x].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!~mul[y])<span class="built_in">dfs</span>(y);</span><br><span class="line">        mul[x]=mul[x]*mul[y]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">topo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(!deg[i])</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(type[x]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            add[pos[x]]=(add[pos[x]]+val[x]*f[x])%mod;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll res=f[x];</span><br><span class="line">        <span class="type">int</span> si=e[x].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=si<span class="number">-1</span>;~i;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=e[x][i];</span><br><span class="line">            f[y]=(f[y]+res)%mod;</span><br><span class="line">            res=res*mul[y]%mod;</span><br><span class="line">            <span class="keyword">if</span>(!--deg[y])q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(type[i]);</span><br><span class="line">        mul[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(type[i]==<span class="number">1</span>)<span class="built_in">read</span>(pos[i],val[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type[i]==<span class="number">2</span>)<span class="built_in">read</span>(val[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c;</span><br><span class="line">            <span class="built_in">read</span>(c);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x;</span><br><span class="line">                <span class="built_in">read</span>(x);</span><br><span class="line">                e[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">                deg[x]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(!deg[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">        <span class="built_in">read</span>(fuc[i]);</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=q;i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=fuc[i];</span><br><span class="line">        <span class="keyword">if</span>(type[x]==<span class="number">1</span>)f[x]=(f[x]+res)%mod;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type[x]==<span class="number">2</span>)res=res*mul[x]%mod;</span><br><span class="line">        <span class="keyword">else</span> f[x]=(f[x]+res)%mod,res=res*mul[x]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">write</span>((<span class="number">1ll</span>*a[i]*res+add[i])%mod,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="2-P7961-NOIP2021-数列"><a href="#2-P7961-NOIP2021-数列" class="headerlink" title="2.P7961 [NOIP2021] 数列"></a>2.<a href="https://www.luogu.com.cn/problem/P7961">P7961 [NOIP2021] 数列</a></h4><p>注意到 $n,m$ 的范围，应该是个高维 DP。</p>
<p>先设计状态，将我们不太好处理的东西直接记录入状态：比如 $1$ 的个数和进位的问题，设 $f_{i,j,k,p}$，意为前 $i$ 个数选取 $j$，$1$ 的个数为 $k$，先高一位进位 $p$ 的方案数。</p>
<p>从之前的状态转移到当前状态显然不好搞，所以考虑从当前状态向之后的状态进行转移。同时最后一层枚举 $t$，表示选  $t$  个 $i$。似乎很容易得到状态的转移：</p>
<script type="math/tex; mode=display">
f_{i,j,k,p}\to f_{i+1,j+t,k+(t+p)\\\&1,\frac{(t+p)}{2}}</script><p>因为权值是一个乘积和的形式，我们也可以尝试拆贡献，也可以比较容易得到：$v_i^t\times C_{n-j}^{t}$。然后就转移就可以了。时间复杂度$\mathcal O(n^4m)$。</p>
<p>其实还可以用滚动数组优化一下，但影响不大。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">40</span>,M=<span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a,pos=<span class="number">1</span>;</span><br><span class="line">ll ans;</span><br><span class="line">ll v[M],sum[M][N],C[N][N];</span><br><span class="line">ll f[<span class="number">2</span>][N][N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">popcnt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)res+=x&amp;<span class="number">1</span>,x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">read</span>(n,m,a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(v[i]);</span><br><span class="line">        sum[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            sum[i][j]=sum[i][j<span class="number">-1</span>]*v[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f[pos],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[pos]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=a;k++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;=n&gt;&gt;<span class="number">1</span>;p++)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=n-j;t++)</span><br><span class="line">                        f[pos][j+t][k+(t+p&amp;<span class="number">1</span>)][t+p&gt;&gt;<span class="number">1</span>]=(f[pos][j+t][k+(t+p&amp;<span class="number">1</span>)][t+p&gt;&gt;<span class="number">1</span>]</span><br><span class="line">                            +f[pos^<span class="number">1</span>][j][k][p]*sum[i][t]%mod*C[n-j][t]%mod)%mod;</span><br><span class="line">        pos^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=a;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;=n&gt;&gt;<span class="number">1</span>;p++)</span><br><span class="line">            <span class="keyword">if</span>(k+<span class="built_in">popcnt</span>(p)&lt;=a)</span><br><span class="line">                ans=(ans+f[pos^<span class="number">1</span>][n][k][p])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="3-P3953-NOIP2017-提高组-逛公园"><a href="#3-P3953-NOIP2017-提高组-逛公园" class="headerlink" title="3.P3953 [NOIP2017 提高组] 逛公园"></a>3.<a href="https://www.luogu.com.cn/problem/P3953">P3953 [NOIP2017 提高组] 逛公园</a></h4><p>我们很容易想到用 DP，并且注意观察 $k$ 的值很小，考虑可以将其记录进状态。设 $f_{x,k}$ 表示从 $1$ 走到点 $x$ ，长度为最短路 $+k$ 的路径数量。 考虑建反图然后记忆化搜索。设边为 $(x,y,z)$，转移很显然有：</p>
<script type="math/tex; mode=display">
f_{x,k}=\sum_y f_{y,dis_x+k-dis_y-z}</script><p>如何判 $0$ 环呢，只需要开一个数组判断一下会不会递归到我们需要求解的状态就可以了。</p>
<p>其实似乎也可以递推求解，状态与上面相似，需要按照 $dis$ 从小到大的顺序转移。只不过对于有 $0$ 的边，需要以拓扑序为第二关键字进行转移。稍微麻烦一点。</p>
<p>下面是记忆化搜索的代码。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,K=<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> T,n,m,k,p;</span><br><span class="line">vector&lt;Edge&gt;e1[N],e2[N];</span><br><span class="line"><span class="type">int</span> dis[N],vis[N];</span><br><span class="line"><span class="type">int</span> flag,f[N][K],v[N][K];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>,vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> si=e1[x].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=e1[x][i].v,z=e1[x][i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+z&lt;dis[y])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y]=dis[x]+z;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y])q.<span class="built_in">push</span>(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">0</span>||flag)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(v[x][k])</span><br><span class="line">    &#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[x][k])<span class="keyword">return</span> f[x][k];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,si=e2[x].<span class="built_in">size</span>();</span><br><span class="line">    v[x][k]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e2[x][i].v,z=e2[x][i].w;</span><br><span class="line">        ans=(ans+<span class="built_in">dp</span>(y,dis[x]+k-dis[y]-z))%p;</span><br><span class="line">    &#125;</span><br><span class="line">    v[x][k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> f[x][k]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(n,m,k,p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            e1[i].<span class="built_in">clear</span>(),e2[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u,v,w;</span><br><span class="line">            <span class="built_in">read</span>(u,v,w);</span><br><span class="line">            e1[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">            e2[v].<span class="built_in">push_back</span>(&#123;u,w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">SPFA</span>();</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//注意这个细节，是用来判 0 环的</span></span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//因为我们需要赋初值，但是赋完我们就不能判断经过 1 的 0 环了，所以上面需要先跑一遍</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">            ans=(ans+<span class="built_in">dp</span>(n,i))%p;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Kruskal 重构树</title>
    <url>/2022/08/25/Kruskal-%E9%87%8D%E6%9E%84%E6%A0%91/</url>
    <content><![CDATA[<p>Kruskal 生成树算法的扩展应用。</p>
<span id="more"></span>
<h3 id="Kruskal-重构树"><a href="#Kruskal-重构树" class="headerlink" title="Kruskal 重构树"></a>Kruskal 重构树</h3><p>考虑一下该算法的过程：一开始 Kruskal 重构树只有 $n$ 个点，没有边。还是类似 Kruskal，我们将所有边从大到小进行考虑。对于每一条边 $(u,v,w)$，若 $u,v$ 不联通，我们就在 Kruskal 重构树上新建一个 $t$。将 $u,v$ 在重构树上的根节点 $rt_u,rt_v$ 作为 $t$ 的左右儿子，并且令 $t$ 点的权值为 $val_t=w$。</p>
<p>建了这样一棵树，我们很明显有这几个性质：</p>
<p>1.一般情况下他是一棵二叉树。</p>
<p>2.原图的节点都是重构树的叶子节点。</p>
<p>3.对于任意节点 $u$ 其祖先 $v$，$val_u$ 与 $val_v$ 满足相同偏序关系。</p>
<p>咕咕咕。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>笔记</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 游记</title>
    <url>/2022/10/27/CSP-S-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>爆炸。</p>
<span id="more"></span>
<h4 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h4><p>连续两天 ZR 模拟赛爆炸，心态也有些爆炸。总感觉自己很不自信，总觉得自己写不出来（多半是后遗症 ），一些实际上不难的题都没有做出来，于是被吊打，极其难受。</p>
<p>到考场上我又应该怎么办呢？T1 不会我应该采取怎么样的策略？或许我的担心也是不必要的，我可能也改变不了最后的结局。</p>
<h4 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h4><p>上午神仙讲课，半懂不通的，又被吊打。</p>
<p>下午去试了下机子，帮老师调试虚拟机。然后用搞来的出门条出去吃了顿华莱士，回机房继续学习了一会。还是很紧张。晚上早早睡了。</p>
<h4 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h4><p>上午复习了会板子，又颓废了一会。心态稍微稳定一点。似乎这次考试也其实并不那么重要了，还不如当成刷经验值来。</p>
<p>到了考场，发现身份证忘带了，幸好还是准时进去了。很紧张，不敢动鼠标键盘。</p>
<p>题发下来，看了 T1，感觉瞬间寄了，想了几个比较正经的写法都寄了，怎么办？也想过要不要开始乱搞（还并没有意识到这题就是乱搞），于是直接就去看 T2，此时大约 15:00。</p>
<p>然后就发现 T2 很简单，是个分讨加上数据结构，于是直接开始大力写，写了四棵线段树，然后调了十多分钟，感觉过了大样例就差不多了。</p>
<p>看到 T3 题面又臭又长，只有写 $\mathcal O(nq)$ 暴力。T4 看起来暴力都不想写，此时已经过去两个多小时。</p>
<p>写完 T3 暴力接着想 T1，脑子里依然是用什么什么算法来做，结果仍然没有头绪。也只好在原来 $\mathcal O(n^3)$ 的基础上再写个 $k=1$ 的 sub。</p>
<p>中间甚至还有一段乌龙，我以为 18:00 就考完了，于是从 17:30 就开始检查，<del>然后发现 T2 大样例其实没过</del>，又赶快改了十多分钟。监考老师提醒时间的时候才意识到还有半个小时。早知道把 T4 暴力写完的！！！</p>
<p>随着广播里的提示考试结束，我也只好接受自己爆炸的现实。出来一看就我 T1 没切，还说什么呢，只能是技不如人了。。。</p>
<p>晚上选手数据发了下来，然后去测了下，大概还是 190 pts 左右，还是爆炸。</p>
<p>然后迷迷糊糊就睡了。</p>
<p>赛后感觉 T3 T4 巨多部分分且好写，并且 T3 正解很短，T4 正解也比较好想，但是还是寄的离谱。。。</p>
<h4 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h4><p>成绩出来了，60 + 100 + 40 = 200 pts。已经无所谓了，只是希望能够更认真地准备 NOIP 吧。</p>
<p>就这样。</p>
<h4 id="Day-20"><a href="#Day-20" class="headerlink" title="Day 20"></a>Day 20</h4><p>分数线 195 pts，混了个没 B 用的 1=。</p>
<p>真的就这样了么。。。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP 字符串匹配</title>
    <url>/2023/05/01/KMP-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>来补一下。</p>
<span id="more"></span>
<h2 id="1-KMP-字符串匹配"><a href="#1-KMP-字符串匹配" class="headerlink" title="1.KMP 字符串匹配"></a>1.KMP 字符串匹配</h2><p>KMP 常用来求单文本串与单模式串的匹配问题。大致分为两步，求出前缀函数与进行匹配。下面分别介绍。</p>
<h3 id="1-1-前缀函数"><a href="#1-1-前缀函数" class="headerlink" title="1.1.前缀函数"></a>1.1.前缀函数</h3><p>第一步：求出模式串的前缀函数。</p>
<p>先介绍 Border 的概念，对于字符串 $s[1\dots n]$，所有满足 $s[1\dots i]=s[n-i+1 \dots n]$ 且 $i \neq 1$ 的前缀为 $s[1\dots n]$ 的一个Border。</p>
<p>字符串 $s[1 \dots n]$ 的前缀函数 $\pi[i]$ 定义为字串 $s[1 \dots i]$ 的最长 Border 的长度，不存在任何 Boder 时值为 $0$。</p>
<h4 id="1-1-1-性质"><a href="#1-1-1-性质" class="headerlink" title="1.1.1.性质"></a>1.1.1.性质</h4><p>$(1)$.若 $s[\pi[i]+1]=s[i+1]$ ，则 $\pi[i+1]=\pi[i]+1$。</p>
<p>$(2)$.$s[1 \dots i]$ 的 Border 的 Border 是 $s[1 \dots i]$ 的 Border。</p>
<p>$(3)$.$s[1 \dots i]$ 的 Border 集合为 $s[1\dots \pi[i]],s[i\dots \pi[\pi[i]]],\cdots$。</p>
<p>通过性质 $(2)$ 以及 $\pi[i]$ 的最长性，通过反证法容易得到性质 $(3)$。</p>
<h4 id="1-1-2-计算"><a href="#1-1-2-计算" class="headerlink" title="1.1.2.计算"></a>1.1.2.计算</h4><p>假设当前情况下，我们根据上面三条性质来求尝试计算 $\pi[i+1]$ 。</p>
<p>根据性质 $(2)$，我们只需要将 $s[i+1]$ 与 $s[1 \dots i]$ 所有 Border 的后面一位进行匹配即可。根据性质 $(3)$，我们在适配时不断将 $i$ 跳到 $\pi[i]$ 即可遍历所有后缀。再根据性质 $(1)$，这样即可求出 $\pi[i+1]$。</p>
<p>这样的是时间复杂度是多少？设 $j$ 为之前已匹配的最大长度，即 $\pi[i]$。注意到 $j$ 每一次最多只能增加 $1$ ，那么 $j$ 的增量最多为 $n$，所以失配时跳到 $\pi[i]$ 的次数为 $\mathcal O(n)$。于是时间复杂度为 $\mathcal O(n)$。</p>
<details class="code" open><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;t[i]!=t[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">    <span class="keyword">if</span>(t[i]==t[j+<span class="number">1</span>])j++;</span><br><span class="line">    ne[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-2-匹配"><a href="#1-2-匹配" class="headerlink" title="1.2.匹配"></a>1.2.匹配</h3><p>第二步：在文本串中进行匹配。</p>
<p>通过上一步的过程，我们已经可以看到，KMP 核心思想是 利用之前匹配好的信息，就是与之匹配的 Border，继续进行匹配。而在第二部中也是如此。我们还是利用不停地跳 $\pi[i]$ 遍历 $s[1 \dots i]$ 的所有 Border，与上面的过程十分相似，此处不再赘述。</p>
<details class="code" open><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;s[i]!=t[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i]==t[j+<span class="number">1</span>])j++;</span><br><span class="line">    <span class="comment">// if(j==m)printf(&quot;%d\n&quot;,i-m+1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-3-应用"><a href="#1-3-应用" class="headerlink" title="1.3.应用"></a>1.3.应用</h3><p>我们发现前缀函数 $\pi[i]$ 有一些很好的性质，于是衍生出更多的应用。下面是一些简单的例子。 </p>
<h4 id="1-UVA1328-Period"><a href="#1-UVA1328-Period" class="headerlink" title="1.UVA1328 Period"></a>1.<a href="https://www.luogu.com.cn/problem/UVA1328">UVA1328 Period</a></h4><p>经典问题，求一个字符串的所有前缀的最大周期长度。仔细观察，设存在 $s[1 \dots j]$ 为 $s[1 \dots i]$ 的最小周期，其充要条件是 $j|i$ 且 $j=i-\pi[i]$。也比较好证明。画个图更好理解。于是我们只需要求一遍 $\pi[i]$ 即可。</p>
<h4 id="2-P3435-POI2006-OKR-Periods-of-Words"><a href="#2-P3435-POI2006-OKR-Periods-of-Words" class="headerlink" title="2.P3435 [POI2006] OKR-Periods of Words"></a>2.<a href="https://www.luogu.com.cn/problem/P3435">P3435 [POI2006] OKR-Periods of Words</a></h4><p>设 $s[1 \dots j]$ 为 $s[1 \dots i]$ 的长度最小的一个 Border，容易发现 $s[i-j+1 \dots i]$ 的长度即为所求。于是不停跳 $\pi[i]$ 找到最短的 Border 长度即可。但是对于每一个子串暴力跳的话 $j$ 的变化次数是 $\mathcal O(n^2)$ 的，时间复杂度也是 $\mathcal O(n^2)$ 的。考虑一个小优化，我们每次跳完 就将 $\pi[i]$ 赋为 $j$，注意到 Border 之间是呈现一个树形结构，于是这个优化可以类似于并查集的路径压缩，所以对于每个前缀最多只需要跳一次。这样做的时间复杂度就是 $\mathcal O(n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n,ne[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>])j++;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">2</span>;i&lt;=n;i++,j=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ne[j])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(j)ne[i]=j,ans+=i-j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="3-P3426-POI2005-SZA-Template"><a href="#3-P3426-POI2005-SZA-Template" class="headerlink" title="3.P3426 [POI2005]SZA-Template"></a>3.<a href="P3426 [POI2005]SZA-Template">P3426 [POI2005]SZA-Template</a></h4><p>不妨直接设记 $f_i$ 表示以 $i$ 结尾的字符串的答案。进行仔细观察，答案必须为字符串的一个 Border 或者字符串本身。更进一步地，答案只可能为 $f_{\pi[i]}$ 或者 $i$。因为不可能存在一个可以表示 $s[1 \dots i]$ 但无法表示 $s[1 \dots \pi[i]]$ 的 Border。这意味着结尾与前面部分最多只能接上 $s[1 \dots \pi[i]]$ 这一段，前面部分也需要有这个结构构成，于是我们要找到一个 $j$，满足 $f_j=f_{\pi[i]}$ 且 $i-j \le \pi[i]$，那么其值为 $f_{\pi[i]}$，否则为 $i$。这个过程可以用一个桶简单实现。</p>
<h2 id="2-Z-函数"><a href="#2-Z-函数" class="headerlink" title="2.Z 函数"></a>2.Z 函数</h2><p>Z 函数也称扩展 KMP，求法与 KMP 很类似。</p>
<h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1.定义"></a>2.1.定义</h3><p>对于字符串 $s[1 \dots n]$，定义函数 $z[i]$ 表示 $s$ 与 $s[i\dots n]$ 的最长公共前缀 LCP 的长度，$z$ 被称为 $s$ 的 Z 函数。</p>
<h3 id="2-2-求法"><a href="#2-2-求法" class="headerlink" title="2.2.求法"></a>2.2.求法</h3><p>核心思想还是利用好之前已经匹配好的信息。我们设 $s[l\dots r]$ 是当前 $r$ 最大的一个匹配段，分为两种情况讨论：</p>
<ul>
<li>如果 $i&lt;r$，因为有 $s[i,r]=s[i-l+1,r-l+1]$，所以得到 $z[i]\ge \min (z[i-l+1],r-i+1)$。于是分为两种情况：<ul>
<li>$z[i-l+1]&lt;r-i+1$，直接令 $z[i]=z[i-l+1]$。</li>
<li>$z[i-l+1]\le r-i+1$，从 $r$ 开始暴力向右进行扩展。</li>
</ul>
</li>
</ul>
<p>具体实现如下：</p>
<details class="code" open><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=r)z[i]=<span class="built_in">min</span>(z[i-l+<span class="number">1</span>],r-i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(i+z[i]&lt;=n&amp;&amp;s[i+z[i]]==s[z[i]+<span class="number">1</span>])z[i]++;</span><br><span class="line">    <span class="keyword">if</span>(i+z[i]<span class="number">-1</span>&gt;r)l=i,r=i+z[i]<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p><code>while</code> 中每次向后扩展一位都至少会使 $r$ 增加 $1$，所以总共最多只会执行 $\mathcal O(n)$ 次，外层循环只有一层遍历。所以总的时间复杂度为 $\mathcal O(n)$。</p>
<p>同样类似于上一步以及 KMP 的匹配过程，Z 函数还可以用来求模板串与文本串的每一个后缀的 LCP 长度数组。这里不再赘述。</p>
 <details class="code" open><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=r)p[i]=<span class="built_in">min</span>(z[i-l+<span class="number">1</span>],r-i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(i+p[i]&lt;=n&amp;&amp;s[i+p[i]]==t[p[i]+<span class="number">1</span>])p[i]++;</span><br><span class="line">    <span class="keyword">if</span>(i+p[i]<span class="number">-1</span>&gt;r)l=i,r=i+p[i]<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="2-3-应用"><a href="#2-3-应用" class="headerlink" title="2.3.应用"></a>2.3.应用</h3><p>通过上面我们逐渐认识到前缀函数 $\pi[i]$ 与 Z 函数 $z[i]$ 是相似的。$\pi[i]$ 是以 $i$ 结尾，$z[i]$ 则是以 $i$ 开头。所以二者的应用也是类似的。但不同情况下的方便程度也不一样。</p>
<h4 id="1-P8112-Cnoi2021-符文破译"><a href="#1-P8112-Cnoi2021-符文破译" class="headerlink" title="1.P8112 [Cnoi2021]符文破译"></a>1.<a href="https://www.luogu.com.cn/problem/P8112">P8112 [Cnoi2021]符文破译</a></h4><p><a href="https://kevinlive.github.io/2022/08/18/P8112-Cnoi2021-%E7%AC%A6%E6%96%87%E7%A0%B4%E8%AF%91/">在这里看</a></p>
<h4 id="2-P7114-NOIP2020-字符串匹配"><a href="#2-P7114-NOIP2020-字符串匹配" class="headerlink" title="2.P7114 [NOIP2020] 字符串匹配"></a>2.<a href="https://www.luogu.com.cn/problem/P7114">P7114 [NOIP2020] 字符串匹配</a></h4><p>经典题，不再赘述。</p>
<h2 id="3-失配树"><a href="#3-失配树" class="headerlink" title="3.失配树"></a>3.失配树</h2><p>KMP 的小扩展，我们很容易发现根据前缀函数 $\pi[i]$ 发现 Border 之间呈现一个树形结构。于是关于一些关于 Border 的问题我们可以通过将这棵树具体地建出来，在进行处理，这棵树就是失配树。同时这个在 AC 自动机上也有应用。</p>
<h4 id="1-P5829-【模板】失配树"><a href="#1-P5829-【模板】失配树" class="headerlink" title="1.P5829 【模板】失配树"></a>1.<a href="https://www.luogu.com.cn/problem/P5829">P5829 【模板】失配树</a></h4><p>模板题，按照上面所说，直接求 LCA 即可。</p>
 <details class="code" open><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> pi[N];</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N],ne[N];</span><br><span class="line"><span class="type">int</span> d[N],si[N],son[N],fa[N],top[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    son[x]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>,fa[y]=x;</span><br><span class="line">        <span class="built_in">dfs1</span>(y);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        <span class="keyword">if</span>(son[x]==<span class="number">-1</span>||si[son[x]]&lt;si[y])son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x]=t;</span><br><span class="line">    <span class="keyword">if</span>(~son[x])<span class="built_in">dfs2</span>(son[x],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span>(ver[i]!=son[x])</span><br><span class="line">            <span class="built_in">dfs2</span>(ver[i],ver[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[top[x]]&lt;d[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&gt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[j+<span class="number">1</span>]!=s[i])j=pi[j];</span><br><span class="line">        <span class="keyword">if</span>(s[j+<span class="number">1</span>]==s[i])j++;</span><br><span class="line">        pi[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pi[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">add</span>(pi[i],i);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">LCA</span>(fa[x],fa[y]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>应用感觉也不多，不太找得到。但上面很多题目都可以用失配树完成。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>KMP</tag>
        <tag>Z函数</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#2127. 「HAOI2015」按位或</title>
    <url>/2023/04/01/LOJ-2127-%E3%80%8CHAOI2015%E3%80%8D%E6%8C%89%E4%BD%8D%E6%88%96/</url>
    <content><![CDATA[<p>min-max 容斥入门题。</p>
<span id="more"></span>
<p>相当于求每个位置的期望次数的最大值，用 min-max 容斥得到：</p>
<script type="math/tex; mode=display">
E(\max_{i\in S}{t_i})=\sum_{T\subseteq S}(-1)^{|T-1|} E(\min_{i\in T}t_i)</script><p>考虑如何求 $\displaystyle E(\min_{i\in S}t_i)$，考虑期望的离散计算方式，设 $f(S)$ 表示选中不覆盖 $S$ 中任意位置的概率，有 $\displaystyle E(\min_{i\in S} t_i)=(1-f(S))\cdot\sum_{k=1}k\cdot f(S)^{k-1}$。后面一部分推一下：</p>
<script type="math/tex; mode=display">
\begin{align}
f(S) \cdot\sum_{k=1}k\cdot f(S)^{k-1} &= \sum_{k=2}(k-1)\cdot f(S)^{k-1}\notag\\
&=\sum_{k=1}k\cdot f(S)^{k-1}-\sum_{k=0}f(S)^k\\

\sum_{k=1}k\cdot f(S)^{k-1} &= \frac{\sum_{k=0}f(S)^k}{1-f(S)}\notag\\

\end{align}</script><p>于是得到：</p>
<script type="math/tex; mode=display">
E(\min_{i\in S} t_i)=\sum_{k=0}f(S)^k=\frac{1}{1-f(S)}</script><p>但其实上面推的式子是完全没有必要的，补集转换就可以得到上式。</p>
<p>对于 $f(S)$ 可以用 FMT 求出，总时间复杂度为 $\mathcal O(n2^n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> popcnt __builtin_popcount</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">21</span>,M=<span class="number">1</span>&lt;&lt;N;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,tot;</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="type">double</span> ans,f[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FMT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                f[j]+=f[j^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;f[i]),sum|=(f[i]!=<span class="number">0</span>)?i:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum!=tot<span class="number">-1</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;INF&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FMT</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;tot;i++)ans+=(<span class="built_in">popcnt</span>(i)&amp;<span class="number">1</span>?<span class="number">1</span>:<span class="number">-1</span>)*(<span class="number">1.0</span>/(<span class="number">1</span>-f[tot<span class="number">-1</span>^i]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>按位或</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#2542. 「PKUWC2018」随机游走</title>
    <url>/2023/03/05/LOJ-2542-%E3%80%8CPKUWC2018%E3%80%8D%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/</url>
    <content><![CDATA[<p>min-max 容斥 练手题。</p>
<span id="more"></span>
<p>发现要求的是： </p>
<script type="math/tex; mode=display">
E(\max_{i\in S} t_i)</script><p>使用 min-max 容斥得到：</p>
<script type="math/tex; mode=display">
E(\max_{i\in S} t_i)=\sum_{T\subseteq S}(-1)^{|T|-1} E(\min_{i\in T} t_i)</script><p>注意到 $n\le 18$，于是考虑直接暴力容斥，求出每个子集 $S$ 的 $\displaystyle E(\min_{i\in S} t_i) $。</p>
<p>设计状态 $f(i)$ 表示从 $i$ 走到第一次走到 $S$ 中任意点的期望步数，</p>
<p>1.对于 $i\in S$，有 $f(i)=0$。</p>
<p>2.对于 $i\notin S$，有 $\displaystyle f(i)=1+\frac{1}{\deg(i)}\sum_{(i,j)\in E} f(j)$。</p>
<p>可以高斯消元，但是时间复杂度就变成 $\mathcal O(n^3 2^n)$ 的，不能接受。</p>
<p>先考虑叶子节点 $i$，它们的值只会与父亲有关（或者 $f(i)=0$），有 $f(i)=A_i f(p_i) +B_i$，其中 $A_i=1,B_i=1$。而我们接着考虑叶子的父亲节点 $i$：</p>
<script type="math/tex; mode=display">
f(i)=1+\frac{1}{\deg_i}\sum_j{(A_j f(i)+b_j)} + \frac{1}{\deg_i}f(p_i)</script><p>变换一下：</p>
<script type="math/tex; mode=display">
f(i)=\frac{1}{\deg(i)-\sum_j{A_j}}f(p_i) + \frac{\deg(i)+\sum_j B_j}{\deg(i)-\sum_j A_j}</script><p>于是我们将叶子的父亲节点 $i$ 也表示成了类似于 $\displaystyle f(i)=A_i f(p_i) +B_i$ 的形式，其中 $\displaystyle A_i=\frac{1}{\deg(i)-\sum_j{A_j}},B_i=\frac{\deg(i)+\sum_j B_j}{\deg(i)-\sum_j A_j}$。</p>
<p>以此类推，我们从下往上可以推出所有节点的 $A_i,B_i$，我们直接以 $x$ 为根，因为 $x$ 没有父节点，所以：</p>
<script type="math/tex; mode=display">
f(x)=B_x</script><p>于是对与每个 $S$ dfs 一遍即可求出对应的 $f(x)$，时间复杂度为 $\mathcal O(n2^n)$。</p>
<p>但是我们要求的是 $\displaystyle \sum_{T\subseteq S}(-1)^{|T|-1} E(\min_{i\in T} t_i)$，对于每个询问求一次是 $\mathcal O(2^n)$ 的。对于这个式子，我们显然可以在预处理出所有 $\displaystyle (-1)^{|T|-1} E(\min_{i\in T} t_i)$ 后，做一次 FMT，即可 $\mathcal O(1)$ 回答询问。</p>
<p>代码非常好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> popcnt __builtin_popcount</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">18</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q,rt;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> s,deg[N],a[N],b[N];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s&gt;&gt;x&amp;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a[x]=<span class="number">0</span>,b[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> suma=<span class="number">0</span>,sumb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        suma=<span class="built_in">adj</span>(suma+a[y]),sumb=<span class="built_in">adj</span>(sumb+b[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[x]=<span class="built_in">qpow</span>(<span class="built_in">adj</span>(deg[x]-suma+mod));</span><br><span class="line">    b[x]=<span class="number">1ll</span>*<span class="built_in">adj</span>(deg[x]+sumb)*<span class="built_in">qpow</span>(<span class="built_in">adj</span>(deg[x]-suma+mod))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FMT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j]=<span class="built_in">adj</span>(a[j]+a[j^(<span class="number">1</span>&lt;&lt;i)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q,rt);</span><br><span class="line">    rt--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        u--,v--;</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">        deg[u]++,deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op=(<span class="built_in">popcnt</span>(s)&amp;<span class="number">1</span>)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(rt,<span class="number">-1</span>);</span><br><span class="line">        f[s]=<span class="built_in">adj</span>(op*b[rt]+mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FMT</span>(n,f);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="built_in">read</span>(k);</span><br><span class="line">        s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            x--;</span><br><span class="line">            s+=<span class="number">1</span>&lt;&lt;x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[s]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>容斥</tag>
        <tag>min-max 容斥</tag>
        <tag>集合幂级数</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#2115. 「HNOI2015」落忆枫音</title>
    <url>/2022/11/09/LOJ-2115-%E3%80%8CHNOI2015%E3%80%8D%E8%90%BD%E5%BF%86%E6%9E%AB%E9%9F%B3/</url>
    <content><![CDATA[<p>拓扑序DP。</p>
<span id="more"></span>
<p>考虑有向无环图，答案显然为 $\prod_i \deg_i$。但是加了一条边可能会出现环，产生不合法的方案。我们考虑将不合法的方案减去。</p>
<p>把环从图中剖出来，那么剩下点的 $\prod_i \deg_i$ 就是该环不合法的方案数。理由很简单，这个环没有入度的，而其它所有点都可以随便选父亲。于是我们将环上点的 $\deg_i$ 除掉即可。</p>
<p>可能会出现多个环。但其实 $a$ 与 $b$ 一定会出现在环上的。此过程可以 DP，计算 $f_i$ 为从 $b$ 到 $i$ 的方案数，最终用原答案减去  $f_a$ 即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],ne[M];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line">ll ans=<span class="number">1</span>,sum=<span class="number">1</span>,f[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mod-(mod/x)*<span class="built_in">inv</span>(mod%x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[x])</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(x==b)</span><br><span class="line">    &#123;</span><br><span class="line">        f[x]=sum*<span class="built_in">inv</span>(deg[x])%mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        f[x]=(f[x]+f[y])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=f[x]*<span class="built_in">inv</span>(deg[x])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">        deg[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    deg[<span class="number">1</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==b)ans=ans*(deg[i]+<span class="number">1</span>)%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=ans*deg[i]%mod;</span><br><span class="line">        sum=sum*deg[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans+mod-f[a])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#2743. 「JOI Open 2016」摩天大楼</title>
    <url>/2022/09/02/LOJ-2743-%E3%80%8CJOI-Open-2016%E3%80%8D%E6%91%A9%E5%A4%A9%E5%A4%A7%E6%A5%BC/</url>
    <content><![CDATA[<p>经典 DP，费用提前计算的思想。</p>
<span id="more"></span>
<p>对于序列类型的 DP 题，我们可以想到用分段型 DP，每次将当前的数插入进去，求解方案数。但是这道题的并费用不好直接计算。</p>
<p>先将 $a$ 排序，并从小到大插入。对于 $i&lt;j$ ，有 $|a_i-a_j|=\sum_{k=i}^{j-1} a_{k+1}-a_k$。根据这个我们可以尝试进行<strong>费用提前计算</strong>。对于之后每个插在当前的 $k$ 个端点上的数，会一共产生 $(a_{i+1}-a_{i})\times k$ 的费用。</p>
<p>状态转移比较套路。注意边界上是没有花费的，所以还需要将边界上填了多少个记录进状态。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">10</span>,M=<span class="number">1e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">ll f[N][N][M][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>;d&lt;=<span class="number">2</span>;d++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> t=k+(a[i+<span class="number">1</span>]-a[i])*(<span class="number">2</span>*j-d);</span><br><span class="line">                    <span class="keyword">if</span>(t&gt;m||!f[i][j][k][d])<span class="keyword">continue</span>;</span><br><span class="line">                    f[i+<span class="number">1</span>][j+<span class="number">1</span>][t][d]=(f[i+<span class="number">1</span>][j+<span class="number">1</span>][t][d]+f[i][j][k][d]*(j+<span class="number">1</span>-d))%mod;</span><br><span class="line">                    <span class="keyword">if</span>(j)f[i+<span class="number">1</span>][j<span class="number">-1</span>][t][d]=(f[i+<span class="number">1</span>][j<span class="number">-1</span>][t][d]+f[i][j][k][d]*(j<span class="number">-1</span>))%mod;</span><br><span class="line">                    <span class="keyword">if</span>(j)f[i+<span class="number">1</span>][j][t][d]=(f[i+<span class="number">1</span>][j][t][d]+f[i][j][k][d]*(<span class="number">2</span>*j-d))%mod;</span><br><span class="line">                    <span class="keyword">if</span>(d&lt;<span class="number">2</span>)f[i+<span class="number">1</span>][j+<span class="number">1</span>][t][d+<span class="number">1</span>]=(f[i+<span class="number">1</span>][j+<span class="number">1</span>][t][d+<span class="number">1</span>]+f[i][j][k][d]*(<span class="number">2</span>-d))%mod;</span><br><span class="line">                    <span class="keyword">if</span>(j&amp;&amp;d&lt;<span class="number">2</span>)f[i+<span class="number">1</span>][j][t][d+<span class="number">1</span>]=(f[i+<span class="number">1</span>][j][t][d+<span class="number">1</span>]+f[i][j][k][d]*(<span class="number">2</span>-d))%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        ans=(ans+f[n][<span class="number">1</span>][i][<span class="number">2</span>])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3339. 「NOI2020」美食家</title>
    <url>/2022/12/25/LOJ-3339-%E3%80%8CNOI2020%E3%80%8D%E7%BE%8E%E9%A3%9F%E5%AE%B6/</url>
    <content><![CDATA[<p>一些小 trick。</p>
<span id="more"></span>
<p>注意到 $T$ 很大，并且 $n,m$ 都比较小，并且求的是恰好 $T$ 时刻。想到用矩阵快速幂来做。</p>
<p>如何处理路径长度？因为 $w_i$ 很小，我们可以考虑拆边，这样总点数是 $n+5m$ 的，不太能接受。实际上我们可以考虑拆点，这样总点数是 $5n$ 的，可以接受。另外还需要将点权转化为边权。</p>
<p>如何处理美食节？我们可以将美食节按照时间进行排序，每次计算时间之差内愉悦值变化，再加上美食节额外的愉悦值即可。</p>
<p>但是这样暴力快速幂做是 $\mathcal O(n^3k\log T)$ 的，无法通过所有数据。其实我们只需要保留矩阵的第一行即可。于是可以预处理原始矩阵的次幂，在求解过程中倍增计算。于是时间复杂度就降到了 $\mathcal O(n^3\log T+n^2k\log T)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">250</span>+<span class="number">10</span>,M=<span class="number">5e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    ll e[N][N];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;<span class="built_in">memset</span>(e,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(e));&#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix a,<span class="type">const</span> Matrix b)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix c;</span><br><span class="line">        c.x=a.x,c.y=b.y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a.x;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=b.y;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a.y;k++)</span><br><span class="line">                    c.e[i][j]=<span class="built_in">max</span>(c.e[i][j],a.e[i][k]+b.e[k][j]);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;f[<span class="number">50</span>],ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Festival</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t,x,y;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Festival a,<span class="type">const</span> Festival b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.t&lt;b.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n,m,t,k;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i<span class="number">-1</span>)*<span class="number">5</span>+j+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;delicacy.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;delicacy.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(n,m,t,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">            f[<span class="number">0</span>].e[<span class="built_in">num</span>(i,j)][<span class="built_in">num</span>(i,j+<span class="number">1</span>)]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        f[<span class="number">0</span>].e[<span class="built_in">num</span>(u,w<span class="number">-1</span>)][<span class="built_in">num</span>(v,<span class="number">0</span>)]=c[v];</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>].x=<span class="number">5</span>*n,f[<span class="number">0</span>].y=<span class="number">5</span>*n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">31</span>;i++)</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]*f[i<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i].t,a[i].x,a[i].y);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+k);</span><br><span class="line">    a[<span class="number">0</span>]=(Festival)&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    a[k+<span class="number">1</span>]=(Festival)&#123;t,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    ans.e[<span class="number">1</span>][<span class="number">1</span>]=c[<span class="number">1</span>];</span><br><span class="line">    ans.x=<span class="number">1</span>,ans.y=<span class="number">5</span>*n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d=a[i].t-a[i<span class="number">-1</span>].t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;~i;i--)</span><br><span class="line">            <span class="keyword">if</span>(d&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                ans=ans*f[i];</span><br><span class="line">        ans.e[<span class="number">1</span>][<span class="built_in">num</span>(a[i].x,<span class="number">0</span>)]+=a[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.e[<span class="number">1</span>][<span class="number">1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans.e[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3737. 「LNOI2022」吃</title>
    <url>/2023/03/31/LOJ-3737-%E3%80%8CLNOI2022%E3%80%8D%E5%90%83/</url>
    <content><![CDATA[<p>有趣的贪心。</p>
<span id="more"></span>
<p>显然先加后乘是最优的。我们考虑将 $a_i=1$ 的 $b_i$ 加起来。考虑 $a_i\ge 2$ 的情况，发现最多甚至会选取一个 $b_i$。因为假如选取 $b_i\ge b_j$，那么选取 $a_j$ 就有 $b_i\times a_j\ge b_i+b_j$。枚举一遍即可。时间复杂度 $\mathcal O(n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line">ll sum=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> prod=<span class="number">1</span>,pos;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(b[i]),(a[i]==<span class="number">1</span>)?sum+=b[i]:prod=<span class="number">1ll</span>*prod*a[i]%mod;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">1</span>||b[i]&lt;=sum)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1ll</span>*(sum+b[pos])*a[i]&lt;=<span class="number">1ll</span>*(sum+b[i])*a[pos])pos=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos)sum=(sum+b[pos])%mod*<span class="built_in">qpow</span>(a[pos]);</span><br><span class="line">    sum%=mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*sum*prod%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3340. 「NOI2020」命运</title>
    <url>/2022/12/25/LOJ-3340-%E3%80%8CNOI2020%E3%80%8D%E5%91%BD%E8%BF%90/</url>
    <content><![CDATA[<p>线段树合并优化 DP。</p>
<span id="more"></span>
<p>注意到对于所有 $(u,v)\in \mathcal Q$ 的 $v$ 只需要深度最深的 $u$ 满足即可。考虑设计状态 $f_{x,i}$ 表示以 $x$ 为根的子树中未满足条件的 $u$ 深度最大为 $i$ 的方案数。考虑 $(x,y)$ 为连向子树的边，选取该条边为 $1$ 的贡献是 $\sum_{j=0}^{dep_x} f_{x,i}\times f_{y,j}$，不选取的贡献是 $\sum_{j=0}^{i} f_{x,i}\times f_{y,j}+\sum_{j=0}^{i-1} f_{x,j}\times f_{y,i}$。用前缀和优化，得到总的转移方程：</p>
<script type="math/tex; mode=display">
f_{x,i}=f_{x,i}\times (sum_y(dep_x)+sum_y(i))+f_{y,i}\times sum_x(i-1)</script><p>这样做到 $\mathcal O(n^2)$，对深度离散化可以做到 $\mathcal O(n\min{n,m})$，建虚树可以做到 $\mathcal O((\min{n,m})^2)$。</p>
<p>观察式子，先不管 $sum_y(dep_x)$，剩下的项全都和下标 $i$ 有关，求区间和。而且真正有用的状态数是 $\mathcal O(m)$ 的，于是考虑整体 DP。整个过程用线段树合并来维护，合并过程中维护 $sum_x,sum_y$，先合并左子树，再合并右子树。$sum_y(dep_x)$ 在线段树上查一下就行了。时间复杂度 $\mathcal O(n \log n)$。</p>
<p>全都和下标 $i$ 有关这一点提醒我们也可以用启发式合并，但是感觉比较难写，是 $\mathcal O(n\log^2 n)$，有被卡的风险。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    ll sum,tag;</span><br><span class="line">&#125;tr[N*<span class="number">80</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> rt[N],d[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].sum=(tr[tr[x].lc].sum+tr[tr[x].rc].sum)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].sum=tr[x].sum*k%mod;</span><br><span class="line">    tr[x].tag=tr[x].tag*k%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].tag==<span class="number">1</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].lc)<span class="built_in">update</span>(tr[x].lc,tr[x].tag);</span><br><span class="line">    <span class="keyword">if</span>(tr[x].rc)<span class="built_in">update</span>(tr[x].rc,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=++cnt;</span><br><span class="line">    tr[x].sum=tr[x].tag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">insert</span>(tr[x].lc,l,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||r&lt;=pos)<span class="keyword">return</span> tr[x].sum;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(tr[x].lc,l,mid,pos);</span><br><span class="line">    <span class="keyword">return</span> (tr[tr[x].lc].sum+<span class="built_in">query</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r,ll &amp;sumx,ll &amp;sumy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x&amp;&amp;!y)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">    &#123;</span><br><span class="line">        sumy=(sumy+tr[y].sum)%mod;</span><br><span class="line">        <span class="built_in">update</span>(y,sumx);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!y)</span><br><span class="line">    &#123;</span><br><span class="line">        sumx=(sumx+tr[x].sum)%mod;</span><br><span class="line">        <span class="built_in">update</span>(x,sumy);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        sumx=(sumx+tr[x].sum)%mod;</span><br><span class="line">        sumy=(sumy+tr[y].sum)%mod;</span><br><span class="line">        tr[x].sum=(tr[x].sum*sumy%mod+tr[y].sum*((sumx+mod-tr[x].sum)%mod)%mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x),<span class="built_in">pushdown</span>(y);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[x].lc=<span class="built_in">merge</span>(tr[x].lc,tr[y].lc,l,mid,sumx,sumy);</span><br><span class="line">    tr[x].rc=<span class="built_in">merge</span>(tr[x].rc,tr[y].rc,mid+<span class="number">1</span>,r,sumx,sumy);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:vec[x])</span><br><span class="line">        res=<span class="built_in">max</span>(res,d[y]);</span><br><span class="line">    <span class="built_in">insert</span>(rt[x],<span class="number">0</span>,n<span class="number">-1</span>,res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        ll sumx=<span class="number">0</span>,sumy=<span class="built_in">query</span>(rt[y],<span class="number">0</span>,n<span class="number">-1</span>,d[x]);</span><br><span class="line">        rt[x]=<span class="built_in">merge</span>(rt[x],rt[y],<span class="number">0</span>,n<span class="number">-1</span>,sumx,sumy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;destiny.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;destiny.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        vec[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(rt[<span class="number">1</span>],<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>整体DP</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP 2022 全题解</title>
    <url>/2023/03/10/NOIP-2022-%E5%85%A8%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>隔了好久好久。。。</p>
<span id="more"></span>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>题意：给定一棵 $n\times m$ 的 01 矩阵，问有多少个由 1 组成形如 <code>C</code> 和形如 <code>F</code> 的图案。</p>
<p><code>C</code> 与 <code>F</code> 做法是类似的，此处只讨论 <code>F</code>。</p>
<p>考虑处理出每个位置向右延伸以及向下延伸的最大值。再枚举每一列统计答案即可，时间复杂度 $\mathcal O(nm)$。</p>
<p>最后注意乘上给定常数 $C,F$。<del>（警钟敲烂）</del></p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p><a href="https://kevinlive.github.io/2023/03/13/LOJ-3897-%E3%80%8CNOIP2022%E3%80%8D%E5%96%B5%E4%BA%86%E4%B8%AA%E5%96%B5/#more">在这里看</a></p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p><a href="https://kevinlive.github.io/2022/12/05/P8867-NOIP2022-%E5%BB%BA%E9%80%A0%E5%86%9B%E8%90%A5/#more">在这里看</a></p>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>题意：给定两个长度为 $n$ 的序列 $A,B$。有 $q$ 次询问 $l,r$，每次询问 $\sum_{l\le p\le q\le r} \max_{i=p}^q A_i\times \max_{i=p}^q B_i$。</p>
<p>考虑将询问离线下来，对右端点 $r$ 直接扫描线，每次将其放进单调栈里，找到最远能影响到的位置。继而维护前面每个位置的答案。</p>
<p>现在就相当于需要维护答案的历史版本之和。我们需要支持三种操作：</p>
<p>1.将 $a$ 区间滚平为 $x$；</p>
<p>2.将 $b$ 区间滚平为 $x$；</p>
<p>3.每个位置加上 $a_i\times b_i$。</p>
<p>但是具体如何用线段树维护？线段树节点上我们需要维护答案 $sum$，以及 $sumx,sumy,sumxy$ 表示 $\sum x,\sum y,\sum xy$。tag 上我们需要维护 $sx,sy$ 表示区间滚平，以及 $addx,addy,addxy,addz$ 表示 $sum’=sum+addx\times sumx+addy\times sumy+addxy\times sumxy+addz\times len$。tag 的意义即为当前节点的 $sum$ 需要加上 $sumx,sumy,sumxy,len$ 分别乘上其 tag 上所对应的系数的和。根据这个意义可以写出 tag 的合并方式。需要注意到是要先累加后滚平。具体代码可以看 <a href="https://loj.ac/s/1720904">https://loj.ac/s/1720904</a> 。还有一种写法即为写成矩阵的形式，不过常数会一些。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Nobody tells.</title>
    <url>/2023/05/01/Nobody-tells/</url>
    <content><![CDATA[<p>5 月 1 日闲话。</p>
<span id="more"></span>
<p>“意义“的问题总是无可避免的。事物的意义是我所赋予的，但是为什么如此模糊而又矛盾？本心是否也会自相矛盾？但是他却告诉我要坚持本心。对一次一次的一乐后的空虚落寞感到懊恼，更加不明白自己到底想要什么。现在还是未来的现在？过去不断交织，我不懂，反而越发沉迷于那些遗憾与快乐。照镜子的过程中逐渐变成不敢直视自己的魔鬼 。</p>
]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP 游记</title>
    <url>/2022/11/24/NOIP%20%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>与诸君共勉。</p>
<span id="more"></span>
<h4 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h4><p>上午考试，T1 做了很久，后面的题也没时间想解法，关键 T1 大样例很水，又挂了分，有点爆炸。</p>
<p>NOIP 就在眼前了，有时候感觉自己或许也比以前进步了很多，但还是达不到真正有水平。我还在犹豫什么呢？我曾经觉得这些考试决定了我人生的轨迹。而我，如今，和各位前途光明的 OIers 坐在同一个机房，并试图说服自己也是他们中的一员，却不断地在空想中迷茫。</p>
<p>可至少和大家一起还是很快乐的吧？大不了考完就退役滚去学文化课，似乎也没什么了，只不过我还是很喜欢 OI 罢了。</p>
<h4 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h4><p>感觉自己很颓废，机房里大家都在耍。而我只是颓废得很，简直不知道干什么。早上 T1 又挂分，在垫底间徘徊。又在洛谷上开了个之前讲过的题，想不出来解法了。这时才感觉到自己真的是废物一个。</p>
<p>晚上打算复习一下板子，其余就都没了。</p>
<h4 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h4><p>睡得不太好。做完核酸就去考试。</p>
<p>开题，T1 形式化的题面让人感觉很不友好，把全部题看完还是决定按照顺序开题。</p>
<p>T1 按照每一列来算，乘法原理计算就可以了，9:20 才写完，然后看 T2。感觉很阴间，想了一个似乎正确的做法，然后感觉比较难写。实际开始写的时候感觉比想象中难写一百倍。写了 20 min 连第一步怎么处理的没写完。决定看后面的题。</p>
<p>然后发现 T3 暴力也不太好写，只有 T4 数据结构题暴力比较好写。</p>
<p>当时已经知道 T3 大概是个边双 + 树形 DP，感觉可能比较难做。但是做出了本场最错误的决定——我选择猛冲 T2，直接放弃 T3。</p>
<p>然后就寄了，甚至连 $k=2\times n-2$ 的解法的写对没有都不清楚，也没时间写 SPJ 了。12:50 写完乱搞，最后检查一遍就结束了。</p>
<p>最后走出了考场，大家都想骂出题人。机房里除了 Dyd 和 mydcwfy 都考得不尽人意（毕竟只有这两位神仙看出来 T3 并不困难），Dyd T1 挂分但是 T3 切掉了，mydcwfy T3 挂分但是 T4 84pts。</p>
<p>那么我呢？甚至 T1 忘记乘上 $c,f$ 一定会挂 7pts，而且前缀和数组在做乘法的时候忘记强制转换了，被 InfOJ 卡到 64pts（InfOJ 的数据真的很强！）。T2 T3 都报零，T4 20pts 暴力。</p>
<p>InfOJ： 64 + 0 + 0 + 20 = 84 pts</p>
<p>luogu：93 + 0 + 0 + 20 = 113 pts</p>
<p>考完感觉整个人都是处于红温状态，回寝室睡得也并不好，</p>
<h4 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h4><p>早上起来整个人都是恍恍惚惚的，昨日仿佛如梦一般，我所认为的很重要的一天就过去。</p>
<p>如果我 T1 没有挂分，看出来 T3 比 T2 更加可做的话，结局是否会改变呢？我得不到答案，我觉得我的水平仍然未达到我想要的高度，仍然不能使我自己变得足够优秀。我只能尽力提升自己，并且希望，能够在明年此时，不会因为当初做的决定而后悔。</p>
<p>新的一天又开始了呢。。。</p>
<h4 id="Day-2-8"><a href="#Day-2-8" class="headerlink" title="Day 2~8"></a>Day 2~8</h4><p>在学文化课，摆了很多常规作业，感觉有点累（NOIP前都没有这般感觉），不知道为什么突然十分迫切地想要放假回去休息。</p>
<p>其实也想明白一些事情吧，或许当我有一天也离开了 OI 这门我所热爱的学科，我也会继续有着自己的生活，继续走着自己的路，只是从万千平凡的 OIer 变成万千平凡的 whker。回忆仍然让我们感到快乐。</p>
<p>分数也不重要了，反正 1= 肯定没戏了。更重要的是好好地走完这一段不知长短的路。</p>
<h4 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h4><p>出分了。没什么感觉。</p>
<p>总分： 93 + 0 + 0 + 20 = 113 pts</p>
<p>一等奖线就是 120 pts，而我差的就是那挂掉的 7 pts。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>我们的故事仍未结束，甚至，才刚刚开始。。。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ#3897. 「NOIP2022」喵了个喵</title>
    <url>/2023/03/13/LOJ-3897-%E3%80%8CNOIP2022%E3%80%8D%E5%96%B5%E4%BA%86%E4%B8%AA%E5%96%B5/</url>
    <content><![CDATA[<p>再次敲响警钟。</p>
<span id="more"></span>
<p>先考虑 $k=2n-2$，我们把 $n-1$ 栈上放上互不相同的 $2n-2$ 种牌。接下来新来的一张牌如果在栈顶出现过，我们放在对应的栈上消去；如果在栈底出现过，我们就将它放在空栈上，再将该栈底消去即可。</p>
<p>再考虑 $k=2n-1$，我们还是把 $n-1$ 栈上放上互不相同的 $2n-2$ 种牌，并且维护一个空栈（否则栈底很可能无法被消除）。接下来新来的一张牌可能是新的第 $2n-1$ 种牌。而这个时候我们就不太好放了。因为放在前 $n-1$ 个栈上，可能会影响到栈顶的消除；放在空栈上，无法及时消去会影响到栈底的消除。</p>
<p>我们尝试放到一个不会影响之后消除的位置上。经过思考，我们考虑这样的过程：</p>
<ol>
<li><p>$n-1$ 个栈上有 $2n-2$ 种不同的牌。</p>
</li>
<li><p>当前要放的第 $2n-1$ 种牌先待定。</p>
</li>
<li><p>找到之后出现的栈底种类之一（或者第 $2n-1$ 种）的第一张牌。</p>
</li>
<li><p>该栈的栈顶牌型出现次数的奇偶性进行讨论：</p>
<p>1.偶数次：将第 $2n-1$ 种牌放在空栈上，消去该栈上的所有牌，并将其作为新的空栈。</p>
<p>2.奇数次：将第 $2n-1$ 种牌放在该栈上，最后利用空栈将栈底消去。</p>
</li>
</ol>
<p>实现起来相当繁琐，可能因为小细节挂掉。。。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300</span>+<span class="number">10</span>,M=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res&lt;<span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),res=-res;</span><br><span class="line">    <span class="keyword">if</span>(res&gt;<span class="number">9</span>)<span class="built_in">write</span>(res/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(res%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;<span class="built_in">putchar</span>(c);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> </span>&#123;<span class="keyword">while</span>(*s)<span class="built_in">putchar</span>(*s++);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> ...ARC&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T res, ARC ...com)</span></span>&#123;<span class="built_in">write</span>(res),<span class="built_in">write</span>(com...);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Op</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> op,x,y;</span><br><span class="line">&#125;ans[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> T,n,m,k;</span><br><span class="line"><span class="type">int</span> a[M];</span><br><span class="line"><span class="type">int</span> now,em;</span><br><span class="line"><span class="type">int</span> vis[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt;sta[N],q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(now&lt;=m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[a[now]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[a[now]]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> i=vis[a[now]];</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                sta[i].<span class="built_in">pop_back</span>();</span><br><span class="line">                q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                vis[a[now]]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> i=-vis[a[now]];</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">2</span>,i,em&#125;;</span><br><span class="line">                sta[i].<span class="built_in">pop_front</span>();</span><br><span class="line">                q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                vis[a[now]]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(sta[i].<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">                    vis[sta[i].<span class="built_in">front</span>()]=-i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">            sta[i].<span class="built_in">push_back</span>(a[now]);</span><br><span class="line">            <span class="keyword">if</span>(sta[i].<span class="built_in">size</span>()==<span class="number">1</span>)vis[a[now]]=-i;</span><br><span class="line">            <span class="keyword">else</span> vis[a[now]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        now++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    now=<span class="number">1</span>,em=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        q.<span class="built_in">push_back</span>(i),q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">work</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos=now+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos&lt;=m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[a[pos]]&lt;<span class="number">0</span>||a[pos]==a[now])<span class="keyword">break</span>;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[pos]==a[now])</span><br><span class="line">        &#123;</span><br><span class="line">            ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=now+<span class="number">1</span>;t&lt;pos;t++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> i=vis[a[t]];</span><br><span class="line">                <span class="keyword">if</span>(i)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                    sta[i].<span class="built_in">pop_back</span>();</span><br><span class="line">                    q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    vis[a[t]]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop_front</span>();</span><br><span class="line">                    ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                    sta[i].<span class="built_in">push_back</span>(a[t]);</span><br><span class="line">                    vis[a[t]]=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">            now=pos+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">1</span>,top=sta[-vis[a[pos]]].<span class="built_in">back</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=now+<span class="number">1</span>;t&lt;pos;t++)</span><br><span class="line">                <span class="keyword">if</span>(a[t]==top)cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,-vis[a[pos]],<span class="number">0</span>&#125;; </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=now+<span class="number">1</span>;t&lt;pos;t++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> i=vis[a[t]];</span><br><span class="line">                    <span class="keyword">if</span>(a[t]==top)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,-vis[a[pos]],<span class="number">0</span>&#125;;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                        sta[i].<span class="built_in">pop_back</span>();</span><br><span class="line">                        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                        vis[a[t]]=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">                        q.<span class="built_in">pop_front</span>();</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                        sta[i].<span class="built_in">push_back</span>(a[t]);</span><br><span class="line">                        vis[a[t]]=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">2</span>,-vis[a[pos]],em&#125;;</span><br><span class="line">                sta[-vis[a[pos]]].<span class="built_in">pop_front</span>();</span><br><span class="line">                sta[-vis[a[pos]]].<span class="built_in">push_back</span>(a[now]);</span><br><span class="line">                vis[a[pos]]=<span class="number">0</span>;</span><br><span class="line">                vis[a[now]]=vis[top];</span><br><span class="line">                vis[top]=-vis[top];</span><br><span class="line">                now=pos+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,em,<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=now+<span class="number">1</span>;t&lt;pos;t++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> i=vis[a[t]];</span><br><span class="line">                    <span class="keyword">if</span>(a[t]==top)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,-vis[a[pos]],<span class="number">0</span>&#125;;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                        sta[i].<span class="built_in">pop_back</span>();</span><br><span class="line">                        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">                        vis[a[t]]=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> i=q.<span class="built_in">front</span>();</span><br><span class="line">                        q.<span class="built_in">pop_front</span>();</span><br><span class="line">                        ans[++tot]=&#123;<span class="number">1</span>,i,<span class="number">0</span>&#125;;</span><br><span class="line">                        sta[i].<span class="built_in">push_back</span>(a[t]);</span><br><span class="line">                        vis[a[t]]=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[++tot]=&#123;<span class="number">1</span>,-vis[a[pos]],<span class="number">0</span>&#125;;</span><br><span class="line">                vis[a[now]]=-em;</span><br><span class="line">                sta[em].<span class="built_in">push_back</span>(a[now]);</span><br><span class="line">                q.<span class="built_in">push_back</span>(em);</span><br><span class="line">                sta[-vis[a[pos]]].<span class="built_in">clear</span>();</span><br><span class="line">                em=-vis[a[pos]];</span><br><span class="line">                vis[top]=vis[a[pos]]=<span class="number">0</span>;</span><br><span class="line">                now=pos+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(tot,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(ans[i].op,<span class="string">&#x27; &#x27;</span>,ans[i].x);</span><br><span class="line">        <span class="keyword">if</span>(ans[i].op==<span class="number">2</span>)<span class="built_in">write</span>(<span class="string">&#x27; &#x27;</span>,ans[i].y);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;meow.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;meow.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>OI日记</title>
    <url>/2022/08/19/OI%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="82b061bf5d41fd73ab16e86af5850707b8a44a8cd317a5bc4514474dbb28648a">6333146992d1960170704a0dfad69583847809dc3c2f675101e538cf9f82e80b8e5664514d76bd3dcb241ed48fd6185c9939373ed1a1dbc349457a49a9845b3d7b0b3bb7bd3aae5d34db10b20a9ae31ecc37009465aabd291eac1ef74b7fa48edbce0fb02e9ce0d0bd3a51d664d58e5baeddc23d3f7ada7c06c4fbf655b4dd1cc26aca7a95cc6e00efde7202aa065cf25dd2662733f183c90a437089b031167f2b544d344976df9cf245f7a22bd73b5337ae8684c25f5aaf660e5d844aca7a6281de19ac568f89096f87838af6b10d49378049f6ce6be60c6e403a683128a54f5c1dea17ee777af3a9abff9e57cacb347e556a6f5153f12450264250e163fd7aee2b57cb3b53c436f645fbc3a8f967c84d8ba4866c672ef8c0d3bd508036ad8f86646751ef3f21e2807c7c3c3d0aab571c8ad5cff4efa62943bb0742545f3b7ad5766dd666ef8c29240534645429a87da63eb9c94c038d7c85831cb0019790e5d3a98495f07f6bb97a00831eed7c5c9b568e0b062fb892e5a6ecb69b95566e09e5a5f0c8fbfe8c4920eef4e71f35043742b1a923a7600b4f7f0fb2e7af0287e92dd56cd8296261c524e91139225217eb1adb19677429f22431370444f4265f15ec37cb250009d90007316056c01970ea70cfc2f08990ba056666924b2cfcb852b4a651a22e908cc9a8bfe13fb77278423c6dc372efc8a63ff6a4dcf7d634baef612a55b4a7e9374b29cf8888c8197d6c7c2610b967ee928433af1899b61927f351d2a7b3b9b5982178b8e98c1f26b72cac96edab3f41f92e80d4b41782bbe3355e9f247e842d8040821849f50b328e60e4b75f730ede876bb0fa0f1256b034ed6bb219c07bce968991a36681a7d775e9ddde41c30e1caa7759d8e359cc3ad2b73abcdd9bf3eb213b694089090717c1d62c2f6f28100995933c7b52cb021180b9894a4b1881324a1e32ff1d0b96e1980bf5c64d2782c350d7b4824cb09a9b11658f0c9e90d24822ba670d6eb90efb2d9ada102a5d0dc7c2a881da74669da6bcb50a9c1c7195c59cdcdcf51d29373a68f4dd1da9799495f8adf70f909c32f7b7f077039e0a0325fbe597086c65ebb45c480947ef62f4d566e97e409b7b2a8e368ef31019f35a5bd6220cb390faad09d0a24365fa0d73be805ac04fc9ba3a5242a876ce5ee811b643a6a1047ae953ab147ceb17afbce669a28f7c7fc595bb86955e0cd2092859c14e27f9c4b307ea11746c82b4046c8a3ebb2ba102a8dd2cb6361cf76caa2c1bd36082f05d31d942573abb4bf37b85800601f7f418a6dfaae8da84a06b4b1cd9a3a916a8948ad98e7d7e77ba21d1d0da4d395ac381c37f0de923f51bd59186eafedcc6db350ebe143befc5702727d2ee88f6c89e65dda5379d971cf35165568518e4e0d5f843618d1d5008cceca7f39e6314e771ede8110ebcfcb0ef3a3faecc95b58e53de56dee49d11cafa6ba5ab00e5c82f229e16f3f23d00cf72811c898ba551fcf3b8be3a184a6d4b429a488511a5c54f40dd4b3bf429eff446404110ad925b31d2f51ff7449a229806db591f7f2b4e7a01312b8cbd49ee5f23d611f87d6e800bd7099f770698c7a7e2a9e01ad5b699ac9502207554351efd44dac8d77befec67d817e5b100dbd24e7235d854096faffe4c87074066686b4a405ba5645ae9ec798854904b2da750adc4db67dbaeeebe0765b7596dc10cff8e16d106951bedfdf53b91e523d39a0f0114ea0d6ac45d12455b78162aa74791000b57ca3c3a26234da476fb3e09c49cb13388579c198af2c6693457e96a297ea23fa8dfd4398c466970793facc9eb34ae377eaf9a291694f37d698b76f2ba13b1871f07c37ee02169db02f5c5d1fe0b59bbc9edbdabad3161807fa3af1e59a87571d3af1c3e7d302d709449ecb23ace8757d4af48e85656fb62cc64cce2561bdccd9c3ddc66ca1c43d81cafb93f1d230284da30728cd0e8ded5613df6b54b6fcb0119f41acb1e4433c2aca8acfb9592ec62c74b01d63f2f4bfb0df2268807a548be90353642f8924ed24d974825b04ca18dccaf40db4ceffbceaca7b22b23a3926bafd3f57cf1f515d797962ec16d8102ca8858f04968d7f599e6ad600820f0bb4f7c8b668cb3e872dfd365bc98a5b651cfa4da73a7bd467843fdb55a56ae616511fac7452aad76b2bdbc3289e2489a0dd7c34cc3068cbae758a92ce7b1a8c01f09096f7b4870bd5f339c97a34f9521aed2cd55c02d3441aa2917ed09f728e70801ff4ef2c19de2185f46b03a1733156c3e38e1f00faecd100d21569e9dfd9afcd137672d55bc4f911b8216138157fd4bfd821e09f750075ba12e37ce6f50933c30721627250ecaabd9b22f5de13fea6a4fb29f5090400acb95154c35fb0829f9f375394e6aa4ae99ddf1a18dc4b40fc50d638a70940499543fcc22381e6d826dd14c67093d86cda16cd33dd617a7005f92afb5f7c432756a0c711e22f3773cab0e00765bad80dde64e91956f82cbe8997012f9804e85627ae0bcd6d29c3fbd14e6e9651bcabeb2210668ce572403e2d61e579d4063118682b849c3caa992f4627fee4c3bee664f34591602265783940f73ffbd85d497709f4b9813106a041f173794004cc560d96ac66e7536a8dcc49bdc48bd55eb334fef62bdf96890d512845892e4cbccd62bceed7b38656db14481625bb41234c1b8b99954770462b9148f4448afa53fd685cee0c07316494896fbf883c1ffeb48bdebfbbf480b9f671b925ad797b2016bd48c33ed4a23b7263155b894eb6744e68a83f37abd7405cec637831cf562c957a95e18f98b3f37d75283a6bbb544f484fafa32529eaf90032dff6c4c3af86e24ddf33748025cf474be5a7ee7182ac6b95bc773d11d5fe0b983a5623e18bf1bc0c64aad58ce4ff596e6e2f5bf762ecec7ef8becf5bf8affb485ea5177b24f01bff0e84a3d48bf160deef5a7626cc4e1fe429e091767a2ddab241930cf6c05672593dfc451740b9dec677d4f2c7becb95c9772642410732ba574cef481a3d51f95f87e158fcd24fda4584b87dfef30d9bf0b89f935e8df49b691d28e9d13c1e017f397626f636aacbd107f67b4b0ccb644c78a37dc4bfdd35c1f0908be894d32abadfd700881baf8de0f91523000649a96bfcd8ba11916664f53e3158f35033a4ffc0ceffffd15cda492d0647628a92fa0979c16d7cbd38838ff93a35d0906bdca177d466052635d562571addec8334a495d56d3a5611ef3317518770fe35bcb47a9245f48f3d3c398a465fdf91f1f0a43b3bfc7458a6675ce713be4c97ab89c6af26967c63708f7bcb43a77f1785dcd4455e96bbc1a08fbbe18806ece9b450760a6aa081aefc8cec8428f227451c22e1fa4a92f8cd757db7ef0fc3b92da5e9be13b6c3abad2623b3b54dfd6cd99659656373a88ae952a422b172aabe5561812ac7dfed78024cb2f7a3c9c8714d44317c46e5421c62cce5278e5f8204765d20df77c1cac16aed0baf02f715be4d5925e2a0dce13559418d1a6ef417477d81becff17c7707f3a29bf9092a37cf434b74675e0ea2f9e4ddd900c122b91a8eca90c76cd148d9f782a3824dcf5c66cb329652f2bdb71a01f400d58b86756f676bdcc8ecaf9c84e918dfdd4849dc62bc88f9b5904a7e2ee458708995325ff47c38ddd57b7696f5c5ed9a0992ae71fecc824d92e5e7d5330060cd6d693abad65f11985577a68fdf00444d826869c613dcfa01096a37294518ccff35b36f749a137245db78848d166bcc7cbc347f151ebdc6c1fa5c7564a2f617452b3736109ffbf064cd0beb87056e28bef905d9ac7a50635b9091a3a2f2f3b094360370f7d4a07b1f31f4924e97c6c0bfdb9135e72f3cf5f899e5232ed5cbac9f8cefb87cc51c9df5251a7fcdc080df387545d8e6b4cabde3343c358a5a7c0a4a40fe6f13fe054c5f3b97fc8ed60278bfafc752486ebc178d73ef4fa2c30e6e83e2df1b90c71479e7ab4c3c03b364085c0ddaa79d7bd09db8f5e38dc45743ba574f1fc9269e4245e126b33f91ffae6bc23282ab3a4ddc64458b6fbd80f79e2fca8a21b7369fd89f8b1452429a3eeda617e1d73ca5f9c9f3b3faf086d61699ccc2bbc949c0b1867b36c808a95715bea3ad2f2595de031e34115277d0f83e7333763f29513fed211287d1dc76f49ee5ca5bbc40379aeb42de63575485d299e546e98567f797ea5329f59b6ecf60c9bdfcb410def89a51963e07357c35f4a688c2fc26eaef80d246e97880a8fbf192cd9ead918cc1240da6295e293be01e2ae95620a2ee78d4d01c32d72e2118e635eab1f1b683345530e0b465fb4352eb76768c6976fd61742382e0591e379f203b80fa4a5bdcd849b3fb3078fb630adfcc50c300c8592a87d116ae534e4d679cd1eee9b4a478088faed079c811373aa4d2445532ce54a2a03b4b138e5080ab9d4d41787a52a9ecc517dc8f9aa166e34f7783b7dd07f42eecf81efae51fef3c2e60e17408b8aaeed22f7e1273c076e04ce84c959494ab17fb4c48b82e9ed5e37eb2075f693d1203c628aca26f0282df523b9ce9b3d669c9491a27d568c10137784c1c79e88d9e3d95a97fb0c2975fc06a52f524f8e0b621fa3ee2525b33f378ea8881e7871a5cc098434796d8ce29a3c7fd391442bcade23e9c339014e3112ca47f96d1b16f4458c6464ad18cc92af4011374f02aa9c96f29bec2674970285e912594e90736c41872bf1582ac298b5295090508fab8d297665926ab053da7beed292fc423665a5ab8a17d30097258a662e14220f7c3e63335055e47afd56a5db8ce09b5c0f496cb74fd713d64f71d18a14c8d6a4668db24a127ca111cbe6fa507658bdd7341cafb7906647f9f51c7f540d4022362c6db5c4869ce770d8514408dd66f1516a81c3601c9ab92f841a7853fb31b008c7279a14c478135756160d69d2be43dfe9883b4ceac91febcb53ad49f336211a01aa647f28190e169ead2e6c63cd39e10a02ffc9de9a95b4aa92c2773b66ac7a184bd228924e4a4bf5a1b5d8e8967e50b43d385b851f47061b8f9ec09a2bf6c72f6e2d552821523f46911e562ff275170463481eb997828e8d3b02284a52c62504ad7818975a2aae8c85ed22a9fc312114ab30b6de118fe08d2e9735f68daa447fd439c855773f292d94f83b996bbd1160ebc11c986130b7338c182e38ba8dcbcb4d91a218d73591166000bfa4acf23ab14c9616e77963ec8397c51defa86f2898afcff66d1c9e99bdc8392f5523ce6d82df9bdfff5dbf45f0042b10abae0b1884ae7e343e7f3ebcb9361b5aa24d6ce621796e16a1c4f83ff5ebd1886e08f5209d084d5737ee0a249d9cdb0fae53e27822f35ea100a6fda84f1563d15189b8c64a899932f33c8b8bcb95b351efcdccd5af8995ebac7c3eadf29e4b1366cd36c7de8c25a2edcddd583f6f57d6f728ff77215f1f0973831c501e6558bcbd27d1f4c93ef8cb9913eb51571d4313d45f322aa8ccfad529b04105c9f9df86e6b0d74e815b9a611952d0d2c7b70c7edac0be77aa20d923d23bfe487dab1b74b4eb601330eef4a2c4e0aed381920886dfca68fb28ff5216ccde2716335473df23b96b404cbf8b23c3bc4ef11c72c9d63ca0d6b8dc9d0d1d6da0bd45a451b81238f6b1b050b23f2a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">? 竞赛 : 生活</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>P1829 [国家集训队]Crash的数字表格 / JZPTAB</title>
    <url>/2023/01/05/P1829-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC-JZPTAB/</url>
    <content><![CDATA[<p>不错的莫反练手题，可以说把大部分套路都涵盖了。</p>
<span id="more"></span>
<p>不妨令 $n\le m$，让我们求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{j=1}^{m} \text{lcm}(i,j)</script><p>先转换为我们熟悉的 $\gcd$：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{j=1}^{m} \frac{i\cdot j}{\gcd(i,j)}</script><p>枚举 $\gcd(i,j)$：</p>
<script type="math/tex; mode=display">
\sum_{k=1}^{n} \sum_{i=1}^n \sum_{j=1}^{m} \frac{i\cdot j \cdot [\gcd(i,j)=k]}{k}</script><p>变换为 $[\gcd(i,j)=1]$ 的形式：</p>
<script type="math/tex; mode=display">
\sum_ {k=1} ^ {n} \sum_ {i=1} ^ {\lfloor \frac{n}{k}\rfloor} \sum_ {j=1} ^ {\lfloor \frac{m}{k}\rfloor} {i\cdot j \cdot k \cdot [\gcd(i,j)=1]}</script><p>根据经典式子 $[\gcd(i,j)=1]=\sum\limits_{d|\gcd(i,j)} \mu(d)$，进一步得到：</p>
<script type="math/tex; mode=display">
\sum_ {k=1} ^ {n} \sum_ {i=1} ^ {\lfloor \frac{n}{k}\rfloor} \sum_ {j=1} ^ {\lfloor \frac{m}{k}\rfloor} \sum_{d|\gcd(i,j)} \mu(d) \cdot {i\cdot j \cdot k }</script><p>把 $d$ 提到前面去，尝试枚举 $d$：</p>
<script type="math/tex; mode=display">
\sum_ {k=1} ^ {n}  \sum_{d=1}^{\lfloor\frac{n}{k}\rfloor} \mu(d) \cdot k \cdot d^2\sum_ {i=1} ^ {\lfloor\frac {n}{kd}\rfloor} \sum_ {j=1} ^ {\lfloor\frac{m}{kd}\rfloor}{i\cdot j}</script><p>把 $kd$  看做一个整体，设 $kd=T$，又得到：</p>
<script type="math/tex; mode=display">
\sum_ {T=1} ^ {n}  T\sum_{d|T}\mu(d) \cdot d\sum_ {i=1} ^ {\lfloor\frac {n}{T}\rfloor} \sum_ {j=1} ^ {\lfloor\frac{m}{T}\rfloor}{i\cdot j}</script><p>最后面是个等差数列求和，并且可以整数分块做。考虑如何求 $f(x)=\sum\limits_{d|x}\mu(d)\cdot d$，很容易知道这是个积性函数，考虑在线性筛的过程中如何求，设 $x=i\cdot j$ ，其中 $j$ 为 $x$ 最小的质因子：</p>
<p>1.$x\in \text{prime}$ ，$f(x)=-x+1$。</p>
<p>2.$j$ 为 $i$ 的质因子，那么 $j$ 对 $f(x)$ 是没有贡献的，$f(x)=f(i)$。</p>
<p>3.$j$ 不为 $i$ 的质因子，那么根据积性函数的定义，$f(x)=f(i)\cdot f(j)$。</p>
<p>时间复杂度 $\mathcal O(n+T\sqrt n)$，$T$ 为询问总数，<del>不过洛谷上这道题只有一个询问</del>。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>,mod=<span class="number">20101009</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> cnt,prime[N],vis[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            f[i]=mod-i+<span class="number">1</span>,prime[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;<span class="number">1ll</span>*i*prime[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                f[i*prime[j]]=f[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i*prime[j]]=<span class="number">1ll</span>*f[i]*f[prime[j]]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">       f[i]=<span class="built_in">adj</span>(f[i<span class="number">-1</span>]+<span class="number">1ll</span>*f[i]*i%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1ll</span>*(x+<span class="number">1</span>)*x/<span class="number">2</span>)%mod*(<span class="number">1ll</span>*(y+<span class="number">1</span>)*y/<span class="number">2</span>%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=<span class="built_in">min</span>(n/(n/l),m/(m/l));</span><br><span class="line">        res=<span class="built_in">adj</span>(res+<span class="number">1ll</span>*<span class="built_in">adj</span>(f[r]-f[l<span class="number">-1</span>]+mod)*<span class="built_in">sum</span>(n/l,m/l)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span>(N<span class="number">-10</span>);</span><br><span class="line">    T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(n,m);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;m)<span class="built_in">swap</span>(n,m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(n,m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>P3193 [HNOI2008]GT考试</title>
    <url>/2022/02/18/P3193-GT%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<p>KMP + 矩阵快速幂。</p>
<span id="more"></span>
<p>首先考虑暴力 DP。</p>
<p>设计状态 $f_{i,j}$ 为长串匹配 $i$ 位，短串最多匹配 $j$ 位时的方案数。</p>
<p>易得转移方程式 $ f_{i,j}=\sum_{k=j}^{m-1} f_{i-1,k}\times g_{k,j}$。</p>
<p>很明显 $g$ 数组是不变的，并且可以通过 KMP 预处理出。</p>
<p>这时我们再观察数据范围 $n$ 很大， $m$ 很小并且 $g$ 数组是不变的，于是我们考虑使用 <strong>矩阵快速幂</strong>。</p>
<p>我们的 $g$ 数组就是我们的构造矩阵，此时直接套上矩阵快速幂即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m,mod,ans;</span><br><span class="line"><span class="type">int</span> a[maxn],ne[maxn];</span><br><span class="line"><span class="type">int</span> g[maxn][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;<span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in">sizeof</span>(s));&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix a,<span class="type">const</span> Matrix b)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">                c.s[i][j]=(c.s[i][j]+a.s[i][k]*b.s[k][j])%mod;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KMP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=ne[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(a[j+<span class="number">1</span>]!=a[i]&amp;&amp;j)j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(a[j+<span class="number">1</span>]==a[i])ne[i]=j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp=i;</span><br><span class="line">            <span class="keyword">while</span>(temp&amp;&amp;a[temp+<span class="number">1</span>]!=j)temp=ne[temp];</span><br><span class="line">            <span class="keyword">if</span>(j==a[temp+<span class="number">1</span>])temp++;</span><br><span class="line">            g[i][temp]++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">quickpow</span><span class="params">(Matrix a,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        sum.s[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)sum=sum*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,a+i);</span><br><span class="line">    <span class="built_in">KMP</span>();</span><br><span class="line">    Matrix a,b;</span><br><span class="line">    a.s[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            b.s[i][j]=g[i][j];</span><br><span class="line">    a=a*<span class="built_in">quickpow</span>(b,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        ans=(ans+a.s[<span class="number">0</span>][i])%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>KMP</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>P2505 [HAOI2012]道路</title>
    <url>/2022/03/05/P2505-HAOI2012-%E9%81%93%E8%B7%AF/</url>
    <content><![CDATA[<p>最短路 DAG。</p>
<span id="more"></span>
<p>首先，我们很容易知道：$i\to j$ 的最短路径的任意子路径 $u\to v$ 都是最短路径，接着我们可以得到另一个结论：若存在一条子路径 $u\to v$ 不是最短路径，那么很明显可以找到一条更短的 $u\to v$ 使得 $i\to j$ 更短。根据这个原则，我们可以得出在固定源点下，存在 $G$ 的一个子图 $G’$，使得 $G’$ 的每一条边都在 $S$ 到其他至少一个点的最短路径上，且 $G’$ 以外的边不在 $S$ 到任意一个点的最短路径上。这里把称 $G’$ 为源点为 $S$  时 $G$ 的<strong>最短路图</strong>。而求出最短路图的方式很简单，就是如果有 $dis_{v_i}=dis_{u_i}+w_i$，我们给这条路打上一个标记就行了。</p>
<p>容易得到这个最短路图是无环的，我们就可以在<strong>最短路图</strong>上进行<strong>拓扑排序</strong>。考虑维护两个数组为 $cnt1_i$ 与 $cnt2_i$ 。接着我们考虑正反两次拓扑分别表示 $i\to u$ 和 $v\to j$ 的最短路径条数，而答案就为 $cnt_1({u_i})*cnt_2({v_i})$ 之和。</p>
<p>使用 Dijkstra 的话时间复杂度应该是 $\mathcal O(nm\log n + n^2)$，只不过这里用了 SPFA。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1500</span>+<span class="number">10</span>,M=<span class="number">5000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> u[M],v[M],w[M];</span><br><span class="line"><span class="type">int</span> dis[N],vis[N];</span><br><span class="line"><span class="type">int</span> flag[M],ans[M];</span><br><span class="line"><span class="type">int</span> len,top[N],deg[N];</span><br><span class="line"><span class="type">int</span> cnt1[N],cnt2[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[now]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[to]&gt;dis[now]+e[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to]=dis[now]+e[i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[to])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[to]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(dis[v[i]]==dis[u[i]]+w[i])</span><br><span class="line">            flag[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">memset</span>(cnt1,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt1));</span><br><span class="line">    <span class="built_in">memset</span>(cnt2,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topo</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(flag[i])deg[v[i]]++;</span><br><span class="line">    cnt1[s]++;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        top[++len]=now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> to=v[i];</span><br><span class="line">            <span class="keyword">if</span>(!--deg[v[i]])q.<span class="built_in">push</span>(to);</span><br><span class="line">            cnt1[to]=(cnt1[to]+cnt1[now])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=top[i];</span><br><span class="line">        cnt2[now]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=head[now];j;j=ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> to=ver[j];</span><br><span class="line">            cnt2[now]=(cnt2[now]+cnt2[to])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">SPFA</span>(s);</span><br><span class="line">    <span class="built_in">topo</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(flag[i])</span><br><span class="line">            ans[i]=(ans[i]+cnt1[u[i]]*cnt2[v[i]])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u[i]&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">        <span class="built_in">add</span>(u[i],v[i],w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>P3571 [POI2014]SUP-Supercomputer</title>
    <url>/2022/06/16/P3571-POI2014-SUP-Supercomputer/</url>
    <content><![CDATA[<p> 可以用堆做到 $\mathcal O(n\log n)$ ，也可以用更加优秀的斜率优化实现 $\mathcal O(n)$。</p>
<span id="more"></span>
<p><a href="https://www.luogu.com.cn/problem/P3571">题目链接</a></p>
<p>考虑按照 $dep$ 分层。记 $cnt_{dep}$ 表示深度为 $dep$ 的点数。考虑从大到小枚举 $k$，将对于每个 $k$ 的最优解都求出来。</p>
<p>在 $k$ 足够大时，显然一次能且仅能选择同一层的点，即 $ans_k=\max {dep_i}$。当某一时刻，$cnt_i&gt;k$，那么我们无法在一次内选择完第 $i$ 层的点，需要将其中 $cnt_i-k$ 个点挪到下一层选取。</p>
<p>题目中限制了拥有父子关系的两个点无法同时选择，我们需要证明只需要将剩下的点向下挪动一层就能够得到合法解。</p>
<p>假设此时 $cnt_{i-1}\le k$。  </p>
<p>我们需要在第 $i$ 次和第 $i+1$ 共选取 $2k$ 个点其中第 $i$ 层选取 $cnt_i$ 个，第 $i+1$ 层选取 $2k-cnt_i$ 个点。  </p>
<p>1. $cnt_{i+1}&lt;2k-cnt_i$：第 $i+1$ 天未取满 $k$ 个点，并不影响结果。  </p>
<p>2. $cnt_{i+1}&gt;2k-cnt_i$：将第 $i+1$ 层多余的点挪向第 $i+2$ 层，这显然是一个相同的子问题。  </p>
<p>3. $cnt_i&gt;2k$：将第 $i$ 层多余的点和第 $i+1$ 层所有点挪向第 $i+2$ 层，这显然又是一个相同的子问题。  </p>
<p>而这 $2k$ 个点拥有父子关系的点对数 $&lt;k$，故一定能找到合法方案。</p>
<p>也可以感性理解，既然当 $k’&gt;k$ 时，被选中的点可以在当层选择，那么挪到下一层就更容易有合法方案了。</p>
<p>由上面的结论我们可以得到，我们始终可以把操作一次多余的点挪向下一层，保证每层的点数 $\le k$，最多有 $n$ 层。  </p>
<p>这个时候暴力维护是不行的，因为我们并不关心多出来的点来自哪一层，我们尝试将多层放在一起合并后维护。  </p>
<p>我们于是就维护的就是一段区间 $[l,r]$，表示连续 $r-l+1$ 天仅选取第 $[l,r]$ 层的点，且一定取完，即 $\sum_{i=l}^r cnt_i\le (r-l+1)\times k$。  </p>
<p>故我们只需要用维护区间，每次将堆顶不合法区间取出，向下合并即可。</p>
<p>时间复杂度 $\mathcal O(n\log n)$ ，比隔壁斜率优化 $\mathcal O(n)$ 要慢，但也算提供新的思路吧。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1&amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l,r,cnt;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;rhs)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (ll)cnt*(rhs.r-rhs.l+<span class="number">1</span>)&lt;(ll)rhs.cnt*(r-l+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (ll)(r-l+<span class="number">1</span>)*k&lt;cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> query[N],ans[N];</span><br><span class="line"><span class="type">int</span> cnt[N],dep[N];</span><br><span class="line"><span class="type">int</span> ed[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">priority_queue&lt;Node&gt;q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    	<span class="built_in">read</span>(query[i]);</span><br><span class="line">    ++cnt[dep[<span class="number">1</span>]=<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">int</span> fa;</span><br><span class="line">    	<span class="built_in">read</span>(fa);</span><br><span class="line">    	++cnt[dep[i]=dep[fa]+<span class="number">1</span>];</span><br><span class="line">    	res=<span class="built_in">max</span>(res,dep[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ed[i]=i;</span><br><span class="line">		q.<span class="built_in">push</span>((Node)&#123;i,i,cnt[i]&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1e6</span>;k&gt;=<span class="number">1</span>;k--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(q.<span class="built_in">top</span>().<span class="built_in">check</span>(k))</span><br><span class="line">		&#123;</span><br><span class="line">			Node x=q.<span class="built_in">top</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span>(vis[x.l])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			vis[x.r+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">			res=<span class="built_in">max</span>(res,ed[x.l]=ed[x.r+<span class="number">1</span>]);</span><br><span class="line">			cnt[x.l]+=cnt[x.r+<span class="number">1</span>];</span><br><span class="line">			q.<span class="built_in">push</span>((Node)&#123;x.l,ed[x.l],cnt[x.l]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		ans[k]=res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[query[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>P3177 [HAOI2015] 树上染色</title>
    <url>/2022/09/03/P3177-HAOI2015-%E6%A0%91%E4%B8%8A%E6%9F%93%E8%89%B2/</url>
    <content><![CDATA[<p>树上背包。</p>
<span id="more"></span>
<p>从前，我一直认为树上背包是 $\mathcal O(n^2m)$ ，直到这道题，才知道树上背包可以做到 $\mathcal O(nm)$ 的qwq。。。</p>
<p>状态很明显是 $f_{x,i}$，表示在 $x$ 为根的子树中选取 $i$ 个黑点得到的最大贡献。很明显我们不能直接计算，而是应该计算每条边的贡献，计算每条边被路径覆盖的次数并乘上其长度。</p>
<p>考虑覆盖次数。 $cnt=k\times (m-k)+size_y\times (n-m-(size_y-k))$，表示 $x$ 的儿子 $y$ 中选取 $k$ 个黑色节点时，$(x,y)$ 的覆盖次数，这很容易理解。然后就树上背包即可。</p>
<p>注意需要先转移 $k=0$ 的状态。还有需要注意不可行的状态，判一下边界即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,M=<span class="number">4e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> si[N];</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">min</span>(si[x]+si[y],m);~j;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="built_in">max</span>(j-si[x],<span class="number">0</span>);k&lt;=<span class="built_in">min</span>(si[y],j);k++)</span><br><span class="line">            &#123;</span><br><span class="line">                ll cnt=k*(m-k)+(si[y]-k)*(n-m+k-si[y]);</span><br><span class="line">                f[x][j]=<span class="built_in">max</span>(f[x][j],f[x][j-k]+f[y][k]+cnt*e[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    m=<span class="built_in">min</span>(m,n-m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>P3960 [NOIP2017 提高组] 列队</title>
    <url>/2022/09/15/P3960-NOIP2017-%E6%8F%90%E9%AB%98%E7%BB%84-%E5%88%97%E9%98%9F/</url>
    <content><![CDATA[<p>平衡树的应用。</p>
<span id="more"></span>
<p>我们很容易将模型抽象成有 $n+1$ 个序列，然后我们对其进行区间移动操作。这似乎很容易用平衡树解决。但是发现空间根本开不下。</p>
<p>一个有用的 trick：我们可以尝试用每个节点储存一个区间。我们需要用这个区间中的子区间时，我们只需要将这个区间拆开就行。这样我们可以保证点的个数始终是 $\mathcal O(n+q)$ 的。</p>
<p>实现用 FHQ-Treap 或 Splay 都可以。FHQ-Treap 写起来似乎要简单一点，但是我却因为某个 merge 中变量写反了而调了很久。。。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll l,r;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> val,cnt;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> tot,rt[N],x,y,z;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].cnt=tr[tr[x].son[<span class="number">0</span>]].cnt+tr[tr[x].son[<span class="number">1</span>]].cnt+(tr[x].r-tr[x].l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">insert</span><span class="params">(ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[++tot].cnt=r-l+<span class="number">1</span>;</span><br><span class="line">    tr[tot].l=l;</span><br><span class="line">    tr[tot].r=r;</span><br><span class="line">    tr[tot].val=<span class="built_in">rand</span>();</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y)<span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].val&lt;tr[y].val)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].son[<span class="number">1</span>]=<span class="built_in">merge</span>(tr[x].son[<span class="number">1</span>],y);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[y].son[<span class="number">0</span>]=<span class="built_in">merge</span>(x,tr[y].son[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">pushup</span>(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> k,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> x=y=<span class="number">0</span>,<span class="built_in">void</span>();</span><br><span class="line">    <span class="keyword">if</span>(tr[tr[p].son[<span class="number">0</span>]].cnt&gt;=k)</span><br><span class="line">        y=p,<span class="built_in">split</span>(tr[p].son[<span class="number">0</span>],k,x,tr[p].son[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=k-tr[tr[p].son[<span class="number">0</span>]].cnt;</span><br><span class="line">        <span class="type">int</span> len=tr[p].r-tr[p].l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(res&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> q=<span class="built_in">insert</span>(tr[p].l+res,tr[p].r);</span><br><span class="line">            tr[p].r=tr[p].l+res<span class="number">-1</span>;</span><br><span class="line">            tr[p].son[<span class="number">1</span>]=<span class="built_in">merge</span>(q,tr[p].son[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">pushup</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        x=p,<span class="built_in">split</span>(tr[p].son[<span class="number">1</span>],res-len,tr[p].son[<span class="number">1</span>],y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        rt[i]=<span class="built_in">insert</span>(<span class="number">1ll</span>*(i<span class="number">-1</span>)*m+<span class="number">1</span>,<span class="number">1ll</span>*i*m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        rt[n+<span class="number">1</span>]=<span class="built_in">merge</span>(rt[n+<span class="number">1</span>],<span class="built_in">insert</span>(<span class="number">1ll</span>*i*m,<span class="number">1ll</span>*i*m));</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">read</span>(a,b);</span><br><span class="line">        <span class="keyword">if</span>(b==m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">split</span>(rt[n+<span class="number">1</span>],a,x,y);</span><br><span class="line">            <span class="built_in">split</span>(x,a<span class="number">-1</span>,x,z);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,tr[z].l);</span><br><span class="line">            rt[n+<span class="number">1</span>]=<span class="built_in">merge</span>(x,<span class="built_in">merge</span>(y,z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">split</span>(rt[a],b,x,y);</span><br><span class="line">            <span class="built_in">split</span>(x,b<span class="number">-1</span>,x,z);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,tr[z].l);</span><br><span class="line">            <span class="type">int</span> x1,y1,z1;</span><br><span class="line">            <span class="built_in">split</span>(rt[n+<span class="number">1</span>],a,x1,y1);</span><br><span class="line">            <span class="built_in">split</span>(x1,a<span class="number">-1</span>,x1,z1);</span><br><span class="line">            rt[a]=<span class="built_in">merge</span>(x,<span class="built_in">merge</span>(y,z1));</span><br><span class="line">            rt[n+<span class="number">1</span>]=<span class="built_in">merge</span>(x1,<span class="built_in">merge</span>(y1,z));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>FHQ-Treap</tag>
      </tags>
  </entry>
  <entry>
    <title>P5574 [CmdOI2019]任务分配问题</title>
    <url>/2022/12/07/P5574-CmdOI2019-%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>决策单调性 + 分治 优化 DP。</p>
<span id="more"></span>
<p>$\mathcal O(k n^2\log n)$ 是比较显然的，暴力 DP 配合树状数组即可。注意到 $w(i,j)+w(i-1,j+1)=w(i-1,j)+w(i,j+1)$ 的经典式子，想到决策单调性。因为贡献是不太好算的，于是我们尝试利用决策单调性直接分治求解，而每次贡献利用树状数组 $\mathcal O(n\log n)$ 求。最后一共求解 $k$ 次即可。时间复杂度为 $\mathcal O(kn\log ^2n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,K=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],t[N];</span><br><span class="line"><span class="type">int</span> f[N],g[N];</span><br><span class="line"><span class="type">int</span> res,tl,tr;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        t[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        res+=t[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tl&gt;l)tl--,res+=<span class="built_in">ask</span>(a[tl]),<span class="built_in">add</span>(a[tl],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(tr&lt;r)tr++,res+=tr-tl-<span class="built_in">ask</span>(a[tr]),<span class="built_in">add</span>(a[tr],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(tl&lt;l)<span class="built_in">add</span>(a[tl],<span class="number">-1</span>),res-=<span class="built_in">ask</span>(a[tl]),tl++;</span><br><span class="line">    <span class="keyword">while</span>(tr&gt;r)<span class="built_in">add</span>(a[tr],<span class="number">-1</span>),res-=tr-tl-<span class="built_in">ask</span>(a[tr]),tr--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,pm=mid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(pr,mid<span class="number">-1</span>);i&gt;=pl;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">calc</span>(i+<span class="number">1</span>,mid);</span><br><span class="line">        <span class="keyword">if</span>(g[i]+res&lt;=f[mid])f[mid]=g[i]+res,pm=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(pl,pm,l,mid<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">solve</span>(pm,pr,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        a[i]=n-a[i]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tl=<span class="number">1</span>,tr=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>]=g[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            g[j]=f[j];</span><br><span class="line">        <span class="built_in">solve</span>(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>决策单调性</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P6186 [NOI Online #1 提高组] 冒泡排序</title>
    <url>/2022/08/29/P6186-NOI-Online-1-%E6%8F%90%E9%AB%98%E7%BB%84-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>不错的思维题。</p>
<span id="more"></span>
<p>先考虑进行一轮冒泡排序的结果。我们发现，对于一个数，当且仅当它前面没有大于它的数，它的位置会被后移到第一个大于它的数，并且在之后的每一轮都会后移。并且每轮冒泡排序有 $k$ 个这样的数，那么这一轮减少的逆序对数量就是 $n-k$。更进一步，我们发现：若一个数前面有 $\le k$ 个大于它的数，那么它将在第 $k+1$ 轮冒泡排序时一定会被后移。</p>
<p>于是我们考虑预处理出 $pre_i$ 表示第 $i$ 个数前面有多少个大于它的数，这个很容易可以用树状数组来求。而逆序对个数就是 $\sum_{i=1}^{n} pre_i$。我们再用树状数组来维护 $k$ 轮冒泡排序进行完后的逆序对个数就行了。</p>
<p>对于修改操作也很简单，就是一个差分形式，直接单点修改就可以了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">ll sum,c[N],pre[N],p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        c[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        res+=c[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        pre[i]=i<span class="number">-1</span>-<span class="built_in">ask</span>(a[i]);</span><br><span class="line">        sum+=pre[i],p[pre[i]]++;</span><br><span class="line">        <span class="built_in">add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>,sum);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res+=p[i];</span><br><span class="line">        <span class="built_in">add</span>(i+<span class="number">2</span>,res-n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,x;</span><br><span class="line">        <span class="built_in">read</span>(op,x);</span><br><span class="line">        x=<span class="built_in">min</span>(x,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[x+<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">swap</span>(pre[x],pre[x+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[x]&lt;a[x+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                pre[x]--;</span><br><span class="line">                <span class="built_in">add</span>(pre[x]+<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">add</span>(pre[x+<span class="number">1</span>]+<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">                pre[x+<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask</span>(x+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>P4841 [集训队作业2013]城市规划</title>
    <url>/2023/01/12/P4841-%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013-%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>所以，到底用没用了生成函数的知识？</p>
<p>upd on 2023.6.6：现在有指数生成函数做法了，<del>不过不在这里，在“生成函数”一文的例题中</del>。</p>
<span id="more"></span>
<p>之前在蓝书上看到过一点这类题的 DP 做法。结果感觉这题的做法有点类似，只不过变成卷积来求，反而跟生成函数没有太大的联系（？）。</p>
<p>设计两个函数 $f(x),g(x)$ 分别表示有标号的无向图和有标号的无向连通图。考虑这类问题的经典套路，固定点 $1$，枚举点 $1$ 所在连通块大小，可以得到关系式：</p>
<script type="math/tex; mode=display">
g(x)=\sum_{i=1}^x {\binom{x-1}{i-1} f(i)g(x-i)}</script><p>显然有 $g(x)=2^{\binom{x}{2}}$，将其带入并做一些变换：</p>
<script type="math/tex; mode=display">
2^{\binom{x}{2}}=\sum_{i=1}^x {\binom{x-1}{i-1} f(i)2^{\binom{n-i}{2}}}\\
\frac {2^{\binom{x}{2}}}{(n-1)!}=\sum_{i=1}^x {\frac{f(i)2^{\binom{n-i}{2}}}{(i-1)!(n-i)!}}</script><p>这就变成类似卷积的形式了，为了更好的操作，我们另外设计几个函数：</p>
<script type="math/tex; mode=display">
F(x)=\frac{f(x)}{(x-1)!}\\
G(x)=\frac{2^{\binom{n-x}{2}}}{x!}\\
H(x)=\frac{2^{\binom{n-x}{2}}}{(x-1)!}</script><p>我们明显有：</p>
<script type="math/tex; mode=display">
H(x)=F(x)G(X)\\
F(x)=H(x)G^{-1}(x) \mod x^{n+1}</script><p>对 $G(x)$ 求逆再和 $H(x)$ 卷积就得到了 $F(x)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,mod=<span class="number">1004535809</span>,G=<span class="number">3</span>,Gi=<span class="number">334845270</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> fac[N],finv[N];</span><br><span class="line"><span class="type">int</span> bit,tot,rev[N];</span><br><span class="line"><span class="type">int</span> g[N],ginv[N],h[N];</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bit=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;(len&lt;&lt;<span class="number">1</span>))bit++;</span><br><span class="line">	tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;bit<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">		x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		<span class="keyword">if</span>(rev[i]&lt;i)<span class="built_in">swap</span>(a[rev[i]],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> g=<span class="built_in">qpow</span>(inv==<span class="number">1</span>?G:Gi,(mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,cur=<span class="number">1</span>;j&lt;mid;j++,cur=<span class="number">1ll</span>*cur*g%mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x=a[i+j],y=<span class="number">1ll</span>*cur*a[i+j+mid]%mod;</span><br><span class="line">				a[i+j]=<span class="built_in">adj</span>(x+y),a[i+j+mid]=<span class="built_in">adj</span>(x-y+mod);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poly_mul</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">1</span>),<span class="built_in">NTT</span>(b,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		a[i]=<span class="number">1ll</span>*a[i]*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> inv=<span class="built_in">qpow</span>(tot,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		a[i]=<span class="built_in">adj</span>(<span class="number">1ll</span>*a[i]*inv%mod+mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poly_inv</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		b[<span class="number">0</span>]=<span class="built_in">qpow</span>(a[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">poly_inv</span>(a,b,(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">init</span>(len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;i&lt;tot;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		c[i]=(i&lt;len?a[i]:<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">1</span>),<span class="built_in">NTT</span>(c,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		b[i]=<span class="number">1ll</span>*<span class="built_in">adj</span>(<span class="number">2</span><span class="number">-1ll</span>*b[i]*c[i]%mod+mod)*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> inv=<span class="built_in">qpow</span>(tot,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		b[i]=<span class="built_in">adj</span>(<span class="number">1ll</span>*b[i]*inv%mod+mod);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;tot;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	fac[<span class="number">0</span>]=finv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod,finv[i]=<span class="built_in">qpow</span>(fac[i],mod<span class="number">-2</span>);</span><br><span class="line">	g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> res=<span class="built_in">qpow</span>(<span class="number">2</span>,(<span class="number">1ll</span>*i*(i<span class="number">-1</span>)/<span class="number">2</span>)%(mod<span class="number">-1</span>));</span><br><span class="line">		g[i]=<span class="number">1ll</span>*res*finv[i]%mod;</span><br><span class="line">		h[i]=<span class="number">1ll</span>*res*finv[i<span class="number">-1</span>]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	n++;</span><br><span class="line">	<span class="built_in">poly_inv</span>(g,ginv,n);</span><br><span class="line">	<span class="built_in">poly_mul</span>(h,ginv,n);</span><br><span class="line">	n--;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1ll</span>*h[n]*fac[n<span class="number">-1</span>]%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>P5999 [CEOI2016] kangaroo</title>
    <url>/2022/09/01/P5999-CEOI2016-kangaroo/</url>
    <content><![CDATA[<p>可能（？）有用的 DP trick。</p>
<span id="more"></span>
<p><a href="https://www.luogu.com.cn/problem/P5999">题目链接</a></p>
<p>先转化题意，我们实际上需要求的就是满足以下条件的 $1\to n$ 排列 $a$ 的个数：</p>
<p>1.$a_1=s,a_n=t$；</p>
<p>2.$\forall i\in [2,n-1],(a_i-a_{i-1})\times (a_i-a_{i+1}) &gt;0$。</p>
<p>如何 DP 呢？这似乎并不好弄，因为我们进行传统的 DP 时我们并不好知道用了哪些数。</p>
<p>于是我们考虑新的思路，尝试分段型 DP。从小到大考虑将每个数插到满足条件的两段之间。这样得到的新段一定是满足条件的，并且不会算重。于是设计状态 $f_{i,j}$ 表示插入了 $i$ 个数，形成了 $j$ 个连续的段的方案数。转移时考虑将 $i$ 插进前面两段之间，或者新建一段就可以了。注意只能将 $s$ 插到最前面，将 $t$ 插到最后面。并且新建一段时不可以将其他数插在 $s$ 之前 $t$ 之后。</p>
<p>或者换一种理解方式，我们将 $f_{i,j}$ 表示使用前 $i$ 个数建了 $j$ 个笛卡尔树。每次转移时，将已有的某两颗笛卡尔树接在当前的 $i$ 上，或者以 $i$ 再建一颗笛卡尔树。容易发现这样构成的笛卡尔树所对应的序列就是满足条件的排列 $a$。</p>
<p>我们这里是将每一段看做相对有序的。其实也可以看成相对无序的，转移方程有所不同。但结果都一样是 $f_{n,1}$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,s,t;</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;s,&amp;t);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=s&amp;&amp;i!=t)</span><br><span class="line">                f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j+<span class="number">1</span>]*j+f[i<span class="number">-1</span>][j<span class="number">-1</span>]*(j-(i&gt;s)-(i&gt;t)))%mod;<span class="comment">//插到中间或新建一段</span></span><br><span class="line">            <span class="keyword">else</span> f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;<span class="comment">//插到两端或新建一段</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P8112 [Cnoi2021]符文破译</title>
    <url>/2022/08/18/P8112-Cnoi2021-%E7%AC%A6%E6%96%87%E7%A0%B4%E8%AF%91/</url>
    <content><![CDATA[<p>不错的 Z 函数练习题。</p>
<span id="more"></span>
<p>很明显正着做不好搞，因为假如选取了当前某个前缀，很容易影响到后面的选取，并且不好优化。</p>
<p>经典正难则反的思想，考虑从后面逐渐选取模式串的前缀，这样就不会影响到前面前缀的选取。也就意味着，我们每次尝试选取一个文本串的一个后缀，使其等于模式串的前缀，然后进行下一步操作。</p>
<p>这是我们想到什么？ Z 函数不就是用来求出这东西的吗。考虑 DP，我们很容易写出状态转移方程：</p>
<script type="math/tex; mode=display">
f_i=\min_{i+1\le j\le i+p_i}{f_j+1}</script><p>有了这个，直接暴力 DP 是 $\mathcal O(n^2)$ 的，显然可以用线段树来维护，但 $\mathcal O(n\log n)$ 复杂度仍不允许我们通过此题。</p>
<p>还能继续优化吗？注意到对于所以可以转移到的 $f_i$  一定是具有单调性，因为较短的后缀的代价一定不会大于较长的后缀的代价。而且根据 Z 函数 的性质，对于所有可以转移到的 $i$，$i+p_i$ 明显是单调递减的。这就转化为经典模型了，我们很容易用单调队列来优化，于是复杂度就变为了优秀的 $\mathcal O(n)$。</p>
<p>因为 $f_i$ 具有单调性，每次我们直接将其加入队尾就可以了。然后注意一些细节就可以了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> z[N],p[N],f[N];</span><br><span class="line"><span class="type">int</span> l,r,q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Z</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    z[<span class="number">1</span>]=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r)z[i]=<span class="built_in">min</span>(z[i-l+<span class="number">1</span>],r-i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i+z[i]&lt;=n&amp;&amp;s[i+z[i]]==s[z[i]+<span class="number">1</span>])z[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+z[i]<span class="number">-1</span>&gt;r)l=i,r=i+z[i]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exkmp</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n,<span class="type">char</span> *t,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Z</span>(t,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l=<span class="number">0</span>,r=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r)p[i]=<span class="built_in">min</span>(z[i-l+<span class="number">1</span>],r-i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i+p[i]&lt;=n&amp;&amp;s[i+p[i]]==t[p[i]+<span class="number">1</span>])p[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+p[i]<span class="number">-1</span>&gt;r)l=i,r=i+p[i]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//Z函数模板</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s %s&quot;</span>,&amp;m,&amp;n,b+<span class="number">1</span>,a+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exkmp</span>(a,n,b,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        j&gt;i+p[i]?p[i]=<span class="number">0</span>:j=i+p[i];<span class="comment">//注意处理不可能转移到的情况</span></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[q[l=r=<span class="number">1</span>]=n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)sa</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!p[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&gt;i+p[i])l++;</span><br><span class="line">        f[i]=f[q[l]]+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// while(l&lt;=r&amp;&amp;f[q[r]]&gt;=f[i])r--;</span></span><br><span class="line">        <span class="comment">//这里直接入队就可以了</span></span><br><span class="line">        q[++r]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[<span class="number">1</span>]&lt;=INF)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Fake&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>希望没有误人子弟 qwq。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>KMP</tag>
        <tag>Z函数</tag>
        <tag>字符串</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P8867 [NOIP2022] 建造军营</title>
    <url>/2022/12/05/P8867-NOIP2022-%E5%BB%BA%E9%80%A0%E5%86%9B%E8%90%A5/</url>
    <content><![CDATA[<p>算是敲个警钟。</p>
<span id="more"></span>
<p>题外话：笔者在 NOIP2022 的考场上，因为水平并不高，给了自己一种会做 T2 的错觉，于是直接放弃可做性更强的 T3 选择暴冲 T2 。最终没有能够取得理想成绩。在此警示后人。</p>
<p>提供一种不太一样的 DP（？）。</p>
<p>很容易考虑到双连通分量缩点，再树形DP（不在树上的边我们称之为非树边）。对于 $\mathcal O(n^2)$ 有比较显然的树形背包。</p>
<p>考虑如何做到线性。设计状态 $f_x$ 表示在以 $x$ 为根的子树中，至少选了一个点，且与 $x$ 连通的方案数。设 $sum_x$ 表示以 $x$ 为根的子树中边的总数。考虑每个子节点 $y$ 对 $f_x$ 的贡献：选取的话贡献为 $f_y$，不选取那么子树 $y$ 中的边和 $y\to x$ 这条边可以随便选（但是点不能选），所以贡献为 $2^{sum_y+1}$。再减去一个点不选的方案数 $2^{sum_x}$ 即可。</p>
<p>因为子树外的边（并且除去到父亲节点的边）可以随便选取，所以对答案的贡献就是 $f_x\times2^{m-sum_x-[fa!=0]}$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,head[N],ver[M&lt;&lt;<span class="number">1</span>],ne[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> num,dfn[N],low[N],bri[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt,c[N];</span><br><span class="line"><span class="type">int</span> a[N],b[N],sum[N];</span><br><span class="line">ll f[N],ans,p[N+M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y,i);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]&lt;low[y])</span><br><span class="line">                bri[i]=bri[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i!=(pre^<span class="number">1</span>))</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c[x]=cnt;</span><br><span class="line">    a[cnt]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!c[y]&amp;&amp;!bri[i])</span><br><span class="line">            <span class="built_in">prework</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x]=p[a[x]+b[x]]%mod;<span class="comment">//f[x]初值</span></span><br><span class="line">    sum[x]=b[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        sum[x]+=sum[y]+<span class="number">1</span>;</span><br><span class="line">        f[x]=f[x]*((f[y]+p[sum[y]+<span class="number">1</span>])%mod)%mod;</span><br><span class="line">        <span class="comment">//y对f[x]的贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=(f[x]+mod-p[sum[x]])%mod;<span class="comment">//减去一个点都不选的方案数</span></span><br><span class="line">    ans=(ans+f[x]*p[m-sum[x]-(fa!=<span class="number">0</span>)]%mod)%mod;<span class="comment">//统计总的方案数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Tarjan</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!c[i])</span><br><span class="line">            cnt++,<span class="built_in">prework</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(c[x]==c[y])b[c[x]]++;</span><br><span class="line">            <span class="keyword">else</span> e[c[x]].<span class="built_in">push_back</span>(c[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        b[i]/=<span class="number">2</span>;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)</span><br><span class="line">        p[i]=(p[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>缩点</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>P8917 [DMOI-R2] 风神瞳（Aeolus Hitomi）</title>
    <url>/2022/12/30/P8917-DMOI-R2-%E9%A3%8E%E7%A5%9E%E7%9E%B3%EF%BC%88Aeolus-Hitomi%EF%BC%89/</url>
    <content><![CDATA[<p>比较裸的树上背包。</p>
<span id="more"></span>
<p>最需要处理的就是向叶子节点连续跳 $k$ 步。设计状态 $f_{x,t,i}$ 为从 $x$ 还需要向叶子节点跳 $t$ 步并且收集 $i$ 个风神瞳最少花费。</p>
<p>考虑如何转移。因为这 $t$ 步只能跳一次，转移过程中我们令 $f_{x,t,i}$ 已经使用了这 $t$ 步。而对于子节点 $y$：</p>
<p>1.在 $y$ 上跳这 $t$ 步，那么相当于 $x$ 在之前的子树上需要跳 $0$ 步：$f_{x,t,i}\gets f_{x,0,i-j}+f_{y,t-1,j}+1$。</p>
<p>2.在之前的子树上跳了这 $t$ 步，那么相当 $x$ 在 $y$ 上需要跳 $0$ 步。而我们可以选择直接走到 $y$，或者先向上走 $\le \min \{dep_x-1,k\}$ 步，再向叶子结点跳 $k$ 步：$f_{x,t,i}\gets f_{x,t,i-j}+ \min \{f_{y,0,j}+2,\min_{p=\max \{k-dep_x+1,1\}}^{k}{k-p+1+f_{y,p-1,j}+1 \}}$，后面的式子是一个整体，拿出来单独计算即可。</p>
<p>对于 $t=0$ 单独处理，类似上面的转移。时间复杂度 $\mathcal O(nmk)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,M=<span class="number">5e2</span>+<span class="number">10</span>,K=<span class="number">1e2</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,p,q;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> a[N],si[N],d[N];</span><br><span class="line"><span class="type">int</span> f[N][K][M],ans[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=a[x];</span><br><span class="line">    f[x][<span class="number">0</span>][a[x]]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=si[x]+si[y];~j;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="built_in">max</span>(j-si[x],<span class="number">0</span>);k&lt;=si[y];k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> res=INF;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="built_in">max</span>(p-d[x],<span class="number">1</span>);t&lt;=p;t++)</span><br><span class="line">                    res=<span class="built_in">min</span>(res,(p-t+<span class="number">1</span>)+f[y][t<span class="number">-1</span>][k]+<span class="number">1</span>);</span><br><span class="line">                res=<span class="built_in">min</span>(res,f[y][<span class="number">0</span>][k]+<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=p<span class="number">-1</span>;t++)</span><br><span class="line">                    f[x][t][j]=<span class="built_in">min</span>(&#123;f[x][t][j],f[x][<span class="number">0</span>][j-k]+<span class="number">1</span>+f[y][t<span class="number">-1</span>][k],f[x][t][j-k]+res&#125;);</span><br><span class="line">                f[x][<span class="number">0</span>][j]=<span class="built_in">min</span>(f[x][<span class="number">0</span>][j],f[x][<span class="number">0</span>][j-k]+res);</span><br><span class="line">            &#125;</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,p,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        a[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][m+<span class="number">1</span>]=<span class="number">2</span>*n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=f[<span class="number">1</span>][<span class="number">0</span>][i];j&lt;f[<span class="number">1</span>][<span class="number">0</span>][i+<span class="number">1</span>];j++)</span><br><span class="line">            ans[j]=i;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">2</span>*n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>P8859 冒泡排序</title>
    <url>/2023/04/16/P8859-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>很早之前看过的趣题。</p>
<span id="more"></span>
<p>先考虑 $\text{type}=1$ 的情况。考虑一个贪心策略，每次操作将该元素操作到一个比它小的元素为止。显然这样是最优的。所以一个元素是前缀最大值时是不用操作的，容易得到 $f(A)=n-\sum_{i=1}^{n} [a_i=\max_{j=1}^ia_j]$。考虑 DP，设 $f_{i,j}$ 表示选取 $i$ 个元素有 $j$ 个元素为前缀最大值，每次插入一个最小的元素进行转移。因为插在最前面才会有贡献，于是容易得到状态转移方程 $f_{i,j}\gets f_{i-1,j-1}+(i-1)\times f_{i-1,j}$。时间复杂度 $\mathcal O(n^2)$。</p>
<p>再考虑 $\text{type}=2$ 的情况。我们不妨直接固定元素 $n$ 为最后一个元素，直接转化为排列的情况。</p>
<p>因为必然会有一个点不会被移动，所以我们可以将前面连续的一段移到序列的末尾，可以视作没有花费，但是这些移到末尾的数是一定会被操作的（因为小于元素 $n$）。这样产生的 $n$ 个新的排列的 $f(A’)$ 的最小值就是原排列的 $f(A)$。</p>
<p>还是设计状态 $f_{i,j}$ 表示选取 $i$ 个元素有 $j$ 个元素不用操作，考虑把最大的元素插入在两段的中间。设前面一段区间有 $p$ 个不用操作，后面一段区间有 $q$ 个不用操作。</p>
<p>我们可以选择直接将该元素插入，那么不用操作的个数为 $p+1$；或者将前面一段区间加上该元素一起移到序列的末尾，这样不用操作的个数应该是 $q$，所以得到状态转移方程 $\displaystyle f_{i,\max \{p+1,q\}}\gets \binom{i-1}{j} f_{j,p}\times f_{i-j-1,q}$。通过前缀和可以做到 $\mathcal O(n^3)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,type;</span><br><span class="line"><span class="type">int</span> C[N][N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        C[i][j]=<span class="built_in">adj</span>(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,type);</span><br><span class="line">    m=n-m;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">                f[i][j]=<span class="built_in">adj</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1ll</span>*(i<span class="number">-1</span>)*f[i<span class="number">-1</span>][j]%mod);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n--,m--;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[<span class="number">0</span>][i]=f[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">                    f[i][k]=<span class="built_in">adj</span>(f[i][k]+<span class="number">1ll</span>*C[i<span class="number">-1</span>][j]*f[j][k<span class="number">-1</span>]%mod*f[i-j<span class="number">-1</span>][k]%mod);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">adj</span>(f[n][m]-f[n][m<span class="number">-1</span>]+mod));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P8907 [USACO22DEC] Making Friends P</title>
    <url>/2023/01/02/P8907-USACO22DEC-Making-Friends-P/</url>
    <content><![CDATA[<p>线段树合并，也可以启发式合并。</p>
<span id="more"></span>
<p>首先，对于一条边 $i \to j$，只有 $i &lt; j$ 时有意义，并且。对于每个点，统计时我们也只统计这样的边。考虑维护每个点与相邻点的点集，而每次将该点的点集合并到 该点的点集中编号最小的点上，仔细思考会发现这样是不重不漏的。</p>
<p>较为简单地可以用 set 启发式合并维护这个点集，时间复杂度 $\mathcal O(n\log^2 n)$。但更加优秀的是用线段树合并来维护，时间复杂度 $\mathcal O(n \log n)$，<del>但是竟然没有前面一种写法跑得快</del>。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> tot,rt[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr[N*<span class="number">80</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].sum=tr[tr[x].lc].sum+tr[tr[x].rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)x=++tot;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> tr[x].sum=<span class="number">1</span>,<span class="built_in">void</span>();</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">insert</span>(tr[x].lc,l,mid,pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p||!q)<span class="keyword">return</span> p+q;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum=tr[p].sum|tr[q].sum;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[p].lc=<span class="built_in">merge</span>(tr[p].lc,tr[q].lc,l,mid);</span><br><span class="line">    tr[p].rc=<span class="built_in">merge</span>(tr[p].rc,tr[q].rc,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].lc&amp;&amp;tr[tr[x].lc].sum)<span class="keyword">return</span> <span class="built_in">query</span>(tr[x].lc,l,mid);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(tr[x].rc,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> tr[x].sum=k,<span class="built_in">void</span>();</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(tr[x].lc,l,mid,pos,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(tr[x].rc,mid+<span class="number">1</span>,r,pos,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="keyword">if</span>(u&gt;v)<span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="built_in">insert</span>(rt[u],<span class="number">1</span>,n,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[rt[x]].sum)<span class="keyword">continue</span>;</span><br><span class="line">        ans+=tr[rt[x]].sum;</span><br><span class="line">        <span class="type">int</span> y=<span class="built_in">query</span>(rt[x],<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">modify</span>(rt[x],<span class="number">1</span>,n,y,<span class="number">0</span>);</span><br><span class="line">        rt[y]=<span class="built_in">merge</span>(rt[y],rt[x],<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans-m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树合并</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>SP3734 PERIODNI - Periodni</title>
    <url>/2022/09/02/SP3734-PERIODNI-Periodni/</url>
    <content><![CDATA[<p>笛卡尔树上进行 DP。</p>
<span id="more"></span>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506">HDU 1506 最大子矩形</a> 也可以用笛卡尔树来做，具体思路就是对于高度建笛卡尔树，再一遍 dfs 即可计算。注意到这道题，直觉告诉我们也需要从高度最小的考虑。于是我们也考虑建出笛卡尔树进行 DP。</p>
<p>这样就变成一个树上背包计数，我们每一次递归子树的时候考虑    将当前列的高度去掉，只计算之上的，这样就不会影响到当前行。很明显有转移方程：$f_{x,i}\gets f_{x,i-j}\times f_{y,j}$。</p>
<p>再考虑将当前高度，就是计算在 $h_x\times size_x$ 的方格里选取 $k$ 个点的方案数。选 $k$ 行 $\binom{k}{h_x}$，选 $k$ 列 $\binom{k}{size_x}$，并且是无序的，所以方案数就是 $k! \cdot \binom{k}{h_x}\cdot \binom{k}{size_x}$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,M=<span class="number">1e7</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> top,sta[N];</span><br><span class="line">ll fac[M];</span><br><span class="line"><span class="type">int</span> si[N];</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;M;i++)</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (mod-mod/x)*<span class="built_in">inv</span>(mod%x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*<span class="built_in">inv</span>(fac[m])%mod*<span class="built_in">inv</span>(fac[n-m])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>]=si[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=tr[x].l;</span><br><span class="line">        <span class="built_in">dfs</span>(y,tr[x].val);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(si[x],k);~i;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,si[y]);j++)</span><br><span class="line">                f[x][i]=(f[x][i]+f[x][i-j]*f[y][j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=tr[x].r;</span><br><span class="line">        <span class="built_in">dfs</span>(y,tr[x].val);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(si[x],k);~i;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,si[y]);j++)</span><br><span class="line">                f[x][i]=(f[x][i]+f[x][i-j]*f[y][j]%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(si[x],k);~i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,tr[x].val-res);j++)</span><br><span class="line">            f[x][i]=(f[x][i]+f[x][i-j]*fac[j]%mod*<span class="built_in">C</span>(tr[x].val-res,j)%mod*<span class="built_in">C</span>(si[x]-(i-j),j)%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(tr[i].val);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=top;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;tr[sta[p]].val&gt;tr[i].val)</span><br><span class="line">            p--;</span><br><span class="line">        <span class="keyword">if</span>(p)tr[sta[p]].r=i;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;top)tr[i].l=sta[p+<span class="number">1</span>];</span><br><span class="line">        sta[++p]=i;</span><br><span class="line">        top=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(sta[<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[sta[<span class="number">1</span>]][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>背包</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title>SP6717 TWOPATHS - Two Paths</title>
    <url>/2022/09/05/SP6717-TWOPATHS-Two-Paths/</url>
    <content><![CDATA[<p>比较裸的换根 DP。</p>
<span id="more"></span>
<p><del>虚高题</del>。</p>
<p>update on 2022.11.13。原题解被 @zhanghenglei 所 Hack。现在已将解法修正，如果仍有问题，欢迎指出qwq。</p>
<p>不难想到用 $f_x,g_x$ 分别表示以 $x$ 为根的子树内和子树外最长链的长度。答案就是 $\max\{f_x\times g_x\}$。$f_x$ 很容易求，考虑 $g_x$ 怎么求。</p>
<p>$g_x$ 可以从父亲节点转移过来，这启发我们可以类似于换根 DP 的方法来求 $g_x$。</p>
<p>考虑怎么构成一条子树外的链。无非是从父节点往上延伸，或者从父节点往下延伸的链。再将他们最长的两段在父节点拼起来成为一个答案。</p>
<p>但是我们选取的两段链不能在 $x$ 的子树中。这就意味着我们需要先求出，从父节点往下延伸的链的最大值、亚大值和次大值，以及对应的子节点。转移时判断一下所选的链有没有在 $x$ 的子树中就行。</p>
<p>从该节点 $x$ 往上延伸的最长链也可以通过最大值和亚大值通过换根 DP 来求出，也比较简单。</p>
<p>但是这样解是有漏洞的，$g_x$ 求出来只是恰好经过其父节点的最长链，而不是整棵树中除去该子树的最长链，就像这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/93kgatph.png" alt=""></p>
<p><code>output : 30</code><br><code>answer : 36</code></p>
<p>所以我们需要再多记一个 $h_x$ 表示该节点的父节点的子树之外的最长链，转移与上面类似。</p>
<p>具体可看看代码，有一些注释。有点繁琐，但还是比较好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[N][<span class="number">3</span>],l[N],t[N][<span class="number">3</span>],f[N],g[N],h[N];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">2</span>]=d[x][<span class="number">1</span>],t[x][<span class="number">2</span>]=t[x][<span class="number">1</span>];</span><br><span class="line">            d[x][<span class="number">1</span>]=d[x][<span class="number">0</span>],t[x][<span class="number">1</span>]=t[x][<span class="number">0</span>];</span><br><span class="line">            d[x][<span class="number">0</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">0</span>]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">2</span>]=d[x][<span class="number">1</span>],t[x][<span class="number">2</span>]=t[x][<span class="number">1</span>];</span><br><span class="line">            d[x][<span class="number">1</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">1</span>]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">2</span>])</span><br><span class="line">            d[x][<span class="number">2</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">2</span>]=y;</span><br><span class="line">        <span class="comment">//处理出从该节点往下延伸的链的最大值、亚大值和次大值</span></span><br><span class="line">        <span class="comment">//以及其所对应的儿子</span></span><br><span class="line">        f[x]=<span class="built_in">max</span>(f[x],f[y]);<span class="comment">//从子节点转移</span></span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=<span class="built_in">max</span>(f[x],d[x][<span class="number">0</span>]+d[x][<span class="number">1</span>]);<span class="comment">//从自己转移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,<span class="number">1ll</span>*f[x]*<span class="built_in">max</span>(g[x],h[x]));<span class="comment">//统计答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        l[y]=l[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[x][<span class="number">0</span>]&amp;&amp;t[x][<span class="number">0</span>]!=y)</span><br><span class="line">            l[y]=<span class="built_in">max</span>(l[x],d[x][<span class="number">0</span>])+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[x][<span class="number">1</span>])</span><br><span class="line">            l[y]=<span class="built_in">max</span>(l[x],d[x][<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//转移从该节点向上延伸的最长链</span></span><br><span class="line">        <span class="type">int</span> res[<span class="number">4</span>];</span><br><span class="line">        res[<span class="number">0</span>]=t[x][<span class="number">0</span>]!=y?d[x][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>]=t[x][<span class="number">1</span>]!=y?d[x][<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">2</span>]=t[x][<span class="number">2</span>]!=y?d[x][<span class="number">2</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">3</span>]=l[x];</span><br><span class="line">        <span class="built_in">sort</span>(res,res+<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//从四条链中选取合法的最长的两条</span></span><br><span class="line">        g[y]=<span class="built_in">max</span>(g[x],res[<span class="number">2</span>]+res[<span class="number">3</span>]);</span><br><span class="line">        h[y]=h[x];</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x);</span><br><span class="line">        res[<span class="number">0</span>]=t[y][<span class="number">0</span>]!=y?d[y][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>]=t[y][<span class="number">1</span>]!=y?d[y][<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">2</span>]=t[y][<span class="number">2</span>]!=y?d[y][<span class="number">2</span>]:<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(res,res+<span class="number">3</span>);</span><br><span class="line">        h[x]=<span class="built_in">max</span>(h[x],res[<span class="number">1</span>]+res[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//转移该节点的父节点的子树之外的最长链</span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>换根DP</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/2023/03/24/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<p>博弈论入门及其经典模型。</p>
<span id="more"></span>
<h3 id="1-SG-函数"><a href="#1-SG-函数" class="headerlink" title="1.SG 函数"></a>1.SG 函数</h3><p>SG 函数是用于解决博弈论中公平组合游戏（<strong>I</strong>mpartial <strong>C</strong>ombinatorial <strong>G</strong>ames，<strong>ICG</strong>）问题的一种方法。此处我们主要讨论公平组合游戏。</p>
<h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p>设一个状态 $X$，设其后继状态的 SG 函数为 $A=\{SG(Y_1),SG(Y_2),\dots,SG(Y_n)\}$，定义：</p>
<script type="math/tex; mode=display">
SG(A)=\left\{
\begin{align}
&0 & {A = \emptyset}\\
&\text{mex}(A) & {A\ne \emptyset}
\end{align}
\right.
\notag</script><p>其中 $\text{mex}(A)$ 表示未在 $A$ 种出现的最小非负整数。</p>
<h4 id="2-性质"><a href="#2-性质" class="headerlink" title="2.性质"></a>2.性质</h4><p>即 SG 定理。设两个互相独立的状态 $X,Y$，状态 $X+Y$ 表示两个状态的组合，有：</p>
<script type="math/tex; mode=display">
SG(X+Y)=SG(X)\oplus SG(Y)</script><p>进一步得到：</p>
<script type="math/tex; mode=display">
SG(X_1+X_2+\dots +X_n)=SG(X_1)\oplus SG(X_2)\oplus \dots \oplus SG(X_n)</script><p>这是我们用 SG 函数求解的关键。</p>
<h3 id="2-基本模型"><a href="#2-基本模型" class="headerlink" title="2.基本模型"></a>2.基本模型</h3><h4 id="1-有向图游戏"><a href="#1-有向图游戏" class="headerlink" title="1.有向图游戏"></a>1.有向图游戏</h4><p>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。判断先手必胜。</p>
<p>SG 函数本质上就是将公平组合游戏中的状态与状态的转移 转化为 有向图上的点与边。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>博弈论</tag>
        <tag>SG函数</tag>
      </tags>
  </entry>
  <entry>
    <title>二项式反演</title>
    <url>/2023/03/16/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<p>经典有用的反演。</p>
<span id="more"></span>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>有这么几个比较重要的式子：</p>
<script type="math/tex; mode=display">
\begin{align}
f(n)=\sum_{i=0}^n (-1)^i \binom{n}{i} g(i)&\Longleftrightarrow g(n)=\sum_{i=0}^n (-1)^i \binom{n}{i} f(i)\\
f(n)=\sum_{i=0}^n \binom{n}{i} g(i)&\Longleftrightarrow g(n)=\sum_{i=0}^n (-1)^{n-i} \binom{n}{i} f(i)\\
f(n)=\sum_{i=n}^m (-1)^i \binom{i}{n} g(i)&\Longleftrightarrow g(n)=\sum_{i=n}^m (-1)^i \binom{i}{n} f(i)\\
f(n)=\sum_{i=n}^m \binom{i}{n} g(i)&\Longleftrightarrow g(n)=\sum_{i=n}^m (-1)^{i-n} \binom{i}{n} f(i)
\end{align}</script><p>这些正是我们进行二项式反演的基础式子，似乎能看到一些容斥的影子。但是公式的运用是浅显的，更加重要的是关于模型的构建。</p>
<p>另外地，利用上式暴力求 $g(1),g(2),\dots,g(n)$ 是 $\mathcal O(n^2)$ 的。但是可以做到更优。我们有：</p>
<script type="math/tex; mode=display">
\begin{align}
f(n)&=\sum_{i=0}^n \binom{n}{i} g(i)\notag\\
\frac{f(n)}{n!}&=\sum_{i=0}^n \frac{1}{(n-i)!}\frac{g(n)}{i!}\notag\\
\end{align}</script><p>设 $F(x),G(x)$ 为 $f(n),g(n)$ 的 EGF。并且有 $\displaystyle e^x=\sum_{n&gt;0}\frac{x_n}{n!}$。我们辨认出卷积的形式，得到：</p>
<script type="math/tex; mode=display">
\begin{align}
F(x)=G(x)*e^x\Longleftrightarrow G(x)=F(x)*e^{-x}
\end{align}</script><p>利用 $(5)$ 式我们可以用 NTT 加速卷积求 $g(1),g(2),\dots,g(n)$，时间复杂度为 $\mathcal O(n\log n)$。</p>
<h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2.例题"></a>2.例题</h3><h4 id="1-P4859-已经没有什么好害怕的了"><a href="#1-P4859-已经没有什么好害怕的了" class="headerlink" title="1.P4859 已经没有什么好害怕的了"></a>1.<a href="https://www.luogu.com.cn/problem/P4859">P4859 已经没有什么好害怕的了</a></h4><p>相当求使 $a&gt;b$ 恰好有 $k$ 对的方案数。注意到 ”恰好“，联想到转化为 “至少” 来求解（”至少“ 限制更宽松，在多数情况下是相对更好求的）。设计 $f(n)$ 表示至少 $n$ 个满足 $a&gt;b$ 的方案数， $g(n)$ 表示恰好 $n$ 个满足  $a&gt;b$ 的方案数。我们要求的就是 $g(k)$。对于这两个函数，我们有关系式：</p>
<script type="math/tex; mode=display">
f(k)=\sum_{i=k}^n \binom{i}{k} g(i)</script><p>使用式子 $(4)$ 进行二项式反演：</p>
<script type="math/tex; mode=display">
g(k)=\sum_{i=k}^n (-1)^{i-k} \binom{i}{k} f(i)</script><p>考虑设 $f_{i,j}$ 表示前 $i$ 个之中选出 $j$ 组满足 $a&gt;b$，相当于钦定了 $j$ 组 $a&gt;b$，剩下的可以随便选。先将 $A,B$ 排序，处理出 $b_j&lt;a_i$ 的个数 $cnt_i$。并且仍然按照此顺序进行 DP，容易得到转移方程：</p>
<script type="math/tex; mode=display">
f_{i,j}={f_{i-1,j}+(cnt_i-j+1)\times f_{i-1,j-1}}</script><p>而我们要求的 $f(i)=(n-i)! f_{n,i}$。然后带入二项式反演的式子即可得到 $g(k)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[N],b[N],cnt[N];</span><br><span class="line"><span class="type">int</span> fac[N],ifac[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">if</span>(n+k&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    k=n+k&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(b[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n),<span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p+<span class="number">1</span>&lt;=n&amp;&amp;a[i]&gt;b[p+<span class="number">1</span>])p++;</span><br><span class="line">        cnt[i]=p;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod,ifac[i]=<span class="built_in">qpow</span>(fac[i]);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">min</span>(i,cnt[i]);j;j--)</span><br><span class="line">            f[j]=<span class="built_in">adj</span>(f[j]+<span class="number">1ll</span>*(cnt[i]-j+<span class="number">1</span>)*f[j<span class="number">-1</span>]%mod);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=(i-k&amp;<span class="number">1</span>)?mod<span class="number">-1ll</span>*f[i]*fac[n-i]%mod*<span class="built_in">C</span>(i,k)%mod:</span><br><span class="line">                <span class="number">1ll</span>*f[i]*fac[n-i]%mod*<span class="built_in">C</span>(i,k)%mod;</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="2-P6478-NOI-Online-2-提高组-游戏"><a href="#2-P6478-NOI-Online-2-提高组-游戏" class="headerlink" title="2.P6478 [NOI Online #2 提高组]游戏"></a>2.<a href="https://www.luogu.com.cn/problem/P6478">P6478 [NOI Online #2 提高组]游戏</a></h4><p>再次注意到 ”恰好“ 的限制条件。考虑像上一道题一样转化为 ”至少“。考虑设计 $f(i)$ 表示至少 $i$ 个非平局回合， $g(i)$ 表示恰好 $i$ 个非平局回合。还是用上面的式子进行二项式反演。考虑用 DP 求出 $f(i)$。</p>
<p>考虑树上背包，设计 $f_{x,i}$ 表示以 $x$ 为根的子树中钦定了 $i$ 个非平局回合，容易得到转移方程：</p>
<script type="math/tex; mode=display">
\begin{align}
f'_{x,i}&\gets \sum_{j=0}^{i} f_{x,i-j}\times f_{y,j}\notag\\
f'_{x,i}&\gets (size_{0/1}[x]-(i-1))\times f_{x,i-1}\notag
\end{align}</script><p>$f(i)$ 即为 $(n-i)!\cdot f_{1,i}$，带入公式即可求出 $g(i)$。总时间复杂度 $\mathcal O(n^2)$。</p>
<p>需要注意的是背包转移时的细节：转移形式是加法卷积，对于初始的 $f’_{x,i}$ 应当为 $f_{x,i}\times f_{y,0}$，而非 $f_{x,i}\times (f_{y,0}+1)$，因为我们必须选完 $y$ 子树里的点（只不过没有非平局回合）。更为保险的做法是开一个副本作为计算当前答案，算完再复制一遍。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> col[N],si[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> f[N][N],fac[N],ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="type">int</span> six=<span class="built_in">min</span>(si[x][<span class="number">0</span>],si[x][<span class="number">1</span>]),siy=<span class="built_in">min</span>(si[y][<span class="number">0</span>],si[y][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=six+siy;~j;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="built_in">max</span>(j-six,<span class="number">0</span>);k&lt;=<span class="built_in">min</span>(siy,j);k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!k)f[x][j]=<span class="number">1ll</span>*f[x][j]*f[y][<span class="number">0</span>]%mod;</span><br><span class="line">                <span class="keyword">else</span> f[x][j]=<span class="built_in">adj</span>(f[x][j]+<span class="number">1ll</span>*f[x][j-k]*f[y][k]%mod);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        si[x][<span class="number">0</span>]+=si[y][<span class="number">0</span>],si[x][<span class="number">1</span>]+=si[y][<span class="number">1</span>];    </span><br><span class="line">    &#125;</span><br><span class="line">    si[x][col[x]]++;</span><br><span class="line">    <span class="type">int</span> six=<span class="built_in">min</span>(si[x][<span class="number">0</span>],si[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=six;i;i--)</span><br><span class="line">        f[x][i]=<span class="built_in">adj</span>(f[x][i]+<span class="number">1ll</span>*(si[x][col[x]^<span class="number">1</span>]-(i<span class="number">-1</span>))*f[x][i<span class="number">-1</span>]%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;col[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod,ifac[i]=<span class="built_in">qpow</span>(fac[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> res=(j-i&amp;<span class="number">1</span>)?mod<span class="number">-1ll</span>*f[<span class="number">1</span>][j]*fac[n-j]%mod*<span class="built_in">C</span>(j,i)%mod:</span><br><span class="line">            <span class="number">1ll</span>*f[<span class="number">1</span>][j]*fac[n-j]%mod*<span class="built_in">C</span>(j,i)%mod;</span><br><span class="line">            ans=<span class="built_in">adj</span>(ans+res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>通过上面两个例题，容易发现很多情况下我们能够通过二项式反演将 ”恰好“ 的限制转化为 ”至少“ 的限制，再进一步求解。这也是解决这一类题的基本思路。换个角度来看，是一个当函数与集合具体有哪些元素无关，而与其中元素个数有关的情况下，进行的一个容斥。这一点能很好的将二者而这联系起来。</p>
<h4 id="3-CF1707D-Partial-Virtual-Trees"><a href="#3-CF1707D-Partial-Virtual-Trees" class="headerlink" title="3.CF1707D Partial Virtual Trees"></a>3.<a href="https://codeforces.com/problemset/problem/1707/D">CF1707D Partial Virtual Trees</a></h4><p>先考虑直接 DP，但发现并不好做。为什么？因为每次操作必须删除一个点，但是合并子树时只要有一棵子树在这一次操作内进行删点就行了。</p>
<p>于是考虑如何去掉这个限制。设计 $f(i)$ 表示至多进行 $i$ 次操作将树删空的方案数，或者换一种说法，进行的 $i$ 次操作其中有操作可以不删点，但是最终仍需要删空。设计 $g(i)$ 表示恰好进行 $i$ 次操作将树删空的方案数。通过枚举进行删点的 $i$ 次操作，我们可以得到：</p>
<script type="math/tex; mode=display">
f(n)=\sum_{i=0}^n \binom{n}{i}g(i)</script><p>这恰是二项式反演的形式！我们使用式子 $(2)$ 得到：</p>
<script type="math/tex; mode=display">
g(n)=\sum_{i=0}^n (-1)^{n-i} f(i)</script><p>还是考虑 DP 求出来 $f(i)$，设计 $f_{x,i}$ 表示将子树 $x$ 内操作 $i$ 次（可以不删点）之后为空的方案数。考虑两种情况：1.将所有子节点删完后，删除 $x$；2.将所有子节点删到只有 $1$ 棵子树 $y$ 中有点，再删去 $x$，再将剩下的节点删完。于是有转移方程：</p>
<script type="math/tex; mode=display">
\begin{align}
f_{x,i}&\gets \prod_y \sum_{j=1}^i f_{y,j}\notag\\
f_{x,i}&\gets \sum_y f_{y,i}\times \sum_{k=1}^{i-1} \ \prod_{t\ne y}\sum_{j=1}^k f_{t,j}\notag
\end{align}</script><p>前缀和一下辅助转移，这一部分是 $\mathcal O(n^2)$ 的。所以总的时间复杂度是 $\mathcal O(n^2)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,mod;</span><br><span class="line"><span class="type">int</span> fac[N],ifac[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> sum[N][N],pre[N][N],suf[N][N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> si=e[x].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)pre[i][j]=suf[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)pre[i][j]=suf[i][j]=sum[y][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;si;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            pre[i][j]=<span class="number">1ll</span>*pre[i<span class="number">-1</span>][j]*pre[i][j]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=si<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            suf[i][j]=<span class="number">1ll</span>*suf[i+<span class="number">1</span>][j]*suf[i][j]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[x][i]=<span class="built_in">adj</span>(f[x][i]+pre[si<span class="number">-1</span>][i]);</span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=e[x][i];</span><br><span class="line">            <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[x][j]=<span class="built_in">adj</span>(f[x][j]+<span class="number">1ll</span>*f[y][j]*res%mod);</span><br><span class="line">                res=<span class="built_in">adj</span>(res+<span class="number">1ll</span>*((i)?pre[i<span class="number">-1</span>][j]:<span class="number">1</span>)*((i+<span class="number">1</span>&lt;si)?suf[i+<span class="number">1</span>][j]:<span class="number">1</span>)%mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sum[x][i]=<span class="built_in">adj</span>(f[x][i]+sum[x][i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod,ifac[i]=<span class="built_in">qpow</span>(fac[i]);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> res=(i-j&amp;<span class="number">1</span>)?mod<span class="number">-1ll</span>*f[<span class="number">1</span>][j]*<span class="built_in">C</span>(i,j)%mod:</span><br><span class="line">            <span class="number">1ll</span>*f[<span class="number">1</span>][j]*<span class="built_in">C</span>(i,j)%mod;</span><br><span class="line">            ans=<span class="built_in">adj</span>(ans+res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>其实</title>
    <url>/2023/04/23/%E5%85%B6%E5%AE%9E/</url>
    <content><![CDATA[<p>4 月 23 日闲话。</p>
<span id="more"></span>
<p>即使是摆烂也不失为一种艺术。久而久之也不知是褒义还是贬义。其实我也没那么在乎结果，对吧？那不然，为什么中途那些逸乐是我流连忘返却又似乎不自知？过程中是不是早就不在乎了？我只知道我真的离不开她，是我发了狂。</p>
]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>启发式合并</title>
    <url>/2022/11/20/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>运用广泛的合并信息方式。</p>
<span id="more"></span>
<blockquote>
<p>启发式算法是什么呢？<br>启发式算法是基于人类的经验和直观感觉，对一些算法的优化。</p>
</blockquote>
<p>启发式合并又名 dsu on tree，常常运用在树上信息的合并，常见的并查集的按秩合并就是其中一种。并且常常与树链剖分相结合，从而达到较优的时间复杂度。</p>
<h3 id="1-重链剖分"><a href="#1-重链剖分" class="headerlink" title="1.重链剖分"></a>1.重链剖分</h3><h4 id="1-1-CF275D-Tree-and-Queries"><a href="#1-1-CF275D-Tree-and-Queries" class="headerlink" title="1.1.CF275D Tree and Queries"></a>1.1.<a href="https://codeforces.com/problemset/problem/375/D">CF275D Tree and Queries</a></h4><p>考虑离线。我们对于一颗子树，先计算它的所有轻儿子的答案，但是删除轻儿子的信息。然后计算重儿子的答案并直接继承重儿子的信息。再暴力将所有轻儿子的信息合并上，最终计算该节点的答案。这样做是 $\mathcal O(n\log n)$。</p>
<p>看起来很不对？我们来分析一波。对于每一个点，到根节点，每有一条轻边就会使该点被暴力计算一次。根据树链剖分经典结论，每个点到根节点的轻边数不会超过 $\mathcal O( \log n)$ 条。那么每个点最多只会被暴力计算  $\mathcal O( \log n)$次，那么时间复杂度就是 $\mathcal O(n\log n)$ 。</p>
<p>当然也可以线段树合并。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> c[N],q[N];</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt,dfn[N],num[N],si[N],son[N];</span><br><span class="line"><span class="type">int</span> col[N],sum[N],ans[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[++col[c[x]]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[col[c[x]]--]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num[dfn[x]=++cnt]=x;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        <span class="keyword">if</span>(si[y]&gt;si[son[x]])</span><br><span class="line">            son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa,<span class="type">bool</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x])</span><br><span class="line">        <span class="built_in">dfs2</span>(son[x],x,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=dfn[y];j&lt;=dfn[y]+si[y]<span class="number">-1</span>;j++)</span><br><span class="line">            <span class="built_in">insert</span>(num[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec[x])</span><br><span class="line">        ans[i]=sum[q[i]];</span><br><span class="line">    <span class="keyword">if</span>(op)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=dfn[x];i&lt;=dfn[x]+si[x]<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="built_in">del</span>(num[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u;</span><br><span class="line">        <span class="built_in">read</span>(u,q[i]);</span><br><span class="line">        vec[u].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>通过上面的例子可以发现，启发式合并需要一个点的贡献很容易加上或者删除。</p>
<h3 id="2-长链剖分"><a href="#2-长链剖分" class="headerlink" title="2.长链剖分"></a>2.长链剖分</h3><p>常常用来优化状态包含深度的 DP。</p>
<h4 id="2-1-P3565-POI2014-HOT-Hotels"><a href="#2-1-P3565-POI2014-HOT-Hotels" class="headerlink" title="2.1.P3565 [POI2014]HOT-Hotels"></a>2.1.<a href="https://www.luogu.com.cn/problem/P3565">P3565 [POI2014]HOT-Hotels</a></h4><p>设计 DP 状态，$f_{x,k}$ 表示子树 $x$ 中与 $x$ 距离为 $k$ 的点的个数。$g_{x,k}$ 表示 $dis(u,lca)=dis(v,lca)=dis(lca,x)+k$ 的 $(u,v)$ 个数。设 $y,y_1,y_2$ 均为 $x$ 的儿子节点，那么状态转移方程为：</p>
<script type="math/tex; mode=display">
\begin{align}
f_{x,0}&\gets 1\notag\\
f_{x,k}&\gets \sum_{y}f_{y,k-1}\notag\\
g_{x,k}&\gets \sum_{y}g_{y,j+1}\notag\\
g_{x,k}&\gets \sum_{y_1\neq y_2}f_{y_1,k-1}\times f_{y_2,k-1}\notag\\
ans&\gets \sum_{y_1\neq y_2} f_{y_1,k-1}\times g_{y_2,k+1} \notag\\
\end{align}</script><p>通过前缀和容易做到 $\mathcal O(n^2)$。注意到状态与深度有关，于是我们可以用长链剖分优化 DP。对于当前点 $x$，我们直接继承它的长儿子的状态，再其余儿子合并计算。容易发现这样做显然只会计算长链上的每个节点一次，而长链总长度是 $\mathcal O(n)$ 的。所有总的复杂度就是 $\mathcal O(n)$。具体地可以通过指针实现对长儿子信息地直接继承。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> dep[N],son[N];</span><br><span class="line"><span class="type">int</span> *f[N],*g[N],p[N&lt;&lt;<span class="number">2</span>],*o=p;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(dep[son[x]]&lt;dep[y])son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    dep[x]=dep[son[x]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x])f[son[x]]=f[x]+<span class="number">1</span>,g[son[x]]=g[x]<span class="number">-1</span>,<span class="built_in">dfs2</span>(son[x],x);</span><br><span class="line">    f[x][<span class="number">0</span>]=<span class="number">1</span>,ans+=g[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        f[y]=o,o+=dep[y]&lt;&lt;<span class="number">1</span>,g[y]=o,o+=dep[y]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=dep[y];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=<span class="number">1ll</span>*g[x][j+<span class="number">1</span>]*f[y][j]+<span class="number">1ll</span>*f[x][j]*g[y][j+<span class="number">1</span>];</span><br><span class="line">            g[x][j]+=g[y][j+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(j)g[x][j]+=f[x][j]*f[y][j<span class="number">-1</span>],f[x][j]+=f[y][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    f[<span class="number">1</span>]=o,o+=dep[<span class="number">1</span>]&lt;&lt;<span class="number">1</span>,g[<span class="number">1</span>]=o,o+=dep[<span class="number">1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>初级图论</title>
    <url>/2022/08/23/%E5%88%9D%E7%BA%A7%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<p>学习和做题笔记，旧的与新的都有。</p>
<span id="more"></span>
<h2 id="1-最短路"><a href="#1-最短路" class="headerlink" title="1.最短路"></a>1.最短路</h2><p>最短路是图论中最基础的一类问题。</p>
<h3 id="1-1-Bellman-Ford"><a href="#1-1-Bellman-Ford" class="headerlink" title="1.1.Bellman-Ford"></a>1.1.Bellman-Ford</h3><p>Bellman-Ford 是一种较为暴力求最短路的算法。</p>
<p>称一轮<strong>松弛</strong>为对于每一条边 $(u,v)$，用 $dis_u+w(u,v)$ 更新 $dis_v$。那么每一轮<strong>松弛</strong>必然会有一个节点的最短路会被更新，只需松弛 $n-1$ 即可。时间复杂度为 $\mathcal O(nm)$。</p>
<p>而我们也可以用该算法来判断<strong>是否存在负环</strong>：若<strong>松弛</strong>超过 $n-1$ 轮仍有节点最短路被更新，那么图中存在负环。</p>
<h3 id="1-2-SPFA"><a href="#1-2-SPFA" class="headerlink" title="1.2.SPFA"></a>1.2.SPFA</h3><p><a href="https://www.luogu.com.cn/problem/P4768">关于SPFA，它死了。</a></p>
<p>本质上是使用队列来优化的 Bellman-Ford。很明显我们每次并不需要枚举所有边，而只需要枚举在上一轮<strong>松弛</strong>中最短路被更新的节点的出边即可。因此每次我们在<strong>松弛</strong>过程中将最短路被更新的加入队列之中。并且可以记录某个节点是否在队列，若是则不用加入。</p>
<p>该算法在随机图上效率很高，但是对于特殊构造的数据，例如<strong>菊花图</strong>，会被卡成与 Bellman-Ford 相同的 $\mathcal O(nm)$。所以对于<strong>非负权图</strong>，应该采用下面即将提到的 Dikjstra 算法。</p>
<p>当然，SPFA 也可以用来判断负环，若<strong>最短路边数</strong>大于 $n-1$，则图中存在负环。（也可以判断每个点的入队次数，不过会稍慢一点）。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">1e3</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> tot,ver[M],e[M],ne[M],head[M];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x15f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!vis[now])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[now]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=ne[i])</span><br><span class="line">            <span class="keyword">if</span>(dis[now]+e[i]&lt;dis[ver[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[ver[i]]=dis[now]+e[i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[ver[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[ver[i]]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(ver[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">SPFA</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-3-Dijkstra"><a href="#1-3-Dijkstra" class="headerlink" title="1.3.Dijkstra"></a>1.3.Dijkstra</h3><p>Dijkstra是基于<strong>贪心</strong>的最短路算法，只适用于<strong>非负权图</strong>。</p>
<p>称<strong>扩展</strong>节点 $u$ 为对于 $u$ 的所有出边 $(u,v)$ ，用 $dis_u+w(u,v)$ 来更新</p>
<p>对于所有当前已经得到最短路的节点，取出所有未扩展节点中 $dis$ 最小的节点并扩展。因为没有负权边，所以取出的节点的 $dis_x$ 必然是<strong>单调不降</strong>的。</p>
<p>注意，这个贪心过程，当每个点被第一次取出时，此时的 $dis$ 就是源点到它的最短路。很容易即可证明这一点。</p>
<p>取出 $dis$ 最小的节点的过程可以用优先队列来实现。每次扩展后将最短路得到更新的节点加入优先队列中。</p>
<p>需要注意的是一个节点可能被扩展多次并多次进入优先队列，这样又会扩展多次，这会使我们的算法退化至 $\mathcal O(m^2\log m)$。但是我们知道每次它第一次被取出时，一定是源点到该节点的最短路。为了避免某个节点扩展多次，我们需要记录该点是否已经从队列中取出（已经得到最短路并扩展），若已经从队列中取出，则直接跳过，否则得到最短路直接扩展并记录。时间复杂度为 $\mathcal O(m\log n)$。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id,dis;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(Node u,Node v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> u.dis&gt;v.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>((Node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().id;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])<span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+e[i]&lt;dis[ver[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[ver[i]]=dis[x]+e[i];</span><br><span class="line">                q.<span class="built_in">push</span>((Node)&#123;ver[i],dis[ver[i]]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-4-Floyd"><a href="#1-4-Floyd" class="headerlink" title="1.4.Floyd"></a>1.4.Floyd</h3><p>用于求<strong>全源最短路</strong>的最常用算法，核心思想是 DP。</p>
<p>主要四步，枚举中转点 $k$，枚举 $i$，枚举 $j$，使用 $dis(i,k)+dis(k,j)$ 来更新 $dis_{i,j}$。</p>
<p>最需要注意的是枚举顺序，需要先枚举中转点 $k$，然后接着枚举 $i,j$ 。该算法正确性很显然，此处不再赘述。</p>
<p>Floyd 常被用来求传递闭包。将内层操作改为 $dis(i,j)\gets dis(i,j) \or (dis(i,k) \and dis(k,j))$ 即可。可用 <code>bitset</code> 来优化。</p>
<p>代码就算了。</p>
<h3 id="1-5-Johnson"><a href="#1-5-Johnson" class="headerlink" title="1.5.Johnson"></a>1.5.Johnson</h3><p>对于<strong>带负权稀疏图的全源最短路</strong>。因为带负权，无法使用 Dijkstra。我们可以直接跑 $n$ 遍 SPFA，但是被卡到 $\mathcal O(n^2m)$ 就直接寄了，我们需要更为优秀的算法。</p>
<p>Johnson 的巧妙之处在于为每个点恰当地赋上<strong>势能</strong> $h_i$，这里的<strong>势能</strong>可以类似于物理上的势能。然后将 $(u,v)$ 的边权变为 $w(u,v)+h_u-h_v$，不难发现 $dis(s,t)=dis’(s,t)-h_s+h_t$，这只与 $s,t$ 有关，并且仍然是原来的最短路。于是我们可以直接在求最短路。</p>
<p>但是我们还没有解决负权的问题。我们需要使得 $w(u,v)+h_u\ge h_v$，联想到<strong>三角形不等式</strong>，如果没负环我们一定可以通过不断松弛使得 $h$ 满足上述关系式。将每个点直接入队（相当于新建一个源点 $0$ 再向每个点连长度为 $0$ 的边），然后跑一遍 SPFA，得出得最短路数组即为 $h$。</p>
<p>其实，这个形式不正是<strong>差分约束</strong>的模型吗？直接跑就可以得到 $h$ 的一组解。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e3</span>+<span class="number">10</span>,M=<span class="number">6e3</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> cnt[N],h[N],dis[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id,d;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d&gt;t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        q.<span class="built_in">push</span>(i),vis[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(h[x]+e[i]&lt;h[y])</span><br><span class="line">            &#123;</span><br><span class="line">                h[y]=h[x]+e[i];</span><br><span class="line">                cnt[y]=cnt[x]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[y]&gt;=n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y])q.<span class="built_in">push</span>(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    priority_queue&lt;Node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    dis[s][s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().id;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])<span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[s][x]+e[i]+h[x]-h[y]&lt;dis[s][y])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[s][y]=dis[s][x]+e[i]+h[x]-h[y];</span><br><span class="line">                q.<span class="built_in">push</span>((Node)&#123;y,dis[s][y]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">SPFA</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">Dijkstra</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i][j]&gt;INF)</span><br><span class="line">                ans+=<span class="number">1ll</span>*j*INF;</span><br><span class="line">            <span class="keyword">else</span> ans+=<span class="number">1ll</span>*j*(dis[i][j]-h[i]+h[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-6-例题"><a href="#1-6-例题" class="headerlink" title="1.6.例题"></a>1.6.例题</h3><h4 id="1-P2505-HAOI2012-道路"><a href="#1-P2505-HAOI2012-道路" class="headerlink" title="1.P2505 [HAOI2012]道路"></a>1.<a href="https://www.luogu.com.cn/problem/P2505">P2505 [HAOI2012]道路</a></h4><p>题目简述：一张有向图，求出每条边被不同最短路径经过的次数， $n\le 1500,m\le 5000$。</p>
<p>经典题，考点：最短路图（或者说 最短路DAG？）。先说一下最短路图的概念：</p>
<p>首先，我们很容易知道：$i\to j$ 的最短路径的任意子路径 $u\to v$ 都是最短路径，接着我们可以得到另一个结论：若存在一条子路径 $u\to v$ 不是最短路径，那么很明显可以找到一条更短的 $u\to v$ 使得 $i\to j$ 更短。根据这个原则，我们可以得出在固定源点下，存在 $G$ 的一个子图 $G’$，使得 $G’$ 的每一条边都在 $S$ 到其他至少一个点的最短路径上，且 $G’$ 以外的边不在 $S$ 到任意一个点的最短路径上。这里把称 $G’$ 为源点为 $S$  时 $G$ 的<strong>最短路图</strong>。而求出最短路图的方式很简单，就是如果有 $dis_{v_i}=dis_{u_i}+w_i$，我们给这条路打上一个标记就行了。</p>
<p>有了这个有什么用呢？容易得到这个最短路图是无环的，我们就可以在<strong>最短路图</strong>上进行<strong>拓扑排序</strong>。考虑维护两个数组为 $cnt1_i$ 与 $cnt2_i$ 。接着我们考虑正反两次拓扑分别表示 $i\to u$ 和 $v\to j$ 的最短路径条数，而答案就为 $cnt_1({u_i})*cnt_2({v_i})$ 之和。</p>
<p>使用 Dijkstra 的话时间复杂度应该是 $\mathcal O(nm\log n + n^2)$，SPFA 也能过。</p>
<h4 id="2-P2680-NOIP2015-提高组-运输计划"><a href="#2-P2680-NOIP2015-提高组-运输计划" class="headerlink" title="2.P2680 [NOIP2015 提高组] 运输计划"></a>2.<a href="https://www.luogu.com.cn/problem/P2680">P2680 [NOIP2015 提高组] 运输计划</a></h4><p><del>还是说几个经典题。</del></p>
<p>注意到需要求的是最后一个完成的任务时间的最小值。最大值最小很容易想到二分答案。设二分值为 $lim$。对于修建的虫洞，其必然经过每个用时大于 $lim$ 的任务，并且用时最多的减去虫洞的长度需要小于 $lim$。</p>
<p>先考虑第一个条件，我们很容易想到<strong>树上差分</strong>，然后通过统计子树和来计算每条边被任务经过的次数。然后我们再统计所有满足第一个条件的边中最长的长度，最后判断一下第二个条件就行了。</p>
<h4 id="3-P4009-汽车加油行驶问题"><a href="#3-P4009-汽车加油行驶问题" class="headerlink" title="3.P4009 汽车加油行驶问题"></a>3.<a href="https://www.luogu.com.cn/problem/P4009">P4009 汽车加油行驶问题</a></h4><p>表面上是一个网络流24题，但直接跑<strong>分层图最短路</strong>就可以了。</p>
<h4 id="4-P7916-CSP-S-2021-交通规划"><a href="#4-P7916-CSP-S-2021-交通规划" class="headerlink" title="4.P7916 [CSP-S 2021] 交通规划"></a>4.<a href="https://www.luogu.com.cn/problem/P7916">P7916 [CSP-S 2021] 交通规划</a></h4><p>第一眼是一个经典最小割模型，直接上 Dinic 有 65pts（<del>真的很多了</del>）。</p>
<p>先考虑 $k=2$ 的情况，不就是 <a href="https://www.luogu.com.cn/problem/P4001">P4001 [ICPC-Beijing 2006] 狼抓兔子</a>吗？直接转成对偶图跑最短路即可。类似的 trick 还有 <a href="https://www.luogu.com.cn/problem/P2046">P2046 [NOI2010] 海拔</a>。</p>
<p>对于 $k&gt;2$ 的情况，我们还是从对偶图最短路的角度进行思考。考虑对于任意两个颜色不同的关键点之间新建一个点。很容易发现对于所有新建的点中，任意两个点的最短路就可以把这张图割成两半。就像这样：<img src="image1.png" alt=""></p>
<p>我们对每个新建的点分别作为源，求与其他点的最短路。因为最优的方案的中的最短路一定不会相交（调整法），于是我们可以尝试断环为链进行区间DP，也就是对其进行两两匹配，最后便可以得出答案。时间复杂度：$\mathcal O(\sum knm\log (nm)+\sum k^3)$。</p>
<h4 id="5-P5304-GXOI-GZOI2019-旅行者"><a href="#5-P5304-GXOI-GZOI2019-旅行者" class="headerlink" title="5.P5304 [GXOI/GZOI2019]旅行者"></a>5.<a href="https://www.luogu.com.cn/problem/P5304">P5304 [GXOI/GZOI2019]旅行者</a></h4><p>首先说一种较为暴力的做法，我们尝试将 $k$ 个关键点分为两组，超级源点 $s$ 向其中一组连边，另一组则向超级汇点 $t$ 连边，很明显 $s\to t$ 的最短路就是不同组之间进行配对的答案 。</p>
<p>介于这个思路，有一个较为暴力做法：每次将点的编号按照二进制中的第 $i$ 位来分为两组，然后按照上述方法跑 $\log k$ 次 $s\to t$ 的最短路，最后取 min 就是答案。这样很显然是正确的，因为最近的一对点的编号本来就是不同的，所以说一定会被统计到。</p>
<p>还有更优秀的做法。我们尝试用 Dijkstra 求出从 $i$ 到最近的关键点的距离 $dis1_i$ 和从最近的关键点到 $i$ 的距离 $dis_2(i)$，并且记录是从哪个关键点转移过来，设为 $f_i$ 和 $g_i$。然后我们枚举每一条边 $(u,v,w)$，若 $f_u$ 不等于 $g_v$，将 $dis_1(u)+w+dis_2(v)$ 计入答案即可。</p>
<p>这样枚举边为什么是正确的呢？这里留给读者思考。想通了这个问题也就不难明白为什么枚举点是错误的。</p>
<h4 id="6-CF843D-Dynamic-Shortest-Path"><a href="#6-CF843D-Dynamic-Shortest-Path" class="headerlink" title="6.CF843D Dynamic Shortest Path"></a>6.<a href="https://codeforces.com/problemset/problem/843/D">CF843D Dynamic Shortest Path</a></h4><p>每次询问直接暴力当然不能够通过。我们考虑先做一次 Dijkstra，然后再计算最短路的增量。</p>
<p>如何计算增量？设原来的最短路为 $dis_i$，考虑类似于 Johnson 的做法，我们把边权变为 $w(u,v)+dis_u-dis_v$，再跑最短路。这样就得到了增量。类似于 Johnson 的边权，这里的边权也一定是非负的。但是为什么这样是正确的呢？还是类似于 Johnson 中最短路的式子，有 $dis’_u=w’(s,p_1)+w’(p_1,p_2)+\dots+w’(p_{l-1},p_l)-dis_u$。于是这里求出的最短路径也是原图上的最短路径。</p>
<p>但是直接用的 Dijkstra 来求增量跟暴力的复杂度没有区别。但是注意到每次的增量最多为 $\min(c,n-1)$，并且最短路是单调不降的，于是我们可以将朴素 Dijkstra 中的堆直接换成桶 ，对于桶的每一个位置开一个队列，再从前往后做就可以了。这样的单次的复杂度就是 $\mathcal O(m)$ 的。</p>
<p>最开始仍然需要做一遍朴素 Dijkstra，总复杂度为 $\mathcal O(m\log n +qm)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e15</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    ll d;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d&gt;t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,T;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;Node&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>((Node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().id;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])<span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+e[i]&lt;dis[y])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y]=dis[x]+e[i];</span><br><span class="line">                q.<span class="built_in">push</span>((Node)&#123;y,dis[y]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=lim;i++)<span class="keyword">while</span>(!q[i].<span class="built_in">empty</span>())q[i].<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i]=lim;</span><br><span class="line">    q[<span class="number">0</span>].<span class="built_in">push</span>(<span class="number">1</span>),f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=mx;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q[t].<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=q[t].<span class="built_in">front</span>();</span><br><span class="line">            q[t].<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(f[x]&lt;t)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> y=ver[i];</span><br><span class="line">                <span class="keyword">if</span>(f[x]+e[i]+dis[x]-dis[y]&lt;f[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    f[y]=f[x]+e[i]+dis[x]-dis[y];</span><br><span class="line">                    mx=<span class="built_in">max</span>(mx,f[y]);</span><br><span class="line">                    q[f[y]].<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(dis[i]&lt;INF)dis[i]+=f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,c;</span><br><span class="line">        <span class="built_in">read</span>(op,c);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dis[c]&lt;INF?dis[c]:<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=c;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x;</span><br><span class="line">                <span class="built_in">read</span>(x);</span><br><span class="line">                e[x]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">BFS</span>(<span class="built_in">min</span>(c,n<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="2-差分约束"><a href="#2-差分约束" class="headerlink" title="2.差分约束"></a>2.差分约束</h2><h3 id="2-1-算法介绍"><a href="#2-1-算法介绍" class="headerlink" title="2.1.算法介绍"></a>2.1.算法介绍</h3><p>前置芝士：Bellman-Ford 和 SPFA。</p>
<p>差分约束问题为：给出若干形如 $x_a-x_b\le c$ 或 $x_a-x_b\ge c$ 求解任意一组 $x$ 的解。</p>
<p>我们很容易将所有的限制写为 $x_i+c\ge x_j$。这熟悉的形式，让我们想起<strong>三角形不等式</strong>，使得我们可以用最短路求解。我们从 $i\to j$ 连一条长度为 $c$ 的边，然后从超级源点 $s$ 向每个点连长度为 $0$ 的边以防止不连通（或者说一开始令所有的 $dis=0$ 并将所有的点入队），跑最短路，每个点的最短路长度就是一组合法解。</p>
<p>因为 $c$ 一般都有负数，所以用 Bellman-Ford 和 SPFA 求解最短路，此时得到的解为字典序最大解（似乎有些违反直觉，但确实是这样）。显然，若出现负环则无解。</p>
<p>时间复杂度为 $\mathcal O(nm)$。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>,M=<span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> vis[N],dis[N],cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        q.<span class="built_in">push</span>(i),vis[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+e[i]&lt;dis[ver[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[ver[i]]=dis[x]+e[i];</span><br><span class="line">                cnt[ver[i]]=cnt[x]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[ver[i]]&gt;=n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!vis[ver[i]])</span><br><span class="line">                    q.<span class="built_in">push</span>(ver[i]),vis[ver[i]]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">SPFA</span>())</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="2-2-例题"><a href="#2-2-例题" class="headerlink" title="2.2.例题"></a>2.2.例题</h3><h4 id="1-P5590-赛车游戏"><a href="#1-P5590-赛车游戏" class="headerlink" title="1.P5590 赛车游戏"></a>1.<a href="https://www.luogu.com.cn/problem/P5590">P5590 赛车游戏</a></h4><p>每条边的长度我们并不好直接将构造，但很明显我们只需要构造一组合法的 $dis$ 就可以了。</p>
<p>考虑<strong>三角形不等式</strong>，对于每条边 $(u,v)$，满足 $1\le dis_v-dis_u\le 9$。熟悉的形式使我们想到<strong>差分约束</strong>。按照模型将图建出来，得到 $dis$ 的任意一组解即可。</p>
<p>需要注意一下去除与答案无关的边，这些边随便取什么值都可以，正反两遍 dfs 即可判断。</p>
<h4 id="2-P4926-1007-倍杀测量者"><a href="#2-P4926-1007-倍杀测量者" class="headerlink" title="2.P4926 [1007]倍杀测量者"></a>2.<a href="https://www.luogu.com.cn/problem/P4926">P4926 [1007]倍杀测量者</a></h4><p>很明显需要先二分，看起来是个<strong>差分约束</strong>的形式，可是我们需要求的是倍数的形式，而非差分。怎样转换？我们只需要对所有的 $k$ 取对数就可以把乘法转化为加法。这样我们直接上差分约束判断负环就可以了。</p>
<p>注意这里给定了初值，我们从 $0$ 向  $i$ 分别连 $\log x$ 和 $-\log x$ 的边就可以了，相等形式的边都可以这样连（转化为 $x_i\ge x_j$ 且 $x_j\ge x_i$ 即可）。</p>
<h4 id="3-AGC056C-01-Balanced"><a href="#3-AGC056C-01-Balanced" class="headerlink" title="3.[AGC056C] 01 Balanced"></a>3.<a href="https://atcoder.jp/contests/agc056/tasks/agc056_c">[AGC056C] 01 Balanced</a></h4><p>形式就很差分约束，可以直接对前缀和数组进行差分约束，但是这样的复杂度是 $\mathcal O(nm)$，无法通过。</p>
<p>我们发现最令人头疼的是对于 $[l,r]$ 这样的限制，因为我们必须建权值为 $(r-l+1)/2$ 的边。这样我们只能够暴力跑 SPFA。</p>
<p>但是我们可以将 $0$ 看为 $1$，而将 $1$ 看为 $-1$。这样我们对于 $[l,r]$ 这样的限制，只需要建长度为 $0$ 的边即可。相邻点的限制变成了 $|v_i-v_{i-1}|\le 1$。所有边权只剩下 $0,1$，我们可以直接用 01 BFS 跑最短路。因为差分约束求出来的解有字典序为最大解，所以求出来就是原问题最小字典序的解。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,M=<span class="number">3e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line">deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=ver[i],d=dis[x]+e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[y]&gt;d)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y]=d;</span><br><span class="line">                <span class="keyword">if</span>(!e[i])q.<span class="built_in">push_front</span>(y);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">add</span>(i,i<span class="number">-1</span>,<span class="number">1</span>),<span class="built_in">add</span>(i<span class="number">-1</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">read</span>(l,r);</span><br><span class="line">        <span class="built_in">add</span>(r,l<span class="number">-1</span>,<span class="number">0</span>),<span class="built_in">add</span>(l<span class="number">-1</span>,r,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BFS</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dis[i<span class="number">-1</span>]&gt;dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="4-P7515-省选联考-2021-A-卷-矩阵游戏"><a href="#4-P7515-省选联考-2021-A-卷-矩阵游戏" class="headerlink" title="4.P7515 [省选联考 2021 A 卷] 矩阵游戏"></a>4.<a href="https://www.luogu.com.cn/problem/P7515">P7515 [省选联考 2021 A 卷] 矩阵游戏</a></h4><p>最重要的限制是矩阵 $a$ 中每个数的大小 $\le 10^6$。</p>
<p>我们考虑先构造出任意一种 $a$，再对其进行调整即可，我们按照奇偶对行列进行分类对奇数 $\pm 1$，对偶数 $\mp 1$，这样还是能够满足 $b$ 的限制的。转化为 $0\le a_{i,j} +(-1)^i h_{i} +(-1)^j l_{j} \le 10^6$。但是当行与列的奇偶性相同时就会出先和约束，这是我们无法解决的。</p>
<p>考虑如何限制 $(-1)^i,(-1)^j$，使其不会出现符号相同的情况。尝试对其进行黑白染色，限制转化为 $0\le a_{i,j} +(-1)^{i+j} h_{i} +(-1)^{i+j+1} l_{j} \le 10^6$，这样也能够满足 $b$ 的限制，并且可以直接跑差分约束求出 $h,l$ 即可。</p>
<p>可能有一点卡常，据说可以使用寻址更连续 Bellman-Ford 来代替 SPFA，但感觉没啥用。真正有用的是将存图方式从链式前向星改成用 vector 实现的邻接表。因为边的数量很多，并且寻址变得非常连续。笔者的代码在改了之后快了将近 5 倍。</p>
<h2 id="3-最小生成树"><a href="#3-最小生成树" class="headerlink" title="3.最小生成树"></a>3.最小生成树</h2><h3 id="3-1-Kruskal"><a href="#3-1-Kruskal" class="headerlink" title="3.1.Kruskal"></a>3.1.Kruskal</h3><p>最经典且常用的最小生成树算法，非常简单且基础。</p>
<p>现将所有边排序，贪心地从小到大选取，若边的两个端点所属联通块不同，就将该边加入答案，用并查集维护连通性。正确性用反证法就可以很容易证明了。其它应用还有 Kruskal 重构树。</p>
<h3 id="3-2-Prim"><a href="#3-2-Prim" class="headerlink" title="3.2.Prim"></a>3.2.Prim</h3><p>Prim 总是维护 MST 的一部分，每次选取维护的联通块所相连的边中最小的边，将该边加入答案的同时维护联通块。其中选取最小的边用优先队列就可以了，时间复杂度 $\mathcal O(m\log n)$。可以类似于 Dijkstra。</p>
<h3 id="3-3-Boruvka"><a href="#3-3-Boruvka" class="headerlink" title="3.3.Boruvka"></a>3.3.Boruvka</h3><p>从点来考虑，对于每个点而言，与它相邻的边权最小的边必然入选。这一点还是可以通过反证法可以证明。</p>
<p>于是我们每次求出每个点与其相连的最小的边。将所有这些边加入最小生成树中。出去至多 $\frac{n}{2}$ 重边，每条边会使联通块个数 $-1$，因此一次这样过程可以使得联通块的个数严格减少一半。这样对剩余联通块继续上述过程至多 $\log_2 n$ 轮即可求得 MST。时间复杂度为 $\mathcal O(m\log n)$。Boruvka 在解决某类最小生成树问题上非常有用。对于形如给定一张 n 个点的完全图，两点之间的信息可以通过某种关系计算得出，该算法可以较好得求解。</p>
<h3 id="3-4-例题"><a href="#3-4-例题" class="headerlink" title="3.4.例题"></a>3.4.例题</h3><h4 id="1-CF827D-Best-Edge-Weight"><a href="#1-CF827D-Best-Edge-Weight" class="headerlink" title="1.CF827D Best Edge Weight"></a>1.<a href="https://codeforces.com/problemset/problem/827/D">CF827D Best Edge Weight</a></h4><p>显然，我们应该先把最小生成树求出来，然后逐渐考虑每条边。设求出的生成树是 $T$，且下文中的路径都指生成树上的路径。</p>
<p>1.$(u,v,w)\notin T$：如果选取这条边，那么很明显其最大值为路径 $(u,v)$ 上的边的边权最大值。</p>
<p>2.$(u,v,w)\in T$：这种情况稍微复杂一点，这种边的最大值，是所有能覆盖这条边的非树边的最小值。何为能覆盖？就是对于一条非树边 $(x,y,z)$，若某一树边 $(u,v,w)$ 在路径 $(x,y)$ 上，我们则称之为能覆盖。</p>
<p> 于是我们先考虑非树边，求出这条边的答案。然后每次对路径 $(u,v)$ 上的边权与 $w$ 进行取 min 操作。这可以用树链剖分很好的维护。但是有更好的做法，因为我们是按照边权从小到大排过序的，所以对于已经覆盖过的边，其已经是最优答案了，我们并不需要再覆盖它。于是我们可以每次直接暴力覆盖，然后用并查集维护未被覆盖的边就行了。时间复杂度 $\mathcal O(m\log m)$，瓶颈是排序。</p>
<p>代码非常的好写。</p>
<h4 id="2-CF1120D-Power-Tree"><a href="#2-CF1120D-Power-Tree" class="headerlink" title="2.CF1120D Power Tree"></a>2.<a href="https://codeforces.com/problemset/problem/1120/D">CF1120D Power Tree</a></h4><p>考虑将树上操作转化为在 $dfn$ 序上进行操作。子树操作就变成了区间操作。对于区间操作我们又可以考虑用差分将其转化为单点操作。这里的 $dfn$ 序可以只考虑叶子结点。</p>
<p>接着很自然地想到了生成树，对于每个操作 $(dfn_i,dfn_i+size_i,w_i)$，我们都把他转化为 $n$ 个节点的图上的一条边。显然只要使这个图联通我们就可以控制所有点的点权。求一遍 MST 就行了。</p>
<h4 id="3-CF888G-Xor-MST"><a href="#3-CF888G-Xor-MST" class="headerlink" title="3.CF888G Xor-MST"></a>3.<a href="https://codeforces.com/problemset/problem/888/G">CF888G Xor-MST</a></h4><p>考虑 Kruskal，我们每次都是贪心的选取边权最小的边。异或最小值我们可以考虑在 01-Trie 上进行操作。</p>
<p>我们考虑将所有点权放进 01-Trie 上。然后从根节点开始，考虑先递归其子树，使左右子树分别联通，再在 01-Trie 中查找边权最小的边，并将左右子树连起来。过程中计算花费即可。时间复杂度 $\mathcal O(n\log V)$，其中 $V$ 为值域。常数稍微有点大。</p>
<p>另外可以用 Boruvka 做。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1ll</span>&lt;&lt;<span class="number">60</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,ch[N&lt;&lt;<span class="number">4</span>][<span class="number">2</span>],ed[N&lt;&lt;<span class="number">4</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;~i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=x&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][num])</span><br><span class="line">            ch[u][num]=++tot;</span><br><span class="line">        u=ch[u][num];</span><br><span class="line">    &#125;</span><br><span class="line">    ed[u]=x;</span><br><span class="line">&#125;<span class="comment">//01-Trie</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ed[u]||ed[v])<span class="keyword">return</span> ed[u]^ed[v];</span><br><span class="line">    ll res1=INF,res2=INF;</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>]&amp;&amp;ch[v][<span class="number">0</span>])res1=<span class="built_in">solve</span>(ch[u][<span class="number">0</span>],ch[v][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">1</span>]&amp;&amp;ch[v][<span class="number">1</span>])res2=<span class="built_in">solve</span>(ch[u][<span class="number">1</span>],ch[v][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(res1!=INF||res2!=INF)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(res1,res2);<span class="comment">//贪心，先尝试朝同一方向走</span></span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>]&amp;&amp;ch[v][<span class="number">1</span>])res1=<span class="built_in">solve</span>(ch[u][<span class="number">0</span>],ch[v][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">1</span>]&amp;&amp;ch[v][<span class="number">0</span>])res2=<span class="built_in">solve</span>(ch[u][<span class="number">1</span>],ch[v][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(res1,res2);<span class="comment">//再向不同方向走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>])<span class="built_in">dfs</span>(ch[u][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">1</span>])<span class="built_in">dfs</span>(ch[u][<span class="number">1</span>]);<span class="comment">//先递归，使其子树联通</span></span><br><span class="line">    <span class="keyword">if</span>(ch[u][<span class="number">0</span>]&amp;&amp;ch[u][<span class="number">1</span>])</span><br><span class="line">        ans+=<span class="built_in">solve</span>(ch[u][<span class="number">0</span>],ch[u][<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//再查找最小边权，将左右子树连起来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="4-Tarjan-与图的连通性"><a href="#4-Tarjan-与图的连通性" class="headerlink" title="4.Tarjan 与图的连通性"></a>4.Tarjan 与图的连通性</h2><h3 id="4-1-算法简介"><a href="#4-1-算法简介" class="headerlink" title="4.1.算法简介"></a>4.1.算法简介</h3><p>无向图的割边（即”桥“）、割点、边双连通分量、点双连通分量，有向图的强连通分量，他们都是图的连通性研究的重要内容，定义此处不再赘述。</p>
<p>Tarjan 利用 dfs 树以及时间戳 $dfn_x$ 追溯值 $low_x$ 来求这些东西。设 $\text{subtree}(x)$ 表示搜索树上以 $x$ 为根的子树，$low_x$ 定义为以下节点的时间戳 $dfn_y$ 的最小值：1.$\text{subtree}(x)$ 中的节点；2.通过一条 $\text{subtree}(x)$ 中的节点上但不属于搜索树上的边，能够到达的节点（不包括）。</p>
<p>我们以割边为例简要阐释其原理。</p>
<h4 id="4-1-1割边判定法则"><a href="#4-1-1割边判定法则" class="headerlink" title="4.1.1割边判定法则"></a>4.1.1割边判定法则</h4><p>无向边 $(x,y)$ 为割边，当且仅当都搜索树上存在 $x$ 的一个子节点 $y$ 满足：</p>
<script type="math/tex; mode=display">
dfn_x<low_y</script><p>先说明充分性，$dfn_x&lt;low_y$，说明从 $\text{subtree}(y)$ 不经过 $(x,y)$ 不可以到达 $x$ 或其之前访问的节点。并且它不可以到达兄弟子树中的节点 。所以若将 $(x,y)$ 删除，那么 $\text{subtree}(y)$ 不再与原图连通，符合割边的定义。</p>
<p>必要性呢？反证，若不存在这样的 $y$ 为搜索树上 $x$ 的子节点满足 $dfn_x&lt;low_y$，那么从 $\text{subtree}(y)$ 不经过 $(x,y)$ 可以到达 $x$ 或其之前访问的节点，删除 $(x,y)$ ，仍可以到达 $x$，不影响图的连通性，此时 $(x,y)$ 自然不为割边。</p>
<h4 id="4-1-1割点判定法则"><a href="#4-1-1割点判定法则" class="headerlink" title="4.1.1割点判定法则"></a>4.1.1割点判定法则</h4><p>若 $x$ 不为搜索树根节点，$x$为割点，当且仅当都搜索树上存在一个 $x$ 的子节点 $y$ 满足：</p>
<script type="math/tex; mode=display">
dfn_x\le low_y</script><p>特别地，若 $x$ 为搜索树根节点，$x$为割点，当且仅当都搜索树上至少存在两个 $x$ 的子节点 $y1,y2$ 满足上述条件。</p>
<p>其证明方法与割边类似。注意到这里是 $dfn_x\le low_y$，我们可以直接将父节点的 $dfn_{fa}$ 算到字节点的 $low_x$ 上。而下面圆方树部分均采用这样的定义。</p>
<h4 id="4-1-1强连通分量判定法则"><a href="#4-1-1强连通分量判定法则" class="headerlink" title="4.1.1强连通分量判定法则"></a>4.1.1强连通分量判定法则</h4><p>在 $x$ 进行回溯之前，$x$ 到栈顶节点形成一个强连通分量，当且仅当 $x$ 满足：</p>
<script type="math/tex; mode=display">
dfn_x=low_x</script><p>此处先不做过多阐述。</p>
<h2 id="5-圆方树"><a href="#5-圆方树" class="headerlink" title="5.圆方树"></a>5.圆方树</h2><h3 id="5-1-算法简介"><a href="#5-1-算法简介" class="headerlink" title="5.1.算法简介"></a>5.1.算法简介</h3><blockquote>
<p>圆方树最初是处理“仙人掌图”（每条边在不超过一个简单环中的无向图）的一种工具，不过发掘它的更多性质， 有时我们可以在一般无向图上使用它。——by OI-wiki</p>
</blockquote>
<p>顾名思义，在圆方树中有两种点——圆点与方点。其中圆点对应原图上的每一个点，方点对应着原图上的每一个点双连通分量。点双连通分量被缩成一个由方点向各圆点连边的菊花图。而这些菊花图通过原图的割点相连。</p>
<p>对于一般的无向图，我们采用类似于求割点的做法。类似于求强连通分量，中途用栈维护来求点双连通分量以及建圆方树。整体实现比较简单。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dfncnt,top,dfn[N],low[N],sta[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_e</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_g</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u!=y;--top)u=sta[top],<span class="built_in">add_g</span>(u,cnt);</span><br><span class="line">    <span class="built_in">add_g</span>(x,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfncnt;</span><br><span class="line">    sta[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]==low[y])<span class="built_in">build</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add_e</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!dfn[i])<span class="built_in">Tarjan</span>(i),top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="5-2-性质"><a href="#5-2-性质" class="headerlink" title="5.2.性质"></a>5.2.性质</h3><h3 id="5-3-例题"><a href="#5-3-例题" class="headerlink" title="5.3.例题"></a>5.3.例题</h3><h4 id="1-P5236-【模板】静态仙人掌"><a href="#1-P5236-【模板】静态仙人掌" class="headerlink" title="1.P5236 【模板】静态仙人掌"></a>1.<a href="https://www.luogu.com.cn/problem/P5236">P5236 【模板】静态仙人掌</a></h4><p>模板题。圆方树的题一般先建出圆方树在树上进行各种算法，过程中可能会将圆点与方点分开进行考虑。这道题类似，我们建出圆方树，求圆方树上 $x,y$ 的 $lca$，设 $dis_u$ 为 $u$ 到根节点的距离。若 $lca$ 为圆点，那么答案为 $dis_x+dis_y-dis_{lca}$。</p>
<p>但是如果 $lca$ 为方点呢？意味着我们倍增过程中跳到了环上。特殊处理，设圆点 $A,B$ 为倍增过程中 $lca$ 的儿子。我们考虑 $A,B$ 之间的最小距离即可。于是我们求出环上每一个点按照一定方向到方点的距离 $s_x$，环的总长为 $stot_x$，那么答案为 $dis_x+dis_y-dis_A-dis_B+\min(|s_A-s_B|,stot_A-|s_A-s_B|)$。</p>
<p>如何在求点双的过程中合理地为每个圆点连向方点赋上边权？直接赋为到割点 $x$ 地最小距离即可。容易发现这样处理是正确的。</p>
<p>但是新的问题又来了，如何在求点双的过程中求出环上所有边的边权。网上很少有这种用点双来实现的做法，笔者这里给出较为简单的一种方式。容易发现，仙人掌上每一个点，最多只有一条路径以该点为起点，能够到达搜索树上的祖先，而这个祖先就是割点。于是我们在求 $low_x$ 的过程中记录下使 $low_x$ 更新的边 $(x,y,z)$ 的权值，找出点双的过程中即可求出我们想要的信息。</p>
<p>这里给出一种实现方式。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>点双连通分量<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>,M=<span class="number">2e4</span>+<span class="number">10</span>,K=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> dfncnt,top,dfn[N],low[N],sta[N],to[N];</span><br><span class="line"><span class="type">int</span> s[N],stot[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">vector&lt;Edge&gt;e[N],g[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N],dis[N],f[N][<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> A,B;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_e</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].<span class="built_in">push_back</span>((Edge)&#123;v,w&#125;);</span><br><span class="line">    e[v].<span class="built_in">push_back</span>((Edge)&#123;u,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_g</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g[u].<span class="built_in">push_back</span>((Edge)&#123;v,w&#125;);</span><br><span class="line">    g[v].<span class="built_in">push_back</span>((Edge)&#123;u,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add_g</span>(x,++cnt,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> i,u=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=top;i&amp;&amp;u!=y;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        u=sta[i];</span><br><span class="line">        sum+=to[u];</span><br><span class="line">        s[u]=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    sum+=z;</span><br><span class="line">    </span><br><span class="line">    stot[x]=sum;</span><br><span class="line">    <span class="keyword">for</span>(u=<span class="number">0</span>;u!=y;top--)</span><br><span class="line">    &#123;</span><br><span class="line">        u=sta[top];</span><br><span class="line">        stot[u]=sum;</span><br><span class="line">        <span class="built_in">add_g</span>(u,cnt,<span class="built_in">min</span>(s[u],sum-s[u]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfncnt;</span><br><span class="line">    sta[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=u.v,z=u.w;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&lt;=low[x])low[x]=low[y],to[x]=z;<span class="comment">//注意这个 if 语句中的 &lt;= 号！留给读者思考</span></span><br><span class="line">            <span class="comment">// low[x]=min(low[x],low[y]);</span></span><br><span class="line">            <span class="keyword">if</span>(dfn[x]==low[y])<span class="built_in">build</span>(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dfn[y]&lt;low[x])low[x]=dfn[y],to[x]=z;</span><br><span class="line">        <span class="comment">// low[x]=min(low[x],dfn[y]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=u.v,z=u.w;</span><br><span class="line">        <span class="keyword">if</span>(y==f[x][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>,dis[y]=dis[x]+z;</span><br><span class="line">        f[y][<span class="number">0</span>]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">            f[y][i]=f[f[y][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)<span class="keyword">if</span>(d[f[x][i]]&gt;=d[y])x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)<span class="keyword">if</span>(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];</span><br><span class="line">    A=x,B=y;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add_e</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="type">int</span> lca=<span class="built_in">LCA</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(lca&lt;=n)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[x]+dis[y]<span class="number">-2</span>*dis[lca]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[x]+dis[y]-dis[A]-dis[B]+<span class="built_in">min</span>(<span class="built_in">abs</span>(s[A]-s[B]),stot[A]-<span class="built_in">abs</span>(s[A]-s[B])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>特别地，对于仙人掌，我们可以采用类似求边双连通分量的方式来建仙人掌的圆方树。因为当我们从 $x$ 走到一个 $y$ 不以 $x$ 为搜索树上的父亲，也不是在 $x$ 之前访问节点。那么搜索树上 $x\to y$ 的路径和 $(y,x)$ 就一同构成了一个环。这样做的话，在处理边权问题时就会方便一些。具体实现也可以看看代码。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>边双连通分量<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>,M=<span class="number">2e4</span>+<span class="number">10</span>,K=<span class="number">15</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> dfncnt,cnt,dfn[N],low[N],fa[N],fw[N];</span><br><span class="line"><span class="type">int</span> stot[N],s[N];</span><br><span class="line">vector&lt;Edge&gt;e[N],g[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N],dis[N],f[N][<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> A,B;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_e</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].<span class="built_in">push_back</span>((Edge)&#123;v,w&#125;);</span><br><span class="line">    e[v].<span class="built_in">push_back</span>((Edge)&#123;u,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_g</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g[u].<span class="built_in">push_back</span>((Edge)&#123;v,w&#125;);</span><br><span class="line">    g[v].<span class="built_in">push_back</span>((Edge)&#123;u,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=y;i!=x;i=fa[i])</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]=sum;</span><br><span class="line">        sum+=fw[i];</span><br><span class="line">    &#125;</span><br><span class="line">    stot[x]=s[x]=sum;</span><br><span class="line">    <span class="built_in">add_g</span>(x,++cnt,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=y;i!=x;i=fa[i])</span><br><span class="line">    &#123;</span><br><span class="line">        stot[i]=sum;</span><br><span class="line">        <span class="built_in">add_g</span>(i,cnt,<span class="built_in">min</span>(s[i],sum-s[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfncnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=u.v,z=u.w;</span><br><span class="line">        <span class="keyword">if</span>(fa[x]==y)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            fa[y]=x,fw[y]=z;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]&lt;low[y])<span class="built_in">add_g</span>(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:e[x])</span><br><span class="line">        <span class="keyword">if</span>(dfn[u.v]&gt;dfn[x]&amp;&amp;fa[u.v]!=x)</span><br><span class="line">            <span class="built_in">build</span>(x,u.v,u.w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=u.v,z=u.w;</span><br><span class="line">        <span class="keyword">if</span>(y==f[x][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>,dis[y]=dis[x]+z;</span><br><span class="line">        f[y][<span class="number">0</span>]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">            f[y][i]=f[f[y][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)<span class="keyword">if</span>(d[f[x][i]]&gt;=d[y])x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)<span class="keyword">if</span>(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];</span><br><span class="line">    A=x,B=y;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add_e</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!dfn[i])<span class="built_in">Tarjan</span>(i);</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="type">int</span> lca=<span class="built_in">LCA</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(lca&lt;=n)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[x]+dis[y]<span class="number">-2</span>*dis[lca]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[x]+dis[y]-dis[A]-dis[B]+<span class="built_in">min</span>(<span class="built_in">abs</span>(s[A]-s[B]),stot[A]-<span class="built_in">abs</span>(s[A]-s[B])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="2-P4630-APIO2018-铁人两项"><a href="#2-P4630-APIO2018-铁人两项" class="headerlink" title="2.P4630 [APIO2018] 铁人两项"></a>2.<a href="https://www.luogu.com.cn/problem/P4630">P4630 [APIO2018] 铁人两项</a></h4><p>经典圆方树练习题，考虑建出圆方树。考虑初末点 $s,f$，容易发现应当求圆方树上路径 $(s,f)$ 经过的所有点双的大小之和。考虑将方点的权值赋为点双的大小，树上 DP 求出。但是这样做显然是会重复的，因为路径上的每个圆点（除 $s,f$）作为原图上的割点会存在于两个点双之中。并且中转点 $c$ 不能为 $s,f$。于是我们将每个圆点点权赋为 $-1$，问题得到很好的解决。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dfncnt,top,tot,dfn[N],low[N],sta[N];</span><br><span class="line"><span class="type">int</span> cnt,val[N&lt;&lt;<span class="number">1</span>],si[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">ll ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N],g[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_e</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;e[u].<span class="built_in">push_back</span>(v);e[v].<span class="built_in">push_back</span>(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_g</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;g[u].<span class="built_in">push_back</span>(v),g[v].<span class="built_in">push_back</span>(u);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add_g</span>(x,++cnt);val[cnt]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u!=y;top--)<span class="built_in">add_g</span>(u=sta[top],cnt),val[cnt]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfncnt;</span><br><span class="line">    sta[++top]=x,tot++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]==low[y])<span class="built_in">build</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=x&lt;=n;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        sum+=<span class="number">1ll</span>*si[x]*si[y];</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">    &#125;</span><br><span class="line">    sum+=<span class="number">1ll</span>*si[x]*(tot-si[x]);</span><br><span class="line">    ans+=<span class="number">2</span>*sum*val[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Tarjan</span>(x);</span><br><span class="line">    <span class="built_in">dfs</span>(x,<span class="number">0</span>);</span><br><span class="line">    top=tot=<span class="number">0</span>;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add_e</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)val[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!dfn[i])<span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="3-P4606-SDOI2018-战略游戏"><a href="#3-P4606-SDOI2018-战略游戏" class="headerlink" title="3.P4606 [SDOI2018]战略游戏"></a>3.<a href="https://www.luogu.com.cn/problem/P4606">P4606 [SDOI2018]战略游戏</a></h4><p>建出圆方树，相当于求点集 $S$ 中所有点最小公共祖先 $lca$ 与 $S$ 中所有点的形成的连通块的原点个数。这就是很经典的问题了，我们考虑将 $S$ 中的点按照圆方树上的 $dfn$ 序排序，那么路径 $(S’_1,S’_2),(S’_2,S’_3),\cdots,(S’_{|S|},S’_1)$ 则可以覆盖连通块上所有边两次。特判一下 $lca$ 是圆点还是方点即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,M=<span class="number">4e5</span>+<span class="number">10</span>,K=<span class="number">18</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m,q;</span><br><span class="line"><span class="type">int</span> dfncnt,top,dfn[N&lt;&lt;<span class="number">1</span>],low[N],sta[N];</span><br><span class="line"><span class="type">int</span> d[N&lt;&lt;<span class="number">1</span>],dis[N&lt;&lt;<span class="number">1</span>],fa[N&lt;&lt;<span class="number">1</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N],g[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_e</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;e[u].<span class="built_in">push_back</span>(v),e[v].<span class="built_in">push_back</span>(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_g</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;g[u].<span class="built_in">push_back</span>(v),g[v].<span class="built_in">push_back</span>(u);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add_g</span>(x,++cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u!=y;top--)u=sta[top],<span class="built_in">add_g</span>(u,cnt);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfncnt;</span><br><span class="line">    sta[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]==low[y])<span class="built_in">build</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=++dfncnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">        d[y]=d[x]+<span class="number">1</span>,dis[y]=dis[x]+(y&lt;=n),fa[y][<span class="number">0</span>]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=K;j++)fa[y][j]=fa[fa[y][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)</span><br><span class="line">        <span class="keyword">if</span>(d[fa[x][i]]&gt;=d[y])</span><br><span class="line">            x=fa[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;~i;i--)</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])</span><br><span class="line">            x=fa[x][i],y=fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)</span></span>&#123;<span class="keyword">return</span> dfn[x]&lt;dfn[y];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add_e</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    d[<span class="number">1</span>]=dis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dfncnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s;</span><br><span class="line">        <span class="built_in">read</span>(s);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            vec.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(vec[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">-2</span>*s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> lca=<span class="built_in">LCA</span>(vec[i],vec[i+<span class="number">1</span>]);</span><br><span class="line">            ans+=dis[vec[i]]+dis[vec[i+<span class="number">1</span>]]<span class="number">-2</span>*dis[lca];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">LCA</span>(vec[s<span class="number">-1</span>],vec[s])&lt;=n)ans+=<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfncnt=top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)low[i]=<span class="number">0</span>,e[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)dfn[i]=d[i]=dis[i]=<span class="number">0</span>,g[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="4-CF487E-Tourists"><a href="#4-CF487E-Tourists" class="headerlink" title="4.CF487E Tourists"></a>4.<a href="https://codeforces.com/problemset/problem/487/E">CF487E Tourists</a></h4><p>经典题。考虑建出圆方树，将方点的权值设为该点双连通分量中所有圆点权值最小值，然后进行树链剖分。但是这样修改原点时会影响到很多方点。考虑经典 trick，只维护方点所有儿子节点的权值最小值，用 <code>multiset</code> 维护即可，寻问时再算上父节点的值。时间复杂度 $\mathcal O(n\log n+q\log^2 n )$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> dfncnt,top,cnt,dfn[N],low[N],sta[N];</span><br><span class="line"><span class="type">int</span> si[N],d[N],fa[N],son[N],num[N],t[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N],g[N];</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt;sonv[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span></span><br><span class="line">&#123;</span><br><span class="line">    Node tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;tr[x].val=<span class="built_in">min</span>(tr[x&lt;&lt;<span class="number">1</span>].val,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tr[x].l=l,tr[x].r=r;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> tr[x].val=a[num[l]],<span class="built_in">void</span>();</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].l==tr[x].r)<span class="keyword">return</span> tr[x].val=k,<span class="built_in">void</span>();</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,pos,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos,k);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)<span class="keyword">return</span> tr[x].val;</span><br><span class="line">        <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>,res=INF;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>,l,r));</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Seg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_e</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;e[u].<span class="built_in">push_back</span>(v),e[v].<span class="built_in">push_back</span>(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_g</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;g[u].<span class="built_in">push_back</span>(v),g[v].<span class="built_in">push_back</span>(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add_g</span>(x,++cnt);a[cnt]=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u!=y;top--)<span class="built_in">add_g</span>(u=sta[top],cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++dfncnt;</span><br><span class="line">    sta[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]==low[y])<span class="built_in">build</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=<span class="number">1</span>,d[x]=d[fa[x]]+<span class="number">1</span>;</span><br><span class="line">    sonv[x].<span class="built_in">insert</span>(a[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:g[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x])<span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;</span><br><span class="line">        sonv[x].<span class="built_in">insert</span>(a[y]);</span><br><span class="line">        <span class="built_in">dfs1</span>(y);</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">        <span class="keyword">if</span>(si[son[x]]&lt;si[y])son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n)a[x]=*sonv[x].<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num[dfn[x]=++dfncnt]=x;</span><br><span class="line">    t[x]=p;</span><br><span class="line">    <span class="keyword">if</span>(son[x])<span class="built_in">dfs2</span>(son[x],p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:g[x])<span class="keyword">if</span>(y!=fa[x]&amp;&amp;y!=son[x])<span class="built_in">dfs2</span>(y,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Seg.<span class="built_in">modify</span>(<span class="number">1</span>,dfn[x],k);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> a[x]=k,<span class="built_in">void</span>();</span><br><span class="line">    sonv[fa[x]].<span class="built_in">erase</span>(sonv[fa[x]].<span class="built_in">find</span>(a[x]));</span><br><span class="line">    sonv[fa[x]].<span class="built_in">insert</span>(k);</span><br><span class="line">    a[x]=k,a[fa[x]]=*sonv[fa[x]].<span class="built_in">begin</span>();</span><br><span class="line">    Seg.<span class="built_in">modify</span>(<span class="number">1</span>,dfn[fa[x]],a[fa[x]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=INF;</span><br><span class="line">    <span class="keyword">while</span>(t[x]!=t[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[t[x]]&lt;d[t[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        res=<span class="built_in">min</span>(res,Seg.<span class="built_in">query</span>(<span class="number">1</span>,dfn[t[x]],dfn[x]));</span><br><span class="line">        x=fa[t[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&gt;d[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    res=<span class="built_in">min</span>(res,Seg.<span class="built_in">query</span>(<span class="number">1</span>,dfn[x],dfn[y]));</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n)res=<span class="built_in">min</span>(res,a[fa[x]]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add_e</span>(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=n;</span><br><span class="line">    <span class="built_in">Tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    dfncnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>),<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    Seg.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)<span class="built_in">modify</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>容斥原理</title>
    <url>/2023/02/26/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>容斥是门学问。</p>
<span id="more"></span>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>集合 $U$ 中的元素有 $n$ 种不同的属性，而第 $i$ 种属性称为 $P_i$，拥有属性 $P_i$ 的元素构成的集合为 $S_i$，那么：</p>
<script type="math/tex; mode=display">
\begin{align}
\bigcup_{i=1}^n S_i=& \sum_i |S_i|-\sum_{i<j} |S_i\bigcap S_j|+\sum_{i<j<k}|S_i\bigcap S_j\bigcap S_k|-\dots\\
&+(-1)^{m-1}\sum_{a_i<a_{i+1}}\bigcap_{i=1}^m S_{a_i}+\dots+(-1)^{n-1}|S_1\cap S_2\cap \dots S_n|
\end{align}</script><p>即：</p>
<script type="math/tex; mode=display">
\begin{align}
\bigcup_{i=1}^n S_i=\sum_{m=1}^{n}(-1)^{m-1}\sum_{a_i<a_{i+1}}\bigcap_{i=1}^m S_{a_i}
\end{align}</script><p>对于证明，我们需要证明每个元素恰好出现一次，把所有出现该元素的集合拿出来，来算其出现次数。设其出现的集合个数为 $m$：</p>
<script type="math/tex; mode=display">
\begin{align}
cnt&=\binom{m}{1}-\binom{m}{2}+\binom{m}{3}-\dots +(-1)^{m-1}\binom{m}{m}\\
&=\binom{m}{0}-\sum_{i=0}^{m}\binom {m}{i}\\
&=1-(1+(-1))^m=1
\end{align}</script><p>另外，集合的并可以用全集减去补集的并得到，即：</p>
<script type="math/tex; mode=display">
\begin{align}
\bigcap_{i=1}^{n}S_i=|U|-\bigcup_{i=1}^{n} \overline{S_i}
\end{align}</script><p>对右边容斥即可。</p>
<h3 id="2-容斥原理一般化"><a href="#2-容斥原理一般化" class="headerlink" title="2.容斥原理一般化"></a>2.容斥原理一般化</h3><p>容斥原理是解决计数问题的利器，对于两个集合的函数 $f(S),g(S)$，若：</p>
<script type="math/tex; mode=display">
\begin{align}
f(S)=\sum_{T\subseteq S}g(T)
\end{align}</script><p>那么有：</p>
<script type="math/tex; mode=display">
\begin{align}
g(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|} f(T)
\end{align}</script><p>同样的对于</p>
<script type="math/tex; mode=display">
\begin{align}
f(T)=\sum_{T\subseteq S}g(S)
\end{align}</script><p>那么有：</p>
<script type="math/tex; mode=display">
\begin{align}
g(T)=\sum_{T\subseteq S}(-1)^{|S|-|T|} f(S)
\end{align}</script><p>我们发现上述的 $f(S),g(S)$，可以对应为 “至多/至少” 与 “恰好”。</p>
<h3 id="3-min-max-容斥"><a href="#3-min-max-容斥" class="headerlink" title="3.min-max 容斥"></a>3.min-max 容斥</h3><p>对于集合 $S,T$ 且 $T\subseteq S$，那么有：</p>
<script type="math/tex; mode=display">
\begin{align}
\max_{i\in S}a_i=\sum_{T\subseteq S}(-1)^{|T|+1}\min_{i\in S}a_i\\
\min_{i\in S}a_i=\sum_{T\subseteq S}(-1)^{|T|+1}\max_{i\in S}a_i
\end{align}</script><p>更加重要的是，这个式子在期望意义下也是成立的，即：</p>
<script type="math/tex; mode=display">
\begin{align}
E(\max_{i\in S}a_i)=\sum_{T\subseteq S}(-1)^{|T|+1}E(\min_{i\in S}a_i)\\
E(\min_{i\in S}a_i)=\sum_{T\subseteq S}(-1)^{|T|+1}E(\max_{i\in S}a_i)
\end{align}</script><p>这就比较好了，因为对于 $(13)$ 式子中，大多数情况下 $\displaystyle E(\min_{a_i\in S}a_i)$ 是相对好求的。</p>
<p>还有更强的：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{kth}\max_{ i\in S}a_i=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}\min_{i\in T} a_i\\
\text{kth}\min_{ i\in S}a_i=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}\max_{i\in T} a_i
\end{align}</script><p>同样对于期望意义下也是成立的：</p>
<script type="math/tex; mode=display">
\begin{align}
E(\text{kth}\max_{ i\in S}a_i)=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}E(\min_{i\in T} a_i)\\
E(\text{kth}\min_{ i\in S}a_i)=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}E(\max_{i\in T} a_i)
\end{align}</script><p>长得很像二项式反演！其实确实可以从二项式反演的角度证明以上等式。</p>
<h3 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h3><h4 id="1-AGC005D-K-Perm-Counting"><a href="#1-AGC005D-K-Perm-Counting" class="headerlink" title="1.AGC005D ~K Perm Counting"></a>1.<a href="https://atcoder.jp/contests/agc005/tasks/agc005_d">AGC005D ~K Perm Counting</a></h4><p>是个错位排列的扩展。我们尝试用类似的做法解决。设 $f(n)$ 表示钦定 $n$ 个元素满足 $|p_i-i|= k$ 的方案数，相当于求恰好有 $0 $ 个元素满足 $|p_i-i|= k$，利用式子 $(11)$ ，容斥得到答案为：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n (-1)^i (n-i)!f(i)</script><p>$f(n)$ 怎么求？钦定 $n$ 个元素满足 $p_i=i\pm k$，显然只有 $\bmod 2k$ 的同余类之间才会产生冲突。于是把每个同余类单独拿出来，需要在 $n$ 个点中选 $m$ 个点。将排列转化为二分图上的匹配。我们根据上面的限制对于每个同余类建出来的图是形如一条链的，问题就变为 $n$ 条匹配选 $m$ 条有多少种方案。相当于要求不能有匹配相邻。我们只要选择一条匹配则其后面的一条一定不能选，通过组合数得到方案数为 $\displaystyle \binom{n-m+1}{m}$。再使用背包进行合并不同同余类即可。这样暴力做是 $\mathcal O(n^2)$ 的，足以通过。但其实这个过程我们完全可以用生成函数来做，直接求其卷积即可，时间复杂度就为 $\mathcal O(n\log n)$。</p>
<p>此处为暴力 $\mathcal O(n^2)$ 代码。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,mod=<span class="number">924844033</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> fac[N],ifac[N];</span><br><span class="line"><span class="type">int</span> f[N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n||m&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;~i;i--)ifac[i]=<span class="number">1ll</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="built_in">prework</span>(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=<span class="built_in">min</span>(n,k&lt;&lt;<span class="number">1</span>);t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m=(t&gt;k)+((n-t)/k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;~i;i--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(i,m);j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> res=<span class="built_in">C</span>(m-j+<span class="number">1</span>,j);</span><br><span class="line">                f[i]=<span class="built_in">adj</span>(f[i]+<span class="number">1ll</span>*f[i-j]*res%mod);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+(i&amp;<span class="number">1</span>?mod<span class="number">-1ll</span>*f[i]*fac[n-i]%mod:<span class="number">1ll</span>*f[i]*fac[n-i]%mod));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>容斥</tag>
        <tag>笔记</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>无</title>
    <url>/2022/08/18/%E6%97%A0/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d4ae7f5d494f03af1a8664b66f4cef6335c3b2241f9df3b23d2f810984d156d3">2e38a67a3587ae81f8e8aaf04b5440843fe32d479caec342b0f00ee7e0b2dba2d49b078f4eb1df66ae05138d21963060de67353b08284844a8a2b4975bccd9ff27fe545e7686465f7906381b0d39293462ce664585782717af13ceb2175cd994b8d678ca9e99d51e5b1a6e691fde46d76137449b34d998e97bc0a3cfa397d890b88370501b3dc867629151d338653cf41da13679f466d7be21de4248b094660bab24453b07d7a616a4d094e6d7af065fe4b380e4c8cd603ca3b4fdad08627e1cf6e362fe917dc1b9be2f70faae51aa1efd59b4692cc48484065f430b0875c3ef5371d5b0d35b0be7ca4e3754d861ad0aab9324dc93b61e051c47dc59387985b9060c8fb8892cb88db463bb97a6c474523a6fe9522bdf6644210d6e8456f656f4bd91692ddcd2afa521a6a3ac01e197fc64d5418c4702596300669b2cbdb0c1f57894ae1f2150097626c037376f68b91a50a434c62a12406753e083bc3512794eb1a120497374b08e7f21456a7077d6a303ba2b6b017797111ed94d2a041ae2ddb7d40af1ffdd3110aad1d19523737ea22dcecbfa0fc6f19bb18ef363026f21eb82529593ba945cf9b9feba5a7f42f31f4648dd95c0cc5b7090e87190510730861eab0a0a0fe475932b54f684ec970746f37cdeacdccd2e6116e8f93a14d59cda91577ce40ddbabc37d401d5f8ff85ab5888070a8d675e347f58998fc47d654e5c1f656e6e04b90751f78658800bce127f26b3931992a5de4510c2ae868ec3bca5d06976a2fe3d9fb05a2634e38138b58775b7897803beb737b2986c98172ca48b27952cbfe649b9741271716523cba6767566e3aea020566e3e0a9655fe8e3727e9b1d757f89cd8a35671eef2555a649567474d75da9af74acd06b258120226b12f9f391cc3b1094f03a8d981620e394aec3ac4006fde6b3b7f1a54dbf662233a44eefb63c2bfdec37ee20866b20349d5666d18dbfbb31a3a81f025a83d5377ba676a5bd99a6bbe4d91c039f3772c92bc7cbe841b3ab1c9569eaf2a497305ffe906fd644275c4cae905b8d43e3611f75189a38e54c7e028e79576ad5244a20f7869aa29eb370eeebc7117b2b79dd8a741eed51ce1d3353ccb3bd745546da875236c14012410b2265053f0f762eb76c955514a7695cbde9e01287f85641da16f326f4f48e892c9f08234592b8c5980fb747f0845f4e03ad6237a17cb971aadb0c16f326204b781eabf5c243789740bc8593ce3a0238d9d47cf480685b7cfcf8dd819433adad4e0906b50447f28923f58edfd9e27ae8ea048a95283122b0f4e63308e4dd9dfa51e17ab3e3a57fbd5c2c9399e873360ee3091abad46bed9071cff72385e03abdb550d45fe6d3f8644f329466f75421658a2bfe21d174dc6727aa88cf56ed51743d34a0ad612a84fdc70445d2a6cc50f0e0deadd14512407ba41773a5591975d744bf9615f5c3a6953560e666bd07481b874bbe434886cb61278d87cfc013baf8a771c39db2d38dba33ffeb2c126d826ad001e6f074ff193e66215d4d6800e426d0865e7222bc8b4e2cf1f67ff4f950992bbd6de44667e6c96905d2668bff96893b8678ee7153385422a0794c89dd16a67d43cfc796565cd04add59ae28b448cd376eba092e2a7faafcb318681daa38781dfa425649939211ec77fac7b6c25c767df702fdd2b717122bde5bfa4bd28768885d37e34d1fdea418cbe53713479e9c115204ced44614cb9cfe497107a8f1b2bfa9ff2e74855624e0e045f502502284d5988a2a2f12f10b7d7605bdd9a4b64b8c2aac550698e0898aca72aa8ed6f7c8df320dc055044d4906e6fabcdb78078ea59e77f510d7b93e93aa3eab520ff94e4bf65e4659a58329fad7b7f5b1c2768be01fe0b8ef58a03317bdc00f94fd63997cb622fed37ab25c9a81352e74065b9ebcc907d89a1b03815ff237e7ef82d6eb876b4638fa92ee645ab2d01be4b3f0be11053965879b0af17bee2aaba1c0677af7ff7622cee794611c2d8eda650c3f909925d03d6e74d8177c5285e6f92ba90eb325c9fa026e2a876c1383321e712a9c04fd9d035b2a2edd75fe0823e1493cdab7bc12fa0d1ff3742714d667d36548662637028696cc077594a30a1a0959fc2dcb3a545d3b64ac20dee95651a1135e3101fc8715a64ab11878dcb8146aedeb8c990dd89bcb15d5b385faa68c9304d298d9d661b53834e457c2eb78bc50459876dba6c2a8a76e062ed27d7c16800f47a75433dc1037e3a71b5b9133fb51dba0bf01ce6b01ff3d3a4d9bdf3053f60b3b1aac612a3f5fc7fd7ccc795206d1732238872d8280b0e67bee0d43d7b19a8198811a3a7aecaf3bfdc82ffb7c94579a24ab6917e59053b7ba377844ef045e7b9194ef98f32242fa2b5b6e9f81a79c633882009523efb24f2bc7c482dbe14889b309172cae84ef7abf81623049b09c74d1ae10f45c192aee068035c7a6bb75e9e45ec962858992dd84190679567ca6eda17b94e63baea0926a316ade729e1cf2377da89cd111840f559ffb0489e4744481d404223cdea1c12634e08d6f39568a455cc2651bba9615850b55fce292a83c02b684a237aaf87b6f50109cfc1271602d508cedffbcda26474497f0954bb5b1155f14447d54d0dbf9223503144e740fe3c982b53d807acc3e883b46b44b0c40505132abda25f0aeef959ec7289ff0c8db007ca48e3803835ad311e8a3180bf276f552679365adcd91fabbf82e118e1db464f815aec4aa2fc49d046557a9eeed4d4973320a79d0882b304767265afcbeb49dbd1b26183312be706b7bd3cd76e820bc6ac486cfd2c6c914d741b8efb28aa211fab7960947f289a16e1ca2c005d87c17739d433840f796320f4626fe671130e49959fdea7d825c96305f973795d35fafbc34b6326e22ca7409459f1d3650cb4f3c01fde71c1e5e7eb5f19a5b922854cc9564d0e38cb3d6e25fe6132882f2567f8a537e7fda1d19857a9a9bbebf0fe161f4cacd8d7ba702806ee756dc6e847d0187853dd1af8b35421372f31c2f90578a6db01b312fa9ed27ad92acb3600dd26d77cd402a5b16e9dc8918c8d27ab22fafff7d297aef63e33f6c73dd1d74ea8af09294da10472c456c079c3fda47d652850d5a57e145aa6014b3ded3d8f4d2b2d10d0a290956e17efb94ae4e74c3b4855e20edd7d8d64cc7e64c0eec458646d4a83e1a37edf26c4e0b72adfb843892c4dc2e6f188c04191a1f7fc56fc6ec457fbccf64276b1770544080ff700659fecfc20ad60b3d0e501dddac200340160a134e15a73a04a2475904b55ea1cf8bcf2563ca4d1e477ff9a232ac9b62986ca4a565f1eb3a61928559b484aa6adcf3a87b4f4051c4e840bec8d79cc896d069997d45de4f9881e155757daed0976bcfcd04dcee1720b6ee947601a78f0c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">无</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>无</tag>
      </tags>
  </entry>
  <entry>
    <title>生成函数</title>
    <url>/2023/01/12/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>很有用。</p>
<span id="more"></span>
<h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0.写在前面"></a>0.写在前面</h2><p>无论是 OGF 还是 EGF，往往都具有很好的数学性质。而很多问题之所以可以用GF解决，因为我们可以将组合问题转化为研究GF的数学性质，再利用多项式科技解决。</p>
<p>所以说到底应该如何理解 GF？</p>
<h2 id="1-普通生成函数-OGF"><a href="#1-普通生成函数-OGF" class="headerlink" title="1.普通生成函数 OGF"></a>1.普通生成函数 OGF</h2><p>从 DP 的角度看，形式幂级数之间的相乘与不同状态间的转移等价，其中 $x^n$ 表示状态，系数 $a_n$ 表示该状态的答案。</p>
<h3 id="1-1-封闭形式"><a href="#1-1-封闭形式" class="headerlink" title="1.1 封闭形式"></a>1.1 封闭形式</h3><p>记几个式子，$F(x)$ 为序列 $a$ 的生成函数所对应的封闭形式：</p>
<script type="math/tex; mode=display">
\begin{align}
&a_n=\binom{m}{n}\Rightarrow F(x)=\sum_{n\ge0} \binom{m}{n} x^n=(1+x)^m\\
&a_n=\binom{m+n}{n} \Rightarrow F(x)=\sum_{n\ge0} \binom{m+n}{n}x^n=\frac{1}{(1-x)^{m+1}}
\end{align}</script><h3 id="1-2-卷积"><a href="#1-2-卷积" class="headerlink" title="1.2 卷积"></a>1.2 卷积</h3><script type="math/tex; mode=display">
\begin{align}
F(x)&=\sum_{i\ge 0} a_nx^i\notag\\
G(x)&=\sum_{i\ge 0} b_nx^i\notag\\
F(x)*G(x)&=\sum_{n\ge 0}x^n\sum_{i\ge 0}a_i b_{n-i}\notag\\
\end{align}</script><p>直接卷积得到的新的生成函数，而这个生成函数系数的系数除了卷积得到的系数外，没有其他系数。从排列组合的角度理解，说明不同元素之间相对顺序的改变不会影响方案总数，故这样求出来是<strong>无标号</strong>的。</p>
<h2 id="2-指数生成函数"><a href="#2-指数生成函数" class="headerlink" title="2.指数生成函数"></a>2.指数生成函数</h2><p>或许还是可以从 DP 的角度理解，不同点是系数 $\frac{1}{i!}$，这可以用来代表 DP 转移中乘上的系数。</p>
<h3 id="2-1-封闭形式"><a href="#2-1-封闭形式" class="headerlink" title="2.1 封闭形式"></a>2.1 封闭形式</h3><h3 id="2-2-卷积"><a href="#2-2-卷积" class="headerlink" title="2.2 卷积"></a>2.2 卷积</h3><p>考虑两个EGF $\hat{F}(x)$ 和 $\hat{G}(x)$ 的卷积：</p>
<script type="math/tex; mode=display">
\begin{align}
\hat{F}(x)&=\sum_{i\ge 0} a_n\frac{x^i}{i!} \notag\\
\hat{G}(x)&=\sum_{i\ge 0} b_n\frac{x^i}{i!} \notag\\
\hat{F}(x)*\hat{G}(x)&=\sum_{n\ge 0}x^n\sum_{i\ge 0}a_i b_{n-i} \frac{1}{i!(n-i)!}\notag\\
&=\sum_{n\ge 0}\frac{x^n}{n!}\sum_{i\ge 0}\binom{n}{i}a_i b_{n-i}
\end{align}</script><p>我们得到一个新的指数生成函数，这个指数生成函数的系数还多上了 $\binom{n}i{}$。从排列组合的角度理解，说明不同元素之间相对顺序的改变会产生新的方案，或者说这样求出来的方案数是<strong>带标号</strong>的。</p>
<h3 id="2-3-指数函数-exp"><a href="#2-3-指数函数-exp" class="headerlink" title="2.3 指数函数 exp"></a>2.3 指数函数 exp</h3><p>设 $\hat{F}(x)$ 为 $f_i$ 的 EGF，考虑 EGF $\hat{F}^k(x)$ 的意义，即 $k$ 个 $\hat{F}(x)$ 卷积得到：</p>
<script type="math/tex; mode=display">
\hat{F}^k(x)=\sum_{n\ge 0}\frac{x^n}{n!}n!\sum_{\sum_i^k a_i=n}\prod_{j}^k\frac{f_{a_j}}{a_j!}</script><p>从集合的角度理解就是将 $n$ 个有标号元素划分到 $k&gt;0$ 个有标号集合中。$n=0$ 时系数为多项式常数项的乘积，之后的多项式 $\exp$ 的常数项需要满足常数项为 $0$。  </p>
<p>设 $F_k(n)$ 为 $n$ 个有标号元素划分为 $k$ 非空无序集合（这里 $n,k$ 的意义与上面相反，非空因为 $\exp$ 要求常数项为 $0$），$f_n$ 为满足原有 $n$ 个元素组成的特定结构的数量（具体由求解问题给定，且只与集合个数 $n$ 相关）。根据定义得到：</p>
<script type="math/tex; mode=display">
\begin{align}
F_k(n)=\frac{n!}{k!}\sum_{\sum_i^k a_i=n}\prod_{j}^k\frac{f_{a_j}}{a_j!}\notag\\
\end{align}</script><p>设 $F_k(n)$ 的 EGF 为 $G(x)$，那么得到：</p>
<script type="math/tex; mode=display">
\begin{align}
G_k(x)&=\sum_{n\ge 0}\frac{x^n}{n!}F_k(n)\notag\\
G_k(x)&=\frac{1}{k!}\sum_{n\ge 0}x^n\sum_{\sum_i^k a_i=n}\prod_{j}^k\frac{f_{a_j}}{a_j!}\notag\\
G_k(x)&=\frac{1}{k!}\hat{F}^k(x)
\end{align}</script><p>我们得到 $G_k$，尝试对 $G$ 求和得到 $G$：</p>
<script type="math/tex; mode=display">
G(x)=\sum_{k\ge 0} G_k(x)=\sum_{k\ge 0}\frac{1}{k!}\hat{F}^k(x)=\exp \hat{F}(x)</script><p>$\hat{F}(x)$ 是 $f_n$ 的指数生成函数，$f_n$ 为满足原有 $n$ 个元素组成的特定结构的数量。于是我们得到指数函数 $\exp$ 即 $G(x)=\exp \hat{F}(x)$ 的组合意义：表示将 $n$ 个元素划分为任意个不为空的集合的方案数。这就是<strong>指数公式定理</strong>。形式化的描述，即：</p>
<p>如果存在两个 EGF $F(x),G(x)$，其中 $F(x)$ 为 $f_n$ 的 EGF，$G(X)=\exp F(x)$，那么 $G(x)$ 是：</p>
<script type="math/tex; mode=display">
g_n=\sum_{\pi={S_1,S_2,\cdots,S_k}}\prod_{i=1}^k f_{|S_i|}</script><p>的 EGF，$\pi$ 是 $[n]$ 的一个划分。</p>
<h3 id="2-4-例题"><a href="#2-4-例题" class="headerlink" title="2.4 例题"></a>2.4 例题</h3><h4 id="1-P4841-集训队作业2013-城市规划"><a href="#1-P4841-集训队作业2013-城市规划" class="headerlink" title="1.P4841 [集训队作业2013]城市规划"></a>1.<a href="https://www.luogu.com.cn/problem/P4841">P4841 [集训队作业2013]城市规划</a></h4><p>设 $f_n$ 表示 $n$ 个点的有标号无向<strong>连通</strong>图方案数，$g_n$ 表示 $n$ 个点的有标号无向图方案数，$F(x),G(x)$ 分别为二者的 EGF。首先容易得到：$g_n=2^{\binom{n}{2}}$。</p>
<p>根据<strong>指数公式定理</strong>，我们容易得到：</p>
<script type="math/tex; mode=display">
\exp F(x)=G(x)</script><p>于是我们只需要对 $G(x)$ 取 $\ln$ 即可得到 $F(x)=\ln G(x)$。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>沉默</title>
    <url>/2022/11/15/%E6%B2%89%E9%BB%98/</url>
    <content><![CDATA[<p> ……</p>
<span id="more"></span>
<p>总有人选择沉默，似乎对于任何事都是这样，无论好的坏的。有人认为他们故作深沉，但他们的姿态不是事不关己，也不是高高在上——而是像树木一般，无言中挺立着。</p>
<p>沉默也许来源于内心的孤独。沉默是因为所流露的感情却也无人在意。既然无人倾听，那就没什么必要用话讲出来了。一个人的路上深一脚浅一脚地走，也只能感觉到自己的情感在泛滥，只好拼尽全力去保护玻璃般的心。随之语言功能也就逐渐退化，独自读一些写一些半懂不通的文字，仿佛徜徉于自己内心的世界的朦胧感，无法自拔。最后只是如此日复一日，江河日下罢了。这就是从前的感觉，像是得了病，是失去了能量的车轮，没有了向上的动力。</p>
<p>但也随着经历的是非越来越多——我想也多半是因为人总是要成长的。人们说：“沉默是成年人的默契。”此话只对了一半。从前的我们也很喜欢较真，一定要争个胜负，也不知道是为了得到什么——或许就是所谓的 <em>优越感</em>，却也害怕着被揭穿，好保住自己可怜的自尊心与<em>优越感</em>。不过谁谁谁做的什么什么事情，其实都心知肚明，只是也不愿多言。这种或是理解，或是不愿与其同流合污但也却无力改变，只暗下决心——像埋下了一颗种子，要用自己的方式完成自己的使命。更多的是少说话而多做事。自然还有一种则是纵容与包庇，这就直接成了令人厌恶的冷眼旁观者，于是这种更是废物了，并不归于这一类。沉默之中，也像这样观察着周围的一切。如此，在沉默中自身也逐渐变化着，褪去青涩就剩下粗糙的枝干，也不知道是应该高兴还是难过。只剩下沉默，直到应当的时机，再爆出口。</p>
<p>开始将目光移向自身，生活中的事物也沉淀下来。沉默中能够摒弃一些浮躁与戾气，逐渐深入自己，感觉到自我生命的本真，并明白自己想要成为什么，不想要成为什么。一切只是关乎你对自己生命价值的满足与充实的快乐。才能够宁静而致远。生命的意义是个永远求不出解的问题，但你能够知道这个问题有解，也会告诉自己继续要不停走下去。自己也在朦胧的内心世界开始清晰起来，也就不会再为了过去而后悔，为了未来而彷徨。</p>
<p>于是只是像树木一般，无言中挺立着。在冷气之中，只是感觉到充实与自由。</p>
<blockquote>
<p>人一旦悟透了就会变得沉默，不是没有与人相处的能力，而是没有了逢人作戏的兴趣。——鲁迅</p>
</blockquote>
]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>脑子里并没有另一个人的记忆</title>
    <url>/2023/01/15/%E8%84%91%E5%AD%90%E9%87%8C%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E8%AE%B0%E5%BF%86/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="18ffc29d707d3591fdf4c70f44b28d641a17f342fe9de0db2344df352626ee7f">ffc2a1a8d5dd2c8af5bcfcf7b828bee0cb524c044d024bc4843593b6a590981848eaae75129507fd7a1b3574b6c6c609c3ba37bbb90bd8dc46ead3468cc68a5ad8e99ced4f8e797217fdbf9ec8f60e730524708200cb811af10d56077d1fabd8ba4651e156fe4e179546ccafe37686fa151c2d54d68606b16715b1c27217ebf4fca4a762c5793bd96dbe88c80717eca13ae1df66429006e68c23303daf2548d557e56a6d60a9ff4cce568e1771db98bd677def74789a178eb9195b427743863e86a64ef866de7b63b4b63be6c4cfe3ff3e023865932cc8e2ee5d2212b5320ef526831af3723a73e036d58b9dcc9ece2f0be31a989814c362f5796f85af51d7339c5c61933d65639aa839431368b9b631113beb746c6d41acaec6f324d7264a47132438bf4959cf80348cdd958fab995828d06423a58acccc66f895bcc678322a0c67c7213208341b3a5cfa085ab1f2b0fd0f280f6b1e11e63100ac63664a19355a390e48b90ec747567a0b03d14dbf196ddc18b4c769a563afcb4c5e030c8c71a1bfd2c98d14e8229c4e7b686d9531320a047c48fdc13544808e3acf046d05fd3b78ceafd3f220d46c736866df9f9b3f8aace2eebe7dd78c43c3048cac205a1607d5dfea04e5144f789e552ecd605198e3a943f15f60c0eaf158f08a44e6c93e927a8e3c3515cada3b93984c7a6b005d872cb33098cf5cac20386d59ae215443bd730ca24e9176b472270635e105bc095a0cf767c73fe6c596b86d3431b410ac006e30d53b4b064d3fcb0e48655f5fc9d8c17609859b3780f065340e7741173f1d9d5451ac306ba4ba43aa687d278ec3c9f3427460fa965b5ed28ce7a3f5a7c74b9aea66f6faa08e7ebd84a028dc73af47c98268cf7985820270efc469760cccacad9b74c6b665f263b0b9cc77163b6e42dba24d68e789867763ddaf53a05df685b0c355c63260cdb97961e7d72532cb436b75a2179185f07106452c2422526c760eb516908f49a6dca8c6f7ad0e599f304520fc245472ac652fcfbca2866c9fbb3e3ee9f56b49b715c79ad3f7ae8e89c97bf7dbc0f9aaed86179b1e6af4abde3a2852dcc897e6787a8f04f88a5e1dd3a25972b8ad211e37ae24d087a3bab769622e1e8337c03329e08504046db2eccd2568d53c3c4fc13a65531ddb476d85b7ff25dd0266f555518f4c089b70b27d6bcbc1fbda5599506d61f69b2b40d43013ca626a3f75767ae98d5773d5804e89de12644a3325c140cc5e33b16e1bec67b76c6501f2b8354e80ae77777526c6bb6f32782fdef4dab57094bb2ab1bab12119a8a8e5373978f01c2d048accfcc58c334d3f0888d368e08e741941a9b76973e3ed0c3e771cdd7ed027a1d52d66ae8fad43fa5796ef5758505fabbb40f297023d1d9c786db9229c103e056f47a9f0a8ba70ef71770e8cd7be2fa07f1c4e35834cac4c5a41a885c089c85cb8214c12721a641e75cb0606dc08d5bab954978740b0f4da15a6a7c4e605a92dc8cae4cec04e9f762dd90c608f8298348b6c06805febaf51eed3aa1a557412f59e6aad936b1d9159257775079a624bc20edb6cc20e35ac38ea7de1f335adbd74c823b1c79295</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">I am.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>辩驳</title>
    <url>/2023/04/22/%E8%BE%A9%E9%A9%B3/</url>
    <content><![CDATA[<p>4 月 22 日闲话。</p>
<span id="more"></span>
<p>脑子很乱。逐渐发现写闲话似乎是十分必要的了。现在情况是议论文处于完全不会写的状态，甚至文字也逐渐变得冗杂凌乱，信息熵极高。可是文字越来越多，时间越来越少，我该怎么办？？？不得不说的是考试的议论文真像是八股。既然阅卷人爱听，也只好说点浮夸美妙的词汇了。问题就在于，我连八股文的排比对偶都搞不懂，什么破题承题权当是一窍不通。我并不觉得好，我不愿写也并不写得出来。出来，于是连评论评论者得资格也丧失了。</p>
<p>也似乎都改不掉无病呻吟的毛病，还是说无病呻吟也是一种毛病？即使有病也不必呻吟，何必用锦绣之饰遮遮掩掩？在这一层层的胶布下的病灶也被修饰的成锦上添花的模样，不知在何处，只好装做出健全的模样，掩饰着真实的痛感。而又为什么不撕开绷带来，仔仔细细地瞧呢？有人就说了：“你居心何在？”或许溃烂的创面让病人自己看了也觉得恶心。索性直接宣称为“特色出口”，希望不会受到人们的怀疑罢了。</p>
<p>改日再写。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>流逝</title>
    <url>/2023/05/03/%E6%B5%81%E9%80%9D/</url>
    <content><![CDATA[<p>5 月 3 日闲话。</p>
<span id="more"></span>
<p>偶然看见博客上一篇篇文章的日期，不由得惊觉已经过去这么久了。似乎还是不久之前呢，但是这么久还是一事无成。这么久了，自己真的成为了一名有水平的选手了吗？恍惚中还是懊恼。</p>
<p>需要静一静。</p>
<p>昨天刚立下的目标，顺间就全忘了。</p>
<p>甚至已经是前天了？</p>
<p>绝对不能再这样颓废下去了！！！</p>
]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>随机100题</title>
    <url>/2022/06/16/%E9%9A%8F%E6%9C%BA100%E9%A2%98/</url>
    <content><![CDATA[<p> 随机的100道题作为练习 ，争取在NOIP前做完。</p>
<span id="more"></span>
<p>update: NOIP前应该是做不完了，还是太菜了。</p>
<p>update: NOIP爆炸了，可能是因为没把这东西做完吧。。。</p>
<p>update: 摆了，练习题目都做不完，还是有空再来吧。。。</p>
<h4 id="1-P4881-hby与tkw的基情"><a href="#1-P4881-hby与tkw的基情" class="headerlink" title="1.P4881 hby与tkw的基情"></a>1.<a href="https://www.luogu.com.cn/problem/P4881">P4881 hby与tkw的基情</a></h4><p>设 $m=\frac{(n+1)}{2}$​，容易得到要求的是 $Ans=\sum_{i=1}^{m}(2i-1)\cdot 26^i $​ </p>
<p>再用错位相减随便推一下得到：  </p>
<p>$26Ans=\sum_{i=1}^{m}(2i-1)\cdot 26^{i+1} $​  </p>
<p>$25Ans=-26+(2m-1)\cdot 26^{m+1}+2\cdot \sum_{i=2}^{m}26^i $​ </p>
<p>最后运用等比数列求和公式就可以得到：</p>
<p>$Ans=\frac{-26+(2m-1)\cdot26^{m+1}+2\cdot \frac{26^{n+1}-26^2}{25} }{25}$</p>
<p>最后直接套式子，除法用逆元即可，时间复杂度 $\mathcal O(T\log n)$。    </p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,inv;</span><br><span class="line"><span class="function">ll <span class="title">power</span><span class="params">(ll a,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inv=<span class="built_in">power</span>(<span class="number">25</span>,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(n);</span><br><span class="line">        <span class="type">int</span> m=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        ll res=<span class="built_in">power</span>(<span class="number">26</span>,m+<span class="number">1</span>);</span><br><span class="line">        ll ans=((<span class="number">2</span>*m<span class="number">-1</span>)*res%mod<span class="number">-26</span><span class="number">-2</span>*((res<span class="number">-26</span>*<span class="number">26</span>+mod)%mod*inv%mod)%mod+mod)%mod*inv%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="2-P5148-大循环"><a href="#2-P5148-大循环" class="headerlink" title="2.P5148 大循环"></a>2.<a href="https://www.luogu.com.cn/problem/P5148">P5148 大循环</a></h4><p>很明显得到 $Ans=C_{n}^{k}\cdot f(q)$ 。<br>而求 $f(q)$ 也很简单的用一个秦九韶算法就完了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line">ll n,m,k,q;</span><br><span class="line">ll a[N],pre[N];</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=a[m]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i;i--)</span><br><span class="line">        res=(res*q%mod+a[i<span class="number">-1</span>])%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (mod-mod/x)*<span class="built_in">inv</span>(mod%x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> pre[n]*<span class="built_in">inv</span>(pre[m])%mod*<span class="built_in">inv</span>(pre[n-m])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,k,q);</span><br><span class="line">    q%=mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    pre[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">f</span>(q)*<span class="built_in">C</span>(n,k)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="3-CF1601C-Optimal-Insertion"><a href="#3-CF1601C-Optimal-Insertion" class="headerlink" title="3.CF1601C Optimal Insertion"></a>3.<a href="https://www.luogu.com.cn/problem/CF1601C">CF1601C Optimal Insertion</a></h4><p>不错的一道分治，也不算很难。</p>
<p>运用调整法很容易证明，将 $b$ 按照升序插入才可能得到最优解，于是我们先将 $b$ 排序。 </p>
<p>考虑求出一个 $pos_i$ 为将 $b_i$ 插入到 $a_{pos_i}$ 前面（特别地 $pos_i=n+1$ 表示将 $b_i$ 插入到 $a$ 的最后面 ）。  </p>
<p>有上面的结论可以得到，$b$ 中的元素各自的<strong>产生的逆序对数</strong>是<strong>互不影响</strong>的，但他们的位置又互相受到限制，都是因为 $b$ 是以升序插入的，于是我们可以知道：当若有 $l&lt;mid&lt;r$ ，那么 $b_{mid}$ 在 $[pos_l,pos_r]$中的最优解即为在全局 $[1,n]$ 中的最优解（微扰法可以证明，此处就不再赘述）。</p>
<p>其实这个贡献有关系式 $w(i,j)+w(i-1,j+1)=w(i,j+1)+w(i-1,j)$，这就是决策单调性的经典式子了。</p>
<p>有了这个新结论，我们利用决策单调性这一点进行分治，用 $solve(p,q,l,r)$，表示将 $b_l,b_{l+1},…,b_r$ 插入到 $a$ 的 $[p,q]$ 之间，每次递归只需要用 $\mathcal O(p-q)$ 求出 $pos_{mid}$。</p>
<p>随后根据求出的 $pos$ 将 $b$ 插入 $a$ 中再求逆序对即可。时间复杂度 $\mathcal O((n+m)\log(n+m))$。</p>
<p>实际上还有另外一种解法，就是先将 $a$ 离散化并计算逆序对，再建立一颗线段树，表示每个位置维护插入到位置 $i$ 新增加的逆序对数。新增加的逆序对数由两部分组成，前面比 $b_i$ 大的 $+$ 后面比 $b_i$ 小的。我们接着考虑当 $b_i$ 变为 $b_{i+1}$ 时对线段树的影响，同时 $a$ 也需要小到大考虑，得到：当 $a_x&lt;b_i$ 时，应当使 $[1,x]+1$；而当 $a_y\le b_i$ 时，应当使 $[y+1,n+1]-1$，同时动态维护答案即可。时间复杂度 $\mathcal O(n\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> pos[N];</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> sum1[N],sum2[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	sum1[p<span class="number">-1</span>]=sum2[q<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=q;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum1[i]=a[i]&gt;b[mid];</span><br><span class="line">		sum2[i]=a[i]&lt;b[mid];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p+<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">		sum1[i]+=sum1[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=q<span class="number">-1</span>;i&gt;=p;i--)</span><br><span class="line">		sum2[i]+=sum2[i+<span class="number">1</span>];</span><br><span class="line">	pos[mid]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=q;i++)</span><br><span class="line">		<span class="keyword">if</span>(!pos[mid]||sum1[i<span class="number">-1</span>]+sum2[i]&lt;sum1[pos[mid]<span class="number">-1</span>]+sum2[pos[mid]])</span><br><span class="line">			pos[mid]=i;</span><br><span class="line">	<span class="built_in">solve</span>(p,pos[mid],l,mid<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">solve</span>(pos[mid],q,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) </span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge</span>(a,l,mid);</span><br><span class="line">    <span class="built_in">merge</span>(a,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>,k=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">        &#123;</span><br><span class="line">        	h[k]=a[i];</span><br><span class="line">			k++;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">            h[k]=a[j];</span><br><span class="line">			k++;</span><br><span class="line">			j++;</span><br><span class="line">            ans+=mid-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">        h[k]=a[i],k++,i++;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">        h[k]=a[j],k++,j++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        a[i]=h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(n,m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">read</span>(a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			<span class="built_in">read</span>(b[i]);</span><br><span class="line">		<span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m);</span><br><span class="line">		<span class="built_in">solve</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">		<span class="type">int</span> p=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;=m&amp;&amp;pos[j]==i)</span><br><span class="line">				c[++p]=b[j++];</span><br><span class="line">            c[++p]=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">merge</span>(c,<span class="number">1</span>,n+m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="4-P4516-JSOI2018-潜入行动"><a href="#4-P4516-JSOI2018-潜入行动" class="headerlink" title="4.P4516 [JSOI2018] 潜入行动"></a>4.<a href="https://www.luogu.com.cn/problem/P4516">P4516 [JSOI2018] 潜入行动</a></h4><p>树形背包裸题，状态和转移方程稍复杂，还需要滚动数组优化一下。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,K=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> si[N];</span><br><span class="line"><span class="type">int</span> f[N][K][<span class="number">2</span>][<span class="number">2</span>],g[K][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    si[x]=<span class="number">1</span>;</span><br><span class="line">    f[x][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=f[x][<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(fa==y)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(y,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(si[x],m);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[j][<span class="number">0</span>][<span class="number">0</span>]=f[x][j][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            g[j][<span class="number">0</span>][<span class="number">1</span>]=f[x][j][<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">            g[j][<span class="number">1</span>][<span class="number">0</span>]=f[x][j][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            g[j][<span class="number">1</span>][<span class="number">1</span>]=f[x][j][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            f[x][j][<span class="number">0</span>][<span class="number">0</span>]=f[x][j][<span class="number">0</span>][<span class="number">1</span>]=f[x][j][<span class="number">1</span>][<span class="number">0</span>]=f[x][j][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(si[x],m);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=si[y]&amp;&amp;j+k&lt;=m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[x][j+k][<span class="number">0</span>][<span class="number">0</span>]=(f[x][j+k][<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1ll</span>*g[j][<span class="number">0</span>][<span class="number">0</span>]*f[y][k][<span class="number">0</span>][<span class="number">1</span>]%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">0</span>][<span class="number">1</span>]=(f[x][j+k][<span class="number">0</span>][<span class="number">1</span>]+<span class="number">1ll</span>*g[j][<span class="number">0</span>][<span class="number">1</span>]*(f[y][k][<span class="number">0</span>][<span class="number">1</span>]+f[y][k][<span class="number">1</span>][<span class="number">1</span>])%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">0</span>][<span class="number">1</span>]=(f[x][j+k][<span class="number">0</span>][<span class="number">1</span>]+<span class="number">1ll</span>*g[j][<span class="number">0</span>][<span class="number">0</span>]*f[y][k][<span class="number">1</span>][<span class="number">1</span>]%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">1</span>][<span class="number">0</span>]=(f[x][j+k][<span class="number">1</span>][<span class="number">0</span>]+<span class="number">1ll</span>*g[j][<span class="number">1</span>][<span class="number">0</span>]*(f[y][k][<span class="number">0</span>][<span class="number">0</span>]+f[y][k][<span class="number">0</span>][<span class="number">1</span>])%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">1</span>][<span class="number">1</span>]=(f[x][j+k][<span class="number">1</span>][<span class="number">1</span>]+<span class="number">1ll</span>*g[j][<span class="number">1</span>][<span class="number">0</span>]*(f[y][k][<span class="number">1</span>][<span class="number">0</span>]+f[y][k][<span class="number">1</span>][<span class="number">1</span>])%mod)%mod;</span><br><span class="line">                f[x][j+k][<span class="number">1</span>][<span class="number">1</span>]=(f[x][j+k][<span class="number">1</span>][<span class="number">1</span>]+<span class="number">1ll</span>*g[j][<span class="number">1</span>][<span class="number">1</span>]*(<span class="number">1ll</span>*f[y][k][<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1ll</span>*f[y][k][<span class="number">0</span>][<span class="number">1</span>]+<span class="number">1ll</span>*f[y][k][<span class="number">1</span>][<span class="number">0</span>]+<span class="number">1ll</span>*f[y][k][<span class="number">1</span>][<span class="number">1</span>])%mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        si[x]+=si[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(f[<span class="number">1</span>][m][<span class="number">0</span>][<span class="number">1</span>]+f[<span class="number">1</span>][m][<span class="number">1</span>][<span class="number">1</span>])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="5-CF1630D-Flipping-Range"><a href="#5-CF1630D-Flipping-Range" class="headerlink" title="5.CF1630D Flipping Range"></a>5.<a href="https://www.luogu.com.cn/problem/CF1630D">CF1630D Flipping Range</a></h4><p>题意简述：给你一个长度为 n 的数组 $A$ 和长度为 $m$ 的数组 $B$，你每次可以选择 $B$ 中的一个数 $b_i$，然后将 $A$ 中一段长度为 $b_i$ 的区间取反，求可能的 $\max{\sum_{i=1}^{n}a_i}$。</p>
<p>首先要转化问题，注意 $B$ 中的一个数 $b_i$ 可以重复选择，那么我们每一次都可以取反长度为 $|b_i-b_j|$ 的区间，容易由<strong>更相减损术</strong>转化为我们每次都选取一段长度为 $\gcd_{i=1}^{m}b_i$ 的区间。</p>
<p>那么问题就很简单了，用 $DP$ 将模 $\gcd_{i=1}^{m}b_i$ 的余数和其奇偶性记录进状态就可以很好转移了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m,a[N],b[N];</span><br><span class="line">ll f[N][<span class="number">2</span>],ans1,ans2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x==<span class="number">0</span>?y:<span class="built_in">gcd</span>(y%x,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(n,m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">read</span>(a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			<span class="built_in">read</span>(b[i]);</span><br><span class="line">		<span class="type">int</span> g=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			g=<span class="built_in">gcd</span>(g,b[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)</span><br><span class="line">			f[i][<span class="number">0</span>]=<span class="number">0</span>,f[i][<span class="number">1</span>]=-INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ll res1=f[i%g][<span class="number">0</span>],res2=f[i%g][<span class="number">1</span>];</span><br><span class="line">			f[i%g][<span class="number">0</span>]=<span class="built_in">max</span>(res1+a[i],res2-a[i]);</span><br><span class="line">			f[i%g][<span class="number">1</span>]=<span class="built_in">max</span>(res1-a[i],res2+a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		ans1=ans2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)</span><br><span class="line">			ans1+=f[i][<span class="number">0</span>],ans2+=f[i][<span class="number">1</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">max</span>(ans1,ans2));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="6-P2150-NOI2015-寿司晚宴"><a href="#6-P2150-NOI2015-寿司晚宴" class="headerlink" title="6.P2150 [NOI2015] 寿司晚宴"></a>6.<a href="https://www.luogu.com.cn/problem/P2150">P2150 [NOI2015] 寿司晚宴</a></h4><p>容易想到以所选数的质因数的集合为状态进行 DP，设 $f_{s_1,s_2}$ 为小 G 和小 W 所选数的质因数的集合分别为 $s_1,s_2$ 的方案数。但 $\le 500$ 的质因数太多了，无法全部记录。</p>
<p>注意一个关键点，$\le 500$ 的数最多有一个 $p\ge 23$ 的质因数，我们可以按照质因数 $p$ 对所有数进行分类，那么我们只需要考虑 $p$ 对同类数之间的限制即可。</p>
<p>考虑 $f1_{s_1,s_2},f2_{s_1,s_2}$，分别为小 G 和 小 W 选 $p$ 的方案数，而 $f’_{s_1,s_2}=f1_{s_1,s_2}+f2_{s_1,s_2}-f_{s_1,s_2}$。</p>
<p>于是我们只需要记录前面 $8$ 个质数即可。DP 过程中枚举 $s_2$ 时枚举 $s_1$ 补集的子集即可，时间复杂度为 $\mathcal O(3^8n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,S=(<span class="number">1</span>&lt;&lt;<span class="number">8</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Num</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s,d;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Num &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d&lt;t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line"><span class="type">int</span> cnt,prime[N],vis[N];</span><br><span class="line"><span class="type">int</span> f[N][N],f1[N][N],f2[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            prime[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j]))<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>&amp;&amp;x&gt;=prime[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(x%prime[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            a[now].s|=<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(x&amp;&amp;!(x%prime[i]))x/=prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[now].d=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,p);</span><br><span class="line">    <span class="built_in">prework</span>(N<span class="number">-10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">get</span>(i);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">2</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].d==<span class="number">1</span>||a[i].d!=a[i<span class="number">-1</span>].d)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(f1,f,<span class="built_in">sizeof</span>(f));</span><br><span class="line">            <span class="built_in">memcpy</span>(f2,f,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s1=S;~s1;s1--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c=S^s1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> s2=c;s2;s2=(s2<span class="number">-1</span>)&amp;c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(a[i].s&amp;s2))f1[s1|a[i].s][s2]=(f1[s1|a[i].s][s2]+f1[s1][s2])%p;</span><br><span class="line">                <span class="keyword">if</span>(!(a[i].s&amp;s1))f2[s1][s2|a[i].s]=(f2[s1][s2|a[i].s]+f2[s1][s2])%p;</span><br><span class="line">            &#125;</span><br><span class="line">            f1[s1|a[i].s][<span class="number">0</span>]=(f1[s1|a[i].s][<span class="number">0</span>]+f1[s1][<span class="number">0</span>])%p;</span><br><span class="line">            <span class="keyword">if</span>(!(a[i].s&amp;s1))f2[s1][a[i].s]=(f2[s1][a[i].s]+f2[s1][<span class="number">0</span>])%p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i].d==<span class="number">1</span>||a[i].d!=a[i+<span class="number">1</span>].d)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> s1=<span class="number">0</span>;s1&lt;=S;s1++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> c=S^s1;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> s2=c;s2;s2=(s2<span class="number">-1</span>)&amp;c)</span><br><span class="line">                    f[s1][s2]=((f1[s1][s2]+f2[s1][s2])%p-f[s1][s2]+p)%p;</span><br><span class="line">                f[s1][<span class="number">0</span>]=((f1[s1][<span class="number">0</span>]+f2[s1][<span class="number">0</span>])%p-f[s1][<span class="number">0</span>]+p)%p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s1=<span class="number">0</span>;s1&lt;=S;s1++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c=S^s1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s2=c;s2;s2=(s2<span class="number">-1</span>)&amp;c)</span><br><span class="line">            ans=(ans+f[s1][s2])%p;</span><br><span class="line">        ans=(ans+f[s1][<span class="number">0</span>])%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>​    </p>
<h4 id="7-CF777E-Hanoi-Factory"><a href="#7-CF777E-Hanoi-Factory" class="headerlink" title="7.CF777E Hanoi Factory"></a>7.<a href="https://www.luogu.com.cn/problem/CF777E">CF777E Hanoi Factory</a></h4><p>比较简单的题目，首先以<strong>外径</strong>为关键字进行排序，保证遍历时外径是有序的。再维护一个栈，直接模拟题意，当栈顶元素的内径 $\ge$ 当前元素的外径，将栈顶元素弹去。同时维护答案即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ring</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    ll h;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(ring x,ring y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x.b!=y.b)<span class="keyword">return</span> x.b&gt;y.b;</span><br><span class="line">        <span class="keyword">return</span> x.a&gt;y.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;k[N],sta[N];</span><br><span class="line"><span class="type">int</span> n,top;</span><br><span class="line">ll f[N],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(k[i].a,k[i].b,k[i].h);</span><br><span class="line">    <span class="built_in">sort</span>(k+<span class="number">1</span>,k+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;k[i].b&lt;=sta[top].a)top--;</span><br><span class="line">        sta[++top]=k[i];</span><br><span class="line">        sta[top].h+=sta[top<span class="number">-1</span>].h;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,sta[top].h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="8-CF475D-CGCDSSQ"><a href="#8-CF475D-CGCDSSQ" class="headerlink" title="8.CF475D CGCDSSQ"></a>8.<a href="https://www.luogu.com.cn/problem/CF475D">CF475D CGCDSSQ</a></h4><p>在线算法不容易实现，我们直接考虑对全局暴力求出所有公约数，用一个 $\text{map}$ 存储答案。只需要考虑优化。</p>
<p>比较简单地有：若 $l\le r&lt;n$，则有 $ \gcd_{i=l}^{r}\le \gcd_{i=l}^{r+1}$。这就意味当左端点固定时，随着右端点递增，$\gcd$ 单调递减。并且 $\gcd$ 种类数是 $\mathcal O(\log V)$ 的</p>
<p>这样就很简单了，我们只需要枚举左端点，对右端点进行二分或者倍增就可以了。ST 表查询 $\gcd$ 的时间是 $\mathcal O(\log V)$，其中 $V$ 为值域。</p>
<p>时间复杂度 $\mathcal O(n\log n\log^2 V+q\log n)$：</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> Log[N],st[N][<span class="number">25</span>];</span><br><span class="line">map&lt;<span class="type">int</span>,ll&gt;ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x?<span class="built_in">gcd</span>(y%x,x):y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        st[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=Log[n];j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">            st[i][j]=<span class="built_in">gcd</span>(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=Log[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len,<span class="type">int</span> g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=x+len,r=n,res=x;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    	<span class="type">int</span> now=<span class="built_in">query</span>(x,mid);</span><br><span class="line">    	<span class="keyword">if</span>(now==g)res=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res-x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=x,r=x;</span><br><span class="line">    <span class="keyword">while</span>(r&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> g=<span class="built_in">query</span>(x,l);</span><br><span class="line">        r=x+<span class="built_in">find</span>(x,l-x,g);</span><br><span class="line">        ans[g]+=r-l;</span><br><span class="line">        l=r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        Log[i]=Log[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="9-P3411-序列变换"><a href="#9-P3411-序列变换" class="headerlink" title="9.P3411 序列变换"></a>9.<a href="https://www.luogu.com.cn/problem/P3411">P3411 序列变换</a></h4><p>学会转化问题，与其考虑变，我们不如将目光放到哪些不变上。手动模拟，我们发现一个长度为 $n$ 的序列无论如何只需要最多 $n-1$ 次操作，我们考虑最优情况哪些数不会被操作。</p>
<p>这下就更简单了，我们只需要找到一条<strong>带重复元素的最长无缝上升子序列</strong>，设其长度为 $len$，因为穿插在这个子序列中的数总是能够被按一定顺序移到两端去从而变得有序。答案就是 $n-len$ 。</p>
<p>然而至今笔者未在网上找到靠谱的<strong>带重复元素的最长无缝上升子序列</strong>解法，现有有两组hack：</p>
<p><code>input1:
4
3 1 2 3
output1:
1</code><br><code>input2:
6
4 2 3 4 1 5
output2:
3</code></p>
<p>希望读者有新的思考，随时可以联系笔者。</p>
<details class="failure"><summary><i class="fa fa-times fa-fw"></i>Code1 100pts<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">int</span> a[N],b[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),b[i]=a[i];</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+len,a[i])-b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[a[i]]=(f[a[i]]?f[a[i]]:f[a[i]<span class="number">-1</span>])+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<details class="failure"><summary><i class="fa fa-times fa-fw"></i>Code2 90pts<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">int</span> a[N],b[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),b[i]=a[i];</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+len,a[i])-b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[a[i]]=<span class="built_in">max</span>(f[a[i]],f[a[i]<span class="number">-1</span>])+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="10-P1730-最小密度路径"><a href="#10-P1730-最小密度路径" class="headerlink" title="10.P1730 最小密度路径"></a>10.<a href="https://www.luogu.com.cn/problem/P1730">P1730 最小密度路径</a></h4><p>注意到关键：<strong>有向无环图</strong>。这意味一条路径最多只会经过 $n-1$ 次。再者 $1\le n\le 50$，我们考虑直接跑一遍 Floyd，并且将走过的边数记录进状态就可以实现类似于<strong>背包</strong>的转移。稍想便知，我们并不需要枚举边的决策点，有状态转移方程：</p>
<p>$f_{t,i,j}=\min f_{t-1,i,j}+f_{1,k,j}$</p>
<p>最直接遍历一遍 $f$ 数组计算出所有答案即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50</span>+<span class="number">10</span>,M=<span class="number">1e3</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> f[N][N][N];</span><br><span class="line"><span class="type">double</span> ans[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            ans[i][j]=<span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        f[<span class="number">1</span>][u][v]=<span class="built_in">min</span>(f[<span class="number">1</span>][u][v],w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">2</span>;t&lt;=n;t++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                    <span class="keyword">if</span>(k!=i&amp;&amp;k!=j&amp;&amp;i!=j)</span><br><span class="line">                        f[t][i][j]=<span class="built_in">min</span>(f[t][i][j],f[t<span class="number">-1</span>][i][k]+f[<span class="number">1</span>][k][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n;t++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(f[t][i][j]&lt;INF)</span><br><span class="line">                    ans[i][j]=<span class="built_in">min</span>(ans[i][j],f[t][i][j]*<span class="number">1.0</span>/t);</span><br><span class="line">    <span class="built_in">read</span>(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(ans[x][y]&lt;INF)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,ans[x][y]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;OMG!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="11-P1485-火枪打怪"><a href="#11-P1485-火枪打怪" class="headerlink" title="11.P1485 火枪打怪"></a>11.<a href="https://www.luogu.com.cn/problem/P1485">P1485 火枪打怪</a></h4><p>很明显的二分，直接选择二分 $p$，重点在于如何写 $check(p)$ 函数。</p>
<p>首先考虑暴力，这样 $check(p)$ 时间复杂度是 $O(n^2)$ 的，尝试推一下性质。</p>
<p>很容易得到：</p>
<p>$\sum p-(i-j)^2=\sum p-\sum i^2+2\sum i\cdot j-\sum j^2=sum\cdot p-sum_{i^2}+2\cdot sum_i\cdot j-sum\cdot j$ </p>
<p>我们只需要维护，$sum,sum_i,sum_{i^2}$ 就可以直接计算出前面对当前的影响。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll a[N],c[N],h[N];</span><br><span class="line">ll l,r=<span class="number">1e12</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>,len=<span class="built_in">sqrt</span>(p),s=<span class="number">0</span>,si=<span class="number">0</span>,si2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        c[i]=a[i],h[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i]-=s*p-si2+<span class="number">2</span>*si*i-s*i*i;</span><br><span class="line">        <span class="keyword">if</span>(c[i]&gt;=<span class="number">0</span>)</span><br><span class="line">            h[i]=c[i]/p+<span class="number">1</span>,cnt+=h[i];</span><br><span class="line">        s+=h[i];</span><br><span class="line">        si+=h[i]*i;</span><br><span class="line">        si2+=h[i]*i*i;</span><br><span class="line">        <span class="keyword">if</span>(i-len&gt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s-=h[i-len];</span><br><span class="line">            si-=h[i-len]*(i-len);</span><br><span class="line">            si2-=h[i-len]*(i-len)*(i-len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;k)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[n-i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="12-CF1000G-Two-Paths"><a href="#12-CF1000G-Two-Paths" class="headerlink" title="12.CF1000G Two-Paths "></a>12.<a href="https://www.luogu.com.cn/problem/CF1000G">CF1000G Two-Paths </a></h4><p>有难度的倍增题目，比较有趣。</p>
<p>首先用DP预处理出数组 $pr_x$ 为遍历节点 $x$ 的子树获得的最大权值。先考虑从节点向根走，尝试求出 $f_{x,i}$ 为从点 $x$ 出发走到它的第 $2^i$ 辈祖先。只不过不能想当然地进行转移，考虑一下容斥，得到：</p>
<p>$f_{x,i}=f_{x,i-1}+f_{fa_{x,i-1},i-1}-pr_{fa_{x,i-1}}$</p>
<p>同时需要注意 $f_{x,0}$ 的值，需要判断 $x$ 的父亲节点是否选取了 $x$ 作为答案。</p>
<p>我们接着就可以使用倍增向上跳并累加答案 $f_{x,i}-pr_x$。但需要注意的是，我们最后只是会跳到 $LCA$ 处，实际上从 $LCA$ 还可以往上跳继续寻找答案。为了累加这个答案，我们可以再用一个 $g_x$ 表示从 $x$ 向上走能够获得的最大权值，从 $x$ 的父节点就可以很好地转移。最后统计答案时加上 $g_{LCA}$ 就行了。记得最后加上原来端点的 $pr_x$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>,M=<span class="number">6e5</span>+<span class="number">10</span>,K=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q,rt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">ll pr[N],g[N];</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">30</span>],d[N];</span><br><span class="line">ll f[N][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr[x]+=a[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ver[i]==fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(ver[i],x);</span><br><span class="line">        pr[x]+=<span class="built_in">max</span>(<span class="number">0ll</span>,pr[ver[i]]<span class="number">-2</span>*e[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		f[x][i]=f[x][i<span class="number">-1</span>]+f[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>]-pr[fa[x][i<span class="number">-1</span>]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(d[ver[i]])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        d[ver[i]]=d[x]+<span class="number">1</span>;</span><br><span class="line">        fa[ver[i]][<span class="number">0</span>]=x;</span><br><span class="line">		f[ver[i]][<span class="number">0</span>]=pr[ver[i]]+pr[x]-e[i]-(pr[ver[i]]<span class="number">-2</span>*e[i]&gt;<span class="number">0</span>?pr[ver[i]]<span class="number">-2</span>*e[i]:<span class="number">0</span>);</span><br><span class="line">		g[ver[i]]=<span class="built_in">max</span>(<span class="number">0ll</span>,g[x]+f[ver[i]][<span class="number">0</span>]-e[i]-pr[ver[i]]);</span><br><span class="line">		<span class="built_in">dfs</span>(ver[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y])</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="type">int</span> u=x,v=y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(d[fa[x][i]]&gt;=d[y])</span><br><span class="line">        &#123;</span><br><span class="line">            res+=f[x][i]-pr[x];</span><br><span class="line">            x=fa[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y)</span><br><span class="line">        <span class="keyword">return</span> res+pr[u]+g[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=K;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            res+=f[x][i]-pr[x]+f[y][i]-pr[y];</span><br><span class="line">            x=fa[x][i],y=fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> lca=fa[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> res+f[x][<span class="number">0</span>]-pr[x]+f[y][<span class="number">0</span>]-pr[y]-pr[lca]+pr[u]+pr[v]+g[lca];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">        <span class="built_in">add</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(rt,<span class="number">0</span>);</span><br><span class="line">    d[rt]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="13-AT4837-ABC150E-Change-a-Little-Bit"><a href="#13-AT4837-ABC150E-Change-a-Little-Bit" class="headerlink" title="13.AT4837 [ABC150E] Change a Little Bit"></a>13.<a href="https://www.luogu.com.cn/problem/AT4837">AT4837 [ABC150E] Change a Little Bit</a></h4><p>推式子为主。</p>
<p>首先很明显应该贪心，先将 $C_i$ 进行排序。并很容易得出答案为：</p>
<p>$2^n\cdot (\sum_{i=1}^{n}2^{i-1}\cdot C_i\cdot \sum_{j=0}^{n-i}\begin{pmatrix} n-i\\ j\end{pmatrix}\cdot(j+1))$</p>
<p>对后面这一坨尝试进行变换：$\sum_{j=0}^{n-i} \begin{pmatrix} n-i \\ j \end{pmatrix} \cdot(j+1) = \sum_{j=0}^{n-i}\begin{pmatrix} n-i \\ j \end{pmatrix} \cdot j+2^{n-i}$</p>
<p>运用<strong>吸收恒等式</strong>：$\begin{pmatrix} i  \\ j \end{pmatrix}\cdot j = \begin{pmatrix} i-1 \\ j-1 \end{pmatrix} \cdot i$，对第一项进行变换：</p>
<p>$\sum_{j=0}^{n-i} \begin{pmatrix} n-i \\ j\end{pmatrix} \cdot j =  \sum_{j=0}^{n-i} \begin{pmatrix} n-i-1 \\ j-1 \end{pmatrix} \cdot (n-i) = (n-i) \cdot2^{n-i-1}$</p>
<p>所以得到最终式子：</p>
<p>$2^n\cdot (\sum_{i=1}^{n}2^{i-1} \cdot C_i \cdot ((n-i) \cdot 2^{n-i-1}+2^{n-i}))$</p>
<p>直接计算即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans,c[N],p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+n);</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=(p[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=(ans+p[i<span class="number">-1</span>]*c[i]%mod*((n-i)*p[n-i<span class="number">-1</span>]%mod+p[n-i]))%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans*p[n]%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="14-P4804-CCC-2016-生命中的圆"><a href="#14-P4804-CCC-2016-生命中的圆" class="headerlink" title="14.P4804 [CCC 2016]生命中的圆"></a>14.<a href="https://www.luogu.com.cn/problem/P4804">P4804 [CCC 2016]生命中的圆</a></h4><p>容易得到：$f_{i,j}=f_{i-1,x-1}⊕f_{i-1,j+1}$。</p>
<p>然后<del>稍加思索</del>，便得到：$f_{i,j}=f_{i-2^k,x-2^k}⊕f_{i-2^k,j+2^k}$。</p>
<p>然后就直接将 $T$ 按照二进制拆开计算就可以了，时间复杂度 $\mathcal O(n\log T)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,K=<span class="number">60</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll t;</span><br><span class="line"><span class="type">int</span> p,f[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;f[p][i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=K;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t&amp;(<span class="number">1ll</span>&lt;&lt;k))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=(<span class="number">1ll</span>&lt;&lt;k)%n,l=(n-r)%n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[p^<span class="number">1</span>][i]=f[p][l]^f[p][r];</span><br><span class="line">                <span class="keyword">if</span>(++l&gt;=n)l-=n;</span><br><span class="line">                <span class="keyword">if</span>(++r&gt;=n)r-=n;</span><br><span class="line">            &#125;</span><br><span class="line">            p^=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[p][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="15-P3097-USACO13DEC-Optimal-Milking-G"><a href="#15-P3097-USACO13DEC-Optimal-Milking-G" class="headerlink" title="15.P3097 [USACO13DEC]Optimal Milking G"></a>15.<a href="https://www.luogu.com.cn/problem/P3097">P3097 [USACO13DEC]Optimal Milking G</a></h4><p>单点修改求最大独立集。尝试使用线段树来维护，左右端点各自取或不取所得到的区间最大值就可以了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll v[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll a[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].v[<span class="number">0</span>][<span class="number">0</span>]=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    tr[x].v[<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    tr[x].v[<span class="number">0</span>][<span class="number">1</span>]=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>],<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>],tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">    tr[x].v[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>],<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>],tr[x&lt;&lt;<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].v[<span class="number">1</span>][<span class="number">1</span>]=a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l==tr[x].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].v[<span class="number">1</span>][<span class="number">1</span>]=k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,pos,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        ans+=<span class="built_in">max</span>(<span class="built_in">max</span>(tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">0</span>],tr[<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">1</span>]),<span class="built_in">max</span>(tr[<span class="number">1</span>].v[<span class="number">1</span>][<span class="number">0</span>],tr[<span class="number">1</span>].v[<span class="number">0</span>][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="16-P6845-CEOI2019-Dynamic-Diameter"><a href="#16-P6845-CEOI2019-Dynamic-Diameter" class="headerlink" title="16.P6845 [CEOI2019] Dynamic Diameter"></a>16.<a href="https://www.luogu.com.cn/problem/P6845">P6845 [CEOI2019] Dynamic Diameter</a></h4><p>单边修改求树上直径。很厉害的一道题，一开始根本没有思路，看题解也想了一会儿才弄懂。</p>
<p>先考虑把树上问题向区间问题转换。还记得我们如何将 LCA 问题进行转化的吗？对，这道题我们就是需要尝试用<strong>欧拉序</strong>进行转换。我们需要求的：$\max_{l,r\in [1,N]} {dep_l+dep_r-2*dep_{lca(l,r)}}$ </p>
<p>就变为了：$\max_{1\le l \le r \le 2N-1}\{dep_l+dep_r- 2\times\min_{l\le mid\le r}{dep_{mid}}$。</p>
<p>考虑怎么维护这个东西，考虑分多个值：</p>
<p>1.区间深度最大值（作为 $dep_l$ 或 $dep_r$）。</p>
<p>2.区间深度最小值（作为 $dep_{lca}$）。</p>
<p>3.左端点与 LCA 合并的最大值，和右端点与 LCA 合并的最大值。</p>
<p>4.区间内直径最大值。</p>
<p>而修改操作就是欧拉序上的一段区间修改，这道题就完美解决了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q,rt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],ne[M];</span><br><span class="line"><span class="type">int</span> cnt,num[N&lt;&lt;<span class="number">1</span>],in[N],out[N],pos[N];</span><br><span class="line">ll w,e[M],val[N],d[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll maxd,mind,lm,mr,lmr;</span><br><span class="line">    ll tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num[in[x]=++cnt]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ver[i]==fa)<span class="keyword">continue</span>;</span><br><span class="line">        d[ver[i]]=d[x]+e[i];</span><br><span class="line">        pos[i+<span class="number">1</span>&gt;&gt;<span class="number">1</span>]=ver[i];</span><br><span class="line">        <span class="built_in">dfs</span>(ver[i],x);</span><br><span class="line">        num[++cnt]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    out[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].maxd=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].maxd,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].maxd);</span><br><span class="line">    tr[x].mind=<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].mind,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mind);</span><br><span class="line">    tr[x].lm=<span class="built_in">max</span>(<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].lm,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lm),tr[x&lt;&lt;<span class="number">1</span>].maxd+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mind);</span><br><span class="line">    tr[x].mr=<span class="built_in">max</span>(<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].mr,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mr),tr[x&lt;&lt;<span class="number">1</span>].mind+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].maxd);</span><br><span class="line">    tr[x].lmr=<span class="built_in">max</span>(<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].lmr,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lmr),<span class="built_in">max</span>(tr[x&lt;&lt;<span class="number">1</span>].lm+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].maxd,tr[x&lt;&lt;<span class="number">1</span>].maxd+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].maxd+=k;</span><br><span class="line">    tr[x].mind-=<span class="number">2</span>*k;</span><br><span class="line">    tr[x].lm-=k;</span><br><span class="line">    tr[x].mr-=k;</span><br><span class="line">    tr[x].tag+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].maxd=d[num[l]];</span><br><span class="line">        tr[x].mind=<span class="number">-2</span>*d[num[l]];</span><br><span class="line">        tr[x].lm=tr[x].mr=-d[num[l]];</span><br><span class="line">        tr[x].lmr=<span class="number">0</span>;</span><br><span class="line">        tr[x].tag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].tag)</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q,w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v,val[i]);</span><br><span class="line">        <span class="built_in">add</span>(u,v,val[i]);</span><br><span class="line">        <span class="built_in">add</span>(v,u,val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        ll k;</span><br><span class="line">        <span class="built_in">read</span>(x,k);</span><br><span class="line">        x=(x+ans%(n<span class="number">-1</span>))%(n<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">        k=(k+ans%w)%w;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,in[pos[x]],out[pos[x]],k-val[x]);</span><br><span class="line">        val[x]=k;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans=tr[<span class="number">1</span>].lmr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="17-AT4835-ABC141F-Xor-Sum-3"><a href="#17-AT4835-ABC141F-Xor-Sum-3" class="headerlink" title="17.AT4835 [ABC141F] Xor Sum 3"></a>17.<a href="https://www.luogu.com.cn/problem/AT4835">AT4835 [ABC141F] Xor Sum 3</a></h4><p>按照每一位来考虑，设 $sum$ 为其所有数的异或和，其中 $sum_i$ 表示其二进制下的第 $i$ 位，考虑其奇偶性，有：</p>
<p>1.$sum_i$ 为 $1$，则分为两组的异或和的贡献一定为 $2^i$。</p>
<p>2.$sum_i$ 为 $0$ ，则分为两组的异或和第 $i$ 位一定相同。</p>
<p>第一种情况可以直接累加上答案，于是我们只需要考虑第二种情况就可以了。由第二条性质可以得到：仅考虑 $sum_i=0$ 的情况下,分为两组的异或和一定是相等的，于是我们直接用<strong>线性基</strong>算之后将答案乘二即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll sum,ans,res,a[N],p[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(x&gt;&gt;i&amp;<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p[i])</span><br><span class="line">        &#123;</span><br><span class="line">            p[i]=x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x^=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),sum^=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=<span class="number">1ll</span>&lt;&lt;i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(a[j]&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                    a[j]^=<span class="number">1ll</span>&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        res=<span class="built_in">max</span>(res,res^p[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans+<span class="number">2ll</span>*res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="18-CF460C-Present"><a href="#18-CF460C-Present" class="headerlink" title="18.CF460C Present"></a>18.<a href="https://www.luogu.com.cn/problem/CF460C">CF460C Present</a></h4><p>最小值最大，很明显考虑二分。$check(i)$ 用线段树修改查询就可以了。</p>
<p>看题解后，发现还是做复杂了，可以直接差分，做到 $\mathcal O(n)$  $check(i)$ 。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll val,tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,w;</span><br><span class="line">ll a[N];</span><br><span class="line">ll l=INF,r;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x&lt;&lt;<span class="number">1</span>].tag+=tr[x].tag;</span><br><span class="line">    tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tag+=tr[x].tag;</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].val=a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].tag+=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].tag)<span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l==tr[x].r)</span><br><span class="line">        <span class="keyword">return</span> tr[x].val+tr[x].tag;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].tag)</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>,pos);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(n&lt;&lt;<span class="number">2</span>);i++)</span><br><span class="line">        tr[i].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res=<span class="built_in">query</span>(<span class="number">1</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(res&lt;x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,i,i+w<span class="number">-1</span>,x-res);</span><br><span class="line">            cnt+=x-res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m,w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),l=<span class="built_in">min</span>(l,a[i]),r+=a[i];</span><br><span class="line">    r=(r+<span class="number">1ll</span>*m*w)/n;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    ll ans=l;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">            l=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="19-CF282E-Sausage-Maximization"><a href="#19-CF282E-Sausage-Maximization" class="headerlink" title="19.CF282E Sausage Maximization"></a>19.<a href="https://www.luogu.com.cn/problem/CF282E">CF282E Sausage Maximization</a></h4><p>直接将所有后缀异或和插入进 <strong>01Trie</strong>，再查询每个前缀异或和所能得到最大值就可以了。</p>
<p>还有 <strong>01Trie</strong> 记得将空间开大。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,cnt,t[N&lt;&lt;<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line">ll a[N],ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">63</span>;~i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=(x&gt;&gt;i&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!t[p][num])</span><br><span class="line">            t[p][num]=++cnt;</span><br><span class="line">        p=t[p][num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">63</span>;~i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=(x&gt;&gt;i&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(t[p][num^<span class="number">1</span>])</span><br><span class="line">            sum+=<span class="number">1ll</span>&lt;&lt;i,p=t[p][num^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> p=t[p][num];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        res^=a[i];</span><br><span class="line">        <span class="built_in">insert</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res^=a[i];</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="20-P4068-SDOI2016-数字配对"><a href="#20-P4068-SDOI2016-数字配对" class="headerlink" title="20.P4068 [SDOI2016]数字配对"></a>20.<a href="https://www.luogu.com.cn/problem/P4068">P4068 [SDOI2016]数字配对</a></h4><p>因为每次我们需要贪心地考虑选择获得价值<strong>最大</strong>的数字进行 配对，考虑使用<strong>费用流</strong>，我们来看看怎么建模。</p>
<p>一定要想到将其转化为<strong>二分图</strong>，它是我们最好解决的了。我们对每个数进行质因数分解，将 $i$ 其分解成 $cnt_i$ 个质因数。再考虑将这些点其按照 $cnt_i$ 的<strong>奇偶性</strong>分为<strong>左部</strong>和<strong>右部</strong>的点，再将能够配对的点连起来，剩下的建图就很显然了。</p>
<p>注意这里我们需要写的是<strong>最大费用最大流</strong>。但又有一些不一样，我们只有在<strong>费用</strong>大于0的情况下才能继续继续增广，改一下就好了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">4e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,s,t,maxflow;</span><br><span class="line"><span class="type">int</span> a[N],b[N],cnt[N];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,head[N],ver[M],e[M],ne[M];</span><br><span class="line"><span class="type">int</span> incf[N],pre[N],vis[N];</span><br><span class="line">ll maxcost,c[N],cost[M],d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    e[tot]=w;</span><br><span class="line">    cost[tot]=c;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add_edge</span>(u,v,w,c);</span><br><span class="line">    <span class="built_in">add_edge</span>(v,u,<span class="number">0</span>,-c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t;i++)</span><br><span class="line">        d[i]=<span class="number">-1e18</span>,vis[i]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    incf[s]=INF;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!e[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> y=ver[i];</span><br><span class="line">            <span class="keyword">if</span>(d[y]&lt;d[x]+cost[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[y]=d[x]+cost[i];</span><br><span class="line">                incf[y]=<span class="built_in">min</span>(incf[x],e[i]);</span><br><span class="line">                pre[y]=i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y])</span><br><span class="line">                    vis[y]=<span class="number">1</span>,q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[t]&gt;<span class="number">-1e18</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll now=d[t]*incf[t];</span><br><span class="line">    <span class="keyword">if</span>(maxcost+now&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        maxflow+=maxcost/(-d[t]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxcost+=now;</span><br><span class="line">    maxflow+=incf[t];</span><br><span class="line">    <span class="type">int</span> x=t;</span><br><span class="line">    <span class="keyword">while</span>(x!=s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i=pre[x];</span><br><span class="line">        e[i]-=incf[t];</span><br><span class="line">        e[i^<span class="number">1</span>]+=incf[t];</span><br><span class="line">        x=ver[i^<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!(x%i))</span><br><span class="line">            x/=i,res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    s=n+<span class="number">1</span>,t=s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),cnt[i]=<span class="built_in">divide</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(b[i]);</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]&amp;<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">add</span>(s,i,b[i],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(i,t,b[i],<span class="number">0</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((a[i]%a[j]==<span class="number">0</span>&amp;&amp;cnt[i]==cnt[j]+<span class="number">1</span>)||(a[j]%a[i]==<span class="number">0</span>&amp;&amp;cnt[j]==cnt[i]+<span class="number">1</span>))</span><br><span class="line">                    <span class="built_in">add</span>(i,j,INF,<span class="number">1ll</span>*c[i]*c[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA</span>()&amp;&amp;<span class="built_in">update</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="21-CF442C-Artem-and-Array"><a href="#21-CF442C-Artem-and-Array" class="headerlink" title="21.CF442C Artem and Array"></a>21.<a href="https://www.luogu.com.cn/problem/CF442C">CF442C Artem and Array</a></h4><p>第一眼是一个<strong>区间DP</strong>，但是数据范围很明显不能让我们通过，我们没法DP直接考虑<strong>贪心</strong>。</p>
<p>很明显，若 $a_i&lt;a_{i-1}$ 且 $a_i&lt;a_{i+1}$ ，我们一定会将 $a_i$ 删去。</p>
<p>我们直接将其放入一个<strong>单调栈</strong>中进行维护并统计，最后得到的序列一定是<strong>单峰</strong>的。然后我们直接在剩下的 $m$ 个数中取最小的 $m-2$ 个就可以得到答案（因为最大的两个数不可能被取到）。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> top,sta[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(top&gt;=<span class="number">2</span>&amp;&amp;sta[top]&lt;=sta[top<span class="number">-1</span>]&amp;&amp;sta[top]&lt;=x)</span><br><span class="line">            ans+=<span class="built_in">min</span>(sta[top<span class="number">-1</span>],x),top--;</span><br><span class="line">        sta[++top]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sta+<span class="number">1</span>,sta+<span class="number">1</span>+top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top<span class="number">-2</span>;i++)</span><br><span class="line">        ans+=sta[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="22-AT4434-ARC103D-Distance-Sums"><a href="#22-AT4434-ARC103D-Distance-Sums" class="headerlink" title="22.AT4434 [ARC103D] Distance Sums"></a>22.<a href="https://www.luogu.com.cn/problem/AT4434">AT4434 [ARC103D] Distance Sums</a></h4><p>比较清新的构造题（？）。</p>
<p>我们尝试从每个点的 $D_i$ 之间的关系入手。很明显 $D_i$ 值最大的节点必定为<strong>叶子</strong>，$D_i$ 值最小的节点必定为<strong>树的重心</strong>（<del>可似乎没什么用</del>），还记得之前的<strong>换根DP</strong>吗？若 $v$ 为 $u$ 的子节点，我们很明显有：$D_v=D_u-2\times size_v+n$。变换一下得到 $D_u=D_v+2\times size_v-n$。我们把两者结合一下，尝试用<strong>叶子节点</strong>逐渐构造其祖先。我们先将其排序，从 $D_i$ 值最大的开始处理，大致分为这几步：</p>
<p>1、计算用当前节点计算父节点的 $D$ 值。 2、父节点的 $D$ 值在给定的 $D_i$ 中进行二分查找。找到了则新加一条边计入答案，并且计算父节点的 $size_u$；若未找到直接输出 $-1$ 。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    ll d;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node x,<span class="type">const</span> Node y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.d&lt;y.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n,si[N];</span><br><span class="line"><span class="type">int</span> cnt,u[N],v[N];</span><br><span class="line">ll dis;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i].d),a[i].id=i,si[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll d=a[i].d-n+(si[i]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> k=<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,(Node)&#123;<span class="number">0</span>,d&#125;)-a;</span><br><span class="line">        <span class="keyword">if</span>(a[k].d!=d)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        u[i]=a[i].id;</span><br><span class="line">        v[i]=a[k].id;</span><br><span class="line">        si[k]+=si[i];</span><br><span class="line">        dis+=si[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis!=a[<span class="number">1</span>].d)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,u[i],v[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="23-AT3621-ARC084B-Small-Multiple"><a href="#23-AT3621-ARC084B-Small-Multiple" class="headerlink" title="23.AT3621 [ARC084B] Small Multiple"></a>23.<a href="https://www.luogu.com.cn/problem/AT3621">AT3621 [ARC084B] Small Multiple</a></h4><p>直接枚举 $k$ 的正整数倍并不是明智之举，我们并不能找到较好的条件或方式来优化。我们考虑直接对其进行搜索，再判断其是否为 $k$ 的倍数。</p>
<p>在搜索过程中，很明显每次只有两种分支：$\times 10$ 或 $+1$。而其花费分别为 $0$ 和 $1$。很自然想到了双端队列 BFS。并且我们在搜索过程中直接对数进行取模就行。时间复杂度 $\mathcal O(k)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num,val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">bitset&lt;N&gt;vis;</span><br><span class="line">deque&lt;Node&gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push_back</span>((Node)&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>().num,y=q.<span class="built_in">front</span>().val;</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[x])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,y);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!vis[x*<span class="number">10</span>%k])</span><br><span class="line">            q.<span class="built_in">push_front</span>((Node)&#123;x*<span class="number">10</span>%k,y&#125;);</span><br><span class="line">        <span class="keyword">if</span>(!vis[(x+<span class="number">1</span>)%k])</span><br><span class="line">            q.<span class="built_in">push_back</span>((Node)&#123;(x+<span class="number">1</span>)%k,y+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(k);</span><br><span class="line">    <span class="built_in">BFS</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="24-AT5361-ABC158E-Divisible-Substring"><a href="#24-AT5361-ABC158E-Divisible-Substring" class="headerlink" title="24.AT5361 [ABC158E] Divisible Substring"></a>24.<a href="https://www.luogu.com.cn/problem/AT5361">AT5361 [ABC158E] Divisible Substring</a></h4><p>很明显应当从低位向高位考虑。每次从后面枚举，得到它后缀 $\mod p$ 的余数，很明显用该后缀减去之前所枚举的所有满足 $\mod p$ 的余数与其相等的后缀，所得到的字串一定被 $p$ 整除。这就很好办了，直接拿一个数组 $f_i$ 来存 $\mod p$ 的余数为 $i$ 的后缀数量，并且在枚举后缀时累加答案即可。</p>
<p>注意特判 $p=2,5$ 时的情况。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,M=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x);</span><br><span class="line">    <span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> sum,t=<span class="number">1</span>,a[N],f[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,a+i);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">2</span>||p==<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            ans+=a[i]%p?<span class="number">0</span>:i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;  </span><br><span class="line">        sum=(sum+t*a[i])%p;</span><br><span class="line">        ans+=f[sum];</span><br><span class="line">        f[sum]++;</span><br><span class="line">        t=t*<span class="number">10</span>%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="25-AT5242-ABC163E-Active-Infants"><a href="#25-AT5242-ABC163E-Active-Infants" class="headerlink" title="25.AT5242 [ABC163E] Active Infants"></a>25.<a href="https://www.luogu.com.cn/problem/AT5242">AT5242 [ABC163E] Active Infants</a></h4><p>开始本来以为是贪心，但发现并不能总是得到最优解。</p>
<p>有端联想，我们似乎可以直接上<strong>费用流</strong>，建图很显然，直接上<strong>最大费用最大流</strong>跑就可以了，确实可以过，但是效率并不高。</p>
<p>我们逐渐想到<strong>区间DP</strong>，但是直接搞的话 $\mathcal O(n^3)$ 的。我们每次只能考虑从端点转移。</p>
<p>于是我们尝试将<strong>区间DP</strong>与<strong>贪心</strong>结合，直觉告诉我们对于 $a_i$ 较大的，应当将它尽可能排在一段区间的两端，而非中间，这样产生的贡献才大。<del>然后乱搞</del>，现将数组按照 $a_i$ 为第一关键字排序，并记录其初始位置 $pos_i$。对于区间 $[l,r]$ 我们只需要将前 $r-l+1$ 个数填进去，这样来满足贪心即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val,pos;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> val&lt;t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i].val),a[i].pos=i;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        f[i][i]=<span class="number">1ll</span>*<span class="built_in">abs</span>(a[<span class="number">1</span>].pos-i)*a[<span class="number">1</span>].val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+i<span class="number">-1</span>&lt;=n;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=l+i<span class="number">-1</span>;</span><br><span class="line">            f[l][r]=<span class="built_in">max</span>(f[l+<span class="number">1</span>][r]+<span class="number">1ll</span>*<span class="built_in">abs</span>(a[i].pos-l)*a[i].val,f[l][r<span class="number">-1</span>]+<span class="number">1ll</span>*<span class="built_in">abs</span>(a[i].pos-r)*a[i].val);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="26-CF360B-Levko-and-Array"><a href="#26-CF360B-Levko-and-Array" class="headerlink" title="26.CF360B Levko and Array"></a>26.<a href="https://www.luogu.com.cn/problem/CF360B">CF360B Levko and Array</a></h4><p>使最大值最小，直接二分答案。我们需要研究 $check$ 函数应该如何写，设二分答案为 $lim$。</p>
<p>容易看出来是个 DP。可是直接 DP 明显很难做到 $\mathcal O(n^2)$。这就很难搞了。我们必须转换思路进行 DP。</p>
<p>经典正难则反，我们直接考虑计算 $[1,i]$ 中最多有多少个可以不变。可是似乎还是不太好转移。又该怎么办？只有当满足 $mid\times (i-j)\ge |a_i-a_j|$ 时，才可能有 $a_j$  不改变，通过改变 $(j,i]$ 得到合法方案。最后判断其中是否存在某个 $i$ 使得 $n-dp_i\le k$ 即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll a[N];</span><br><span class="line">ll l,r,f[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lim*(i-j)&gt;=<span class="built_in">abs</span>(a[i]-a[j]))</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[i]+k&gt;=n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        r=<span class="built_in">max</span>(r,<span class="built_in">abs</span>(a[i]-a[i+<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">            r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="27-CF573B-Bear-and-Blocks"><a href="#27-CF573B-Bear-and-Blocks" class="headerlink" title="27.CF573B Bear and Blocks"></a>27.<a href="https://www.luogu.com.cn/problem/CF573B">CF573B Bear and Blocks</a></h4><p>简单题，分别从左和从右模拟一次就可以了</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">int</span> h[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(h[i]);</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        f[i]=<span class="built_in">min</span>(f[i<span class="number">-1</span>]+<span class="number">1</span>,h[i]);</span><br><span class="line">    f[n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i;i--)</span><br><span class="line">        f[i]=<span class="built_in">min</span>(f[i+<span class="number">1</span>]+<span class="number">1</span>,f[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="28-AT2368-AGC013B-Hamiltonish-Path"><a href="#28-AT2368-AGC013B-Hamiltonish-Path" class="headerlink" title="28.AT2368 [AGC013B] Hamiltonish Path"></a>28.<a href="https://www.luogu.com.cn/problem/AT2368">AT2368 [AGC013B] Hamiltonish Path</a></h4><p>又是简单题，两遍 dfs 即可</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M&lt;&lt;<span class="number">1</span>],ne[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="type">int</span> cnt1,cnt2,ans1[N],ans2[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[ver[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[ver[i]]=<span class="number">1</span>;</span><br><span class="line">            ans1[++cnt1]=ver[i];</span><br><span class="line">            <span class="built_in">dfs1</span>(ver[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[ver[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[ver[i]]=<span class="number">1</span>;</span><br><span class="line">            ans2[++cnt2]=ver[i];</span><br><span class="line">            <span class="built_in">dfs2</span>(ver[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt1+cnt2+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cnt1;i;i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans1[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt2;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans2[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="29-AT923-IOI饅頭（IOI-Manju）"><a href="#29-AT923-IOI饅頭（IOI-Manju）" class="headerlink" title="29.AT923 IOI饅頭（IOI Manju）"></a>29.<a href="https://www.luogu.com.cn/problem/AT923">AT923 IOI饅頭（IOI Manju）</a></h4><p>还是简单题（大雾）。排序后直接 01背包 就可以了，然后注意细节。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>,M=<span class="number">1e4</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> c[N],e[N];</span><br><span class="line">ll p[M],f[M],ans;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(m,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">read</span>(p[i]);</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">        p[i]+=p[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(c[i],e[i]),c[i]=<span class="built_in">min</span>(c[i],m);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=c[i];j--)</span><br><span class="line">            f[j]=<span class="built_in">min</span>(f[j],f[j-c[i]]+e[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            f[j]=<span class="built_in">min</span>(f[j],f[j+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ll res=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,p[i]-f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="30-CF242E-XOR-on-Segment"><a href="#30-CF242E-XOR-on-Segment" class="headerlink" title="30.CF242E XOR on Segment"></a>30.<a href="https://www.luogu.com.cn/problem/CF242E">CF242E XOR on Segment</a></h4><p>小清新数据结构题，<del>比较水</del>。看到位运算很容易想到按位拆开来算，毕竟时限本来就很宽松（<del>以至于暴力用循环展开都可以卡过去</del>）。对于线段树中每个节点维护一个数组 $sum_i$，表示在此区间中有多少个数第 $i$ 位为 $1$。查询和修改大力维护就可以了。时间复杂度 $\mathcal O(m\log n\log V)$，其中 $V$ 为值域。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,K=<span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> sum[<span class="number">32</span>],tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K;i++)</span><br><span class="line">        tr[x].sum[i]=tr[x&lt;&lt;<span class="number">1</span>].sum[i]+tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].tag^=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K;i++)</span><br><span class="line">        <span class="keyword">if</span>(k&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">            tr[x].sum[i]=(tr[x].r-tr[x].l+<span class="number">1</span>-tr[x].sum[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[x].tag)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K;i++)</span><br><span class="line">            tr[x].sum[i]=(a[l]&gt;&gt;i&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=K;i++)</span><br><span class="line">            res+=<span class="number">1ll</span>*tr[x].sum[i]&lt;&lt;i;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)res+=<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)res+=<span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,l,r;</span><br><span class="line">        <span class="built_in">read</span>(op,l,r);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,l,r));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">read</span>(x);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="31-CF444A-DZY-Loves-Physics"><a href="#31-CF444A-DZY-Loves-Physics" class="headerlink" title="31.CF444A DZY Loves Physics"></a>31.<a href="https://www.luogu.com.cn/problem/CF444A">CF444A DZY Loves Physics</a></h4><p>第一眼觉得很神秘。但是我们容易发现最优方案似乎只有一条边。因为加入选取一条密度最大的边后，选取其它边只会是密度变小。</p>
<p><del>然后就过了？</del></p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">double</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">read</span>(u,v,w);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,(a[u]+a[v])*<span class="number">1.0</span>/w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="32-AT3559-Squeezing-Slimes"><a href="#32-AT3559-Squeezing-Slimes" class="headerlink" title="32.AT3559 Squeezing Slimes"></a>32.<a href="https://www.luogu.com.cn/problem/AT3559">AT3559 Squeezing Slimes</a></h4><p>考虑假如每次将一个数拆成两半，最少会进行 $\lceil\log_2 n\rceil$ 次。一个贪心的想法是一次尽可能选尽量多的数进行操作。我们只用考虑一段单峰区间的最大操作次数就行了。每次只需要记录上一个数的操作次数就行了。</p>
<p>但是这样似乎很容易被 Hack：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3 3 3</span><br><span class="line">out:2</span><br><span class="line">ans:3</span><br><span class="line">3 3 3 -&gt; 1 2 2 1 3 -&gt; 1 1 1 1 1 1 3 -&gt; 1 1 1 1 1 1 1 2 -&gt;</span><br><span class="line">1 1 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure>
<p>原因很显然，可能存在并不能将多个数一起操作的情况。但是没有关系，这种情况只可能存在于需要上取整的情况。对于此种情况，如果前面的操作次数比它小，我们就将其看做已经对其执行了一次操作，使它变成了较小的另一半。这样继续贪心就没有问题了。</p>
<p>这样看来似乎有一点奇怪，但仔细想想这确实是没有问题的。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,res,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,d;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        d=<span class="built_in">log2</span>(x);</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;d)&lt;x&amp;&amp;d&gt;=res)</span><br><span class="line">            d++;</span><br><span class="line">        <span class="keyword">if</span>(d&gt;res)ans+=d-res;</span><br><span class="line">        res=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="33-CF14D-Two-Paths"><a href="#33-CF14D-Two-Paths" class="headerlink" title="33.CF14D Two Paths"></a>33.<a href="https://www.luogu.com.cn/problem/CF14D">CF14D Two Paths</a></h4><p>水题，暴力断开一条边，然后对剩下的两棵树分别求直径。最后求最大值就可以。时间复杂度 $\mathcal O(n^2)$。</p>
<p>难道就这样吗？</p>
<p>不如看看加强版 <a href="https://www.luogu.com.cn/problem/SP6717">SP6717 TWOPATHS - Two Paths</a>（<del>但还是虚高题</del>）。</p>
<p>我们考虑 $\mathcal O(n)$ 的做法。</p>
<p>update on 2022.11.13。原题解被 @zhanghenglei 所 Hack。现在已将解法修正，如果仍有问题，欢迎指出qwq。</p>
<p>不难想到用 $f_x,g_x$ 分别表示以 $x$ 为根的子树内和子树外最长链的长度。答案就是 $\max\{f_x\times g_x\}$。$f_x$ 很容易求，考虑 $g_x$ 怎么求。</p>
<p>$g_x$ 可以从父亲节点转移过来，这启发我们可以类似于换根 DP 的方法来求 $g_x$。</p>
<p>考虑怎么构成一条子树外的链。无非是从父节点往上延伸，或者从父节点往下延伸的链。再将他们最长的两段在父节点拼起来成为一个答案。</p>
<p>但是我们选取的两段链不能在 $x$ 的子树中。这就意味着我们需要先求出，从父节点往下延伸的链的最大值、亚大值和次大值，以及对应的子节点。转移时判断一下所选的链有没有在 $x$ 的子树中就行。</p>
<p>从该节点 $x$ 往上延伸的最长链也可以通过最大值和亚大值通过换根 DP 来求出，也比较简单。</p>
<p>但是这样解是有漏洞的，$g_x$ 求出来只是恰好经过其父节点的最长链，而不是整棵树中除去该子树的最长链，就像这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/93kgatph.png" alt=""></p>
<p><code>output : 30</code> \<br><code>answer : 36</code></p>
<p>所以我们需要再多记一个 $h_x$ 表示该节点的父节点的子树之外的最长链，转移与上面类似。</p>
<p>具体可看看代码，有一些注释。有点繁琐，但还是比较好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> d[N][<span class="number">3</span>],l[N],t[N][<span class="number">3</span>],f[N],g[N],h[N];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">2</span>]=d[x][<span class="number">1</span>],t[x][<span class="number">2</span>]=t[x][<span class="number">1</span>];</span><br><span class="line">            d[x][<span class="number">1</span>]=d[x][<span class="number">0</span>],t[x][<span class="number">1</span>]=t[x][<span class="number">0</span>];</span><br><span class="line">            d[x][<span class="number">0</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">0</span>]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            d[x][<span class="number">2</span>]=d[x][<span class="number">1</span>],t[x][<span class="number">2</span>]=t[x][<span class="number">1</span>];</span><br><span class="line">            d[x][<span class="number">1</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">1</span>]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[y][<span class="number">0</span>]+<span class="number">1</span>&gt;=d[x][<span class="number">2</span>])</span><br><span class="line">            d[x][<span class="number">2</span>]=d[y][<span class="number">0</span>]+<span class="number">1</span>,t[x][<span class="number">2</span>]=y;</span><br><span class="line">        <span class="comment">//处理出从该节点往下延伸的链的最大值、亚大值和次大值</span></span><br><span class="line">        <span class="comment">//以及其所对应的儿子</span></span><br><span class="line">        f[x]=<span class="built_in">max</span>(f[x],f[y]);<span class="comment">//从子节点转移</span></span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=<span class="built_in">max</span>(f[x],d[x][<span class="number">0</span>]+d[x][<span class="number">1</span>]);<span class="comment">//从自己转移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,<span class="number">1ll</span>*f[x]*<span class="built_in">max</span>(g[x],h[x]));<span class="comment">//统计答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        l[y]=l[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[x][<span class="number">0</span>]&amp;&amp;t[x][<span class="number">0</span>]!=y)</span><br><span class="line">            l[y]=<span class="built_in">max</span>(l[x],d[x][<span class="number">0</span>])+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[x][<span class="number">1</span>])</span><br><span class="line">            l[y]=<span class="built_in">max</span>(l[x],d[x][<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//转移从该节点向上延伸的最长链</span></span><br><span class="line">        <span class="type">int</span> res[<span class="number">4</span>];</span><br><span class="line">        res[<span class="number">0</span>]=t[x][<span class="number">0</span>]!=y?d[x][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>]=t[x][<span class="number">1</span>]!=y?d[x][<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">2</span>]=t[x][<span class="number">2</span>]!=y?d[x][<span class="number">2</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">3</span>]=l[x];</span><br><span class="line">        <span class="built_in">sort</span>(res,res+<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//从四条链中选取合法的最长的两条</span></span><br><span class="line">        g[y]=<span class="built_in">max</span>(g[x],res[<span class="number">2</span>]+res[<span class="number">3</span>]);</span><br><span class="line">        h[y]=h[x];</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x);</span><br><span class="line">        res[<span class="number">0</span>]=t[y][<span class="number">0</span>]!=y?d[y][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>]=t[y][<span class="number">1</span>]!=y?d[y][<span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">        res[<span class="number">2</span>]=t[y][<span class="number">2</span>]!=y?d[y][<span class="number">2</span>]:<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(res,res+<span class="number">3</span>);</span><br><span class="line">        h[x]=<span class="built_in">max</span>(h[x],res[<span class="number">1</span>]+res[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//转移该节点的父节点的子树之外的最长链</span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="34-P5078-Tweetuzki-爱军训"><a href="#34-P5078-Tweetuzki-爱军训" class="headerlink" title="34.P5078 Tweetuzki 爱军训"></a>34.<a href="https://www.luogu.com.cn/problem/P5078">P5078 Tweetuzki 爱军训</a></h4><p>考虑贪心。我们依次考虑，将每个点放在左端或者右端。</p>
<p>而是对于每个点，我们考虑拆贡献。设放在前面的点 $[1,l]$ 的和为 $sum_1$，放在后面的点 $ [r,n]$ 的和为 $sum_2$，所有点和为 $sum$，那么：</p>
<p>1.放在前面的点，对其后面的点贡献为 $sum-sum_1$。</p>
<p>2.放在后面的点，对其后面的点贡献为 $sum_2$。而他前面还有 $r-l+1$ 个点未计算贡献，而这部分贡献为 $a_i\times (r-l+1)$。</p>
<p>注意，我们直接统计贡献是会有重复的。但是这样贪心的话，我们能保证对于之后的决策都会是更优的。真正的的贡献直接统计就好了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> l,r,ans[N];</span><br><span class="line">ll sum1,sum2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),sum1+=a[i];</span><br><span class="line">    l=<span class="number">1</span>,r=n;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum1&gt;=<span class="number">1ll</span>*a[i]*(r-l+<span class="number">1</span>)+sum2)</span><br><span class="line">            res+=<span class="number">1ll</span>*a[i]*l,ans[l++]=a[i],sum1-=a[i];</span><br><span class="line">        <span class="keyword">else</span> res+=<span class="number">1ll</span>*a[i]*r,ans[r--]=a[i],sum2+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="35-CF1305F-Kuroni-and-the-Punishment"><a href="#35-CF1305F-Kuroni-and-the-Punishment" class="headerlink" title="35.CF1305F Kuroni and the Punishment"></a>35.<a href="https://www.luogu.com.cn/problem/CF1305F">CF1305F Kuroni and the Punishment</a></h4><p>神秘题。随机化题目都没怎么做过，所以根本不会。。。</p>
<p>考虑两个结论：</p>
<p>1.操作次数 $&lt; n$。</p>
<p>2.操作超过两次的数 $\le \frac{n}{2}$。</p>
<p>那么随机化做法就来了，我们每次随机选取一个数 $x$，并将 $x-1,x,x+1$ 都分解质因数，放入一个 set 里。我们一共选取 50 次，这样最多有约 600 个质数。</p>
<p>然后我们暴力枚举每个质因数 $p$，计算 $\gcd=p$ 时的操作次数是多少。取最小值就可以了。</p>
<p>我们每次都有至少 $\frac{1}{2}$ 的概率选中操作次数小于等于一次的数。所以错误的概率只为 $\frac{1}{2^{50}}$。</p>
<p>注意每个数不能为 $0$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line">ll a[N];</span><br><span class="line">set&lt;ll&gt;prime;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">divide</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(x%i))</span><br><span class="line">        &#123;</span><br><span class="line">            prime.<span class="built_in">insert</span>(i);</span><br><span class="line">            <span class="keyword">while</span>(!(x%i))x/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>)prime.<span class="built_in">insert</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos=<span class="built_in">rand</span>()*<span class="built_in">rand</span>()%n+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">divide</span>(a[pos]<span class="number">-1</span>),<span class="built_in">divide</span>(a[pos]),<span class="built_in">divide</span>(a[pos]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    set&lt;ll&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it=prime.<span class="built_in">begin</span>();it!=prime.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;*it)</span><br><span class="line">                res+=<span class="built_in">min</span>(a[i]%*it,(*it-a[i]%*it));</span><br><span class="line">            <span class="keyword">else</span> res+=*it-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="36-AT3911-Forest"><a href="#36-AT3911-Forest" class="headerlink" title="36.AT3911 Forest"></a>36.<a href="https://www.luogu.com.cn/problem/AT3911">AT3911 Forest</a></h4><p>假如有 $cnt$ 个连通块，那么我们需要连 $cnt-1$ 条边，那么就要选取 $2\times cnt-2$ 个点。现在每个连通块里选一个最小的，再贪心地在所以里面再选 $cnt-2$ 个最小的即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> a[N],fa[N],v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]),fa[i]=i,v[i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        fa[<span class="built_in">find</span>(v+<span class="number">1</span>)]=<span class="built_in">find</span>(u+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        v[<span class="built_in">find</span>(i)]=<span class="built_in">min</span>(v[<span class="built_in">find</span>(i)],a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==v[<span class="built_in">find</span>(i)])</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=a[i];</span><br><span class="line">            cnt++;</span><br><span class="line">            v[<span class="built_in">find</span>(i)]=INF;</span><br><span class="line">            a[i]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt<span class="number">-2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==INF)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="37-CF351A-Jeff-and-Rounding"><a href="#37-CF351A-Jeff-and-Rounding" class="headerlink" title="37.CF351A Jeff and Rounding"></a>37.<a href="https://www.luogu.com.cn/problem/CF351A">CF351A Jeff and Rounding</a></h4><p>如果没有整数的话，答案就是一定的。我们只需要枚举将多少个整数上取整即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-4</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N],sum,ans=INF;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i]);</span><br><span class="line">        a[i]=a[i]-<span class="built_in">int</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=eps)cnt++;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">max</span>(cnt-n,<span class="number">0</span>);i&lt;=<span class="built_in">min</span>(cnt,n);i++)</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(sum-n+i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="38-CF448C-Painting-Fence"><a href="#38-CF448C-Painting-Fence" class="headerlink" title="38.CF448C Painting Fence"></a>38.<a href="https://www.luogu.com.cn/problem/CF448C">CF448C Painting Fence</a></h4><p>分治求解即可。每次考虑将区间内高度最小的横着刷，将其分成多个小区间再求解。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> <span class="built_in">min</span>(<span class="number">1</span>,a[l]-h);</span><br><span class="line">    <span class="type">int</span> minx=INF,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        minx=<span class="built_in">min</span>(minx,a[i]);</span><br><span class="line">    <span class="type">int</span> pre=l,res=minx-h;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==minx)</span><br><span class="line">            res+=<span class="built_in">solve</span>(pre,i<span class="number">-1</span>,minx),pre=i+<span class="number">1</span>;</span><br><span class="line">    res+=<span class="built_in">solve</span>(pre,r,minx);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(<span class="number">1</span>,n,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>虽然这样已经做可以通过此题，但这并不影响我们对更优解的思考。我们发现时间都浪费在找最小值上，我们可以用笛卡尔树来做（本题的形式就是笛卡尔树的经典模型）。这样很容易做到 $\mathcal O(n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> top,sta[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">solve</span>(l,pos<span class="number">-1</span>,tr[pos].l,tr[pos].val)+</span><br><span class="line">            <span class="built_in">solve</span>(pos+<span class="number">1</span>,r,tr[pos].r,tr[pos].val)+tr[pos].val-h;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(tr[i].val);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=top;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;tr[sta[p]].val&gt;tr[i].val)</span><br><span class="line">            p--;</span><br><span class="line">        <span class="keyword">if</span>(p)tr[sta[p]].r=i;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;top)tr[i].l=sta[p+<span class="number">1</span>];</span><br><span class="line">        sta[++p]=i;</span><br><span class="line">        top=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(<span class="number">1</span>,n,sta[<span class="number">1</span>],<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="39-Manga-Market"><a href="#39-Manga-Market" class="headerlink" title="39.Manga Market"></a>39.<a href="https://www.luogu.com.cn/problem/AT_hitachi2020_d">Manga Market</a></h4><p>先考虑贪心，考虑微扰法，假设有 $i$ 与 $j$，他们的花费分别为 $(a_i+1)\times (a_j\times t+b_j+t+1)+b_i$ 与 $(a_j+1)\times (a_i\times t+b_i+t+1)+b_j$，两式相减即可得到 $a_i\times b_j +a_i- a_j\times b_i -a_j$，于是我们按照 $\frac{a_i}{b_i+1}&lt;\frac{a_j}{b_j+1}$ 的顺序排序即可。</p>
<p>确定顺序后考虑 DP，$f_{i,j}$ 为考虑前 $i$ 个点选取 $j$ 个点，很容易有转移方程 $f_{i,j}=\min \{f_{i-1,j},(f_{i-1,j-1}+1)*(a_i+1)+b_i\}$。</p>
<p>这样状态已经是 $\mathcal O(n^2)$ 的。但是我们注意当 $a_i\ge 1$ 时，时间是按照指数级别增长，那么我们最多就只能选取 $\log t$ 个点，状态就变为 $\mathcal O(n\log t)$ 了。过程中还可以使用滚动数组优化。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,K=<span class="number">40</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">    ll k,b;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n,t,ans,tot;</span><br><span class="line">ll c[N],f[N][K];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Line x,Line y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y.k*(x.b+<span class="number">1</span>)&lt;x.k*(y.b+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i].k,a[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a[i].k==<span class="number">0</span>)</span><br><span class="line">            c[++tot]=a[i].b,a[i].k=INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+<span class="number">1</span>+tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            f[i][j]=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            f[i][j]=<span class="built_in">min</span>(f[i][j<span class="number">-1</span>],(f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>)*(a[j].k+<span class="number">1</span>)+a[j].b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">        c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> j=tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n&amp;&amp;f[i][n]&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;f[i][n]+c[j]&gt;t)j--;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,i+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="40-AGC033C-Removing-Coins"><a href="#40-AGC033C-Removing-Coins" class="headerlink" title="40.[AGC033C] Removing Coins"></a>40.<a href="https://www.luogu.com.cn/problem/AT_agc033_c">[AGC033C] Removing Coins</a></h4><p>考虑每一次操作的本质就是断开该节点以外的所有叶子。于是考虑树的直径 $len$，简单博弈就可以得到当 $len \equiv 2\mod3$ 时才是 <code>Second</code>。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> len,d[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        len=<span class="built_in">max</span>(len,d[x]+d[y]+<span class="number">1</span>);</span><br><span class="line">        d[x]=<span class="built_in">max</span>(d[x],d[y]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    len++;</span><br><span class="line">    <span class="built_in">puts</span>(len%<span class="number">3</span>!=<span class="number">2</span>?<span class="string">&quot;First&quot;</span>:<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="41-Polycarp-and-Div-3"><a href="#41-Polycarp-and-Div-3" class="headerlink" title="41.Polycarp and Div 3"></a>41.<a href="https://www.luogu.com.cn/problem/CF1005D">Polycarp and Div 3</a></h4><p>简单题，前缀和然后 DP 就完了。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">int</span> a[N],sum[N],f[N],pre[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;a[++n])!=EOF)</span><br><span class="line">        sum[n]=sum[n<span class="number">-1</span>]+a[n];</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>],f[pre[sum[i]%<span class="number">3</span>]]+(pre[sum[i]%<span class="number">3</span>]||sum[i]%<span class="number">3</span>==<span class="number">0</span>));</span><br><span class="line">        pre[sum[i]%<span class="number">3</span>]=i;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="42-P6835-Cnoi2020-线形生物"><a href="#42-P6835-Cnoi2020-线形生物" class="headerlink" title="42.P6835 [Cnoi2020]线形生物"></a>42.<a href="https://www.luogu.com.cn/problem/P6835">P6835 [Cnoi2020]线形生物</a></h4><p>考虑 $f_x$ 为从点 $x$ 走到 $x+1$ 的期望步数。$\deg_x$ 为 $x$ 的出度那么有：</p>
<p>$f_x=1+\frac{\sum_y \sum_{i=y}^{x} f_i}{\deg_x}$ </p>
<p>使用对 $f$ 做前缀和得到：</p>
<p>$f_x=\frac{\deg_x+(\deg_x-1)\times sum_x-\sum sum_{y-1}}{\deg_x}$</p>
<p>将 $sum_x$ 替换为 $sum_{x-1}+f_x$ 得：</p>
<p>$f_x=\deg_x+(\deg_x-1)\times sum_{x-1}-\sum sum_{y-1}$</p>
<p>线性递推即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,id;</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[M],ne[M];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line">ll f[N],sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(id,n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">read</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        deg[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">            f[x]=(f[x]+sum[ver[i]<span class="number">-1</span>])%mod;</span><br><span class="line">        f[x]=((deg[x]+<span class="number">1</span>+deg[x]*sum[x<span class="number">-1</span>]%mod-f[x])%mod+mod)%mod;</span><br><span class="line">        sum[x]=(sum[x<span class="number">-1</span>]+f[x])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="43-Pudding-Monsters"><a href="#43-Pudding-Monsters" class="headerlink" title="43.Pudding Monsters"></a>43.<a href="https://www.luogu.com.cn/problem/CF526F">Pudding Monsters</a></h4><p>将问题转化为一维，等价于求 $max-min=r-l$  的区间个数。</p>
<p>考虑枚举左端点 $l$，求出满足答案的右端点 $r$，并且用线段树维护 $max-min-r+l$ 的最小值及其个数。每次移动左端点 $l$ 时，用单调栈维护最小值和最大值，消除前面的影响即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> val,cnt,tag;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> top1,top2,sta1[N],sta2[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val=<span class="built_in">min</span>(tr[x&lt;&lt;<span class="number">1</span>].val,tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val);</span><br><span class="line">    tr[x].cnt=(tr[x&lt;&lt;<span class="number">1</span>].val==tr[x].val)*tr[x&lt;&lt;<span class="number">1</span>].cnt</span><br><span class="line">            +(tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val==tr[x].val)*tr[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].val+=k;</span><br><span class="line">    tr[x].tag+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[x].tag)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    <span class="built_in">update</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tr[x].tag);</span><br><span class="line">    tr[x].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].l=l,tr[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].val=l,tr[x].cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].l&gt;=l&amp;&amp;tr[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(x,k);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=tr[x].l+tr[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        a[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top1&amp;&amp;a[i]&lt;a[sta1[top1]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,sta1[top1<span class="number">-1</span>]+<span class="number">1</span>,sta1[top1],-(a[i]-a[sta1[top1]]));</span><br><span class="line">            top1--;</span><br><span class="line">        &#125;</span><br><span class="line">        sta1[++top1]=i;</span><br><span class="line">        <span class="keyword">while</span>(top2&amp;&amp;a[i]&gt;a[sta2[top2]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,sta2[top2<span class="number">-1</span>]+<span class="number">1</span>,sta2[top2],a[i]-a[sta2[top2]]);</span><br><span class="line">            top2--;</span><br><span class="line">        &#125;</span><br><span class="line">        sta2[++top2]=i;</span><br><span class="line">        ans+=tr[<span class="number">1</span>].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="44-P3609-USACO17JAN-Hoof-Paper-Scissor-G"><a href="#44-P3609-USACO17JAN-Hoof-Paper-Scissor-G" class="headerlink" title="44.P3609 [USACO17JAN]Hoof, Paper, Scissor G"></a>44.<a href="https://www.luogu.com.cn/problem/P3609">P3609 [USACO17JAN]Hoof, Paper, Scissor G</a></h4><p>直接DP。$f_{i,j,k}$ 表示到第 $i$ 轮变换 $j$ 次变成手势 $k$ 时最多赢的次数。时间复杂度 $\mathcal O(nk)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][M][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((x==<span class="number">0</span>&amp;&amp;y==<span class="number">1</span>)||(x==<span class="number">1</span>&amp;&amp;y==<span class="number">2</span>)||(x==<span class="number">2</span>&amp;&amp;y==<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch);</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>]==<span class="string">&#x27;H&#x27;</span>)a[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>)a[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> a[i]=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>][i]=<span class="built_in">h</span>(i,a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;<span class="number">3</span>;l++)</span><br><span class="line">                    f[i][j][k]=<span class="built_in">max</span>(f[i][j][k],<span class="built_in">max</span>(f[i<span class="number">-1</span>][j][k],(j-(k!=l)&gt;=<span class="number">0</span>)?f[i<span class="number">-1</span>][j-(k!=l)][l]:<span class="number">0</span>)+<span class="built_in">h</span>(k,a[i]));</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,f[n][i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="44-X-or-mas-Tree"><a href="#44-X-or-mas-Tree" class="headerlink" title="44.X(or)-mas Tree"></a>44.<a href="https://www.luogu.com.cn/problem/CF1615D">X(or)-mas Tree</a></h4><p>小清新构造题。</p>
<p>注意观察，其实我们只需要将边权按照 popcount 的奇偶全部转为 $0,1$ 即可。我们再通过边的限制维护两个点集，表示两个点集中的元素互相之间边权异或和为 $1$，而点集内部的点之间的边权异或和为 $0$。这个可以直接用扩展域并查集维护即可。</p>
<p>需要注意的是最后输出方案时也需要把新加的边权加进限制里面。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> u[N],v[N],w[N];</span><br><span class="line"><span class="type">int</span> fa[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x==fa[x])?x:fa[x]=<span class="built_in">get</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="built_in">get</span>(x),y=<span class="built_in">get</span>(y);</span><br><span class="line">	fa[y]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++)</span><br><span class="line">		fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(u[i],v[i],w[i]);</span><br><span class="line">		<span class="keyword">if</span>(!~w[i])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> x=__builtin_popcount(w[i])&amp;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(x)<span class="built_in">merge</span>(u[i]+n,v[i]),<span class="built_in">merge</span>(u[i],v[i]+n);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">merge</span>(u[i],v[i]),<span class="built_in">merge</span>(u[i]+n,v[i]+n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">read</span>(u,v,w);</span><br><span class="line">		<span class="keyword">if</span>(w)<span class="built_in">merge</span>(u+n,v),<span class="built_in">merge</span>(u,v+n);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">merge</span>(u,v),<span class="built_in">merge</span>(u+n,v+n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">get</span>(i)==<span class="built_in">get</span>(i+n))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!~w[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">get</span>(u[i])!=<span class="built_in">get</span>(v[i]))w[i]=<span class="number">1</span>,<span class="built_in">merge</span>(u[i]+n,v[i]),<span class="built_in">merge</span>(u[i],v[i]+n);</span><br><span class="line">			<span class="keyword">else</span> w[i]=<span class="number">0</span>,<span class="built_in">merge</span>(u[i],v[i]),<span class="built_in">merge</span>(u[i]+n,v[i]+n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,u[i],v[i],w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="45-ABC131F-Must-Be-Rectangular"><a href="#45-ABC131F-Must-Be-Rectangular" class="headerlink" title="45.[ABC131F] Must Be Rectangular!"></a>45.<a href="https://www.luogu.com.cn/problem/AT_abc131_f">[ABC131F] Must Be Rectangular!</a></h4><p>感觉自己的人类智慧又不够用了。</p>
<p>通过简单动手画图，如果将每个点向所有和它同行或同列的点连边，我们发现只要形成连通块，那么可以按照这个连通块的最大长与宽把这个长方形填满。维护连通性？我们可以用并查集。</p>
<p>我们有一种比较巧妙的方法来维护。我们将一个点的坐标拆成 $x$ 和 $y$ 单独的两个点，并且将每个点的第 $x$ 行与第 $y$ 列合并。最后统计根节点的长与宽就行了，代码很简洁。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="type">int</span> fa[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[N&lt;&lt;<span class="number">1</span>],g[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">get</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="built_in">get</span>(x),y=<span class="built_in">get</span>(y);</span><br><span class="line">	fa[y]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m&lt;&lt;<span class="number">1</span>;i++)</span><br><span class="line">		fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">read</span>(x,y);</span><br><span class="line">		<span class="built_in">merge</span>(x,y+m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)f[<span class="built_in">get</span>(i)]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)g[<span class="built_in">get</span>(i+m)]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m&lt;&lt;<span class="number">1</span>;i++)</span><br><span class="line">		ans+=<span class="number">1ll</span>*f[i]*g[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans-n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="46-GCD等于XOR-GCD-XOR"><a href="#46-GCD等于XOR-GCD-XOR" class="headerlink" title="46.GCD等于XOR GCD XOR"></a>46.<a href="https://www.luogu.com.cn/problem/UVA12716">GCD等于XOR GCD XOR</a></h4><p>有点意思的结论题。</p>
<p>直接给结论，设 $a&gt;b$，则 $a-b=a\oplus b$。</p>
<p>简单证明：</p>
<p>先考虑一个结论 $a-b\le a\oplus b$，</p>
<p>又因为 $\gcd(a,b)\ge a-b$。</p>
<p>就有了上面的结论。</p>
<p>剩下的直接枚举就行了，时间复杂度 $\mathcal O(n\ln n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*i;j&lt;=n;j+=i)</span><br><span class="line">			<span class="keyword">if</span>(((j-i)^j)==i)</span><br><span class="line">				sum[j]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">prework</span>(N<span class="number">-10</span>);</span><br><span class="line">	<span class="built_in">read</span>(T);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=T;t++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		<span class="built_in">read</span>(x);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case %d: %lld\n&quot;</span>,t,sum[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="47-CF258D-Little-Elephant-and-Broken-Sorting"><a href="#47-CF258D-Little-Elephant-and-Broken-Sorting" class="headerlink" title="47.CF258D Little Elephant and Broken Sorting"></a>47.<a href="https://www.luogu.com.cn/problem/CF258D">CF258D Little Elephant and Broken Sorting</a></h4><p>有意思的一道题。</p>
<p>直接 DP，但是似乎不好设计出好转移的状态。这里就比较关键，直接设 $f_{i,j}$ 表示位置 $i$ 与 位置 $j$ 上的数满足偏序关系的期望。这样就对于每一个交换操作我们可以 $\mathcal O(n)$ 求出其贡献，而预处理和统计答案的时间为 $\mathcal O(n^2)$。总时间复杂度为 $\mathcal O(n^2+qn)$。</p>
<p>代码十分好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">double</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j)<span class="keyword">continue</span>;</span><br><span class="line">            f[i][j]=(a[i]&lt;a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">read</span>(x,y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==x||i==y)<span class="keyword">continue</span>;</span><br><span class="line">            f[x][i]=f[y][i]=f[x][i]*<span class="number">0.5</span>+f[y][i]*<span class="number">0.5</span>;</span><br><span class="line">            f[i][x]=f[i][y]=f[i][x]*<span class="number">0.5</span>+f[i][y]*<span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[x][y]=f[y][x]=f[x][y]*<span class="number">0.5</span>+f[y][x]*<span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            ans+=f[j][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="48-CF662C-Binary-Table"><a href="#48-CF662C-Binary-Table" class="headerlink" title="48.CF662C Binary Table"></a>48.<a href="https://www.luogu.com.cn/problem/CF662C">CF662C Binary Table</a></h4><p>这次是真的要认真开始做了。</p>
<p>比较容易想复杂，但还是挺巧妙的经典题。</p>
<p>因为有 $n\le 20$，考虑对每一列进行状压，设第 $i$ 行的初始状态为 $g[i]$。接着考虑对行操作，也只有 $2^n$ 种。对行的操作为 $x$ 时，答案 $\displaystyle f[x]=\sum_{i=1}^m \min(\text{popcount} (g[i]\oplus x),\text{popcount}(\neg g[i]\oplus x))$。暴力计算是 $\mathcal O(m2^n)$。考虑将 $m$ 去掉，所有行的状态总数最多为 $2^n$，记 $\displaystyle a[x]=\sum_{i=1}^{m}[g[i]=x]$。关键的来了，这个转移成立满足的条件是 $g[i]\oplus x=y$ 或 $\neg g[i]\oplus x=y$，贡献与 $y$ 相关，要求的是对 $x$ 的贡献，于是将 $y$ 移至等式右侧，$x$ 移至等式右侧吗，得到 $g[i]\oplus y=x$ 或 $g[i]\oplus \neg y=x$。于是进一步得到下面的式子：</p>
<script type="math/tex; mode=display">
f[x]=\sum_{i\oplus j=x}a[i]*b[j]</script><p>其中 $b[i]$ 代表 $\min(\text{popcount} (i),\text{popcount}(\neg x))$。转化为 FWT 板子，时间复杂度为 $\mathcal O(n 2^n)$。</p>
<p>注意 FWT 过程中需要开<code>long long</code>。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> popcnt __builtin_popcount</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">21</span>,M=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[M];</span><br><span class="line">ll a[<span class="number">1</span>&lt;&lt;N],b[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT</span><span class="params">(<span class="type">int</span> n,ll *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ll x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=x+y,a[i+j+mid]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IFWT</span><span class="params">(<span class="type">int</span> x,ll *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ll x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=x+y&gt;&gt;<span class="number">1</span>,a[i+j+mid]=x-y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;x);</span><br><span class="line">            g[j]|=x&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)a[g[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)b[i]=<span class="built_in">popcnt</span>(i),b[i]=<span class="built_in">min</span>(b[i],n-b[i]);</span><br><span class="line">    <span class="built_in">FWT</span>(n,a),<span class="built_in">FWT</span>(n,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)a[i]*=b[i];</span><br><span class="line">    <span class="built_in">IFWT</span>(n,a);</span><br><span class="line">    ll ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)ans=<span class="built_in">min</span>(ans,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>集合幂级数</title>
    <url>/2023/02/19/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/</url>
    <content><![CDATA[<p>快速莫比乌斯变换 FMT 与 快速沃尔什变换 FWT。</p>
<span id="more"></span>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>一个长度为 $2^n$ 的序列 $f(i)$，有一个生成函数 $F(x)=\sum_{i=0}^{2^n-1}f(i) x^i$，那么，这个生成函数叫做集合幂级数。</p>
<p>这和集合有什么关系呢？将集合 $\{0,1,\cdots,n-1 \}$ 的一个子集状态压缩后就对应着原序列的一个下标 $i$。</p>
<p>其卷积形式大多为 $c(i)=\sum_{j\oplus k=i}a(j)*b(k)$，这里的 $\oplus$ 指代某种运算，其大多是位运算。</p>
<p>直接暴力求卷积是 $\mathcal O(4^n)$ 的，考虑更优的做法。</p>
<h3 id="2-快速莫比乌斯变换-FMT"><a href="#2-快速莫比乌斯变换-FMT" class="headerlink" title="2.快速莫比乌斯变换 FMT"></a>2.快速莫比乌斯变换 FMT</h3><p>用来求高维前缀和。高维前缀和就是对 $n$ 维数组求前缀和，不过每一维只有 $0,1$ 两个下标。本质上就是子集和 $b(i)=\sum_{j|i=i} a(j)$。暴力枚举子集来求的时间复杂度是 $\mathcal O(3^n)$ 的。</p>
<p>是实际上我们可以对每一维单独来做遍前缀和，容易发现这样做是正确的。于是是时间复杂度 为 $\mathcal O(n2^n)$。</p>
<p>其实这样做法也可以从子集和或者另外的角度来理解。而高维后缀和同理。</p>
<details class="code" open><summary><i class="fab fa-code fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1</span>&lt;&lt;n;j++)</span><br><span class="line">        <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">            a[j]+=a[j^(<span class="number">1</span>&lt;&lt;i)];</span><br></pre></td></tr></table></figure>

</details>
<h3 id="3-快速沃尔什变换-FWT"><a href="#3-快速沃尔什变换-FWT" class="headerlink" title="3.快速沃尔什变换 FWT"></a>3.快速沃尔什变换 FWT</h3><p>用于求异或卷积，在下面说。</p>
<h3 id="4-卷积"><a href="#4-卷积" class="headerlink" title="4.卷积"></a>4.卷积</h3><p>为了让卷积 $c(i)=\sum_{j\oplus k=i}a(i)*b(i)$ 更快计算，我们需要用 FMT/FWT 将 $a,b$ 进行变换，再 $\mathcal O(n)$ 求出变换后的 $c$，再对其进行逆变换就可以求出原本的 $c$。</p>
<h4 id="1-或卷积"><a href="#1-或卷积" class="headerlink" title="1.或卷积"></a>1.或卷积</h4><p>求卷积 $c_i=\sum_{j|k=i} a_j*b_k$。</p>
<p>考虑构造出变换 $FMT(c)_x=FMT(a)_x*FMT(b)_x$。</p>
<p>证明如下：</p>
<script type="math/tex; mode=display">
\begin{align}
FMT(a)_x*FMT(b)_x&=\sum_{i|x=x} a(i)*\sum_{i|x=x}b(i)\\
&=\sum_{i|x=x}\sum_{j|x=x} a(i)*b(j)\\
&=\sum_{i|x=x}c(i)\\
&=FMT(c)_x
\end{align}</script><p>于是先对 $a,b$ 做一次高维前缀和，相乘后做一次逆变换即得到了 $c$。</p>
<h4 id="2-与卷积"><a href="#2-与卷积" class="headerlink" title="2.与卷积"></a>2.与卷积</h4><p>和或卷积类似，将高维前缀和变为高维后缀和即可。</p>
<h4 id="3-异或卷积"><a href="#3-异或卷积" class="headerlink" title="3.异或卷积"></a>3.异或卷积</h4><p>求卷积 $c_i=\sum_{j\oplus k=i} a_j*b_k$。</p>
<p>我们设对序列 $a$ 变换为 $FWT(a)_x=\sum_{i=0}^{n-1} g(x,i)a_i$。</p>
<p>我们要想使 </p>
<script type="math/tex; mode=display">
FWT(c)_x=FWT(a)_x*FWT(b)_x</script><p>尝试变换一下：</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=0}^{n-1} g(x,i)c_i=\sum_{i=0}^{n-1} g(x,i)a_i *\sum_{i=0}^{n-1} g(x,i)b_i
\\
\sum_{i=0}^{n-1} g(x,i)\sum_{j\oplus k=i} a_j*b_k=\sum_{i=0}^{n-1} g(x,i)a_i \sum_{i=0}^{n-1} *g(x,i)b_i
\\
\sum_{i=0}^{n-1}\sum_{j\oplus k=i} g(x,i) a_j*b_k=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1} g(x,i)g(x,j)a_i*b_j
\\
\sum_{i=0}^{n-1}\sum_{j=0}^{n-1} g(x,i\oplus j)a_i*b_j=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1} g(x,i)g(x,j)a_i*b_j
\end{align}</script><p>于是得到：</p>
<script type="math/tex; mode=display">
g(x,i\oplus j)=g(x,i)g(x,j)</script><p>我们需要构造的式子需要满足上面这个等式，并且能够快速得到 $FWT(a)$。前人的智慧告诉我们应当为 $g(x,i)=(-1)^{|i\odot x|}$，因为有 $(i\oplus j)\odot x=(i\odot x)\oplus (j\odot x)$。所以 FWT 的式子就是：</p>
<script type="math/tex; mode=display">
FWT(a)_x=(-1)^{|i\odot x|}a_i</script><p>至于如何快速求出 $FWT(a)$，考虑一个类似于蝶形运算的过程，具体可见代码，这里不再赘述。这样总的时间复杂度为 $\mathcal O(n2^n)$。</p>
<details class="code" open><summary><i class="fab fa-code fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=x+y,a[i+j+mid]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IFWT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=x+y&gt;&gt;<span class="number">1</span>,a[i+j+mid]=x-y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>发现此过程和 NTT 非常相似。</p>
<h4 id="4-子集卷积"><a href="#4-子集卷积" class="headerlink" title="4.子集卷积"></a>4.子集卷积</h4><p>求 $c_i=\sum_{j\odot k=0,j|k=i} a_j*b_k$。</p>
<p>注意到 $j,k$ 对 $j|k$ 有贡献，当且仅当 $\mid j\mid +\mid k\mid =\mid j|k\mid $。这启发我们按照集合的大小来进行分类。</p>
<p>将原序列扩展到二维为 $A_{x,i}=a_i[|i|=x]$，于是有：</p>
<script type="math/tex; mode=display">
\begin{align}
C_{|x|,x}=\sum_{i|j=x,|i|+|j|=|x|} A_{|i|,i}*B_{|j|,j}\\
FMT(C_{|x|})=\sum_{|i|}(FMT(A_{|i|})*FMT(B_{|x|-|i|}))
\end{align}</script><p>这里我们同时对两边做 FMT，这显然是成立的。我们先处理出 $FMT (A_{|i|}),FMT(B_{|i|})$，求出 $FMT(C_{|x|})$ 后做 $IFMT$ 即可。时间复杂度为 $\mathcal O(n^22^n)$。</p>
 <details class="code" open><summary><i class="fab fa-code fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">FMT</span>(n,a[i]),<span class="built_in">FMT</span>(n,b[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n-i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;tot;x++)</span><br><span class="line">            c[i+j][x]=<span class="built_in">adj</span>(c[i+j][x]+<span class="number">1ll</span>*a[i][x]*b[j][x]%mod);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">IFMT</span>(n,c[i]);</span><br></pre></td></tr></table></figure>

</details>
<h3 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h3><h4 id="1-CF914G-Sum-the-Fibonacci"><a href="#1-CF914G-Sum-the-Fibonacci" class="headerlink" title="1.CF914G Sum the Fibonacci"></a>1.<a href="https://codeforces.com/problemset/problem/914/G">CF914G Sum the Fibonacci</a></h4><p>模板题。</p>
 <details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> popcnt __builtin_popcount</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">17</span>,M=<span class="number">1</span>&lt;&lt;N,mod=<span class="number">1e9</span>+<span class="number">7</span>,inv=mod+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,tot;</span><br><span class="line"><span class="type">int</span> f[M],A[M];</span><br><span class="line"><span class="type">int</span> a[N+<span class="number">1</span>][M],b[N+<span class="number">1</span>][M],c[M],d[M],e[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FMT</span><span class="params">(<span class="type">int</span> op,<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">if</span>(!op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j]=<span class="built_in">adj</span>(a[j]+a[j^(<span class="number">1</span>&lt;&lt;i)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j^(<span class="number">1</span>&lt;&lt;i)]=<span class="built_in">adj</span>(a[j]+a[j^(<span class="number">1</span>&lt;&lt;i)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IFMT</span><span class="params">(<span class="type">int</span> op,<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">if</span>(!op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=tot<span class="number">-1</span>;~j;j--)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j]=<span class="built_in">adj</span>(a[j]-a[j^(<span class="number">1</span>&lt;&lt;i)]+mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=tot<span class="number">-1</span>;~j;j--)</span><br><span class="line">            <span class="keyword">if</span>(j&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                a[j^(<span class="number">1</span>&lt;&lt;i)]=<span class="built_in">adj</span>(a[j^(<span class="number">1</span>&lt;&lt;i)]-a[j]+mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=<span class="built_in">adj</span>(x+y),a[i+j+mid]=<span class="built_in">adj</span>(x-y+mod);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">IFWT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=a[i+j],y=a[i+j+mid];</span><br><span class="line">                a[i+j]=<span class="number">1ll</span>*<span class="built_in">adj</span>(x+y)*inv%mod,a[i+j+mid]=<span class="number">1ll</span>*<span class="built_in">adj</span>(x-y+mod)*inv%mod;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        A[x]++,tot=<span class="built_in">max</span>(tot,x);</span><br><span class="line">    &#125;</span><br><span class="line">    tot++;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;n)&lt;tot)n++;</span><br><span class="line">    tot=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>,f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;tot;i++)</span><br><span class="line">        f[i]=<span class="built_in">adj</span>(f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//subset</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        a[<span class="built_in">popcnt</span>(i)][i]=A[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="built_in">FMT</span>(<span class="number">0</span>,n,a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n-i;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;tot;x++)</span><br><span class="line">                b[i+j][x]=<span class="built_in">adj</span>(b[i+j][x]+<span class="number">1ll</span>*a[i][x]*a[j][x]%mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">IFMT</span>(<span class="number">0</span>,n,b[i]);</span><br><span class="line">    <span class="comment">//xor</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c,A,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">FWT</span>(n,c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        c[i]=<span class="number">1ll</span>*c[i]*c[i]%mod;</span><br><span class="line">    <span class="built_in">IFWT</span>(n,c);</span><br><span class="line">    <span class="comment">//and</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        d[i]=<span class="number">1ll</span>*b[<span class="built_in">popcnt</span>(i)][i]*f[i]%mod;</span><br><span class="line">    <span class="built_in">memcpy</span>(e,A,<span class="built_in">sizeof</span>(e));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        c[i]=<span class="number">1ll</span>*c[i]*f[i]%mod,e[i]=<span class="number">1ll</span>*e[i]*f[i]%mod;</span><br><span class="line">    <span class="built_in">FMT</span>(<span class="number">1</span>,n,c),<span class="built_in">FMT</span>(<span class="number">1</span>,n,d),<span class="built_in">FMT</span>(<span class="number">1</span>,n,e);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        c[i]=<span class="number">1ll</span>*c[i]*d[i]%mod*e[i]%mod;</span><br><span class="line">    <span class="built_in">IFMT</span>(<span class="number">1</span>,n,c);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+c[<span class="number">1</span>&lt;&lt;i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>集合幂级数</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P2048 [NOI2010] 超级钢琴</title>
    <url>/2023/05/09/P2048-NOI2010-%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4/</url>
    <content><![CDATA[<p>经典题。</p>
<span id="more"></span>
<p>需要求出前 $k$ 大的长度在 $[l,r]$ 之间的子段和。需要考虑如何删去已经选过的子段。将每个点 $p$ 单独对应一个候选区间 $[l_p,r_p]$，设 $x$ 该区间中的最优解的位置贡献为 $sum[x]-sum[p-1]$，$sum[]$ 为原数组前缀和，$x$ 可以通过 ST 表 查询区间最大值的位置得到。选取之后考虑将候选区间 $[l_p,r_p]$ 分为 $[l_p,x-1]$ 和 $[x+1,r_p]$，这样就不会取到重复的区间了。整个过程用优先队列来维护，选 $k$ 次即可。时间复杂度 $\mathcal O(n\log n+k\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,K=<span class="number">21</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k,l,r;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">int</span> st[N][K];</span><br><span class="line"><span class="type">int</span> Log[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p,l,r,x;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;t)<span class="type">const</span>&#123;<span class="keyword">return</span> sum[x]-sum[p<span class="number">-1</span>]&lt;sum[t.x]-sum[t.p<span class="number">-1</span>];&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Node&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)st[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=Log[n];j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">            sum[st[i][j<span class="number">-1</span>]]&gt;=sum[st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]]?st[i][j]=st[i][j<span class="number">-1</span>]:st[i][j]=st[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=Log[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> sum[st[l][t]]&gt;=sum[st[r-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>][t]]?st[l][t]:st[r-(<span class="number">1</span>&lt;&lt;t)+<span class="number">1</span>][t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k,l,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">read</span>(x);</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+x;</span><br><span class="line">    &#125;</span><br><span class="line">    Log[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)Log[i]=Log[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-l+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> L=i+l<span class="number">-1</span>,R=<span class="built_in">min</span>(i+r<span class="number">-1</span>,n);</span><br><span class="line">        q.<span class="built_in">push</span>((Node)&#123;i,L,R,<span class="built_in">query</span>(L,R)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Node now=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=sum[now.x]-sum[now.p<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(now.x&gt;now.l)q.<span class="built_in">push</span>((Node)&#123;now.p,now.l,now.x<span class="number">-1</span>,<span class="built_in">query</span>(now.l,now.x<span class="number">-1</span>)&#125;);</span><br><span class="line">        <span class="keyword">if</span>(now.x&lt;now.r)q.<span class="built_in">push</span>((Node)&#123;now.p,now.x+<span class="number">1</span>,now.r,<span class="built_in">query</span>(now.x+<span class="number">1</span>,now.r)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>ST表</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P3600 随机数生成器</title>
    <url>/2023/05/11/P3600-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p>还是 min-max 容斥加 DP。</p>
<span id="more"></span>
<p>相当于求 $\displaystyle E(\max_{i=1}^q \min_{j=l_i}^{r_i} a_j)$，其中 $a_j$ 是值域为 $[1,m]$ 随机数列。最小值的最大值并不好处理，利用 min-max 容斥转化为最小值的最小值，得到 ：$\displaystyle \sum_{T\subseteq S} (-1)^{|T|+1} E(\min_{i\in T} \min_{j=l_i}^{r_i} a_j)$。注意到后面的部分只和区间集合的区间并的大小有关，这个也可以通过 DP简单求出。主要考虑求容斥系数。将并集大小压进状态，设计状态 $f(i,j)$ 表示选取到位置 $i$，并集长度为 $j$ 的容斥系数。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>min-max 容斥</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P4707 重返现世</title>
    <url>/2023/05/10/P4707-%E9%87%8D%E8%BF%94%E7%8E%B0%E4%B8%96/</url>
    <content><![CDATA[<p>巧妙的 DP 题目。</p>
<span id="more"></span>
<p>设 $k’=n-k-1$ ，并接下来都是用 $k’$ 。设每种材料被收集的时间为 $t_i$，相当于求 $\displaystyle E(\text{kth}\max_{i=1}^n t_i)$。max 显然不好直接求，考虑 min-max 容斥得到：</p>
<script type="math/tex; mode=display">
E(\text{kth}\max_{ i\in S}t_i)=\sum_{T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}E(\min_{i\in T} t_i)</script><p>其中 $\displaystyle E(\min_{i\in S} t_i)= \frac{m}{\sum_{i\in S} p_i}$。考虑一个暴力 DP，设状态 $f(i,j)$ 表示选择 $i$ 种材料，$\sum_{i\in S} p_i=j$ 的方案数。因为需要每次枚举所有材料。这样的时间复杂度 $\mathcal O(n^2m)$，不能通过。</p>
<p>注意到 $k$ 是很小的。考虑 $k$ 压进去。于是我们直接求容斥系数 $\displaystyle \sum_{\sum_{i\in S} p_i=j}(-1)^{|T|-k}\binom{|T|-1}{k-1}$。因为需要计算 $\frac{m}{f(S)}$ 的贡献，$\sum_{i\in S} p_i$ 还是需要压进状态里，于是考虑设计状态 $f(i,j,k)$ 表示考虑前 $i$ 个数，$\sum_{i\in S} p_i=j$，关于 $k$ 的容斥系数。但是处理组合数似乎令人头疼，尝试用 $\binom{n}{m}=\binom{n-1}{m}+\binom{n-1}{m-1}$，拆一下 $|T|,k$ 的容斥系数，得到：</p>
<script type="math/tex; mode=display">
\begin{align}
&(-1)^{|T|-k}\binom{|T|-1}{k-1}\\
=&(-1)^{|T|-k}(\binom{|T|-2}{k-1}+\binom{|T|-2}{k-2})\\
=&-(-1)^{|T|-k-1}\binom{|T|-2}{k-1}+(-1)^{|T|-k}\binom{|T|-2}{k-2}
\end{align}</script><p>拆出来的两个是 $|T|-1,k$ 和 $|T|-1,k-1$ 的容斥系数！这就很棒了，因为这个递推关系与 $|T|$ 具体值无关，我们就不用枚举每一种材料了。我们容易得到状态转移方程：</p>
<script type="math/tex; mode=display">
f(i,j,k)=f(i-1,j,k)-f(i-1,j-p_i,k)+f(i-1,j-p_i,k-1)</script><p>需要注意的是对边界的处理。有用的状态只有 $k&gt;0$。$k=0$ 作为边界，只会被贡献到 $f(i+1,p_i,1)$，新选的产生的容斥系数为 $(-1)^{1-1}\binom{0}{0}=1$，于是边界应为 $f(i,0,0)$。或者换一种角度，从定义出发，$f(i,0,0)=(-1)^{0-0}\binom{-1}{-1}=1$，这里的组合数涉及到负数，需要用到扩展的定义，但依然满足上面的递推式。</p>
<p>滚动数组倒序枚举 $j$ 能够压掉 $i$ 这一维的空间。总的时间复杂度为 $\mathcal O(nmk)$。</p>
<p>代码极短，并且十分好写。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>,M=<span class="number">1e4</span>+<span class="number">10</span>,K=<span class="number">15</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[M][K];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span>  x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,k,m);</span><br><span class="line">    k=n-k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(p[i]);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=p[i];j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=k;l;l--)</span><br><span class="line">                f[j][l]=<span class="built_in">adj</span>(<span class="built_in">adj</span>(f[j][l]+f[j-p[i]][l<span class="number">-1</span>])-f[j-p[i]][l]+mod);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*<span class="built_in">qpow</span>(i)*f[i][k]%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*m*ans%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>min-max 容斥</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>痛定思痛</title>
    <url>/2023/05/14/%E7%97%9B%E5%AE%9A%E6%80%9D%E7%97%9B/</url>
    <content><![CDATA[<p>我的时日也不久了。</p>
<span id="more"></span>
<p>何其憾？何其乐？何其短？</p>
<p>多乎哉？不多矣！！！</p>
]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>BEAST</title>
    <url>/2023/05/17/BEAST/</url>
    <content><![CDATA[<p>Inspired by BEASTAR.</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>[ARC093F] Dark Horse</title>
    <url>/2023/05/21/ARC093F-Dark-Horse/</url>
    <content><![CDATA[<p>容斥经典好题。</p>
<span id="more"></span>
<p>感觉思路反而很自然。将满二叉树画出来，是这样的：<img src="image1.png" alt=""></p>
<p>我们容易发现只需要保证，图上的 所有子树中编号最小值 都不为 $a_i$ 即可，因为只有子树中编号最小的人才会与 $1$ 交手。</p>
<p>考虑容斥，钦定子树集合 $S$ 的最小值都是 $a_i$，其余子树任意选。然后利用 $\displaystyle g(S)=\sum_{T\subseteq S} (-1)^{|T|+1} f(T)$ 进行容斥得到答案即可。</p>
<p>我们从大到小依次考虑 $a_i$，因为我们只关心子树中的最小值是否为 $a_i$，从大到小恰好可以满足当前枚举的 $a_i$ 是最小的。设计状态 $f_{i,S}$ 表示 选取到第 $i$，钦定集合为 $S$，转移很容易得到。DP时可以直接将容斥系数数算进去，再乘上组合数即可。时间复杂度 $\mathcal O(nm2^n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">17</span>,M=<span class="number">1</span>&lt;&lt;N,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"><span class="type">int</span> fac[M],ifac[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> j=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        j&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*fac[n]*ifac[m]%mod*ifac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)ifac[i<span class="number">-1</span>]=<span class="number">1ll</span>*ifac[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    f[m][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-1</span>;~i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);s++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][s]=<span class="built_in">adj</span>(f[i][s]+f[i+<span class="number">1</span>][s]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                <span class="keyword">if</span>(!(s&gt;&gt;j&amp;<span class="number">1</span>))</span><br><span class="line">                    f[i][s|(<span class="number">1</span>&lt;&lt;j)]=<span class="built_in">adj</span>(f[i][s|(<span class="number">1</span>&lt;&lt;j)]+<span class="number">1ll</span>*<span class="built_in">C</span>((<span class="number">1</span>&lt;&lt;n)-a[i]-s,(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>)*(mod-f[i+<span class="number">1</span>][s])%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">0</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(s&gt;&gt;i&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*fac[<span class="number">1</span>&lt;&lt;i]%mod;</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*res*fac[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>-s]%mod*f[<span class="number">0</span>][s]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1ll</span>*ans*(<span class="number">1</span>&lt;&lt;n)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>容斥</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>斯特林数</title>
    <url>/2023/05/25/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/</url>
    <content><![CDATA[<p>斯特林数学习笔记。</p>
<span id="more"></span>
<h2 id="1-第二类斯特林数"><a href="#1-第二类斯特林数" class="headerlink" title="1.第二类斯特林数"></a>1.第二类斯特林数</h2><p>虽然被称为第二类，但是应用比第一类更为广泛重要。</p>
<p><strong>第二类斯特林数</strong>（斯特林子集数）$\displaystyle {n \brace k}$，也可记作 $S(n,k)$，表示将 $n$ 个两两不同数，划分为 $k$ 个互不区分的非空集合的方案数。</p>
<h3 id="1-1-递推式"><a href="#1-1-递推式" class="headerlink" title="1.1 递推式"></a>1.1 递推式</h3><script type="math/tex; mode=display">
{n \brace k}={n-1 \brace k-1}+k{n-1 \brace k}</script><p>边界为 $\displaystyle {n \brace 0}=[n=0]$。</p>
<p>考虑组合意义，设当前元素为 $n$，将 $n$ 放进一个新建的集合的方案数为 $\displaystyle {n-1 \brace k-1}$，或者将其放进任意一个已有的集合的方案数为 $\displaystyle k{n-1 \brace k}$，二者相加得到。</p>
<h3 id="1-2-通项公式"><a href="#1-2-通项公式" class="headerlink" title="1.2 通项公式"></a>1.2 通项公式</h3><p>考虑先固定 $n$。发现“非空”的限制条件不好处理。考虑用容斥去掉这一条件。设计 $f(i)$ 表示将 $n$ 个两两不同数，划分为 $i$ 个<strong>互相区分</strong>的<strong>非空集合</strong>， $g(i)$ 表示将 $n$ 个两两不同数，划分为 $i$ 个<strong>互相区分</strong>的<strong>集合</strong>。根据定义容易得到：</p>
<script type="math/tex; mode=display">
\begin{align}
g(i)&=i^n\notag\\
g(i)&=\sum_{j=0}^n \binom{i}{j} f(j)\notag\\ 
\end{align}</script><p>运用二项式反演，得到：</p>
<script type="math/tex; mode=display">
\begin{align}
f(i)&=\sum_{j=0}^n (-1)^{i-j}\binom{i}{j}g(j)\notag\\
f(i)&=\sum_{j=0}^n \frac{(-1)^{i-j} j^n i!}{j!(i-j)!}\notag\\
\end{align}</script><p>最终得到：</p>
<script type="math/tex; mode=display">
{n \brace k}=\frac{f(k)}{k!}=\sum_{i=0}^n \frac{(-1)^{k-i} i^n}{i!(k-i)!}</script><h3 id="1-3-同一行第二类斯特林数的计算"><a href="#1-3-同一行第二类斯特林数的计算" class="headerlink" title="1.3 同一行第二类斯特林数的计算"></a>1.3 同一行第二类斯特林数的计算</h3><p>求出 $\displaystyle {n \brace i}$，其中 $i=0,1,\cdots,n$。</p>
<p>很容易根据通项公式辨识出卷积的形式：$\displaystyle {n \brace k}=\sum_{i=0}^n \frac{i^n}{i!}\frac{(-1)^{k-i}}{(k-i)!}$，直接卷积计算即可。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e6</span>+<span class="number">10</span>,mod=<span class="number">167772161</span>,G=<span class="number">3</span>,Gi=(mod+<span class="number">1</span>)/G;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="type">int</span> bit,tot,rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bit=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;len)bit++;</span><br><span class="line">	tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;bit<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">		x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)<span class="keyword">if</span>(rev[i]&lt;i)<span class="built_in">swap</span>(a[rev[i]],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> g=<span class="built_in">qpow</span>(inv==<span class="number">1</span>?G:Gi,(mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,cur=<span class="number">1</span>;j&lt;mid;j++,cur=<span class="number">1ll</span>*cur*g%mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x=a[i+j],y=<span class="number">1ll</span>*cur*a[i+j+mid]%mod;</span><br><span class="line">				a[i+j]=<span class="built_in">adj</span>(x+y),a[i+j+mid]=<span class="built_in">adj</span>(x-y+mod);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(inv==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> inv=<span class="built_in">qpow</span>(tot,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)a[i]=<span class="built_in">adj</span>(<span class="number">1ll</span>*a[i]*inv%mod+mod);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,prod=<span class="number">1</span>;i&lt;=n;i++,prod=<span class="number">1ll</span>*prod*i%mod)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> inv=<span class="built_in">qpow</span>(prod);</span><br><span class="line">		a[i]=<span class="number">1ll</span>*<span class="built_in">qpow</span>(i,n)*inv%mod;</span><br><span class="line">		b[i]=((i&amp;<span class="number">1</span>)?mod-inv:inv);</span><br><span class="line">	&#125;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">init</span>(n&lt;&lt;<span class="number">1</span>); </span><br><span class="line">    <span class="built_in">NTT</span>(a,<span class="number">1</span>),<span class="built_in">NTT</span>(b,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)a[i]=<span class="number">1ll</span>*a[i]*b[i]%mod;</span><br><span class="line">    <span class="built_in">NTT</span>(a,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-4-同一行第二类斯特林数的计算"><a href="#1-4-同一行第二类斯特林数的计算" class="headerlink" title="1.4 同一行第二类斯特林数的计算"></a>1.4 同一行第二类斯特林数的计算</h3><h2 id="2-第一类斯特林数"><a href="#2-第一类斯特林数" class="headerlink" title="2.第一类斯特林数"></a>2.第一类斯特林数</h2><p><strong>第一类斯特林数</strong>（斯特林轮换数）$\displaystyle {n \brack k}$，也可记作 $s(n,k)$，表示将 $n$ 个两两不同数，划分为 $k$ 个互不区分的非空轮换的方案数。</p>
<h3 id="1-1-递推式-1"><a href="#1-1-递推式-1" class="headerlink" title="1.1 递推式"></a>1.1 递推式</h3><script type="math/tex; mode=display">
{n \brack k}={n-1 \brack k-1}+(n-1){n-1 \brack k}</script><p>边界为 $\displaystyle {n \brack 0}=[n=0]$。</p>
<p>其组合意义与<strong>第二类斯特林数</strong>类似，不再赘述。</p>
<h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h2><p>记上升幂 $x^{\overline n}=\prod_{k=0}^{n-1}(x+k)=\frac{(x+n-1)!}{(x-1)!}$，下降幂 $x^{\underline n} =\prod_{k=0}^{n-1}(x-k)=\frac{x!}{(x-n)!}$。</p>
<p>我们发现他跟组合数相乘有很好的性质：</p>
<script type="math/tex; mode=display">
\begin{align}
\binom{n}{k}\times k^{\underline m}&=\binom{n-m}{k-m}\times n^{\underline m}\notag\\
\binom{n}{k}\times (n+1)^{\overline m}&=\binom{n+m}{k+m}\times (k+1)^{\overline m}\notag\\
\end{align}</script><p>我们很多时候可以利用这一点来处理带组合数的问题。</p>
<h3 id="3-1-普通幂与上升幂的相互转换"><a href="#3-1-普通幂与上升幂的相互转换" class="headerlink" title="3.1 普通幂与上升幂的相互转换"></a>3.1 普通幂与上升幂的相互转换</h3><script type="math/tex; mode=display">
\begin{align}
x^{\overline n}&=\sum_k {n\brack k} x^k\\
x^n&=\sum_k (-1)^{n-k} {n\brace k} x^{\overline k}\\
\end{align}</script><h3 id="3-2-普通幂与下降幂升幂的相互转换"><a href="#3-2-普通幂与下降幂升幂的相互转换" class="headerlink" title="3.2 普通幂与下降幂升幂的相互转换"></a>3.2 普通幂与下降幂升幂的相互转换</h3><script type="math/tex; mode=display">
\begin{align}
x^n&=\sum_k {n\brace k} x^{\underline k}\\
x^{\underline n}&=\sum_k (-1)^{n-k} {n\brack k} x^k\\
\end{align}</script><p>至于证明，$(1),(3)$ 式可以通过斯特林数的递推关系得到。$(2),(4)$ 式根据 $(1),(3)$ 式的结果，利用式子 $x_{\underline n}=(-1)^n (-x)^{\overline n}$ 容易得到。</p>
<p>利用这几条性质，我们可以容易实现普通幂多项式对下降幂多项式或者上升幂多项式的转化。</p>
<h3 id="3-3-点值转下降幂表示"><a href="#3-3-点值转下降幂表示" class="headerlink" title="3.3 点值转下降幂表示"></a>3.3 点值转下降幂表示</h3><p>给定 $n$ 次多项式 $F(x)$ 在 $[0,n]$ 的点值，求出它的下降幂表示。</p>
<p>根据定义得到：</p>
<script type="math/tex; mode=display">
F(x)=\sum_{i=0}^n b_i x^{\underline i}=\sum_{i=0}^n b_i \frac{x!}{(x-i)!}</script><p>将 $F(x)$ 转为 $\text{EGF}$，得到：</p>
<script type="math/tex; mode=display">
\hat{F}(x)=\sum_{i=0}^n b_i \frac{1}{(x-i)!}=b*e^x</script><p>于是得到 $b=\hat{F}(x)*e^{-x}$。卷积求出即可。详见 </p>
<h3 id="3-4-例题"><a href="#3-4-例题" class="headerlink" title="3.4 例题"></a>3.4 例题</h3><h4 id="1-P6620-省选联考-2020-A-卷-组合数问题"><a href="#1-P6620-省选联考-2020-A-卷-组合数问题" class="headerlink" title="1.P6620 [省选联考 2020 A 卷] 组合数问题"></a>1.<a href="https://www.luogu.com.cn/problem/P6620">P6620 [省选联考 2020 A 卷] 组合数问题</a></h4><p>有组合数？注意到 $n$ 很大，$m$ 比较小，我们尝试将带 $n$ 的枚举项消掉。先将普通幂多项式对下降幂多项式，设 $b_i$ 为 $f(x)$ 下降幂多项式形式的系数，即 $\displaystyle f(k)=\sum_{i=0}^m a_i k^i=\sum_{i=0}^m b_i k^{\underline i}$。</p>
<p>接下来就是推一下式子：</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{k=0}^n \sum_{i=0}^m b_i\times k^{\underline i}\times \binom{n}{k} \times x^k \notag\\
\sum_{k=0}^n \sum_{i=0}^m b_i\times n^{\underline i}\times \binom{n-i}{k-i} \times x^k \notag\\
\sum_{i=0}^m b_i\times n^{\underline i}\times x^i \sum_{k=0}^n \binom{n-i}{k-i} \times x^{k-i} \notag\\
\sum_{i=0}^m b_i\times n^{\underline i}\times x^i \times (x+1)^{n-i}\notag\\
\end{align}</script><p>直接计算即可。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,x,mod,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,x,mod,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)<span class="built_in">read</span>(a[i]),a[i]%=mod;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    b[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i][j]=<span class="built_in">adj</span>(s[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1ll</span>*j*s[i<span class="number">-1</span>][j]%mod);</span><br><span class="line">            b[j]=<span class="built_in">adj</span>(b[j]+<span class="number">1ll</span>*a[i]*s[i][j]%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    x%=mod;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,now=<span class="number">1</span>;i&lt;=m;now=<span class="number">1ll</span>*now*(n-i)%mod*x%mod,i++)</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*b[i]*now%mod*<span class="built_in">qpow</span>(x+<span class="number">1</span>,n-i)%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h4 id="2-P6667-清华集训2016-如何优雅地求和"><a href="#2-P6667-清华集训2016-如何优雅地求和" class="headerlink" title="2.P6667 [清华集训2016] 如何优雅地求和"></a>2.<a href="https://www.luogu.com.cn/problem/P6667">P6667 [清华集训2016] 如何优雅地求和</a></h4><p>和上一道题几乎一模一样。其中 $\displaystyle f(k)=\sum_{i=0}^m a_i k^i=\sum_{i=0}^m b_i k^{\underline i}$，推一下即可得到：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^m b_i\times n^{\underline i}\times x^i</script><p>只不过 $m\le 2\times 10^4$。需要将点值转下降幂表示求出 $b$。时间复杂度为 $\mathcal O(m\log m)$。</p>
<p>但是对此我们更简单的做法。我们设 $c_i=b_i\times i!$，容易得到：</p>
<script type="math/tex; mode=display">
f(k)=\sum_{i=0}^k c_i\cdot \frac{k^{\underline i}}{i!}=\sum_{i=0}^k \binom{k}{i} c_i</script><p>于是直接利用二项式反演即可得到：</p>
<script type="math/tex; mode=display">
c_k=\sum_{i=0}^k(-1)^{k-i}\binom{k}{i}f(i)</script><p>卷积得到即可 $\mathcal O(n\log n)$ 得到 $c$。这样可以避免点值转下降幂表示求出 $b$。两种方法本质上是一样的。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数学</tag>
        <tag>斯特林数</tag>
        <tag>下降幂</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式汇总</title>
    <url>/2023/05/27/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>一些模板与式子。</p>
<span id="more"></span>
<h2 id="1-多项式乘法"><a href="#1-多项式乘法" class="headerlink" title="1.多项式乘法"></a>1.多项式乘法</h2><p>梦开始的地方。</p>
<h3 id="1-1-FFT-快速傅里叶变换"><a href="#1-1-FFT-快速傅里叶变换" class="headerlink" title="1.1. FFT 快速傅里叶变换"></a>1.1. FFT 快速傅里叶变换</h3><details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>; </span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="type">const</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x+t.x,y+t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x-t.x,y-t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> Complex <span class="keyword">operator</span>*(<span class="type">const</span> Complex &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x*t.x-y*t.y,x*t.y+y*t.x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N],b[N];</span><br><span class="line"><span class="type">int</span> tot,bit,rev[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FFT</span><span class="params">(Complex *a,<span class="type">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        <span class="keyword">if</span>(rev[i]&lt;i)<span class="built_in">swap</span>(a[rev[i]],a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Complex w1=&#123;<span class="built_in">cos</span>(PI/mid),<span class="built_in">sin</span>(inv*PI/mid)&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=mid*<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Complex cur=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;mid;j++,cur=cur*w1)</span><br><span class="line">            &#123;</span><br><span class="line">                Complex x=a[i+j],y=cur*a[i+j+mid];</span><br><span class="line">                a[i+j]=x+y,a[i+j+mid]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">read</span>(x);</span><br><span class="line">        a[i].x=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">read</span>(x);</span><br><span class="line">        b[i].x=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;n+m+<span class="number">1</span>)bit++;</span><br><span class="line">    tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;bit<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(a,<span class="number">1</span>),<span class="built_in">FFT</span>(b,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)a[i]=a[i]*b[i];</span><br><span class="line">    <span class="built_in">FFT</span>(a,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">int</span>(a[i].x/tot+<span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="1-2-NTT-快速数论变换"><a href="#1-2-NTT-快速数论变换" class="headerlink" title="1.2. NTT 快速数论变换"></a>1.2. NTT 快速数论变换</h3><details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e6</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>,G=<span class="number">3</span>,Gi=<span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> bit,tot,rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">		x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		<span class="keyword">if</span>(rev[i]&lt;i)<span class="built_in">swap</span>(a[rev[i]],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> g=<span class="built_in">qpow</span>(inv==<span class="number">1</span>?G:Gi,(mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,cur=<span class="number">1</span>;j&lt;mid;j++,cur=<span class="number">1ll</span>*cur*g%mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x=a[i+j],y=<span class="number">1ll</span>*cur*a[i+j+mid]%mod;</span><br><span class="line">				a[i+j]=<span class="built_in">adj</span>(x+y),a[i+j+mid]=<span class="built_in">adj</span>(x-y+mod);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="built_in">read</span>(b[i]);</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;n+m+<span class="number">1</span>)bit++;</span><br><span class="line">	tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;bit<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">1</span>),<span class="built_in">NTT</span>(b,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		a[i]=<span class="number">1ll</span>*a[i]*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(a,<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> inv=<span class="built_in">qpow</span>(tot,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n+m+<span class="number">1</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="number">1ll</span>*a[i]*inv%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="2-多项式乘法逆"><a href="#2-多项式乘法逆" class="headerlink" title="2.多项式乘法逆"></a>2.多项式乘法逆</h2><p>给定 $f(x)$，求 $f^{-1}(x)$。</p>
<h3 id="倍增法"><a href="#倍增法" class="headerlink" title="倍增法"></a>倍增法</h3><p>首先知道：</p>
<script type="math/tex; mode=display">
\begin{align}
[x_0]f^{-1}(x)&=([x_0]f(x))^{-1}\notag
\end{align}</script><p>考虑倍增。假设已经求出 $f(x)$ 在 $\pmod {x^{\lceil \frac{n}{2}\rceil}}$ 意义下逆元 $f_0^{-1}(x)$。推一下：</p>
<script type="math/tex; mode=display">
\begin{align}
f(x)f_0^{-1}(x)&\equiv 1 \pmod {x^{\lceil \frac{n}{2}\rceil}}\notag \\
(f(x)f_0^{-1}(x)-1)^2&\equiv 0 \pmod {x^n}\notag \\
f(x)^2f_0^{-2}(x)-2f(x)f_0^{-1}(x)+1&\equiv 0 \pmod {x^n}\notag \\
\end{align}</script><p>同时除以 $f(x)$ 得到：</p>
<script type="math/tex; mode=display">
\begin{align}
f(x)f_0^{-2}(x)-2f_0^{-1}(x)+f^{-1}(x)&\equiv 0 \pmod {x^n}\notag \\
\end{align}</script><p>整理一下，最终得到：</p>
<script type="math/tex; mode=display">
\begin{align}
f^{-1}(x)&\equiv f_0^{-1}(x)(2-f(x)f_0^{-1}(x)) \pmod {x^n}\notag \\
\end{align}</script><p>递归计算即可，时间复杂度 $\mathcal O(n\log n)$。</p>
<details class="code"><summary><i class="fab fa-code fa-fw"></i>模板<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N=<span class="number">4e6</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>,G=<span class="number">3</span>,Gi=<span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="type">int</span> bit,tot,rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bit=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;(len&lt;&lt;<span class="number">1</span>))bit++;</span><br><span class="line">	tot=<span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;bit<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">		x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		<span class="keyword">if</span>(rev[i]&lt;i)<span class="built_in">swap</span>(a[rev[i]],a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;tot;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> g=<span class="built_in">qpow</span>(inv==<span class="number">1</span>?G:Gi,(mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,cur=<span class="number">1</span>;j&lt;mid;j++,cur=<span class="number">1ll</span>*cur*g%mod)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> x=a[i+j],y=<span class="number">1ll</span>*cur*a[i+j+mid]%mod;</span><br><span class="line">				a[i+j]=<span class="built_in">adj</span>(x+y),a[i+j+mid]=<span class="built_in">adj</span>(x-y+mod);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poly_inv</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		b[<span class="number">0</span>]=<span class="built_in">qpow</span>(a[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">poly_inv</span>(a,b,(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">init</span>(len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;i&lt;tot;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		c[i]=(i&lt;len?a[i]:<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">1</span>),<span class="built_in">NTT</span>(c,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		b[i]=<span class="number">1ll</span>*<span class="built_in">adj</span>(<span class="number">2</span><span class="number">-1ll</span>*b[i]*c[i]%mod+mod)*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> inv=<span class="built_in">qpow</span>(tot,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">		b[i]=<span class="built_in">adj</span>(<span class="number">1ll</span>*b[i]*inv%mod+mod);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;tot;i++)b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="built_in">poly_inv</span>(a,b,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="3-多项式开根"><a href="#3-多项式开根" class="headerlink" title="3.多项式开根"></a>3.多项式开根</h2><p>给定 $g(x)$，求 $f(x)$ 满足：</p>
<script type="math/tex; mode=display">
\begin{align}
f(x)^2\equiv g(x)\pmod x^n
\end{align}</script><h3 id="倍增法-1"><a href="#倍增法-1" class="headerlink" title="倍增法"></a>倍增法</h3><p>首先知道：</p>
<script type="math/tex; mode=display">
\begin{align}
[x_0]f(x)&=\sqrt{[x_0]g(x)}\notag
\end{align}</script><p>考虑倍增。假设已经求出 $g(x)$ 在 $\pmod {x^{\lceil \frac{n}{2}\rceil}}$ 意义的平方根 $f_0(x)$。推一下：</p>
<script type="math/tex; mode=display">
\begin{align}
f_0(x)^2&\equiv g(x) &\pmod {x^{\lceil \frac{n}{2}\rceil}} \notag\\
f_0(x)^2-g(x)&\equiv 0 &\pmod {x^{\lceil \frac{n}{2}\rceil}} \notag\\
(f_0(x)^2-g(x))^2&\equiv 0 &\pmod {x^n} \notag\\
(f_0(x)^2+g(x))^2&\equiv 4 f_0(x)^2g(x) &\pmod {x^n} \notag\\
\frac{(f_0(x)^2+g(x))^2}{4 f_0(x)^2} &\equiv f(x)^2 &\pmod {x^n} \notag\\
\frac{f_0(x)^2+g(x)}{2 f_0(x)} &\equiv f(x) &\pmod {x^n} \notag\\
\end{align}</script><p>最终得到：</p>
<script type="math/tex; mode=display">
\begin{align}
2^{-1}f_0(x)+2^{-1}f_0^{-1}(x)g(x) &\equiv f(x) &\pmod {x^n} \notag\\
\end{align}</script><p>需要一次多项式求逆，时间复杂度 $\mathcal O(n\log n)$。</p>
<h3 id="多项式快速幂"><a href="#多项式快速幂" class="headerlink" title="多项式快速幂"></a>多项式快速幂</h3><h2 id="4-多项式除法"><a href="#4-多项式除法" class="headerlink" title="4.多项式除法"></a>4.多项式除法</h2><p>给定一个 $n$ 次多项式 $F(x)$ 和一个 $m$ 次多项式  $G(x)$ ，请求出多项式 $Q(x)$, $R(x)$，满足以下条件：</p>
<ul>
<li>$Q(x)$ 次数为 $n-m$，$R(x)$ 次数小于 $m$</li>
<li>$F(x) = Q(x) * G(x) + R(x)$</li>
</ul>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>我们发现假如没有 $R(x)$，那么我们只需要对 $G(x)$ 做一次多项式求逆，再与 $F(x)$ 相乘即可。于是尝试去掉 $R(x)$ 的影响。</p>
<p>考虑一种变换，我们将 $F(x)$ 视作 $n$ 次多项式（实际次数小于等于 $n$），$F_R(x)=x^n F(\frac{1}{x})$，即 $[x_i]F_R(x)=[x_{n-i}]F(x)$。</p>
<p>开始推导：</p>
<script type="math/tex; mode=display">
\begin{align}
F(x) &= Q(x) * G(x) + R(x)\notag\\
F(\frac{1}{x}) &= Q(\frac{1}{x}) * G(\frac{1}{x}) + R(\frac{1}{x})\notag\\
x^n F(\frac{1}{x}) &= x^{n-m} Q(\frac{1}{x}) * x^m G(\frac{1}{x}) + x^{n-m+1} x^{m-1} R(\frac{1}{x})\notag\\
F_R(x) &= Q_R(x) * G_R(x) + x^{n-m+1} R_R(x)\notag\\
\end{align}</script><p>注意 $Q_R(x)$ 的次数为 $n-m$，我们考虑对整个式子对 $x^{n-m+1}$ 取模并不会影响 $Q_R(x)$，并且可以消去 $R_R(x)$。</p>
<script type="math/tex; mode=display">
\begin{align}
F_R(x) &\equiv Q_R(x) * G_R(x) &\pmod {x^{n-m+1}}\notag\\
Q_R(x) &\equiv F_R(x) * G_R^{-1}(x) &\pmod {x^{n-m+1}}\notag\\
\end{align}</script><p>于是可以得到 $Q(x)$，继而可以得到 $R(x)$。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>今昔是何年</title>
    <url>/2023/06/05/%E4%BB%8A%E6%98%94%E6%98%AF%E4%BD%95%E5%B9%B4/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="410acea76d5c0b3c48d45417665a7ead919ab0aba788548fdbf21b9c818b8e93">2469dfd2f0168e6fb8837314fda7e94b61e613d14e7de66be741995c40cd631f00f9a320146712db8371a5ee42af601096e46134ab7dacea4a190d85c3f94cf6e7ab1a6e48dbdd1fd014ad3261416759f7f87d9dc63c989222e9d3fbc792ff551bb27c14b5fc04b3bb6e3517a5c1164e9602fdddf6f4058204e0b8ceebaf5a62b7c08baba23b0f11a370e8ece38fb616b751094b79d324f4544dc3d39f86a8bb4a739397f52c235ccffe2252708e7babb263b88c7fcc3c51c8c71fbf07194607637e0226651c91b98ce5fa3014b0de8fc39c50738e7953122690d4072373369f56bd0f5adb74356159af5563b937e36806026f07f09bbf0b5a40ca0ea4d7877103bdf97d2d5f7d2f76d8e726fbf7ad89b9d7b0462e95d0b96df1325abd4496606ec435ac6e99bdf0cc0923ce500f3f3b286a1249850cf9fd99bdde7c8c46f4a8e3fb6daf2b0e18fd031eef98526f100cac0ca724350829931da6381e21e966f2033c8e2b95423f1d6554f7e458a1fb363b065e9eac8ace5b40d4b1736a8472b31fba9b0257567e84cd5a35d8a57aa7e6095d8ec04443e352be4cce397aaaa1e1ee2a4f0e7e0c7fd23215416ffad731d056cec5706b28004a3667f49fa634781ed8d0958c6ff77f34d7d8c85111d5c1422d2772a3617c2bf46bb96619f0eba901211422bce6afe38ab8998e22e584b19f0e24392f17156c67e8d489af1659e197a0eb9c9d666aa2ef9f599543ae67a8c083eaba58a105a0d022fe384c5b89f4672b7a475a9a4b2ad6ac46d8406fa97663934c8578cc01848b12a735914ddb263741fc1c4567f36b05f589ba5a80dc25506e3b7942b033aca18e2d839847d211016ee674e763b6912a6d773e436f25f4835118623ad211897881adbf45ae6fe41c531b93aa05f682aad030b13d5cba9fdfd67b40db67f168fb0ad61301e237cb67cc4085d6628a6f29cb43866417941aed0f0063509a2a4e2b741ba1d745695aacb1849f893e422ff8b05deaa47e18ce97ad249746d254069b19c1779005e5efbd1bfc403312bd5a9ebdc890c2e23873a34fdb8652686a1741f093ad92d24d726727cf70240640da968a19e4128d06630ff4092db841f7966356c9894ecbadda804252e0d889877acc56745f023e87d8d9d9aaca3a039bb5dd7f5dae427dfec9c71660190333b4115ec8ac7c88a64ff31ff449e0059fa567bb2f73f464b599fac4704c9fe65eeab09880c52e20f0b4b6b00fd6c7f3e3d27ad4e29fe9e0d4df3decd6547266f94644cdf6da6cba22fbd43c4caaf98c3aaa03672f825b74b09317ffb2eb5805561545802fd9c53f3ae6715f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Life.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>记梦</title>
    <url>/2023/06/12/%E8%AE%B0%E6%A2%A6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7d0d551092b88140aaa79f14f47cf4c324e4e0aca3cbb135e557c4ac630b99ee">1b05e05313998e5f4de994245a1b63dc3fa1111bfa407d42f7d6819ed87864b770335d25511c58f55134098d9dd5e4e07d9fcb413fbc4b9c04e7d152af1f92e5b7328711c34502d84e8b2c0503f1f25ea6effe57f18f74b44f7882feafe0f176aa825f06a7dcb47db7602bc21fb9e51491fe4c1d97b374f76b17de20ff935ae896254c0ac19cef6707f224322641489efab57a41026ff4e4209acc0d46955cca4eb06f2a75788fc50b79f505d350f72064534c55d8fc285be36e0315c78095dd13d3319dc76343488c488dd68e8510d8297c51561e6941823fdfbfa15a31c3ee454a482a8d22e5635791516901d1ed3b26b1c16f8b435d2e7fd22d2811cacbe119f818c0569f72c678c370ac00f789881510033f512047fe674111ce2fbf76c10c91886c3ab6f4353af3041501041e24fd1b9b36430ab288d885c44d9a2476f1ac042619fffffd0ffc2e3d47cdf18705632799b9b35712a5b589e7bff25dfef9ee59ba7ee7341dcd9441e7dea4c493afd410cccaa1be740c81350b38e6474ed44a0f6ebac3b5d93e3623149ee67cfe274c6a0bc7422164097ab74d1d9c2dddc481cb58d38ff9b3c6dfad954eb7fd09b8543a3ea90043887040a815d577a3a80c66728faba0308490826a7ca983647e0f32f46ee211494ff3e5c370a95bde71c6b233322e96d506a653ac87decec5d371b3b88d91b8fc8f731d5e13fd472a7466877d6dbb8197201034e0cae54fb1589ecb99feaec6e6a186e731ec70e323c18f2efbe571206348adcbc7909c3bddf2e110a8eb005e198b3a04d6611b119bc920d7363ac984d51e8560c8db9d4c0ad6b0eecd3ebf31796f3bc082baf82838f0d33e91e57844a694384c3174f9eb09813107934c8088397f5a6f5bab517f33fe5216cc8429efd24930be44df81ea087a800e77f7818a29ce9c6b3d8b2c423b93e67ea04097dd7d70021d9cc492839b98ee066e8681c2e35f636c3b59bcbc46f9a3b71aa702369215d38b9c4e72e5aab7294029548877081359ccff5d0b72d752b7e3431aa2be6334aad69eccd20e012038956ba02bffb0559dd385b84616d19fc08ce6a3f1797781eded9abd1a37c3ec17da6ff716e6cf768759f602d314a3d8aee562ffab4dbfb33a8e4dcaaba7aca483029f44756cb368316436ec78d548a297c54e6f4a969a56c8627067af0bbadc6144c0b1bc6bc5fe7bb7cff028a01f9454a89694943558b4dc7a3552d3360cf44a6c2107839b5f7586fcd3c5908d93e7e42b29b34fc472d2c822b08f3aaf436c0733fcb733103da38ed8d64d15dfa9b1f84a8eb12839900723d2a761fea1dd90a1df7b8e24a6458c4efccca7b25b326ca5ef2afd1a464ac67ab5cdbdea3e8072c111fd2249609b61f14fc0ca39ea0849cf6e7dd83cb91a196afb931926ec40d18807611c7b07fe3f06520cc37f65dddfacb9349b75c99704bf04eeacd115f74abd429669aa9a5bb63aa7fcdcc188362864fe553452ed706c20457476a103fa2fa1d58184d8cf4afb19d3e4cf1e12b90b3312ccef443ffdb781194d0dd03f3c693f86169e2afa813537ccd2043497d3ea61a4a5e79c1987204dad9dfd017fc58b36ef24a51e37fff9e5e68dcc51831760db36fc7012cac7675965552be8d8b6eb1d5ca5dcb8a90563733505d4f541fc79135872b6a87f01f2a4a51f2a9c2207d083bfe7aa19c570dd9cf1747fe44de1667b7ce8fb47fd31e5a5b4da1778efc0c12ac59f1d39c88a02ebda37bfead4dfc3d33b33185f3a681be0658d1355d3db75d9038771c7c309b0b7a9d8a2d15716ed5f0c8fd40eb3400b4012afedaf974ebd7a918432e6be33fc114cdd3c2ddee69ae36a547c66462f5eb21700b20506a18b371f33d2dd0ddf79b7186f4b13d1753c8d48a1411711e1aa12eefb0b86eefc057daa9efef5b419e5db6f37b7515fcbbe14e5eda0274bf784c2abf56ca3186956f210433017adcd1137fe345c98159b109226d234be4ab5305bee061b748f97c91786e64818ed2e095771aacf0ebcb80be7489c8aca5ee3d6a76bda08a7b6e59384fe11109e2f9429d580575e1445f5d59be8fa1c065a01abf70ce8e9f42026238157ea4f339ae37f6e86e89461c3fb4152e66c881822c4dc602450e10b127cbff3143a2443345ea21da244a99d694753f3a4ed830e9bd0caa8daf8f7ac2660dd5262aed605a65316cbaab23deb6e8047f8bce2bdea71ed37d6b527f875f4813f9006e2f83d742c63864c9930694981dcc7dcdfb2c8be73908635124ee182c2352a189087040c17a35a10e7d8c35cbab9d57cd2abb5de1ec26bcba145491a8f1f63fff8f70fcb860047c2c88e452591f54f575d543fb5ab07147275871571094815d049216a6a221e48cc09ad7cd6d5a912cfb768dacbf8ec4b0e0dddcdcac04a5222d58a91cc2b6e3d50bdee680ca2acdfc8c2cceefa329ec8a6bab56acc2bb02178bf3ce6a9c1d65706736270efb52e299fa865537c6efefce6a6458de1011518eefef9e42664f37e731fb4fa8e95f18c350baf8de7e6a27d6488d5138ca0e4bf6983f059a33481482548bc32ec0b868416ab7b2490f3a38887e1d2a3655c73ae0f5d666161b234015a2f021fbdbea99d741d11a2092ba229f4a4bd2bd6a1927321cee6b3e9de963c58d619322d23023681beabe61450524d5cbe440bb9cd1fd282b04ee34a0b34958fb6b276477a87262f33b656dd62dd79a5e9f99bd28626df9a50d5c5f3bbf0eb0f5e84342fa88a2f9ea63bd1246c92f69e20fe8f7c0e8d249e773dd30496added6dde916905a95590a488ae1453189baa2f4ad120afc00507e66a56211ca2b90f8d3b08ca44216767301896610edebc25fdb9e6b0dc338560309daa0d75aaa582e0ff2aac174b567c4690d4dbc9a86da3c48d25a82b6163646309fc9ea874a995d909c758887e30a32c09d11429e42ff55db341851740ab48badc0d0a36856005da377ed31fc39cf57c7995f1d656d7e4fa4632c3a563b0c1c52ca1bddd0ef69b9c5781086c6eb76b9cc8859c681092c11dcdd63c214a9f4a35adf39f361a731a44aae762bdbcb5e0bc5d73291559891a176c80306cea8d7eedad8169256d33df2b6a30e3f8616b970874f9b8d99b3b7af429656301c2f8752483a7d3d773d29f114ca5d02c3a55f4564990ed3e03a45e4f9a3f1a0cc5a3a91ae520d013e5eea3fc4706e62abe2aca929d0f6146fe686b6d6f9b27d053d00</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Say goodbye.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>新建文件夹</category>
      </categories>
      <tags>
        <tag>闲话</tag>
      </tags>
  </entry>
  <entry>
    <title>P8329 [ZJOI2022] 树</title>
    <url>/2023/06/12/P8329-ZJOI2022-%E6%A0%91/</url>
    <content><![CDATA[<p>好的容斥题目。</p>
<span id="more"></span>
<p>容易发现DP过程中直接钦定叶子是不好做的，并且需要满足并集为全集。很容易想到使用容斥去掉这一条件。我们对于非叶子进行考虑：设 $f(S)$ 表示第一棵树中集合 $S$ 为<strong>非叶子</strong>节点时的方案数， $g(T)$ 表示第二棵树中集合 $T$ 为<strong>非叶子</strong>节点时的方案数，得到答案为：</p>
<script type="math/tex; mode=display">
Ans=\sum_{S\cap T=\emptyset,S\cup T=\{1,2,\cdots,n\}} f(S)g(T)</script><p>直接容斥，设 $f’(S)$ 表示第一棵树中集合 $S’\subseteq S$ 为<strong>非叶子</strong>节点时的方案数， $g(T)$ 表示第二棵树中集合 $T’\subseteq T$ 为<strong>非叶子</strong>节点时的方案数，进一步得到：</p>
<script type="math/tex; mode=display">
\begin{align}
Ans=&\sum_{S\cap T=\emptyset,S\cup T=\{1,2,\cdots,n\}} \sum_{S'\subseteq S,T'\subseteq T}(-1)^{|S|-|S'|+|T|-|T'|} f'(S')g'(T')\notag \\
=&\sum_{S'\cap T'=\emptyset}(-2)^{n-|S'|-|T'|}f'(S')g'(T')\notag \\
\end{align}</script><p>我们成功将“并集为全集”这一条件去掉。并且这是容易DP的。影响决策的只有 $|S’|,|T’|$，将其压入状态，设 $f(x,i,j)$ 表示考虑到 $x$，$S’$ 有 $i$ 个元素，$T’$ 有 $j$ 个的元素带容斥系数的方案数。我们顺序枚举所有元素，将两棵树以不同的顺序 DP，设边界为 $f(1,1,i)=1$，最终答案为 $\sum_i f(n,i,1)\times i$。考虑转移。对于当前枚举的元素 $x$，可以选择 $S’$ 中任意元素作为第一棵树上的父亲，和选择 $T’$ 中任意元素作为第二棵树上的父亲。所以转移系数为 $i\times j$。现在考虑是否将 $x+1$ 放进 $S’,T’$ 里，分类讨论一下：</p>
<p>$(1).x\in S’$，钦定 $x+1$ 为第二棵树的叶子， $i\times j\times f(x,i,j)\to f(x+1,i+1,j)$。</p>
<p>$(2).x\in T’$，钦定 $x+1$ 为第一棵树的叶子， $i\times j\times f(x,i,j)\to f(x+1,i,j-1)$。</p>
<p>$(3).x\notin S’,x\notin T’$，钦定 $x+1$ 为第一棵树的叶子和第二棵树的叶子，$-2\times i\times j\times f(x,i,j)\to f(x+1,i,j)$。</p>
<p>需要滚动数组优化空间。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,mod;</span><br><span class="line"><span class="type">int</span> p,f[<span class="number">2</span>][N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x+=y;x=(x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)f[p][<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;n;x++,p^=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f[p^<span class="number">1</span>],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[p^<span class="number">1</span>]));</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;<span class="built_in">upd</span>(ans,<span class="number">1ll</span>*i*f[p][i][<span class="number">1</span>]%mod),i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n-x;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">upd</span>(f[p^<span class="number">1</span>][i+<span class="number">1</span>][j],<span class="number">1ll</span>*i*j*f[p][i][j]%mod);</span><br><span class="line">                <span class="built_in">upd</span>(f[p^<span class="number">1</span>][i][j<span class="number">-1</span>],<span class="number">1ll</span>*i*j*f[p][i][j]%mod);</span><br><span class="line">                <span class="built_in">upd</span>(f[p^<span class="number">1</span>][i][j],<span class="number">1ll</span>*i*j*(mod<span class="number">-2</span>)%mod*f[p][i][j]%mod);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>容斥</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC044C] Strange Dance</title>
    <url>/2023/06/23/AGC044C-Strange-Dance/</url>
    <content><![CDATA[<p>Trie 树的 全局 +1 操作 trick。</p>
<span id="more"></span>
<p>比较经典的 trick。我们容易发现按照 Trie 常规建法从高位向低位建不好进行该操作。于是从低位向高位建 Trie。而我们现在只需要直接交换当前节点的儿子即可。如何考虑进位呢？进位只会发生在交换后的该位为 $0$ 的儿子上。于是我们直接不停地交换儿子，再沿着 $0$ 链走。<a href="https://www.luogu.com.cn/problem/P6623">P6623 [省选联考 2020 A 卷] 树</a> 就可以利用这个 trick 比较简单地解决。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>,K=<span class="number">12</span>,C=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[M];</span><br><span class="line"><span class="type">int</span> pw[K],ans[N];</span><br><span class="line"><span class="type">int</span> tot=<span class="number">1</span>,ch[N][<span class="number">3</span>],tag[N],val[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> d,<span class="type">int</span> x,<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&gt;=n)<span class="keyword">return</span> val[x]=now,<span class="built_in">void</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;C;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ch[x][i]=++tot;</span><br><span class="line">        <span class="built_in">build</span>(d+<span class="number">1</span>,ch[x][i],now+i*pw[d]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tag[x])<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">swap</span>(ch[x][<span class="number">1</span>],ch[x][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;C;i++)tag[ch[x][i]]^=<span class="number">1</span>;</span><br><span class="line">    tag[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> d,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&gt;=n)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> tmp=ch[x][<span class="number">2</span>];</span><br><span class="line">    ch[x][<span class="number">2</span>]=ch[x][<span class="number">1</span>];</span><br><span class="line">    ch[x][<span class="number">1</span>]=ch[x][<span class="number">0</span>];</span><br><span class="line">    ch[x][<span class="number">0</span>]=tmp;</span><br><span class="line">    <span class="built_in">modify</span>(d+<span class="number">1</span>,ch[x][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> d,<span class="type">int</span> x,<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&gt;=n)<span class="keyword">return</span> ans[val[x]]=now,<span class="built_in">void</span>();</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;C;i++)<span class="built_in">get</span>(d+<span class="number">1</span>,ch[x][i],now+i*pw[d]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %s&quot;</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">    m=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pw[i]=pw[i<span class="number">-1</span>]*C;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;S&#x27;</span>)tag[<span class="number">1</span>]^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pw[n];i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>P6623 [省选联考 2020 A 卷] 树</title>
    <url>/2023/06/23/P6623-%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2020-A-%E5%8D%B7-%E6%A0%91/</url>
    <content><![CDATA[<p>有比较好想的 Trie 树做法。但是树上差分更巧妙。</p>
<span id="more"></span>
<p>从下往上做。从儿子继承到父亲，使得儿子内所有点到父亲的距离等于儿子内所有点到儿子的距离 $+1$，也就是全局 $+1$ 操作。并且维护的信息是异或和。于是我们直接 01-Trie 合并即可。时间复杂度 $\mathcal O(n\log V)$。</p>
<p>换种思路，我们对于每一个 $v_i$ 分别考虑其对祖先的贡献。考虑整个 $+1$ 然后进位的过程，对于第 $k$ 位为 $1$，那么对它的祖先的第 $k$ 位贡献 $\underbrace{11\cdots 11}_{2^k-(v_i\text{ mod } 2^k)}\underbrace{00\cdots 00}_{2^k}\underbrace{11\cdots 11}_{2^k}$。根据这一点进行树上差分。给定差分数组 $g[x][i]$ 表示 $x$ 第 $i$ 位的差分。把当前 $v_i$ 每一位的差分往上传递到，把 $g[x][i]$ 的差分到 $g[fa_{x,2^i}][i]$。需要长链剖分求 $k$ 级祖先，时间复杂度 $\mathcal O(n\log n + n\log V)$。常数要小一点。</p>
<p>实际上有更好的实现方式。我们发现对于每个点，产生差分的点的充要条件是 $d_i=x\pmod {2^k}$。我们开一个新的 $p[k][x]$ 表示 $d_i=x\pmod {2^k}$ 的差分。递归之前先去掉已经原来的差分数组，再递归得到子树的贡献，再算出当前点的答案即可。时间复杂度 $\mathcal O(n\log n)$。常数很小。</p>
<p>具体实现参考如下。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5.26e5</span>+<span class="number">10</span>,K=<span class="number">21</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],p[K][N];</span><br><span class="line"><span class="type">int</span> tot,head[N],ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=v;</span><br><span class="line">    ne[tot]=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=a[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)res^=p[i][d&amp;((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>)];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=ver[i];</span><br><span class="line">        res^=<span class="built_in">dfs</span>(y,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)res^=p[i][d&amp;((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>)];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;K;i++)p[i][(d+a[x])&amp;((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>)]^=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">    ans+=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,fa;i&lt;=n;i++)<span class="built_in">read</span>(fa),<span class="built_in">add</span>(fa,i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Trie</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>P8338 [AHOI2022] 排列</title>
    <url>/2023/06/16/P8338-AHOI2022-%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>并没有用到什么高深的知识。</p>
<span id="more"></span>
<p>对于一个排列，我们从 $i$ 向 $p_i$ 连边，会得到若干个置换环。答案就是新的置换环的大小的 $\text{lcm}$。容易发现 $a_i^{(k)}=j$ 当且仅当 $i,j$ 属于同一个置换环。否则的话，交换 $i,j$，会将 $i,j$ 分属于的两个置换环合并为一个。</p>
<p>答案只与置换环的大小有关。并且大小不同的置换环最多有 $\mathcal O(\sqrt{n})$ 个。所以说可以直接暴力枚举两个置换环的大小。至于求 $\text{lcm}$，我们需要分解质因数来求，因为有值域的限制，利用筛法分解质因数容易做到单次 $\mathcal O(\log n)$。开一个桶来维护所有质因子的最大幂。枚举两个置换环时最多会影响两个值，所以桶中记录前三大的值即可。时间复杂度 $\mathcal O(n\log n)$。</p>
<p>随便写写就好。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,P=<span class="number">5e4</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> ...T1&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T,n,m;</span><br><span class="line"><span class="type">int</span> cnt,prime[P],g[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="type">int</span> p[P][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> ans,res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=<span class="number">1ll</span>*res*x%mod;</span><br><span class="line">        x=<span class="number">1ll</span>*x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!g[i])prime[++cnt]=i,g[i]=cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;<span class="number">1ll</span>*i*prime[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i*prime[j]]=j;</span><br><span class="line">            <span class="keyword">if</span>(!(i%prime[j]))<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=g[x],tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(x%prime[j]))x/=prime[j],tot++;</span><br><span class="line">        <span class="keyword">if</span>(tot&gt;=p[j][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p[j][<span class="number">2</span>]=p[j][<span class="number">1</span>];</span><br><span class="line">            p[j][<span class="number">1</span>]=p[j][<span class="number">0</span>];</span><br><span class="line">            p[j][<span class="number">0</span>]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot&gt;=p[j][<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p[j][<span class="number">2</span>]=p[j][<span class="number">1</span>];</span><br><span class="line">            p[j][<span class="number">1</span>]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot&gt;=p[j][<span class="number">2</span>])</span><br><span class="line">            p[j][<span class="number">2</span>]=tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=g[x],tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(x%prime[j]))x/=prime[j],tot++;</span><br><span class="line">        <span class="keyword">if</span>(tot==p[j][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            res=<span class="number">1ll</span>*res*<span class="built_in">qpow</span>(<span class="built_in">qpow</span>(prime[j],p[j][<span class="number">0</span>]-p[j][<span class="number">1</span>]))%mod;</span><br><span class="line">            p[j][<span class="number">0</span>]=p[j][<span class="number">1</span>];</span><br><span class="line">            p[j][<span class="number">1</span>]=p[j][<span class="number">2</span>];</span><br><span class="line">            p[j][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot==p[j][<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p[j][<span class="number">1</span>]=p[j][<span class="number">2</span>];</span><br><span class="line">            p[j][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot==p[j][<span class="number">2</span>])</span><br><span class="line">            p[j][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;T:&quot;&lt;&lt;T&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in">sizeof</span>(p));</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> x=i,tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;vis[x]=<span class="number">1</span>,x=a[x],tot++;&#125;</span><br><span class="line">        <span class="keyword">while</span>(x!=i);</span><br><span class="line">        b[++m]=tot;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;tot&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=b[i];</span><br><span class="line">        <span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;m:&quot;&lt;&lt;m&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m);</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]!=b[i<span class="number">-1</span>])pos++;</span><br><span class="line">        c[pos]++;</span><br><span class="line">    &#125;</span><br><span class="line">    m=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m)-b<span class="number">-1</span>;</span><br><span class="line">    ans=<span class="number">0</span>,res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)res=<span class="number">1ll</span>*res*<span class="built_in">qpow</span>(prime[i],p[i][<span class="number">0</span>])%mod;</span><br><span class="line">    <span class="type">int</span> clone=res;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;res:&quot;&lt;&lt;res&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;m:&quot;&lt;&lt;m&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> x=b[i]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        res=clone;</span><br><span class="line">        <span class="built_in">del</span>(b[i]),<span class="built_in">del</span>(b[i]);</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=g[x],tot=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!(x%prime[j]))x/=prime[j],tot++;</span><br><span class="line">            <span class="keyword">if</span>(tot&gt;p[j][<span class="number">0</span>])res=<span class="number">1ll</span>*res*<span class="built_in">qpow</span>(prime[j],tot-p[j][<span class="number">0</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">insert</span>(b[i]),<span class="built_in">insert</span>(b[i]);</span><br><span class="line">        ans=<span class="built_in">adj</span>(ans+<span class="number">1ll</span>*c[i]*(c[i]<span class="number">-1</span>)%mod*b[i]%mod*b[i]%mod*res%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;ans:&quot;&lt;&lt;ans&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=b[i]+b[j];</span><br><span class="line">            res=clone;</span><br><span class="line">            <span class="built_in">del</span>(b[i]),<span class="built_in">del</span>(b[j]);</span><br><span class="line">            <span class="keyword">while</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j=g[x],tot=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(!(x%prime[j]))x/=prime[j],tot++;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;prime[j]&lt;&lt;&quot; &quot;&lt;&lt;tot&lt;&lt;&quot; &quot;&lt;&lt;p[j][0]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">                <span class="keyword">if</span>(tot&gt;p[j][<span class="number">0</span>])res=<span class="number">1ll</span>*res*<span class="built_in">qpow</span>(prime[j],tot-p[j][<span class="number">0</span>])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">insert</span>(b[i]),<span class="built_in">insert</span>(b[j]);</span><br><span class="line">            ans=<span class="built_in">adj</span>(ans+<span class="number">2ll</span>*c[i]*c[j]%mod*b[i]%mod*b[j]%mod*res%mod);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;&quot;done:&quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;b[i]&lt;&lt;&quot; &quot;&lt;&lt;b[j]&lt;&lt;&quot;:&quot;&lt;&lt;res&lt;&lt;&quot; &quot;&lt;&lt;2ll*c[i]*c[j]%mod*res%mod&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">prework</span>(N<span class="number">-10</span>);</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC056B] Range Argmax</title>
    <url>/2023/06/25/AGC056B-Range-Argmax/</url>
    <content><![CDATA[<p>妙妙 DP 题。</p>
<span id="more"></span>
<p>因为一个 $x$ 可能会对应着不同的 $p$，所以直接对 $x$ 进行计数是十分困难。所以我们尝试对于特定的 $p$ 与 $x$ 建立双射关系。我们尝试用 $x$ 来构造 $p$。</p>
<p>假设已知 $x$，求一个对应的 $p$。我们从大到小考虑每个数。若剩下的经过 $i$ 的区间都有 $x=i$ ，我们称 $i$ 为可行位置。我们每次将当前 $n$ 放在最靠左的一个可行位置上，然后删去所有经过 $i$ 的区间。一直的重复直到区间删完。但是，这样可能存在一些位置没有被选到。于是为了确定唯一的 $p$，我们加入新的 $n$ 个区间 $[i,i],i\in [1,n]$。</p>
<p>显然这样生成的排列 $p$ 与 $x$ 构成双射关系。并且 $x$ 当且仅当可以生成 $p$ 时合法。问题转化为对排列 $p$ 的计数。</p>
<p>观察限制条件：在删去经过该点的区间后，左右两侧的区间之间是相互独立的。对于右侧区间是没有影响的，但是对于左侧区间有影响。经过该点的区间中必然存在一个区间包含当前最大值与左边的最大值。证明很简单，如果没有这样的区间的话，我们直接选择左侧的区间即可，当前情况就不合法了。所以说我们需要限制左侧区间的 $x$ 大于 经过该点的区间的最左端点。</p>
<p>于是 DP 就很显然了。设计 $f(l,r,k)$ 表示 $[l,r]$ 的 $x\ge k$ 的方案数，容易得到转移方程：</p>
<script type="math/tex; mode=display">
f(l,r,k)=f(l,r,k+1)+f(l,k-1,pos_{l,r,k})\times f(k+1,r,k+1)</script><p>其中 $pos_{l,r,k}$ 为在 $[l,r]$ 之内的区间且包含 $k$ 的最左端点。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300</span>+<span class="number">10</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span>(f)x=~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span> ...T1&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x,T1 &amp;...x1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(x),<span class="built_in">read</span>(x1...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> pos[N][N][N],f[N][N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">                pos[i][j][k]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">read</span>(l,r);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;=r;j++)pos[l][r][j]=<span class="built_in">min</span>(pos[l][r][j],l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j;k++)</span><br><span class="line">                pos[i][j][k]=<span class="built_in">min</span>(pos[i][j][k],<span class="built_in">min</span>(pos[i+<span class="number">1</span>][j][k],pos[i][j<span class="number">-1</span>][k]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            f[i][i<span class="number">-1</span>][j]=<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j;k&gt;=i;k--)</span><br><span class="line">                f[i][j][k]=<span class="built_in">adj</span>(f[i][j][k+<span class="number">1</span>]+<span class="number">1ll</span>*f[i][k<span class="number">-1</span>][pos[i][j][k]]*f[k+<span class="number">1</span>][j][k+<span class="number">1</span>]%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[<span class="number">1</span>][n][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Dilworth定理</title>
    <url>/2023/06/27/Dilworth%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>感觉有些时候比较有用。</p>
<span id="more"></span>
<h3 id="1-内容"><a href="#1-内容" class="headerlink" title="1.内容"></a>1.内容</h3><p>先说明<strong>偏序集</strong>。我们定义两个元素的比较关系。可以存在部分元素无法比较。需要满足以下三个条件：</p>
<p>1.自反性，$\forall a\in S$，有 $a\le a$.。</p>
<p>2.对称性，$\forall a,b\in S$，若 $a\le b$，有 $b\ge a$。</p>
<p>3.传递性，$\forall a,b,c\in S$，若 $a\le b,b\le c$，有 $a\le c$。</p>
<p>我们将偏序集中的元素按照比较关系建图，容易发现会得到一张 DAG。而<strong>最小链划分</strong>就是将 DAG 划分成最少条链。<strong>反链</strong>为集合中一个一集满足该子集中所有元素都无法比较，其长度即为集合大小。</p>
<p>容易发现<strong>最小链剖分</strong>，直接求是不好求的。$\text{Dilworth}$ 定理描述的就是其与反链的关系：</p>
<p><strong>偏序集</strong>上<strong>最小链划分</strong>中链的数量等于其<strong>反链</strong>长度的最大值。</p>
<h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2.例题"></a>2.例题</h3><h4 id="1-P1020-NOIP1999-普及组-导弹拦截"><a href="#1-P1020-NOIP1999-普及组-导弹拦截" class="headerlink" title="1.P1020 [NOIP1999 普及组] 导弹拦截"></a>1.<a href="https://www.luogu.com.cn/problem/P1020">P1020 [NOIP1999 普及组] 导弹拦截</a></h4><p>关于第二问的解法。比较简单的是贪心。但是可以从 $\text{Dilworth}$ 定理的角度思考。</p>
<p>对于每一个位置用一个二元组 $(x,y)$，其中 $x$ 代表该位置的下标，$y$ 表示高度。定义 $(x_1,y_1)\le (x_2,y_2)$ 当且仅当 $x_1\le x_2,y_1\ge y_2$。一个最长上升子序列对应的就是 DAG 上的一条链，于是就转化为<strong>最小链剖分</strong>的问题，而<strong>反链</strong>就是两两满足 $x_1&lt; x_2,y_2&lt; y_2$ 的元素的集合。所以答案就是最长上升子序列。</p>
<h4 id="2-P3974-TJOI2015-组合数学"><a href="#2-P3974-TJOI2015-组合数学" class="headerlink" title="2.P3974 [TJOI2015] 组合数学"></a>2.<a href="https://www.luogu.com.cn/problem/P3974">P3974 [TJOI2015] 组合数学</a></h4><p>还是考虑建立偏序关系。对于每个位置设 $(x,y)$ 表示其坐标。定义 $(x_1,y_1)\le (x_2,y_2)$ 当且仅当 $x_1\le x_2,y_1\le y_2$。并且将每个位置的权值 $v_{i,j}$ 拆成 $v_{i,j}$ 个点。求的就是 DAG 上的<strong>最小链剖分</strong>。即满足 $x_1&lt; x_2,y_1&lt; y_2$ 的集合大小的最大值。从右下角到左上角进行 DP 即可求出。</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>P8386 [PA2021] Od deski do deski</title>
    <url>/2023/06/26/P8386-PA2021-Od-deski-do-deski/</url>
    <content><![CDATA[<p>小清新记数题。</p>
<span id="more"></span>
<p>发现将两段合法的拼接起来计数会有很多重复，因为会有很多种消除方法。于是我们考虑对于一位以为计数，并且将合法性压入状态。</p>
<p>考虑怎样才能够合法。如果对于当前位置选择数字 $x$，需要存在之前的某个位置 $i$ 数字为 $x$，满足 $[1,i-1]$ 合法。前面有满足这样的与 $x$ 相等的都可以选。于是我们考虑将有多少不同的数满足该条件压入状态中。设计状态 $f(i,j),g(i,j)$ 分别表示有 $j$ 不同的数满足该条件，不合法与合法的方案数。</p>
<p>于是我们可以很好的进行转移。得到状态转移方程：</p>
<script type="math/tex; mode=display">
\begin{align}
f(i,j)&\gets f(i-1,j)\times (m-j)\notag\\
f(i,j)&\gets g(i-1,j-1)\times (m-j+1)\notag\\
g(i,j)&\gets f(i-1,j)\times j\notag\\
g(i,j)&\gets g(i-1,j)\times\ j\notag\\
\end{align}</script><p>时间复杂度 $\mathcal O(n\log n)$。</p>
<details class="success"><summary><i class="fa fa-check fa-fw"></i>Code<div class="box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e3</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N][N],g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">adj</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=mod)?x-mod:x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>]=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(n,m);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=<span class="built_in">adj</span>(f[i][j]+<span class="number">1ll</span>*g[i<span class="number">-1</span>][j<span class="number">-1</span>]*(m-j+<span class="number">1</span>)%mod);</span><br><span class="line">            f[i][j]=<span class="built_in">adj</span>(f[i][j]+<span class="number">1ll</span>*f[i<span class="number">-1</span>][j]*(m-j)%mod);</span><br><span class="line">            g[i][j]=<span class="built_in">adj</span>(g[i][j]+<span class="number">1ll</span>*f[i<span class="number">-1</span>][j]*j%mod);</span><br><span class="line">            g[i][j]=<span class="built_in">adj</span>(g[i][j]+<span class="number">1ll</span>*g[i<span class="number">-1</span>][j]*j%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(m,n);i++)ans=<span class="built_in">adj</span>(ans+g[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
</search>
